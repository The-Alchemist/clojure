{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Practicalli Clojure \u03bb\ufe0e Getting started with Clojure programming language using Clojure CLI and community tools . A practical guide to learning Clojure with step by step explanations of code and design decisions and live coding videos to demonstrate the Clojure REPL workflow. John Stevenson, Practical.li Clojure - an elegant language for a more civilised development experience Clojure REPL Driven Development \u03bb\ufe0e Clojure runs in a REPL process that provides instant feedback as code is written, encouraging experimentation and allowing effective designs to evolve rapidly and with confidence that comes with a clear understanding. The REPL is Clojure interactive environment used to create an run Clojure code, in both development and production. Quickly grow confidence with Clojure by evaluating, breaking, fixing and extending code in the REPL. All the while getting instant feedback on what the code is doing. Adrian Cockcroft - formally Cloud Architect, Netflix The most productive programmers I know are writing everything in Clojure and swearing by it and then just producing ridiculously sophisticated things in a very short time. And that programmer productivity matters. About the book \u03bb\ufe0e Practicalli Clojure provides a hands on approach to learning Clojure through the entire development workflow. As we work through code we will discuss the concepts behind Clojure, including functional programming, \"pure\" functions and a stateless approach with persistent data structures, changing state safely, Java interoperability and tooling around Clojure. Resources \u03bb\ufe0e practicalli/clojure-deps-edn - Clojure tools and common aliases Clojure Aware Editors Practicalli YouTube channel Sponsor my work \u03bb\ufe0e The majority of my work is now focused on the Practicalli series of books and videos and an advisory role with several communities Thank you to Cognitect , Nubank and a wide range of other sponsors from the Clojure community for your continued support Creative commons license \u03bb\ufe0e This work is licensed under a Creative Commons Attribution 4.0 ShareAlike License (including images & stylesheets).","title":"Overview"},{"location":"#practicalli-clojure","text":"Getting started with Clojure programming language using Clojure CLI and community tools . A practical guide to learning Clojure with step by step explanations of code and design decisions and live coding videos to demonstrate the Clojure REPL workflow. John Stevenson, Practical.li Clojure - an elegant language for a more civilised development experience","title":"Practicalli Clojure"},{"location":"#clojure-repl-driven-development","text":"Clojure runs in a REPL process that provides instant feedback as code is written, encouraging experimentation and allowing effective designs to evolve rapidly and with confidence that comes with a clear understanding. The REPL is Clojure interactive environment used to create an run Clojure code, in both development and production. Quickly grow confidence with Clojure by evaluating, breaking, fixing and extending code in the REPL. All the while getting instant feedback on what the code is doing. Adrian Cockcroft - formally Cloud Architect, Netflix The most productive programmers I know are writing everything in Clojure and swearing by it and then just producing ridiculously sophisticated things in a very short time. And that programmer productivity matters.","title":"Clojure REPL Driven Development"},{"location":"#about-the-book","text":"Practicalli Clojure provides a hands on approach to learning Clojure through the entire development workflow. As we work through code we will discuss the concepts behind Clojure, including functional programming, \"pure\" functions and a stateless approach with persistent data structures, changing state safely, Java interoperability and tooling around Clojure.","title":"About the book"},{"location":"#resources","text":"practicalli/clojure-deps-edn - Clojure tools and common aliases Clojure Aware Editors Practicalli YouTube channel","title":"Resources"},{"location":"#sponsor-my-work","text":"The majority of my work is now focused on the Practicalli series of books and videos and an advisory role with several communities Thank you to Cognitect , Nubank and a wide range of other sponsors from the Clojure community for your continued support","title":"Sponsor my work"},{"location":"#creative-commons-license","text":"This work is licensed under a Creative Commons Attribution 4.0 ShareAlike License (including images & stylesheets).","title":"Creative commons license"},{"location":"clojure-as-a-recipe/","text":"Article by Chris Ford \u03bb\ufe0e https://thoughtworks.github.io/p2/issue05/cooking-with-clojure/ Cooking with Clojure Words and Music by Chris Ford When I speak to developers about functional programming, they\u2019re often interested, but are sometimes concerned that functional programming might make it hard to model the \u201creal world\u201d. The theory goes that the everyday world is full of objects that evolve over time, so the most natural way to describe it is using object-oriented design. Leaving aside the question of whether or not programmers should be overly concerned about this thing referred to as the \u201creal world\u201d, functional programming provides a rich set of concepts that are more than adequate for modelling complex domains. As a demonstration of functional design, I\u2019ll use Clojure to describe a recipe. Clojure is a variant of Lisp designed to run on the Java Virtual Machine, and it has the key ingredient that makes functional programming possible \u2013 functions that can be passed around as values, and that reliably return the same output for the same inputs. Here are a couple of simple examples of Clojure: (def y 3) (+ 2 y) ;=> 5 (reduce + [2 3 4 5]) ;=> 14 The first example simply binds the name y to the value 3. The second example is straightforward enough, though it might seem strange that the function + appears inside the braces and in the first position. That\u2019s the way that all Lisps depict function invocation. The third example has a curious aspect \u2013 + is being passed as an argument to the reduce function, which uses it to boil down a list of numbers into a single total. Using functions as values that can be passed around isn\u2019t possible in many object-oriented programming languages like Java, but it turns out to be very useful. Values in Clojure are immutable, meaning that we never destroy old values, we only create new ones representing the new state. Whereas in Java, y = y + 1 means \u201cadd one to y\u201d, the equivalent in Clojure is just a comparison: (= y (+ y 1)) ;=> false Of course, simple expressions on their own aren\u2019t very useful. Here is how to define a named function in Clojure: (defn plus-one [n] (+ 1 n)) (plus-one 4) ;=> 5 Clojure functions can themselves return functions. Here\u2019s a function that makes plus functions. Note that while defn defines a named function, fn creates an anonymous function. (defn plus [incrementor] (fn [n] (+ incrementor n))) (def plus-three (plus 3)) (plus-three 4) ;=> 7 Here\u2019s another function that works like plus, but uses Clojure\u2019s fnil function to use a default value of 0 if nil is supplied: (defn safe-plus [n] (fnil (plus n) 0)) ((safe-plus 4) nil) ;=> 4 Each stage in the recipe will be represented as a simple hash map. Some functional programming languages, like Haskell, have very sophisticated type systems that can tell the compiler when functions are invoked on the wrong kind of arguments. Such systems can be tremendously powerful, but they are not strictly necessary for doing functional programming. By using Clojure, we do not have to manage types or type annotations, but we must accept the burden of ensuring that we invoke our functions in the right way without strong compiler support. The following represents butter-beans with some water added (measured in grams): {:butter-beans 150, :water 300} But we\u2019re modelling a process, not a fixed state, so we also need a way to depict time and change. The following represents the same ingredients, five minutes into the recipe. {:time 5, :butter-beans 150, :water 300} The process of preparing a recipe can then be represented as a series of states: [{:time 0}, {:time 1, :butter-beans 150}, {:time 3, :butter-beans 150, :water 300}] But how do we get from one state to another? This is where the functions come in. Functions are just a way of representing a mapping from one state to another. Here is a simple function that represents mixing in a certain amount of an ingredient: (defn mix-in [dish ingredient quantity] (update-in dish [ingredient] (safe-plus quantity))) (mix-in {:time 1, :butter-beans 150} :water 300) ;=> {:time 1, :butter-beans 150, :water 300} There\u2019s no need to overwrite the original state of the dish. Instead of having objects with identity that morph and mutate over time, functions take the original state and produce a new state. In the example above, mix-in takes a dish that has one minute of elapsed time and 150 grams of butter-beans, and produced a new state that had one minute of elapsed time, 150 grams of butter-beans and 300 grams of water. Remember, functions are themselves values in a functional programming language, so we can represent the addition of a particular ingredient as a function. Note that add is a function that takes the ingredient and its quantity as arguments, and returns another function that represents the actual addition. Clojure has no good way to print functions, so it\u2019s forced to use a somewhat cryptic identifier when displaying a function to the screen: (defn add [ingredient quantity] (fn [dish] (mix-in (mix-in dish ingredient quantity) :time 1))) (add :water 300) ;=> # (def add-some-water (add :water 200)) add-some-water is now a function representing the addition of some water. The function also increments the time taken so far in the recipe. We can use it to transform one state into another: (add-some-water {:time 0, :butter-beans 100}) ;=> {:time 1, :butter-beans 100, :water 200} We can represent any step in our recipe as a function of one state to another. sit leaves the dish to sit for a certain number of minutes, cooling it if it\u2019s warmer than room temperature. For the first time, we\u2019ll use Clojure\u2019s (let [\u2026]) form, which allows us to create local names: (def room-temperature 21) (defn sit [minutes] (fn [dish] (let [temperature (max (- (:temperature dish) (* 2 minutes)) room-temperature)] (mix-in (assoc dish :temperature temperature) :time minutes)))) Sauteing heats up the dish, and evaporates away some of the water: (defn saute [minutes] (fn [dish] (let [hot-dish (assoc dish :temperature 50) reduced-dish (update-in hot-dish [:water] (plus (- minutes)))] (mix-in reduced-dish :time minutes)))) add-water-for adds water to the dish based on the weight of a specified ingredient: (defn add-water-for [ingredient] (fn [dish] (let [quantity (* 2 (ingredient dish))] ((add :water quantity) dish)))) soak transfers mass from :water to another ingredient, representing the water being absorbed over time. drain removes all water from the dish: (defn soak [ingredient minutes] (fn [dish] (let [absorption (/ (:water dish) 2) swelling #(mix-in % ingredient absorption) reduction #(mix-in % :water (- absorption)) absorb (comp swelling reduction)] (mix-in (absorb dish) :time minutes)))) (defn drain [] (fn [dish] (mix-in (dissoc dish :water) :time 3))) The recipe is therefore just a list of functions: (def recipe [(add :beans 150) (add-water-for :beans) (soak :beans (* 4 60)) (drain) (add :water 50) (add :garlic 5) (saute 15) (sit 10) (add :olive-oil 5)]) To work out how the dish changes over the course of its preparation, we just need to progressively apply each step to an initial state, which in this case is {:time 0, :temperature room-temperature}. Clojure\u2019s standard library has a function called reductions that does that for us, returning a list of all the successive states. (defn preparations [steps] (let [perform (fn [dish step] (step dish))] (reductions perform {:time 0, :temperature room-temperature} steps))) (preparations recipe) ;=> ({:time 0, :temperature 21} ; {:time 1, :temperature 21, :beans 150} ; {:time 2, :temperature 21, :water 300, :beans 150} ; {:time 242, :temperature 21, :water 150, :beans 300} ; {:time 245, :temperature 21, :beans 300} ; {:time 246, :temperature 21, :water 50, :beans 300} ; {:time 247, :temperature 21, :garlic 5, :water 50, :beans 300} ; {:time 262, :temperature 50, :garlic 5, :water 35, :beans 300} ; {:time 272, :temperature 30, :garlic 5, :water 35, :beans 300} ; {:time 273, :temperature 30, :olive-oil 5, :garlic 5, :water 35, :beans 300, :time 258}) To prepare a recipe, we just need to take the final state: (defn prepare [steps] (last (preparations steps))) (prepare recipe) ;=> {:time 273, :temperature 30, :olive-oil 5, :garlic 5, :water 35, :beans 300} One advantage of representing a process like this is that we are modelling each state explicitly. For example, if we wanted to calculate what ingredients had been added at a certain time in the preparation, we could. If our dish had been a mutable object, then each time we performed a new step in the recipe the old state would have been lost: (defn ingredients-after [minutes recipe] (let [all-states (preparations recipe) state (first (drop-while #(> minutes (:time %)) all-states))] (keys state))) (ingredients-after 250 recipe) ;=> (:time :temperature :garlic :water :beans) Paradoxically, by avoiding changing individual values, functional programming languages make representing change itself easier. Though functional programming can be used in any domain that object-oriented programming can, I have personally found that domains where time and change are important concepts are where functional programming languages like Clojure really shine.","title":"Clojure as a recipe"},{"location":"clojure-as-a-recipe/#article-by-chris-ford","text":"https://thoughtworks.github.io/p2/issue05/cooking-with-clojure/ Cooking with Clojure Words and Music by Chris Ford When I speak to developers about functional programming, they\u2019re often interested, but are sometimes concerned that functional programming might make it hard to model the \u201creal world\u201d. The theory goes that the everyday world is full of objects that evolve over time, so the most natural way to describe it is using object-oriented design. Leaving aside the question of whether or not programmers should be overly concerned about this thing referred to as the \u201creal world\u201d, functional programming provides a rich set of concepts that are more than adequate for modelling complex domains. As a demonstration of functional design, I\u2019ll use Clojure to describe a recipe. Clojure is a variant of Lisp designed to run on the Java Virtual Machine, and it has the key ingredient that makes functional programming possible \u2013 functions that can be passed around as values, and that reliably return the same output for the same inputs. Here are a couple of simple examples of Clojure: (def y 3) (+ 2 y) ;=> 5 (reduce + [2 3 4 5]) ;=> 14 The first example simply binds the name y to the value 3. The second example is straightforward enough, though it might seem strange that the function + appears inside the braces and in the first position. That\u2019s the way that all Lisps depict function invocation. The third example has a curious aspect \u2013 + is being passed as an argument to the reduce function, which uses it to boil down a list of numbers into a single total. Using functions as values that can be passed around isn\u2019t possible in many object-oriented programming languages like Java, but it turns out to be very useful. Values in Clojure are immutable, meaning that we never destroy old values, we only create new ones representing the new state. Whereas in Java, y = y + 1 means \u201cadd one to y\u201d, the equivalent in Clojure is just a comparison: (= y (+ y 1)) ;=> false Of course, simple expressions on their own aren\u2019t very useful. Here is how to define a named function in Clojure: (defn plus-one [n] (+ 1 n)) (plus-one 4) ;=> 5 Clojure functions can themselves return functions. Here\u2019s a function that makes plus functions. Note that while defn defines a named function, fn creates an anonymous function. (defn plus [incrementor] (fn [n] (+ incrementor n))) (def plus-three (plus 3)) (plus-three 4) ;=> 7 Here\u2019s another function that works like plus, but uses Clojure\u2019s fnil function to use a default value of 0 if nil is supplied: (defn safe-plus [n] (fnil (plus n) 0)) ((safe-plus 4) nil) ;=> 4 Each stage in the recipe will be represented as a simple hash map. Some functional programming languages, like Haskell, have very sophisticated type systems that can tell the compiler when functions are invoked on the wrong kind of arguments. Such systems can be tremendously powerful, but they are not strictly necessary for doing functional programming. By using Clojure, we do not have to manage types or type annotations, but we must accept the burden of ensuring that we invoke our functions in the right way without strong compiler support. The following represents butter-beans with some water added (measured in grams): {:butter-beans 150, :water 300} But we\u2019re modelling a process, not a fixed state, so we also need a way to depict time and change. The following represents the same ingredients, five minutes into the recipe. {:time 5, :butter-beans 150, :water 300} The process of preparing a recipe can then be represented as a series of states: [{:time 0}, {:time 1, :butter-beans 150}, {:time 3, :butter-beans 150, :water 300}] But how do we get from one state to another? This is where the functions come in. Functions are just a way of representing a mapping from one state to another. Here is a simple function that represents mixing in a certain amount of an ingredient: (defn mix-in [dish ingredient quantity] (update-in dish [ingredient] (safe-plus quantity))) (mix-in {:time 1, :butter-beans 150} :water 300) ;=> {:time 1, :butter-beans 150, :water 300} There\u2019s no need to overwrite the original state of the dish. Instead of having objects with identity that morph and mutate over time, functions take the original state and produce a new state. In the example above, mix-in takes a dish that has one minute of elapsed time and 150 grams of butter-beans, and produced a new state that had one minute of elapsed time, 150 grams of butter-beans and 300 grams of water. Remember, functions are themselves values in a functional programming language, so we can represent the addition of a particular ingredient as a function. Note that add is a function that takes the ingredient and its quantity as arguments, and returns another function that represents the actual addition. Clojure has no good way to print functions, so it\u2019s forced to use a somewhat cryptic identifier when displaying a function to the screen: (defn add [ingredient quantity] (fn [dish] (mix-in (mix-in dish ingredient quantity) :time 1))) (add :water 300) ;=> # (def add-some-water (add :water 200)) add-some-water is now a function representing the addition of some water. The function also increments the time taken so far in the recipe. We can use it to transform one state into another: (add-some-water {:time 0, :butter-beans 100}) ;=> {:time 1, :butter-beans 100, :water 200} We can represent any step in our recipe as a function of one state to another. sit leaves the dish to sit for a certain number of minutes, cooling it if it\u2019s warmer than room temperature. For the first time, we\u2019ll use Clojure\u2019s (let [\u2026]) form, which allows us to create local names: (def room-temperature 21) (defn sit [minutes] (fn [dish] (let [temperature (max (- (:temperature dish) (* 2 minutes)) room-temperature)] (mix-in (assoc dish :temperature temperature) :time minutes)))) Sauteing heats up the dish, and evaporates away some of the water: (defn saute [minutes] (fn [dish] (let [hot-dish (assoc dish :temperature 50) reduced-dish (update-in hot-dish [:water] (plus (- minutes)))] (mix-in reduced-dish :time minutes)))) add-water-for adds water to the dish based on the weight of a specified ingredient: (defn add-water-for [ingredient] (fn [dish] (let [quantity (* 2 (ingredient dish))] ((add :water quantity) dish)))) soak transfers mass from :water to another ingredient, representing the water being absorbed over time. drain removes all water from the dish: (defn soak [ingredient minutes] (fn [dish] (let [absorption (/ (:water dish) 2) swelling #(mix-in % ingredient absorption) reduction #(mix-in % :water (- absorption)) absorb (comp swelling reduction)] (mix-in (absorb dish) :time minutes)))) (defn drain [] (fn [dish] (mix-in (dissoc dish :water) :time 3))) The recipe is therefore just a list of functions: (def recipe [(add :beans 150) (add-water-for :beans) (soak :beans (* 4 60)) (drain) (add :water 50) (add :garlic 5) (saute 15) (sit 10) (add :olive-oil 5)]) To work out how the dish changes over the course of its preparation, we just need to progressively apply each step to an initial state, which in this case is {:time 0, :temperature room-temperature}. Clojure\u2019s standard library has a function called reductions that does that for us, returning a list of all the successive states. (defn preparations [steps] (let [perform (fn [dish step] (step dish))] (reductions perform {:time 0, :temperature room-temperature} steps))) (preparations recipe) ;=> ({:time 0, :temperature 21} ; {:time 1, :temperature 21, :beans 150} ; {:time 2, :temperature 21, :water 300, :beans 150} ; {:time 242, :temperature 21, :water 150, :beans 300} ; {:time 245, :temperature 21, :beans 300} ; {:time 246, :temperature 21, :water 50, :beans 300} ; {:time 247, :temperature 21, :garlic 5, :water 50, :beans 300} ; {:time 262, :temperature 50, :garlic 5, :water 35, :beans 300} ; {:time 272, :temperature 30, :garlic 5, :water 35, :beans 300} ; {:time 273, :temperature 30, :olive-oil 5, :garlic 5, :water 35, :beans 300, :time 258}) To prepare a recipe, we just need to take the final state: (defn prepare [steps] (last (preparations steps))) (prepare recipe) ;=> {:time 273, :temperature 30, :olive-oil 5, :garlic 5, :water 35, :beans 300} One advantage of representing a process like this is that we are modelling each state explicitly. For example, if we wanted to calculate what ingredients had been added at a certain time in the preparation, we could. If our dish had been a mutable object, then each time we performed a new step in the recipe the old state would have been lost: (defn ingredients-after [minutes recipe] (let [all-states (preparations recipe) state (first (drop-while #(> minutes (:time %)) all-states))] (keys state))) (ingredients-after 250 recipe) ;=> (:time :temperature :garlic :water :beans) Paradoxically, by avoiding changing individual values, functional programming languages make representing change itself easier. Though functional programming can be used in any domain that object-oriented programming can, I have personally found that domains where time and change are important concepts are where functional programming languages like Clojure really shine.","title":"Article by Chris Ford"},{"location":"core-async/","text":"Core.async \u03bb\ufe0e Discussion from the clojurians clojure-uk slack channel \u03bb\ufe0e recommendation / intro tutorial https://github.com/clojure/core.async/blob/master/examples/walk-through.clj EuroClojure talk about clojure otp library that built on top of core.async because they felt it was too low level At the REPL - if you don\u2019t create channels with non-zero sized buffers, or don\u2019t perform operations in separate threads or go-blocks, then you can end up blocked quite easily In production be sure to catch exceptions, or at least be logging them. It can be too easy to loose errors (and the processes that threw them) if you make a note of the nrepl port when you start a repl, you can always connect a second repl to the same process to recover from accidental blocking core.async and transducers \u03bb\ufe0e core.async + transducers Manifold - alternative to core.async \u03bb\ufe0e another approach is to use manifold it\u2019s use of deferred values makes it harder to block the REPL - but obviously the buffering still has to happen somewhere! manifold for general async stuff more than core.async use core.async as a way of chaining together bits of data processing. manifold would be good for that too put multiple calls to an external API on a channel and have them \u201cdo their thing\u201d in their own time in the background. This seems to be a good use for core.async\u2026 Is Manifold is as good / better? If processing streams of data then core.async is fine (as are manifold Stream s) If calls are better suited to promises then consider manifold Deferred If you are wanting streams of promises then manifold is a more complete solution (because the manifold stream and deferred work easily together API calls are generally more promise-like than stream-like (unless your result is an SSE stream or websocket etc) there are promise-chan s in core.async too though Manifold could be used to collect a number of remote resources together in a let which isn't very stream like manifold has two distinct core abstractions - the deferred , which is a promise with callbacks and additional machinery, and the stream which is a umm stream of values, and supports buffering, backpressure etc First call to the API I will get a total back as part of the result and as there is no paging functionality \u201cbuilt in\u201d on the API in question I will need to take the total and figure out how many more calls I need to make to get the \u201crest\u201d of the data. I was going to do this by throwing the calls onto a channel using core.async\u2026 I am sensing that their promise-y nature would, you feel, be better suited to Manifold Deferred..? a stream or a channel works quite well for that sort of query in my data access lib we actually use a promise of a stream for that sort of access which is an improvement over just a plain stream because it allows easy mixing with other calls which return promises of a value I was intending to stack up API operations in a channel as a queue so that a) I don\u2019t block execution and b) so that I don\u2019t have to use an actual queue (SQS / rabbitMQ etc) I am starting to think I may not have understood the implications of what I want to do\u2026 i'm not sure - are you just trying to get a stream of records from a paginated api ? what are you trying to not block the execution of? The API is not paginated, I need to figure out how many pages there are and stack up the calls. can you pass an offset or something ? What I am looking for is a way to stack work up asynchronously in the background so that my call(s) to the external API don\u2019t lock up the whole app / program for minutes at a time. yes, but there is no \u201cnext\u201d call - the offset and page-size are arbitrary params every call, there is no way to ask for \u201cpage 2 of my last query to the API\u201d a channel of results in core.async is perfectly reasonable, as is a manifold stream of deferred responses so: Make call for first page Process first page (hopefully async) Use total to work out how many more ops I need to make Fill up channel with calls Consume channel \u201celsewhere\u201d. is my thesis - does that make sense..? what is the main thread in this context? the app that \u201cruns\u201d which in turn is a hybrid API / webapp core.async itself uses a threadpool, so you might not need to funnel them all down one channel unless you wanted to limit the number of concurrent api calls I would like to do as much concurrently as possible, but it\u2019s not a deal-breaker, serial is fine as long as the work can be \u201ckicked off\u201d and left going. order of results being processed is not important, so concurrency (particularly if it makes the whole thing faster) would be great. I need to make one call to find out how many results match the request, the vendor / curator of the AI in question is not prepared to produce a simplified response to figure out the size of results sets, so I am stuck with that. I am assuming that I need to \u201cdef\u201d the channel(s) and then have a form that is in an evaluated namespace that is \u201cwaiting\u201d for the channel(s) to have something on them..? a common idiom is to return channels/streams/promises as the result of a query fn OK, but how would I consume them without tying up the main thread? many options - put the consuming code inside a core.async go block - create a new channel with a transducer and pipe your first channel to that - have your api fn take the channel you want responses put on and pass in a channel with a transducer similarly in manifold, - chain a step onto a deferred https://github.com/ztellman/manifold/blob/master/docs/deferred.md#composing-with-deferreds - map a fn over a stream https://github.com/ztellman/manifold/blob/master/docs/stream.md#stream-operators need some code in an evaluated namespace that was effectively \u201clistening\u201d for there to be \u201cthings\u201d on the channel, just a form at the end of my namespace containing a go block that was consuming a named channel onto which my API function would place \u201cthings\u201d most web or UI frameworks will already have an event loop to do that i\u2019d have expected? order of ops: Make first query to API Process result, including calculation of how many more ops required Load up a channel with the other calls It\u2019s an app that will periodically (every hour / day not sure yet) make calls to an API, stash the returned data in a database and an ElasticSearch cluster, and then do it all again the next time. might want to add [4] concatenate results from each of the page queries into a single record stream but what will consume the eventual record stream ? This makes the API into a smaller, custom dataset that can be interrogated via Kibana I am not saying I don\u2019t want to add \u201c[4] concatenate results from each of the page queries into a single record stream\u201d, but I can\u2019t think of why I would do that, and that is probably me being ignorant of the benefits etc. Please could you explain to me why I would add this step - I really am asking, not being a prick, I promise do you want to expose your downstream consumers to an additional level of structure (pages) which is an implementation feature of the upstream API ? No I want to take each of the 100 / 1000 / 10000 results and store them as individual documents in ES and as JSONB fields in Postgres The API I am \u201charvesting\u201d has a 90 day sliding window, so over time the queries I make will have different results. I don\u2019t want to keep track of the last article I harvested, nor do I want to have to \u201cfind\u201d it in the results to then get all the newer ones. It\u2019s easier to just \u201ceat\u201d the whole response every time and reply on ES refusing to re-import a document with an existing id (into the same index) and on postgres\u2019s ability to enforce a \u201cunique\u201d index on the id field. but I can\u2019t \u201cget\u201d all of the results in one query, the API limits \u201cpages\u201d to 1000 results, so I need to be able to stack up calls and execute them in an async, non-blocking manner. yep, so you can concatenate the pages into a single record-stream, and process each of the records individually OK, I like the sound of this in principle, and I think I am sort of doing that already with the synchronous, manual approach, as I get 100 articles back and then I do a doseq over the vector of maps to do INSERT queries into postgres and PUT calls to ES What do you mean by a \u201crecord-stream\u201d? by \"record stream\" i mean a conceptual sequence of individual records... could be on a core.async chan or a manifold stream the benefit is just simplicity - a sequence of individual records is a simpler thing than a sequence of pages of individual records... but there are tradeoffs - sometimes you want to deal with pages of records Oh I see! Right, yeah, I was just going to consume the channel of returned promises with the doseq I already have, so concatenating them together into one HUGE vector first seemed like a redundant step. i.e. one of the queries I am going to do returns (currently) a little over 13,000 records - I was expecting to grab the results of 14 promises off the channel and \u201cdoseq\u201d each one until the channel was empty I suppose I could consume them off the channel into one big vector, or indeed another channel and then have another consumer running what currently runs inside the doseq on each map / JSON blob that comes out of the channel\u2026 Is that what you mean? so: channel of promises consumer turns vector of maps into another channel of individual maps consumer2 puts maps into DB and ES off second channel i meant another channel, yes possibly even: consumer2 puts maps into DB and onto another channel consumer3 puts maps on third channel into ES (as an aside @maleghast , doing any long-running or blocking processing in a vanilla core.async go block isn't a good idea - there is a fixed-size core.async threadpool which you can exhaust, causing blocking - so you can use https://clojure.github.io/core.async/index.html#clojure.core.async/thread ) So if I use thread inside a go block, or instead of a go block..? here is an example (async/go (let [v (async/<! (async/thread (do-blocking-stuff)))] (do-non-blocking-stuff v)) something like that Long running processes \u03bb\ufe0e also, beware long-running processes in core.async that expand items with eg. mapcat operations. You can break back pressure that way. (ie. pages on a channel being expanded into multiple events) ooo i haven't come across that problem what happens ? requires a very specific use case to be a problem, but it\u2019s caught a few people out: https://stackoverflow.com/questions/37953401/where-is-the-memory-leak-when-mapcat-breaks-backpressure-in-core-async Where is the memory leak when mapcat breaks backpressure in core.async? I wrote some core.async code in Clojure and when I ran it it consumed all available memory and failed with an error. It appears that using mapcat in a core.async pipeline breaks back pressure. (Whi... you\u2019re not likely to hit it unless you are using a lot of transforms on your channels, and then its easily worked around, but it can work fine in test, and then blow up in prod with more data/longer running processing","title":"Core.async"},{"location":"core-async/#coreasync","text":"","title":"Core.async"},{"location":"core-async/#discussion-from-the-clojurians-clojure-uk-slack-channel","text":"recommendation / intro tutorial https://github.com/clojure/core.async/blob/master/examples/walk-through.clj EuroClojure talk about clojure otp library that built on top of core.async because they felt it was too low level At the REPL - if you don\u2019t create channels with non-zero sized buffers, or don\u2019t perform operations in separate threads or go-blocks, then you can end up blocked quite easily In production be sure to catch exceptions, or at least be logging them. It can be too easy to loose errors (and the processes that threw them) if you make a note of the nrepl port when you start a repl, you can always connect a second repl to the same process to recover from accidental blocking","title":"Discussion from the clojurians clojure-uk slack channel"},{"location":"core-async/#coreasync-and-transducers","text":"core.async + transducers","title":"core.async and transducers"},{"location":"core-async/#manifold-alternative-to-coreasync","text":"another approach is to use manifold it\u2019s use of deferred values makes it harder to block the REPL - but obviously the buffering still has to happen somewhere! manifold for general async stuff more than core.async use core.async as a way of chaining together bits of data processing. manifold would be good for that too put multiple calls to an external API on a channel and have them \u201cdo their thing\u201d in their own time in the background. This seems to be a good use for core.async\u2026 Is Manifold is as good / better? If processing streams of data then core.async is fine (as are manifold Stream s) If calls are better suited to promises then consider manifold Deferred If you are wanting streams of promises then manifold is a more complete solution (because the manifold stream and deferred work easily together API calls are generally more promise-like than stream-like (unless your result is an SSE stream or websocket etc) there are promise-chan s in core.async too though Manifold could be used to collect a number of remote resources together in a let which isn't very stream like manifold has two distinct core abstractions - the deferred , which is a promise with callbacks and additional machinery, and the stream which is a umm stream of values, and supports buffering, backpressure etc First call to the API I will get a total back as part of the result and as there is no paging functionality \u201cbuilt in\u201d on the API in question I will need to take the total and figure out how many more calls I need to make to get the \u201crest\u201d of the data. I was going to do this by throwing the calls onto a channel using core.async\u2026 I am sensing that their promise-y nature would, you feel, be better suited to Manifold Deferred..? a stream or a channel works quite well for that sort of query in my data access lib we actually use a promise of a stream for that sort of access which is an improvement over just a plain stream because it allows easy mixing with other calls which return promises of a value I was intending to stack up API operations in a channel as a queue so that a) I don\u2019t block execution and b) so that I don\u2019t have to use an actual queue (SQS / rabbitMQ etc) I am starting to think I may not have understood the implications of what I want to do\u2026 i'm not sure - are you just trying to get a stream of records from a paginated api ? what are you trying to not block the execution of? The API is not paginated, I need to figure out how many pages there are and stack up the calls. can you pass an offset or something ? What I am looking for is a way to stack work up asynchronously in the background so that my call(s) to the external API don\u2019t lock up the whole app / program for minutes at a time. yes, but there is no \u201cnext\u201d call - the offset and page-size are arbitrary params every call, there is no way to ask for \u201cpage 2 of my last query to the API\u201d a channel of results in core.async is perfectly reasonable, as is a manifold stream of deferred responses so: Make call for first page Process first page (hopefully async) Use total to work out how many more ops I need to make Fill up channel with calls Consume channel \u201celsewhere\u201d. is my thesis - does that make sense..? what is the main thread in this context? the app that \u201cruns\u201d which in turn is a hybrid API / webapp core.async itself uses a threadpool, so you might not need to funnel them all down one channel unless you wanted to limit the number of concurrent api calls I would like to do as much concurrently as possible, but it\u2019s not a deal-breaker, serial is fine as long as the work can be \u201ckicked off\u201d and left going. order of results being processed is not important, so concurrency (particularly if it makes the whole thing faster) would be great. I need to make one call to find out how many results match the request, the vendor / curator of the AI in question is not prepared to produce a simplified response to figure out the size of results sets, so I am stuck with that. I am assuming that I need to \u201cdef\u201d the channel(s) and then have a form that is in an evaluated namespace that is \u201cwaiting\u201d for the channel(s) to have something on them..? a common idiom is to return channels/streams/promises as the result of a query fn OK, but how would I consume them without tying up the main thread? many options - put the consuming code inside a core.async go block - create a new channel with a transducer and pipe your first channel to that - have your api fn take the channel you want responses put on and pass in a channel with a transducer similarly in manifold, - chain a step onto a deferred https://github.com/ztellman/manifold/blob/master/docs/deferred.md#composing-with-deferreds - map a fn over a stream https://github.com/ztellman/manifold/blob/master/docs/stream.md#stream-operators need some code in an evaluated namespace that was effectively \u201clistening\u201d for there to be \u201cthings\u201d on the channel, just a form at the end of my namespace containing a go block that was consuming a named channel onto which my API function would place \u201cthings\u201d most web or UI frameworks will already have an event loop to do that i\u2019d have expected? order of ops: Make first query to API Process result, including calculation of how many more ops required Load up a channel with the other calls It\u2019s an app that will periodically (every hour / day not sure yet) make calls to an API, stash the returned data in a database and an ElasticSearch cluster, and then do it all again the next time. might want to add [4] concatenate results from each of the page queries into a single record stream but what will consume the eventual record stream ? This makes the API into a smaller, custom dataset that can be interrogated via Kibana I am not saying I don\u2019t want to add \u201c[4] concatenate results from each of the page queries into a single record stream\u201d, but I can\u2019t think of why I would do that, and that is probably me being ignorant of the benefits etc. Please could you explain to me why I would add this step - I really am asking, not being a prick, I promise do you want to expose your downstream consumers to an additional level of structure (pages) which is an implementation feature of the upstream API ? No I want to take each of the 100 / 1000 / 10000 results and store them as individual documents in ES and as JSONB fields in Postgres The API I am \u201charvesting\u201d has a 90 day sliding window, so over time the queries I make will have different results. I don\u2019t want to keep track of the last article I harvested, nor do I want to have to \u201cfind\u201d it in the results to then get all the newer ones. It\u2019s easier to just \u201ceat\u201d the whole response every time and reply on ES refusing to re-import a document with an existing id (into the same index) and on postgres\u2019s ability to enforce a \u201cunique\u201d index on the id field. but I can\u2019t \u201cget\u201d all of the results in one query, the API limits \u201cpages\u201d to 1000 results, so I need to be able to stack up calls and execute them in an async, non-blocking manner. yep, so you can concatenate the pages into a single record-stream, and process each of the records individually OK, I like the sound of this in principle, and I think I am sort of doing that already with the synchronous, manual approach, as I get 100 articles back and then I do a doseq over the vector of maps to do INSERT queries into postgres and PUT calls to ES What do you mean by a \u201crecord-stream\u201d? by \"record stream\" i mean a conceptual sequence of individual records... could be on a core.async chan or a manifold stream the benefit is just simplicity - a sequence of individual records is a simpler thing than a sequence of pages of individual records... but there are tradeoffs - sometimes you want to deal with pages of records Oh I see! Right, yeah, I was just going to consume the channel of returned promises with the doseq I already have, so concatenating them together into one HUGE vector first seemed like a redundant step. i.e. one of the queries I am going to do returns (currently) a little over 13,000 records - I was expecting to grab the results of 14 promises off the channel and \u201cdoseq\u201d each one until the channel was empty I suppose I could consume them off the channel into one big vector, or indeed another channel and then have another consumer running what currently runs inside the doseq on each map / JSON blob that comes out of the channel\u2026 Is that what you mean? so: channel of promises consumer turns vector of maps into another channel of individual maps consumer2 puts maps into DB and ES off second channel i meant another channel, yes possibly even: consumer2 puts maps into DB and onto another channel consumer3 puts maps on third channel into ES (as an aside @maleghast , doing any long-running or blocking processing in a vanilla core.async go block isn't a good idea - there is a fixed-size core.async threadpool which you can exhaust, causing blocking - so you can use https://clojure.github.io/core.async/index.html#clojure.core.async/thread ) So if I use thread inside a go block, or instead of a go block..? here is an example (async/go (let [v (async/<! (async/thread (do-blocking-stuff)))] (do-non-blocking-stuff v)) something like that","title":"Manifold - alternative to core.async"},{"location":"core-async/#long-running-processes","text":"also, beware long-running processes in core.async that expand items with eg. mapcat operations. You can break back pressure that way. (ie. pages on a channel being expanded into multiple events) ooo i haven't come across that problem what happens ? requires a very specific use case to be a problem, but it\u2019s caught a few people out: https://stackoverflow.com/questions/37953401/where-is-the-memory-leak-when-mapcat-breaks-backpressure-in-core-async Where is the memory leak when mapcat breaks backpressure in core.async? I wrote some core.async code in Clojure and when I ran it it consumed all available memory and failed with an error. It appears that using mapcat in a core.async pipeline breaks back pressure. (Whi... you\u2019re not likely to hit it unless you are using a lot of transforms on your channels, and then its easily worked around, but it can work fine in test, and then blow up in prod with more data/longer running processing","title":"Long running processes"},{"location":"explaining-macros/","text":"Explaining Macros \u03bb\ufe0e The macro system allows you to extend the design of the Clojure language, without waiting for the language designers. Hint::Clojure macros are quite unique \u03bb\ufe0e Many languages have macros, although most are more akin to a template systems. Clojure macros are a language within the Clojure language that generate Clojure code when the Clojure Reader parses a macro. In fact the Clojure Reader will pass the macro to the macro reader which does the expansion. Expose as much of your API as possible as functions so that they can be stored in hash-maps, mapped over sequences of widgets, negated with complement, juxtaposed with juxt, and so on. Only define your own macros when functions are insufficient or there is a very common abstraction that creates a simpler system. Hint::Every Macro adds maintenance cost \u03bb\ufe0e Adding custom macros adds a higher maintenance cost to a codebase and increased the amount of on-boarding of developers onto a project. Custom macros are additional abstractions to learn when working with a project that are not common across projects in the same way as clojure.core or common libraries. Functional composition and Macros \u03bb\ufe0e Macros do not compose functionally Macros in Clojure aren't values. They can't be passed as arguments to other functions or macros, can't be returned as the result of computations, and can't be stored in data structures. If macros were values and used as arguments to functions then the compile cycle of Clojure would need to change, otherwise the results of macro expansion wouldn't be known until runtime and could even vary between function calls. Wrapping Macros in functions for composition \u03bb\ufe0e It is possible to wrap a macro in a function and then that macro can be used as part of a functionally composed expression. ( reduce and [ true true false true ]) ;;=> RuntimeException ( reduce # ( and %1 %2 ) [ true true false true ]) ;;=> false If you are doing this, then its more probably that a simple function would be a better approach.","title":"Explaining Macros"},{"location":"explaining-macros/#explaining-macros","text":"The macro system allows you to extend the design of the Clojure language, without waiting for the language designers.","title":"Explaining Macros"},{"location":"explaining-macros/#hintclojure-macros-are-quite-unique","text":"Many languages have macros, although most are more akin to a template systems. Clojure macros are a language within the Clojure language that generate Clojure code when the Clojure Reader parses a macro. In fact the Clojure Reader will pass the macro to the macro reader which does the expansion. Expose as much of your API as possible as functions so that they can be stored in hash-maps, mapped over sequences of widgets, negated with complement, juxtaposed with juxt, and so on. Only define your own macros when functions are insufficient or there is a very common abstraction that creates a simpler system.","title":"Hint::Clojure macros are quite unique"},{"location":"explaining-macros/#hintevery-macro-adds-maintenance-cost","text":"Adding custom macros adds a higher maintenance cost to a codebase and increased the amount of on-boarding of developers onto a project. Custom macros are additional abstractions to learn when working with a project that are not common across projects in the same way as clojure.core or common libraries.","title":"Hint::Every Macro adds maintenance cost"},{"location":"explaining-macros/#functional-composition-and-macros","text":"Macros do not compose functionally Macros in Clojure aren't values. They can't be passed as arguments to other functions or macros, can't be returned as the result of computations, and can't be stored in data structures. If macros were values and used as arguments to functions then the compile cycle of Clojure would need to change, otherwise the results of macro expansion wouldn't be known until runtime and could even vary between function calls.","title":"Functional composition and Macros"},{"location":"explaining-macros/#wrapping-macros-in-functions-for-composition","text":"It is possible to wrap a macro in a function and then that macro can be used as part of a functionally composed expression. ( reduce and [ true true false true ]) ;;=> RuntimeException ( reduce # ( and %1 %2 ) [ true true false true ]) ;;=> false If you are doing this, then its more probably that a simple function would be a better approach.","title":"Wrapping Macros in functions for composition"},{"location":"io/","text":"IO in Clojure \u03bb\ufe0e From http://blog.isaachodes.io/p/clojure-io-p1/ The Ins and Outs of Clojure: Part I November 13, 2010 (Written about Clojure 1.2.) It is a truth universally acknowledged, that a programmer using Clojure will want to perform IO. Let me help you out (put). I\u2019ll go over some of the basics of IO, focusing on what you can use Clojure to do directly. I\u2019ll move on after the basic introduction, to some of the more interesting and generally useful classes that Java offers, giving a little context for each. In Reading files in is generally one of the first things I want to do when playing with a new language, so I\u2019ll start there. Before I get started though, I should mentioned that in Clojure, strings are always encoded using UTF-16. Generally this saves time and worry, but it\u2019s something to keep in mind should you run into problems on the encoding front. slurp Clojure comes with a handy little function called slurp that takes in a string representing a filename (or, really, pretty much anything; a File, a stream, a byte array, URL, etc) and returns a string containing the contents of your file. It\u2019s pretty handy if you just need to get some information from a file that\u2019s relatively small, and you\u2019ll be parsing it yourself. (slurp \"/home/user/file.txt\") => \"A little bit\\nof information here.\" A nice thing about slurp is that you can easily build up file paths with str. For example, say you want to output to a file based on information you find at runtime: (slurp (str \"/home/\" username \"/projects/\" filename)) But slurp is pretty basic, and once your files get large enough, totally impractical. Nonetheless, it\u2019s a handy function to know about. As a useful and comical aside, the function spit is the counterpart to slurp, except that instead of reading input, spit does output. More on this in a future article, though. line-seq One of my favorite IO functions has got to be line-seq; line-seq takes a reader object (which must implement BufferedReader) and returns a lazy sequence of the lines of the text the reader supplies. This is handy when you\u2019re dealing with files (if this offends you, taking a Unix approach here for now and say that everything is a file) that are too big to merely slurp, but that are \\newline delimited (or CR/LF delimited, if you\u2019re of the Windows persuasion). (use '[clojure.java.io '(reader)]) (take 2 (line-seq (reader \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") Notice how we take 2 from the sequence we get from using line-seq. We can take as much or as little as we need; we won\u2019t be reading much (Clojure will read a bit more than you tell it to in order to get more IO performance, but let\u2019s not worry about that) more than we specify. We can do anything we want with the resulting seq; that\u2019s the beauty of line-seq and the ubiquitous sequence abstraction. Back in the day, Clojurists had to sink a little lower than the clojure.java.io namespace to use line-seq; two Java classes were needed. One of these Java classes is the most wondrous and amazing thing just below the surface of the more elegant and beautiful Clojure code; BufferedReader. Here\u2019s how we used to do it; (import '(java.io FileReader BufferedReader)) (take 2 (line-seq (BufferedReader. (FileReader. \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") This might give you a better sense of what\u2019s going on when you use reader, though in reality reader is far more complicated than just that: you can trust it to handle a variety of \u201creadable things\u201d and return to you a BufferedReader if possible. FileReader will return a Reader on a file, and BufferedReader takes and buffers a Reader, as you might have extrapolated from the name. Readers are basically just objects upon which a few methods (like read, skip and close) may be enacted and expected to return reasonable results. line-seq essentially reads up until a line-delimiter and returns the read chunk as an element in the sequence it is generating. While on the subject of files, I should probably mentioned the file function, from clojure.java.io. file takes in an arbitrary number of string arguments, and pieces them together into a file hierarchy, returning a File instance. This can come in handy. Rivers? inputStreams? Brooks? Streams are an especially useful class of readers. Oftentimes you\u2019re reading in text; that\u2019s what Readers do. But often you need to read in a stream of bytes; that\u2019s where you need to use clojure.java.io\u2019s input-stream. (use '[clojure.java.io '(reader)]) (def g (input-stream \"t.txt\")) (.read g) => 105 (.read g) => 115 (char (.read g)) => \\space As you can see, instead of getting characters from this file (like we get when we use a reader), we\u2019re getting integer byte values. This can be useful when reading, for example, a media file. In general, strings are always UTF-16, which are 16-bit pieces of data, whereas byte-streams are 8-bit pieces of data. It bears repeating that the stream operators should be used when you\u2019re not dealing with strings: they are not trivially interchangeable, as they might be in other languages where strings are syntactic sugar for byte arrays. RandomAccessFile Finally, let me introduce to you a spectacularly useful Java class. RandomAccessFile is a class which allows you to quickly jump around in a large file, and read bytes from it. (import '(java.io RandomAccessFile)) (def f (RandomAccessFile. \"stuff.txt\" \"r\")) Note the second argument of the constructor, \u201cr\u201d; this indicates that we\u2019re opening the file just for reading. Now that we have f, we can use it to navigate and read the file: (.read f) => 105 (.length f) => 2015 ;; this is the number of bytes this file is in length (.skipBytes f 20) (.getFilePointer h) => 21 ;; the position we're at in the file (.read f) => 89 As you can see, you can jump around (quickly!) through a file, and read from the parts you want, and skip the parts you do not want. The key methods/functions here (among many others that can also be useful; be sure to check the documentation) are read, length, skipBytes, seek and getFilePointer. Closing Every file that is opened should be closed, and what we\u2019ve been doing is a little unsafe. In order to close an open reader/file, we should use the close method on it; in the above example, when you\u2019re done with f, simply execute (.close f) to tell the file system that you\u2019re done with the file. Alternatively, and more idiomatically, you can open your files with the handy with-open binder: (with-open [f (RandomAccessFile. \"stuff.txt\" \"r\")] (.read f)) When you\u2019re done with f, Clojure will close it, and you won\u2019t have to worry one iota about it. Digging Deeper Should slurp and line-seq not be enough for your reading needs (and chances are that, should you code enough in Clojure, they won\u2019t always been), you might want to explore clojure.java.io some more, as well as some of the Java classes (namely, those stemming from Reader and BufferedReader, as well as InputStream and BufferedInputStream) mentioned above. See my previous article on using Java if you\u2019re unfamiliar with using Java. Next up is an introduction to the \u201couts\u201d of Clojure and Java. Stay tuned! I owe a big thank you to Phil Hagelberg for reading over this essay and offering advice. If you don\u2019t already, you should be using his Leiningen for both dependency management and a stress-free development environment. The Ins and Outs of Clojure: Part I November 13, 2010 (Written about Clojure 1.2.) It is a truth universally acknowledged, that a programmer using Clojure will want to perform IO. Let me help you out (put). I\u2019ll go over some of the basics of IO, focusing on what you can use Clojure to do directly. I\u2019ll move on after the basic introduction, to some of the more interesting and generally useful classes that Java offers, giving a little context for each. In Reading files in is generally one of the first things I want to do when playing with a new language, so I\u2019ll start there. Before I get started though, I should mentioned that in Clojure, strings are always encoded using UTF-16. Generally this saves time and worry, but it\u2019s something to keep in mind should you run into problems on the encoding front. slurp Clojure comes with a handy little function called slurp that takes in a string representing a filename (or, really, pretty much anything; a File, a stream, a byte array, URL, etc) and returns a string containing the contents of your file. It\u2019s pretty handy if you just need to get some information from a file that\u2019s relatively small, and you\u2019ll be parsing it yourself. (slurp \"/home/account/projects/config.txt\") => \"A little bit\\nof information here.\" A nice thing about slurp is that you can easily build up file paths with str. For example, say you want to output to a file based on information you find at runtime: (slurp (str \"/home/\" username \"/projects/\" filename)) But slurp is pretty basic, and once your files get large enough, totally impractical. Nonetheless, it\u2019s a handy function to know about. As a useful and comical aside, the function spit is the counterpart to slurp, except that instead of reading input, spit does output. More on this in a future article, though. line-seq One of my favorite IO functions has got to be line-seq; line-seq takes a reader object (which must implement BufferedReader) and returns a lazy sequence of the lines of the text the reader supplies. This is handy when you\u2019re dealing with files (if this offends you, taking a Unix approach here for now and say that everything is a file) that are too big to merely slurp, but that are \\newline delimited (or CR/LF delimited, if you\u2019re of the Windows persuasion). (use '[clojure.java.io '(reader)]) (take 2 (line-seq (reader \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") Notice how we take 2 from the sequence we get from using line-seq. We can take as much or as little as we need; we won\u2019t be reading much (Clojure will read a bit more than you tell it to in order to get more IO performance, but let\u2019s not worry about that) more than we specify. We can do anything we want with the resulting seq; that\u2019s the beauty of line-seq and the ubiquitous sequence abstraction. Back in the day, Clojurists had to sink a little lower than the clojure.java.io namespace to use line-seq; two Java classes were needed. One of these Java classes is the most wondrous and amazing thing just below the surface of the more elegant and beautiful Clojure code; BufferedReader. Here\u2019s how we used to do it; (import '(java.io FileReader BufferedReader)) (take 2 (line-seq (BufferedReader. (FileReader. \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") This might give you a better sense of what\u2019s going on when you use reader, though in reality reader is far more complicated than just that: you can trust it to handle a variety of \u201creadable things\u201d and return to you a BufferedReader if possible. FileReader will return a Reader on a file, and BufferedReader takes and buffers a Reader, as you might have extrapolated from the name. Readers are basically just objects upon which a few methods (like read, skip and close) may be enacted and expected to return reasonable results. line-seq essentially reads up until a line-delimiter and returns the read chunk as an element in the sequence it is generating. While on the subject of files, I should probably mentioned the file function, from clojure.java.io. file takes in an arbitrary number of string arguments, and pieces them together into a file hierarchy, returning a File instance. This can come in handy. Rivers? inputStreams? Brooks? Streams are an especially useful class of readers. Oftentimes you\u2019re reading in text; that\u2019s what Readers do. But often you need to read in a stream of bytes; that\u2019s where you need to use clojure.java.io\u2019s input-stream. (use '[clojure.java.io '(reader)]) (def g (input-stream \"t.txt\")) (.read g) => 105 (.read g) => 115 (char (.read g)) => \\space As you can see, instead of getting characters from this file (like we get when we use a reader), we\u2019re getting integer byte values. This can be useful when reading, for example, a media file. In general, strings are always UTF-16, which are 16-bit pieces of data, whereas byte-streams are 8-bit pieces of data. It bears repeating that the stream operators should be used when you\u2019re not dealing with strings: they are not trivially interchangeable, as they might be in other languages where strings are syntactic sugar for byte arrays. RandomAccessFile Finally, let me introduce to you a spectacularly useful Java class. RandomAccessFile is a class which allows you to quickly jump around in a large file, and read bytes from it. (import '(java.io RandomAccessFile)) (def f (RandomAccessFile. \"stuff.txt\" \"r\")) Note the second argument of the constructor, \u201cr\u201d; this indicates that we\u2019re opening the file just for reading. Now that we have f, we can use it to navigate and read the file: (.read f) => 105 (.length f) => 2015 ;; this is the number of bytes this file is in length (.skipBytes f 20) (.getFilePointer h) => 21 ;; the position we're at in the file (.read f) => 89 As you can see, you can jump around (quickly!) through a file, and read from the parts you want, and skip the parts you do not want. The key methods/functions here (among many others that can also be useful; be sure to check the documentation) are read, length, skipBytes, seek and getFilePointer. Closing Every file that is opened should be closed, and what we\u2019ve been doing is a little unsafe. In order to close an open reader/file, we should use the close method on it; in the above example, when you\u2019re done with f, simply execute (.close f) to tell the file system that you\u2019re done with the file. Alternatively, and more idiomatically, you can open your files with the handy with-open binder: (with-open [f (RandomAccessFile. \"stuff.txt\" \"r\")] (.read f)) When you\u2019re done with f, Clojure will close it, and you won\u2019t have to worry one iota about it. Digging Deeper Should slurp and line-seq not be enough for your reading needs (and chances are that, should you code enough in Clojure, they won\u2019t always been), you might want to explore clojure.java.io some more, as well as some of the Java classes (namely, those stemming from Reader and BufferedReader, as well as InputStream and BufferedInputStream) mentioned above. See my previous article on using Java if you\u2019re unfamiliar with using Java. Next up is an introduction to the \u201couts\u201d of Clojure and Java. Stay tuned! I owe a big thank you to Phil Hagelberg for reading over this essay and offering advice. If you don\u2019t already, you should be using his Leiningen for both dependency management and a stress-free development environment.","title":"IO in Clojure"},{"location":"io/#io-in-clojure","text":"From http://blog.isaachodes.io/p/clojure-io-p1/ The Ins and Outs of Clojure: Part I November 13, 2010 (Written about Clojure 1.2.) It is a truth universally acknowledged, that a programmer using Clojure will want to perform IO. Let me help you out (put). I\u2019ll go over some of the basics of IO, focusing on what you can use Clojure to do directly. I\u2019ll move on after the basic introduction, to some of the more interesting and generally useful classes that Java offers, giving a little context for each. In Reading files in is generally one of the first things I want to do when playing with a new language, so I\u2019ll start there. Before I get started though, I should mentioned that in Clojure, strings are always encoded using UTF-16. Generally this saves time and worry, but it\u2019s something to keep in mind should you run into problems on the encoding front. slurp Clojure comes with a handy little function called slurp that takes in a string representing a filename (or, really, pretty much anything; a File, a stream, a byte array, URL, etc) and returns a string containing the contents of your file. It\u2019s pretty handy if you just need to get some information from a file that\u2019s relatively small, and you\u2019ll be parsing it yourself. (slurp \"/home/user/file.txt\") => \"A little bit\\nof information here.\" A nice thing about slurp is that you can easily build up file paths with str. For example, say you want to output to a file based on information you find at runtime: (slurp (str \"/home/\" username \"/projects/\" filename)) But slurp is pretty basic, and once your files get large enough, totally impractical. Nonetheless, it\u2019s a handy function to know about. As a useful and comical aside, the function spit is the counterpart to slurp, except that instead of reading input, spit does output. More on this in a future article, though. line-seq One of my favorite IO functions has got to be line-seq; line-seq takes a reader object (which must implement BufferedReader) and returns a lazy sequence of the lines of the text the reader supplies. This is handy when you\u2019re dealing with files (if this offends you, taking a Unix approach here for now and say that everything is a file) that are too big to merely slurp, but that are \\newline delimited (or CR/LF delimited, if you\u2019re of the Windows persuasion). (use '[clojure.java.io '(reader)]) (take 2 (line-seq (reader \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") Notice how we take 2 from the sequence we get from using line-seq. We can take as much or as little as we need; we won\u2019t be reading much (Clojure will read a bit more than you tell it to in order to get more IO performance, but let\u2019s not worry about that) more than we specify. We can do anything we want with the resulting seq; that\u2019s the beauty of line-seq and the ubiquitous sequence abstraction. Back in the day, Clojurists had to sink a little lower than the clojure.java.io namespace to use line-seq; two Java classes were needed. One of these Java classes is the most wondrous and amazing thing just below the surface of the more elegant and beautiful Clojure code; BufferedReader. Here\u2019s how we used to do it; (import '(java.io FileReader BufferedReader)) (take 2 (line-seq (BufferedReader. (FileReader. \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") This might give you a better sense of what\u2019s going on when you use reader, though in reality reader is far more complicated than just that: you can trust it to handle a variety of \u201creadable things\u201d and return to you a BufferedReader if possible. FileReader will return a Reader on a file, and BufferedReader takes and buffers a Reader, as you might have extrapolated from the name. Readers are basically just objects upon which a few methods (like read, skip and close) may be enacted and expected to return reasonable results. line-seq essentially reads up until a line-delimiter and returns the read chunk as an element in the sequence it is generating. While on the subject of files, I should probably mentioned the file function, from clojure.java.io. file takes in an arbitrary number of string arguments, and pieces them together into a file hierarchy, returning a File instance. This can come in handy. Rivers? inputStreams? Brooks? Streams are an especially useful class of readers. Oftentimes you\u2019re reading in text; that\u2019s what Readers do. But often you need to read in a stream of bytes; that\u2019s where you need to use clojure.java.io\u2019s input-stream. (use '[clojure.java.io '(reader)]) (def g (input-stream \"t.txt\")) (.read g) => 105 (.read g) => 115 (char (.read g)) => \\space As you can see, instead of getting characters from this file (like we get when we use a reader), we\u2019re getting integer byte values. This can be useful when reading, for example, a media file. In general, strings are always UTF-16, which are 16-bit pieces of data, whereas byte-streams are 8-bit pieces of data. It bears repeating that the stream operators should be used when you\u2019re not dealing with strings: they are not trivially interchangeable, as they might be in other languages where strings are syntactic sugar for byte arrays. RandomAccessFile Finally, let me introduce to you a spectacularly useful Java class. RandomAccessFile is a class which allows you to quickly jump around in a large file, and read bytes from it. (import '(java.io RandomAccessFile)) (def f (RandomAccessFile. \"stuff.txt\" \"r\")) Note the second argument of the constructor, \u201cr\u201d; this indicates that we\u2019re opening the file just for reading. Now that we have f, we can use it to navigate and read the file: (.read f) => 105 (.length f) => 2015 ;; this is the number of bytes this file is in length (.skipBytes f 20) (.getFilePointer h) => 21 ;; the position we're at in the file (.read f) => 89 As you can see, you can jump around (quickly!) through a file, and read from the parts you want, and skip the parts you do not want. The key methods/functions here (among many others that can also be useful; be sure to check the documentation) are read, length, skipBytes, seek and getFilePointer. Closing Every file that is opened should be closed, and what we\u2019ve been doing is a little unsafe. In order to close an open reader/file, we should use the close method on it; in the above example, when you\u2019re done with f, simply execute (.close f) to tell the file system that you\u2019re done with the file. Alternatively, and more idiomatically, you can open your files with the handy with-open binder: (with-open [f (RandomAccessFile. \"stuff.txt\" \"r\")] (.read f)) When you\u2019re done with f, Clojure will close it, and you won\u2019t have to worry one iota about it. Digging Deeper Should slurp and line-seq not be enough for your reading needs (and chances are that, should you code enough in Clojure, they won\u2019t always been), you might want to explore clojure.java.io some more, as well as some of the Java classes (namely, those stemming from Reader and BufferedReader, as well as InputStream and BufferedInputStream) mentioned above. See my previous article on using Java if you\u2019re unfamiliar with using Java. Next up is an introduction to the \u201couts\u201d of Clojure and Java. Stay tuned! I owe a big thank you to Phil Hagelberg for reading over this essay and offering advice. If you don\u2019t already, you should be using his Leiningen for both dependency management and a stress-free development environment. The Ins and Outs of Clojure: Part I November 13, 2010 (Written about Clojure 1.2.) It is a truth universally acknowledged, that a programmer using Clojure will want to perform IO. Let me help you out (put). I\u2019ll go over some of the basics of IO, focusing on what you can use Clojure to do directly. I\u2019ll move on after the basic introduction, to some of the more interesting and generally useful classes that Java offers, giving a little context for each. In Reading files in is generally one of the first things I want to do when playing with a new language, so I\u2019ll start there. Before I get started though, I should mentioned that in Clojure, strings are always encoded using UTF-16. Generally this saves time and worry, but it\u2019s something to keep in mind should you run into problems on the encoding front. slurp Clojure comes with a handy little function called slurp that takes in a string representing a filename (or, really, pretty much anything; a File, a stream, a byte array, URL, etc) and returns a string containing the contents of your file. It\u2019s pretty handy if you just need to get some information from a file that\u2019s relatively small, and you\u2019ll be parsing it yourself. (slurp \"/home/account/projects/config.txt\") => \"A little bit\\nof information here.\" A nice thing about slurp is that you can easily build up file paths with str. For example, say you want to output to a file based on information you find at runtime: (slurp (str \"/home/\" username \"/projects/\" filename)) But slurp is pretty basic, and once your files get large enough, totally impractical. Nonetheless, it\u2019s a handy function to know about. As a useful and comical aside, the function spit is the counterpart to slurp, except that instead of reading input, spit does output. More on this in a future article, though. line-seq One of my favorite IO functions has got to be line-seq; line-seq takes a reader object (which must implement BufferedReader) and returns a lazy sequence of the lines of the text the reader supplies. This is handy when you\u2019re dealing with files (if this offends you, taking a Unix approach here for now and say that everything is a file) that are too big to merely slurp, but that are \\newline delimited (or CR/LF delimited, if you\u2019re of the Windows persuasion). (use '[clojure.java.io '(reader)]) (take 2 (line-seq (reader \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") Notice how we take 2 from the sequence we get from using line-seq. We can take as much or as little as we need; we won\u2019t be reading much (Clojure will read a bit more than you tell it to in order to get more IO performance, but let\u2019s not worry about that) more than we specify. We can do anything we want with the resulting seq; that\u2019s the beauty of line-seq and the ubiquitous sequence abstraction. Back in the day, Clojurists had to sink a little lower than the clojure.java.io namespace to use line-seq; two Java classes were needed. One of these Java classes is the most wondrous and amazing thing just below the surface of the more elegant and beautiful Clojure code; BufferedReader. Here\u2019s how we used to do it; (import '(java.io FileReader BufferedReader)) (take 2 (line-seq (BufferedReader. (FileReader. \"bobby.txt\"))) => (\"Bobby was a good boy,\" \"and didn't complain too much\") This might give you a better sense of what\u2019s going on when you use reader, though in reality reader is far more complicated than just that: you can trust it to handle a variety of \u201creadable things\u201d and return to you a BufferedReader if possible. FileReader will return a Reader on a file, and BufferedReader takes and buffers a Reader, as you might have extrapolated from the name. Readers are basically just objects upon which a few methods (like read, skip and close) may be enacted and expected to return reasonable results. line-seq essentially reads up until a line-delimiter and returns the read chunk as an element in the sequence it is generating. While on the subject of files, I should probably mentioned the file function, from clojure.java.io. file takes in an arbitrary number of string arguments, and pieces them together into a file hierarchy, returning a File instance. This can come in handy. Rivers? inputStreams? Brooks? Streams are an especially useful class of readers. Oftentimes you\u2019re reading in text; that\u2019s what Readers do. But often you need to read in a stream of bytes; that\u2019s where you need to use clojure.java.io\u2019s input-stream. (use '[clojure.java.io '(reader)]) (def g (input-stream \"t.txt\")) (.read g) => 105 (.read g) => 115 (char (.read g)) => \\space As you can see, instead of getting characters from this file (like we get when we use a reader), we\u2019re getting integer byte values. This can be useful when reading, for example, a media file. In general, strings are always UTF-16, which are 16-bit pieces of data, whereas byte-streams are 8-bit pieces of data. It bears repeating that the stream operators should be used when you\u2019re not dealing with strings: they are not trivially interchangeable, as they might be in other languages where strings are syntactic sugar for byte arrays. RandomAccessFile Finally, let me introduce to you a spectacularly useful Java class. RandomAccessFile is a class which allows you to quickly jump around in a large file, and read bytes from it. (import '(java.io RandomAccessFile)) (def f (RandomAccessFile. \"stuff.txt\" \"r\")) Note the second argument of the constructor, \u201cr\u201d; this indicates that we\u2019re opening the file just for reading. Now that we have f, we can use it to navigate and read the file: (.read f) => 105 (.length f) => 2015 ;; this is the number of bytes this file is in length (.skipBytes f 20) (.getFilePointer h) => 21 ;; the position we're at in the file (.read f) => 89 As you can see, you can jump around (quickly!) through a file, and read from the parts you want, and skip the parts you do not want. The key methods/functions here (among many others that can also be useful; be sure to check the documentation) are read, length, skipBytes, seek and getFilePointer. Closing Every file that is opened should be closed, and what we\u2019ve been doing is a little unsafe. In order to close an open reader/file, we should use the close method on it; in the above example, when you\u2019re done with f, simply execute (.close f) to tell the file system that you\u2019re done with the file. Alternatively, and more idiomatically, you can open your files with the handy with-open binder: (with-open [f (RandomAccessFile. \"stuff.txt\" \"r\")] (.read f)) When you\u2019re done with f, Clojure will close it, and you won\u2019t have to worry one iota about it. Digging Deeper Should slurp and line-seq not be enough for your reading needs (and chances are that, should you code enough in Clojure, they won\u2019t always been), you might want to explore clojure.java.io some more, as well as some of the Java classes (namely, those stemming from Reader and BufferedReader, as well as InputStream and BufferedInputStream) mentioned above. See my previous article on using Java if you\u2019re unfamiliar with using Java. Next up is an introduction to the \u201couts\u201d of Clojure and Java. Stay tuned! I owe a big thank you to Phil Hagelberg for reading over this essay and offering advice. If you don\u2019t already, you should be using his Leiningen for both dependency management and a stress-free development environment.","title":"IO in Clojure"},{"location":"lazy-evaluation/","text":"repeat","title":"Lazy evaluation"},{"location":"namespace-design/","text":"Namespace Design \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Namespace size \u03bb\ufe0e When is a namespace too big? I suggest there is no 'size' limit to a namespace, as you can always code fold and have much less code showing. Namespaces are a way to logically group behaviour (functions) and information (data structures), so as you think about the aspects or components of your codebase then namespaces should evolve fairly naturally. Start with one namespace and split out into more when it makes sense to logically separate parts of the system. To help understanding when to refactor, use comments to identify sections of your code. For example, group functions and vars via concepts such as application state, helper functions, areas of business logic, system, services, etc. Hint::Caveats \u03bb\ufe0e If your namespace is too big to load into your editor comfortably, then its time to refactor Notes from #clojure-uk slack channel \u03bb\ufe0e how big is too big for a namespace? about ~200 lines and I start thinking \u201chmm, I should break this down\u201d, but should I instead just turn my monitor sideways? IMO it depends on the problem space you're dealing with. I don't see an issue with a file growing larger than 200 loc if all the code is very relevant to the namespace IMO: No function should be larger than a screen (horizontal). For a namespace, count the number of publicly available functions and cap it at a aesthetically reasonable number. (edited) For example: a really large namespace that\u2019s all about page rendering. Group functions based on their conceptual use within that namespace and if a particular part of the page gets complex and thought about as it\u2019s own thing (like a file up-loader or editor), split into it\u2019s own namespace A small main namespace can generally be a good sign of a well organised project, with clearly understood additional namespaces that are logically separate. I think there was around 8,000 lines of code. The largest single code file contained all the configuration/environment variables (using aero to manage multiple regions and hardware environments, prod, qa, uat, dev). God classes come into being (IMO) for lack of function capabilities Each and every Util would be better as separate functions we grew some very large namespaces quite early on - i remember splitting one monster down into 9 separate namespaces at one point. i think there is less of a tendency to large namespaces in yapster now, perhaps because there are so many namespaces already that there is no draw to \u201ckeep things simple\u201d by avoiding creating further namespaces More to the point I\u2019m just reading simple vs easy. A screen-sized function is easy (to read, because you need never to cache its above-fold contents in your memory.) A namespace is simple if it has a single concern. i think our largest namespaces are unit-test namespaces now, because they are constrained by relation to the code being tested for me it\u2019s usually ease of comprehension i think the single-concern thing is right - i need to be able to forget about as much as possible to focus on what\u2019s important, and it\u2019s much easier to forget about simple stuff lein var-graph useful as a way of visualising if I can/should break up a namespace btw, this is the one I'm breaking up atm https://gist.github.com/otfrom/92ac4d4f1c175f017380b6ef2dbb4853 it is looking at this repo: https://github.com/MastodonC/witan.send https://github.com/gfredericks/clj-usage-graph I look for things where there are arrows coming in from lots of different namespaces into one thing and I look for things where the arrow comes into a namespace from only one other (a helper function that isn't very local) single responsibility is usually the key. I think it\u2019s worth mentioning there are two different styles of slicing functionality/responsibilities. One is vertically, the other is horizontally. I think vertically sliced usually belongs to applications; and it means that you want to slice namespaces per feature; not by layer; i.e. I consider it a bit of a smell to have in a web app my-web-service.handlers , my-web-service.models , my-web-service.templates \u2026 unfortunately as far as I\u2019ve seen most getting started templates tend to slice apps this way\u2026 which I think scales poorly; and results in a mixing of concerns. In apps I much prefer to see my-web-service.blog , my-web-service.follow , my-web-service.product.search my-web-service.product.purchase etc\u2026 Things can then be split horizontally within those; if required. Splitting this way makes it much easier to write tests; and much easier to verify where you have test coverage and where you don\u2019t\u2026 as you should basically have at least 1 test ns per namespace. If things are split horizontally different features get mixed up and split in weird ways that becomes harder to verify they\u2019re tested etc. Libraries tend to be for more cross-cutting concerns; they\u2019re by definition usually intended to be reusable. So I think it\u2019s more natural to split them horizontally\u2026 e.g. a library for database access, a library for async stuff, a library for string manipulation. i.e. you expect a bucket of miscellaneous functions for doing X in a namespace. I'm trying to make witan.send more vertical and see if there is a library (around monte carlo methods and markov chains and others) that can be factored out here is what the app used to look like: https://gist.github.com/otfrom/f511916d77851ee2de776445dac3e89c I'm iteratively refactoring from the entry point (and hitting some of the obvious ones in other parts) and just doing the really mechanical ones first I think a feature first templating system would be harder to write though. Why does vertical work better than horizontal? Doesn't it actually result in a mixing of feature logic with http semantics? A number of reasons: The app\u2019s layout immediately tells you about what the app is doing ; rather than how it is doing it\u2026 i.e. the what is brought up to the top of the app, rather than being buried and split across leaf namespaces. This I think has huge benefits for onboarding, and groking a new unfamiliar app. Typically one works on a feature at a time; which means the majority of changes occur together. I personally find it easier to work on things when all the files are co-located, rather than split across a large tree\u2026 though this latter point is perhaps more subjective. Split by feature typically results in less conflicts when multiple developers are adding features\u2026. though cross cutting changes will clearly touch lots of things\u2026 yes there are trade offs Easier to confirm things are tested/untested. Probably less bespoke rules about where things go, leading to greater consistency. I think it\u2019s easier to say to people \u201call feature stuff goes together\u201d, and have your expectations met rather than horizontally dividing things, where people tend to make more wildly different decisions (in my experience). On the mixing HTTP semantics front\u2026 it depends what you mean by semantics. I think HTTP semantics tend to get removed pretty quickly in the handlers\u2026 but yes in rest features tend to map roughly to routes, and the rules about roughly follows the route form\u2026 though I think that\u2019s more a coincidence of organising features into tree\u2019s (paths on filesystem and http) rather than being about HTTP semantics. Within a large feature splitting horizontally; or by input/output operations also works well IMHO. Obviously you have the problem of where to put shared stuff\u2026 I typically like to organise this in a common namespace; often at various levels of hierarchy\u2026. The more common stuff is the closer to the root common it moves. common stuff is then also a good candidate for factoring out into libraries. ( got to go do some decorating - bbl) (edited) The django approach in python is supposed to be vertical slicing, but it tends toward a collection of monoliths, so you end up having to use e.g. flask to do micro-services instead By http semantics, I mean that you put together your counter and ring handler in one area. It's harder to have the layer split perhaps? Possibly\u2026 but it\u2019s not something I\u2019ve seen happening. I certainly agree that you don\u2019t want response codes etc being mixed with business logic; but people seem to understand that\u2019s the job of the handler/middleware layer - or your \u201cresource\u201d abstraction if you\u2019re using something like liberator/yada/compojure-api etc. I\u2019m personally not too prescriptive about every feature having a app.feature.handler namespace as some trivial features may just be app.feature , which contains the handler and the data access etc in a single namespace. When you do that the functions should be clearly layered, but there\u2019s no point adding extra boilerplate/files etc if it\u2019s not serving a purpose\u2026. basically features & apps should be organised at a level that\u2019s appropriate for their complexity. At the point you start sprouting more than a handful of http helper functions to handle http things, and/or the same for data access / business logic etc, you should definitely start splitting horizontally but within the initial vertical feature layering. Sometimes you might want to group features into top level feature categories etc\u2026 but these are bridges you should cross as you come to them.","title":"Namespace Design"},{"location":"namespace-design/#namespace-design","text":"","title":"Namespace Design"},{"location":"namespace-design/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"namespace-design/#namespace-size","text":"When is a namespace too big? I suggest there is no 'size' limit to a namespace, as you can always code fold and have much less code showing. Namespaces are a way to logically group behaviour (functions) and information (data structures), so as you think about the aspects or components of your codebase then namespaces should evolve fairly naturally. Start with one namespace and split out into more when it makes sense to logically separate parts of the system. To help understanding when to refactor, use comments to identify sections of your code. For example, group functions and vars via concepts such as application state, helper functions, areas of business logic, system, services, etc.","title":"Namespace size"},{"location":"namespace-design/#hintcaveats","text":"If your namespace is too big to load into your editor comfortably, then its time to refactor","title":"Hint::Caveats"},{"location":"namespace-design/#notes-from-clojure-uk-slack-channel","text":"how big is too big for a namespace? about ~200 lines and I start thinking \u201chmm, I should break this down\u201d, but should I instead just turn my monitor sideways? IMO it depends on the problem space you're dealing with. I don't see an issue with a file growing larger than 200 loc if all the code is very relevant to the namespace IMO: No function should be larger than a screen (horizontal). For a namespace, count the number of publicly available functions and cap it at a aesthetically reasonable number. (edited) For example: a really large namespace that\u2019s all about page rendering. Group functions based on their conceptual use within that namespace and if a particular part of the page gets complex and thought about as it\u2019s own thing (like a file up-loader or editor), split into it\u2019s own namespace A small main namespace can generally be a good sign of a well organised project, with clearly understood additional namespaces that are logically separate. I think there was around 8,000 lines of code. The largest single code file contained all the configuration/environment variables (using aero to manage multiple regions and hardware environments, prod, qa, uat, dev). God classes come into being (IMO) for lack of function capabilities Each and every Util would be better as separate functions we grew some very large namespaces quite early on - i remember splitting one monster down into 9 separate namespaces at one point. i think there is less of a tendency to large namespaces in yapster now, perhaps because there are so many namespaces already that there is no draw to \u201ckeep things simple\u201d by avoiding creating further namespaces More to the point I\u2019m just reading simple vs easy. A screen-sized function is easy (to read, because you need never to cache its above-fold contents in your memory.) A namespace is simple if it has a single concern. i think our largest namespaces are unit-test namespaces now, because they are constrained by relation to the code being tested for me it\u2019s usually ease of comprehension i think the single-concern thing is right - i need to be able to forget about as much as possible to focus on what\u2019s important, and it\u2019s much easier to forget about simple stuff lein var-graph useful as a way of visualising if I can/should break up a namespace btw, this is the one I'm breaking up atm https://gist.github.com/otfrom/92ac4d4f1c175f017380b6ef2dbb4853 it is looking at this repo: https://github.com/MastodonC/witan.send https://github.com/gfredericks/clj-usage-graph I look for things where there are arrows coming in from lots of different namespaces into one thing and I look for things where the arrow comes into a namespace from only one other (a helper function that isn't very local) single responsibility is usually the key. I think it\u2019s worth mentioning there are two different styles of slicing functionality/responsibilities. One is vertically, the other is horizontally. I think vertically sliced usually belongs to applications; and it means that you want to slice namespaces per feature; not by layer; i.e. I consider it a bit of a smell to have in a web app my-web-service.handlers , my-web-service.models , my-web-service.templates \u2026 unfortunately as far as I\u2019ve seen most getting started templates tend to slice apps this way\u2026 which I think scales poorly; and results in a mixing of concerns. In apps I much prefer to see my-web-service.blog , my-web-service.follow , my-web-service.product.search my-web-service.product.purchase etc\u2026 Things can then be split horizontally within those; if required. Splitting this way makes it much easier to write tests; and much easier to verify where you have test coverage and where you don\u2019t\u2026 as you should basically have at least 1 test ns per namespace. If things are split horizontally different features get mixed up and split in weird ways that becomes harder to verify they\u2019re tested etc. Libraries tend to be for more cross-cutting concerns; they\u2019re by definition usually intended to be reusable. So I think it\u2019s more natural to split them horizontally\u2026 e.g. a library for database access, a library for async stuff, a library for string manipulation. i.e. you expect a bucket of miscellaneous functions for doing X in a namespace. I'm trying to make witan.send more vertical and see if there is a library (around monte carlo methods and markov chains and others) that can be factored out here is what the app used to look like: https://gist.github.com/otfrom/f511916d77851ee2de776445dac3e89c I'm iteratively refactoring from the entry point (and hitting some of the obvious ones in other parts) and just doing the really mechanical ones first I think a feature first templating system would be harder to write though. Why does vertical work better than horizontal? Doesn't it actually result in a mixing of feature logic with http semantics? A number of reasons: The app\u2019s layout immediately tells you about what the app is doing ; rather than how it is doing it\u2026 i.e. the what is brought up to the top of the app, rather than being buried and split across leaf namespaces. This I think has huge benefits for onboarding, and groking a new unfamiliar app. Typically one works on a feature at a time; which means the majority of changes occur together. I personally find it easier to work on things when all the files are co-located, rather than split across a large tree\u2026 though this latter point is perhaps more subjective. Split by feature typically results in less conflicts when multiple developers are adding features\u2026. though cross cutting changes will clearly touch lots of things\u2026 yes there are trade offs Easier to confirm things are tested/untested. Probably less bespoke rules about where things go, leading to greater consistency. I think it\u2019s easier to say to people \u201call feature stuff goes together\u201d, and have your expectations met rather than horizontally dividing things, where people tend to make more wildly different decisions (in my experience). On the mixing HTTP semantics front\u2026 it depends what you mean by semantics. I think HTTP semantics tend to get removed pretty quickly in the handlers\u2026 but yes in rest features tend to map roughly to routes, and the rules about roughly follows the route form\u2026 though I think that\u2019s more a coincidence of organising features into tree\u2019s (paths on filesystem and http) rather than being about HTTP semantics. Within a large feature splitting horizontally; or by input/output operations also works well IMHO. Obviously you have the problem of where to put shared stuff\u2026 I typically like to organise this in a common namespace; often at various levels of hierarchy\u2026. The more common stuff is the closer to the root common it moves. common stuff is then also a good candidate for factoring out into libraries. ( got to go do some decorating - bbl) (edited) The django approach in python is supposed to be vertical slicing, but it tends toward a collection of monoliths, so you end up having to use e.g. flask to do micro-services instead By http semantics, I mean that you put together your counter and ring handler in one area. It's harder to have the layer split perhaps? Possibly\u2026 but it\u2019s not something I\u2019ve seen happening. I certainly agree that you don\u2019t want response codes etc being mixed with business logic; but people seem to understand that\u2019s the job of the handler/middleware layer - or your \u201cresource\u201d abstraction if you\u2019re using something like liberator/yada/compojure-api etc. I\u2019m personally not too prescriptive about every feature having a app.feature.handler namespace as some trivial features may just be app.feature , which contains the handler and the data access etc in a single namespace. When you do that the functions should be clearly layered, but there\u2019s no point adding extra boilerplate/files etc if it\u2019s not serving a purpose\u2026. basically features & apps should be organised at a level that\u2019s appropriate for their complexity. At the point you start sprouting more than a handful of http helper functions to handle http things, and/or the same for data access / business logic etc, you should definitely start splitting horizontally but within the initial vertical feature layering. Sometimes you might want to group features into top level feature categories etc\u2026 but these are bridges you should cross as you come to them.","title":"Notes from #clojure-uk slack channel"},{"location":"testing-in-clojure/","text":"My recommended Clojure testing setup kaocha test runner in watch mode Occasionally, either on Stack Overflow or in the Clojurians Slack group, someone will ask what tools they should use to test Clojure code. Below is what I would currently recommend. I\u2019ve come to this recommendation through observing teams using a variety of testing tools and through my own use them. Use clojure.test with humane-test-output and lein-test-refresh. Use clojure.test clojure.test is ubiquitous and not a big departure from other languages' testing libraries. It has its warts but your team will be able to understand it quickly and will be able to write maintainable tests. Use humane-test-output You should use clojure.test with humane-test-output. Together they provide a testing library that has minimal additional syntax and good test failure reporting. Use lein-test-refresh If you\u2019re not using a tool that reloads and reruns your tests on file changes then you are wasting your time. The delay between changing code and seeing test results is drastically reduced by using a tool like lein-test-refresh. Nearly everyone I know who tries adding lein-test-refresh to their testing toolbox continues to use it. Many of these converts were not newcomers to Clojure either, they had years of experience and had already developed workflows that worked for them. Use lein-test-refresh\u2019s advanced features lein-test-refresh makes development better even if you don\u2019t change any of its settings. It gets even better if you use some of its advanced features. Below is a stripped down version of my ~/.lein/profiles.clj. The :test-refresh key points towards my recommended lein-test-refresh settings. {:user {:dependencies [[pjstadig/humane-test-output \"0.8.0\"]] :injections [(require 'pjstadig.humane-test-output) (pjstadig.humane-test-output/activate!)] :plugins [[[com.jakemccrary/lein-test-refresh \"0.16.0\"]]] :test-refresh {:notify-command [\"terminal-notifier\" \"-title\" \"Tests\" \"-message\"] :quiet true :changes-only true}}} These settings turn on notifications when my tests finish running (:notify-command setting), make clojure.test\u2019s output less verbose (:quiet true), and only run tests in namespaces affected by the previous code change (:changes-only true). These three settings give me the quickest feedback possible and free me from having the terminal running lein test-refresh visible. Quick feedback lets you make changes faster. If you\u2019re going to write tests, and you should write tests, having them run quickly is powerful. After years of writing Clojure, this is my current go-to for testing Clojure code and getting extremely fast feedback. I use test-refresh every day. Frankly I'm not sure how one can program effectively without it. I especially like being able to control the notifications","title":"Testing in clojure"},{"location":"alternative-tools/","text":"Alternative Tools \u03bb\ufe0e","title":"Alternative Tools"},{"location":"alternative-tools/#alternative-tools","text":"","title":"Alternative Tools"},{"location":"alternative-tools/clojure-cli/basic-repl/","text":"Basic Command Line REPL UI \u03bb\ufe0e The clojure command will start a REPL by default or if given the --repl argument. clj is a script that wraps the clojure command and uses rlwrap , an external readline command, to navigate REPL history via the \u2191 and \u2193 keys. Use clj when you want to run a repl (or preferably use rebel readline instead) and clojure for everything else. Hint::rebel readline feature rich repl \u03bb\ufe0e rebel readline is a command line REPL UI that provides interactive help, function autocomplete, signature prompts and many other features to provide a very rich REPL experience. practicalli/clojure-deps-edn includes the -M:repl/rebel alias to run rebel readline REPL. clojure command in a terminal window starts a Clojure REPL and shows the version of Clojure used. The command does not need to be in a directory containing a Clojure project. clojure Type in a Clojure expression at the => user prompt and press Return to see the result Clojure code can now be run in the REPL by typing the code and pressing the ENTER key. Exit the REPL by typing Ctrl+D (pressing the Ctrl and D keys at the same time).","title":"Basic Command Line REPL UI"},{"location":"alternative-tools/clojure-cli/basic-repl/#basic-command-line-repl-ui","text":"The clojure command will start a REPL by default or if given the --repl argument. clj is a script that wraps the clojure command and uses rlwrap , an external readline command, to navigate REPL history via the \u2191 and \u2193 keys. Use clj when you want to run a repl (or preferably use rebel readline instead) and clojure for everything else.","title":"Basic Command Line REPL UI"},{"location":"alternative-tools/clojure-cli/basic-repl/#hintrebel-readline-feature-rich-repl","text":"rebel readline is a command line REPL UI that provides interactive help, function autocomplete, signature prompts and many other features to provide a very rich REPL experience. practicalli/clojure-deps-edn includes the -M:repl/rebel alias to run rebel readline REPL. clojure command in a terminal window starts a Clojure REPL and shows the version of Clojure used. The command does not need to be in a directory containing a Clojure project. clojure Type in a Clojure expression at the => user prompt and press Return to see the result Clojure code can now be run in the REPL by typing the code and pressing the ENTER key. Exit the REPL by typing Ctrl+D (pressing the Ctrl and D keys at the same time).","title":"Hint::rebel readline feature rich repl"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/","text":"Cognitect REBL data browser \u03bb\ufe0e Cognitect REBL captures the results of evaluating expressions and visualizes them in a human readable form. REBL was initially created to support development with the Datomic database and is useful viewing and navigating data structures, especially nested data structures and large data sets. REBL requires an end user license and a personal access token to obtain the packaged library. Open alternatives include Reveal and Portal , which are simpler to install. {% youtube %} https://www.youtube.com/watch?v=c52QhiXsmyI Sign-up for Cognitect dev-tools license \u03bb\ufe0e REBL is part of the Cognitect dev-tools project that also includes Datomic dev-local (local running instance of Datomic). Accept the Cognitect dev-tools license to receive an email containing a link to download the latest version of Datomic local and a personal access token for access to the Cognitect Maven repository which contains the REBL library. Follow the maven configuration link in the email to configure your build tool (Clojure CLI tools or Leiningen) and the repository in the project pom.xml. Aliases for Cognitect REBL \u03bb\ufe0e Follow the REBL installation steps to create an alias in the user-wide deps.edn configuration. Alternatively, use the practicalli/clojure-deps-edn configuration which contains the :inspect/rebl alias for use with Java 11. Running REBL with a project \u03bb\ufe0e Run the project using the Clojure CLI tools clojure -M:inspect/rebl If rlwrap is installed, then use: clj -M:inspect/rebl Configure REBL with Clojure editors \u03bb\ufe0e nrebl.middleware is a middleware library that listens to the nREPL connection between editor and REPL, sending the results of every evaluation to Cognitect REBL. This library is described as very alpha but works in basic tests run by Practicalli. {% tabs practicalli2=\"practicalli/clojure-deps-edn\", manual2=\"Manually add Alias\" %} {% content \"practicalli2\" %} An :middleware/nrebl alias along with the supporting :lib/cider-nrepl aliases are included in practicalli/clojure-deps-edn configuration {% content \"manual2\" %} Add an alias called :middleware/nrebl to ~/.clojure/deps.edn or a deps.edn file in the root of a specific project :middleware/nrebl { :extra-deps { rickmoynihan/nrebl.middleware { :mvn/version \"0.3.1\" }} :main-opts [ \"-e\" \"((requiring-resolve,'cognitect.rebl/ui))\" \"-m\" \"nrepl.cmdline\" \"-i\" \"--middleware\" \"[nrebl.middleware/wrap-nrebl,cider.nrepl/cider-middleware]\" ]} Supporting aliases for nrebl.middleware :lib/cider-nrepl { :extra-deps { nrepl/nrepl { :mvn/version \"0.8.2\" } cider/cider-nrepl { :mvn/version \"0.25.3\" } refactor-nrepl/refactor-nrepl { :mvn/version \"2.5.0\" }}} {% endtabs %} Using REBL with Clojure editors \u03bb\ufe0e CIDER and Calva use the nREPL protocol to connect to the REBL REPL and have all the evaluated code in those editors automatically display the results in the REBL UI. In a terminal, run REBL listening to nREPL using the command clojure -M:lib/cider-nrepl:inspect/rebl:middleware/nrebl {% tabs cider=\"CIDER - Spacemacs/Emacs\", calva=\"Calva - VSCode\" %} {% content \"cider\" %} Then cider-connect-clj in Spacemacs / Emacs and CIDER will connect to the nREPL port and results of evaluated code are sent to REBL UI. Hint::Using cider-jack-in - not recommended \u03bb\ufe0e To use cider-jack-in-clj add a .dir-locals.el file to the root of a Clojure project. The .dir-locals.el configuration adds the nREBL aliases set via cider-clojure-cli-global-options . The automatically injected configuration must be disabled or the command will fail. (( clojure-mode . (( cider-preferred-build-tool . clojure-cli ) ( cider-clojure-cli-global-options . \"-M:lib/cider-nrepl:inspect/rebl:middleware/nrebl\" ) ( cider-jack-in-dependencies . nil ) ( cider-jack-in-nrepl-middlewares . nil ) ( cider-jack-in-lein-plugins . nil ) ( cider-clojure-cli-parameters . \"\" )))) revert-buffer will force Emacs to load in the .dir-locals.el configuration if it was added to a project with files already opened. {% content \"calva\" %} See the guide on using VSCode Calva with REBL {% endtabs %} References \u03bb\ufe0e Cognitect Labs REBL-distro repository and issue tracker Cognitect Local Dev and CI with dev-local Cognitect REBL documentation shows how to use nREPL with REBL practicalli/clojure-deps-aliases common aliases for Clojure nrebl.middleware project and documentation #rebl channel on Clojurians Community nrepl-rebl alternative to nrebl.middleware cider-repl - configurable form results with REBL","title":"Cognitect REBL data browser"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#cognitect-rebl-data-browser","text":"Cognitect REBL captures the results of evaluating expressions and visualizes them in a human readable form. REBL was initially created to support development with the Datomic database and is useful viewing and navigating data structures, especially nested data structures and large data sets. REBL requires an end user license and a personal access token to obtain the packaged library. Open alternatives include Reveal and Portal , which are simpler to install. {% youtube %} https://www.youtube.com/watch?v=c52QhiXsmyI","title":"Cognitect REBL data browser"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#sign-up-for-cognitect-dev-tools-license","text":"REBL is part of the Cognitect dev-tools project that also includes Datomic dev-local (local running instance of Datomic). Accept the Cognitect dev-tools license to receive an email containing a link to download the latest version of Datomic local and a personal access token for access to the Cognitect Maven repository which contains the REBL library. Follow the maven configuration link in the email to configure your build tool (Clojure CLI tools or Leiningen) and the repository in the project pom.xml.","title":"Sign-up for Cognitect dev-tools license"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#aliases-for-cognitect-rebl","text":"Follow the REBL installation steps to create an alias in the user-wide deps.edn configuration. Alternatively, use the practicalli/clojure-deps-edn configuration which contains the :inspect/rebl alias for use with Java 11.","title":"Aliases for Cognitect REBL"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#running-rebl-with-a-project","text":"Run the project using the Clojure CLI tools clojure -M:inspect/rebl If rlwrap is installed, then use: clj -M:inspect/rebl","title":"Running REBL with a project"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#configure-rebl-with-clojure-editors","text":"nrebl.middleware is a middleware library that listens to the nREPL connection between editor and REPL, sending the results of every evaluation to Cognitect REBL. This library is described as very alpha but works in basic tests run by Practicalli. {% tabs practicalli2=\"practicalli/clojure-deps-edn\", manual2=\"Manually add Alias\" %} {% content \"practicalli2\" %} An :middleware/nrebl alias along with the supporting :lib/cider-nrepl aliases are included in practicalli/clojure-deps-edn configuration {% content \"manual2\" %} Add an alias called :middleware/nrebl to ~/.clojure/deps.edn or a deps.edn file in the root of a specific project :middleware/nrebl { :extra-deps { rickmoynihan/nrebl.middleware { :mvn/version \"0.3.1\" }} :main-opts [ \"-e\" \"((requiring-resolve,'cognitect.rebl/ui))\" \"-m\" \"nrepl.cmdline\" \"-i\" \"--middleware\" \"[nrebl.middleware/wrap-nrebl,cider.nrepl/cider-middleware]\" ]} Supporting aliases for nrebl.middleware :lib/cider-nrepl { :extra-deps { nrepl/nrepl { :mvn/version \"0.8.2\" } cider/cider-nrepl { :mvn/version \"0.25.3\" } refactor-nrepl/refactor-nrepl { :mvn/version \"2.5.0\" }}} {% endtabs %}","title":"Configure REBL with Clojure editors"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#using-rebl-with-clojure-editors","text":"CIDER and Calva use the nREPL protocol to connect to the REBL REPL and have all the evaluated code in those editors automatically display the results in the REBL UI. In a terminal, run REBL listening to nREPL using the command clojure -M:lib/cider-nrepl:inspect/rebl:middleware/nrebl {% tabs cider=\"CIDER - Spacemacs/Emacs\", calva=\"Calva - VSCode\" %} {% content \"cider\" %} Then cider-connect-clj in Spacemacs / Emacs and CIDER will connect to the nREPL port and results of evaluated code are sent to REBL UI.","title":"Using REBL with Clojure editors"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#hintusing-cider-jack-in-not-recommended","text":"To use cider-jack-in-clj add a .dir-locals.el file to the root of a Clojure project. The .dir-locals.el configuration adds the nREBL aliases set via cider-clojure-cli-global-options . The automatically injected configuration must be disabled or the command will fail. (( clojure-mode . (( cider-preferred-build-tool . clojure-cli ) ( cider-clojure-cli-global-options . \"-M:lib/cider-nrepl:inspect/rebl:middleware/nrebl\" ) ( cider-jack-in-dependencies . nil ) ( cider-jack-in-nrepl-middlewares . nil ) ( cider-jack-in-lein-plugins . nil ) ( cider-clojure-cli-parameters . \"\" )))) revert-buffer will force Emacs to load in the .dir-locals.el configuration if it was added to a project with files already opened. {% content \"calva\" %} See the guide on using VSCode Calva with REBL {% endtabs %}","title":"Hint::Using cider-jack-in - not recommended"},{"location":"alternative-tools/clojure-cli/cognitect-rebl/#references","text":"Cognitect Labs REBL-distro repository and issue tracker Cognitect Local Dev and CI with dev-local Cognitect REBL documentation shows how to use nREPL with REBL practicalli/clojure-deps-aliases common aliases for Clojure nrebl.middleware project and documentation #rebl channel on Clojurians Community nrepl-rebl alternative to nrebl.middleware cider-repl - configurable form results with REBL","title":"References"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/","text":"Compare Clojure Project configuration tools \u03bb\ufe0e Leiningen, Clojure CLI tools and Boot are different approaches to Clojure project configuration. Regardless of the tool used, the Clojure code in the project remains the same. Clojure CLI tools overview \u03bb\ufe0e Clojure CLI tools takes a very simple approach, focusing on running a REPL process, Clojure programs via clojure main and specific functions via clojure exec. With the Clojure exec approach any function can be called as the entry point to running an application or tool written in Clojure. CLI tools can use both Maven and Git repositories for dependency management. Code from a Git repository dependency can be used without packaging it into a library (Java jar file), simplifying the use of libraries under active development. Clojure CLI tools provides a comprehensive set of features via community tools. These community tools are provided via aliases in the user level configuration for all projects (e.g. practicalli/clojure-deps-edn) or an alias for a specific project deps.edn configuration. Leiningen overview \u03bb\ufe0e Leiningen is a feature rich tool which is simple to get started with a plugin extension to add more functionality. Leiningen does use more resources as it starts a Java Virtual machine to run itself and another to run the application. Boot overview \u03bb\ufe0e Boot runs tasks written in Clojure on the command line, providing a flexible way to work with projects. However, this approach does require expertise with Clojure and Clojure scripts to work with projects. Hint::Clojure code is the same which ever tool is used \u03bb\ufe0e The Clojure code for the project will be the same regardless of which tool is used to configure and manage the Clojure project. Installation \u03bb\ufe0e {% tabs depsinstall=\"Clojure CLI tools\", leininstall=\"Leiningen\", bootinstall=\"Boot\" %} {% content \"depsinstall\" %} As Clojure CLI tools is a wrapper around the Java command line, its really lightweight. Tools are mostly libraries and are only installed on first use or when a version is updated. Install is via a Linux script or Homebrew. For windows, Scoop is recommended, although there is also an alpha level install from Clojure.org {% content \"leininstall\" %} Leiningen is a script that managed the download and use of the leiningen-$LEIN_VERSION-standalone.zip package. Lein script or lein.bat to install, or use one of the supported package managers . {% content \"bootinstall\" %} Install via package mangers or the boot.sh script {% endtabs %} Configuration \u03bb\ufe0e Tool Project Config User Config Extension Clojure CLI tools deps.edn hash-map merged with user config ~/.clojure/deps.edn aliases in deps.edn Leiningen project.clj and defproject macro ~/.lein/profiles.clj Leiningen specific plugin Boot build.boot with deftask , task-options! , set-env! Write the tasks required in Clojure {% tabs depsconfig=\"Clojure CLI tools\", leinconfig=\"Leiningen\", bootconfig=\"Boot\" %} {% content \"depsconfig\" %} Clojure CLI tools are configured with an EDN data structure, i.e. a hash-map of key-value pairs. As this is a Clojure data structure its much easier to parse and should be very familiar to Clojure developers. {% content \"leinconfig\" %} Leiningen projects are configured with a project.clj file which contains a defproject macro with a great many options. The Leiningen tutorial explains the options in detail. A sample project.clj contains examples of using each of this options. For most projects all the configuration resides in the project.clj file. Exceptions to this include figwheel-main, which also adds it own EDN configuration and EDN build configuration files. Leiningen also has a user level configuration {% content \"bootconfig\" %} build.boot is a file containing Clojure code that defines the tasks for using your project. {% endtabs %} Extending the tools \u03bb\ufe0e {% tabs depsextend=\"Clojure CLI tools\", leinextend=\"Leiningen\", bootextend=\"Boot\" %} {% content \"depsextend\" %} Clojure CLI tools has been designed for a very specific role, to provide a lightweight wrapper over running Clojure programs and via tools.deps managing dependencies from Maven and Git repositories. The projects that extend Clojure CLI tools are self-contained libraries and tools, so are not tied to any one particular tool. Any general tools written for Clojure should work with Clojure CLI tools by calling their main function (clojure main) or a specifically named function (clojure exec) {% content \"leinextend\" %} Leiningen plugin extension was the main way to extend the functionality of Leiningen (or getting pull requests accepted to the Leiningen projects). Although there are several plugins that were widely adopted, some plugins eventually caused more confusion than benefit or were simply trivial and in the main plugins seem to have become less important to the Clojure community. One of the limitations of Leiningnen plugin mechanism was not being able to exclude any configuration in a users .lein/profiles.clj file, so there was greater potential for conflict. The recommended way to extend Leiningen is to not write plugins, but to include aliases that define a qualified function to run when that alias is used with the Leiningen command. {% content \"bootextend\" %} Write clojure to define scripts to run with boot projects. {% endtabs %} Hint::Babashka for Clojure scripting \u03bb\ufe0e Babashka is an approach to writing bash-style scripts using the Clojure language. Babashka bundles additional libraries to support common tasks","title":"Compare Clojure Project configuration tools"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#compare-clojure-project-configuration-tools","text":"Leiningen, Clojure CLI tools and Boot are different approaches to Clojure project configuration. Regardless of the tool used, the Clojure code in the project remains the same.","title":"Compare Clojure Project configuration tools"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#clojure-cli-tools-overview","text":"Clojure CLI tools takes a very simple approach, focusing on running a REPL process, Clojure programs via clojure main and specific functions via clojure exec. With the Clojure exec approach any function can be called as the entry point to running an application or tool written in Clojure. CLI tools can use both Maven and Git repositories for dependency management. Code from a Git repository dependency can be used without packaging it into a library (Java jar file), simplifying the use of libraries under active development. Clojure CLI tools provides a comprehensive set of features via community tools. These community tools are provided via aliases in the user level configuration for all projects (e.g. practicalli/clojure-deps-edn) or an alias for a specific project deps.edn configuration.","title":"Clojure CLI tools overview"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#leiningen-overview","text":"Leiningen is a feature rich tool which is simple to get started with a plugin extension to add more functionality. Leiningen does use more resources as it starts a Java Virtual machine to run itself and another to run the application.","title":"Leiningen overview"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#boot-overview","text":"Boot runs tasks written in Clojure on the command line, providing a flexible way to work with projects. However, this approach does require expertise with Clojure and Clojure scripts to work with projects.","title":"Boot overview"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#hintclojure-code-is-the-same-which-ever-tool-is-used","text":"The Clojure code for the project will be the same regardless of which tool is used to configure and manage the Clojure project.","title":"Hint::Clojure code is the same which ever tool is used"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#installation","text":"{% tabs depsinstall=\"Clojure CLI tools\", leininstall=\"Leiningen\", bootinstall=\"Boot\" %} {% content \"depsinstall\" %} As Clojure CLI tools is a wrapper around the Java command line, its really lightweight. Tools are mostly libraries and are only installed on first use or when a version is updated. Install is via a Linux script or Homebrew. For windows, Scoop is recommended, although there is also an alpha level install from Clojure.org {% content \"leininstall\" %} Leiningen is a script that managed the download and use of the leiningen-$LEIN_VERSION-standalone.zip package. Lein script or lein.bat to install, or use one of the supported package managers . {% content \"bootinstall\" %} Install via package mangers or the boot.sh script {% endtabs %}","title":"Installation"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#configuration","text":"Tool Project Config User Config Extension Clojure CLI tools deps.edn hash-map merged with user config ~/.clojure/deps.edn aliases in deps.edn Leiningen project.clj and defproject macro ~/.lein/profiles.clj Leiningen specific plugin Boot build.boot with deftask , task-options! , set-env! Write the tasks required in Clojure {% tabs depsconfig=\"Clojure CLI tools\", leinconfig=\"Leiningen\", bootconfig=\"Boot\" %} {% content \"depsconfig\" %} Clojure CLI tools are configured with an EDN data structure, i.e. a hash-map of key-value pairs. As this is a Clojure data structure its much easier to parse and should be very familiar to Clojure developers. {% content \"leinconfig\" %} Leiningen projects are configured with a project.clj file which contains a defproject macro with a great many options. The Leiningen tutorial explains the options in detail. A sample project.clj contains examples of using each of this options. For most projects all the configuration resides in the project.clj file. Exceptions to this include figwheel-main, which also adds it own EDN configuration and EDN build configuration files. Leiningen also has a user level configuration {% content \"bootconfig\" %} build.boot is a file containing Clojure code that defines the tasks for using your project. {% endtabs %}","title":"Configuration"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#extending-the-tools","text":"{% tabs depsextend=\"Clojure CLI tools\", leinextend=\"Leiningen\", bootextend=\"Boot\" %} {% content \"depsextend\" %} Clojure CLI tools has been designed for a very specific role, to provide a lightweight wrapper over running Clojure programs and via tools.deps managing dependencies from Maven and Git repositories. The projects that extend Clojure CLI tools are self-contained libraries and tools, so are not tied to any one particular tool. Any general tools written for Clojure should work with Clojure CLI tools by calling their main function (clojure main) or a specifically named function (clojure exec) {% content \"leinextend\" %} Leiningen plugin extension was the main way to extend the functionality of Leiningen (or getting pull requests accepted to the Leiningen projects). Although there are several plugins that were widely adopted, some plugins eventually caused more confusion than benefit or were simply trivial and in the main plugins seem to have become less important to the Clojure community. One of the limitations of Leiningnen plugin mechanism was not being able to exclude any configuration in a users .lein/profiles.clj file, so there was greater potential for conflict. The recommended way to extend Leiningen is to not write plugins, but to include aliases that define a qualified function to run when that alias is used with the Leiningen command. {% content \"bootextend\" %} Write clojure to define scripts to run with boot projects. {% endtabs %}","title":"Extending the tools"},{"location":"alternative-tools/clojure-cli/compare-with-leiningen/#hintbabashka-for-clojure-scripting","text":"Babashka is an approach to writing bash-style scripts using the Clojure language. Babashka bundles additional libraries to support common tasks","title":"Hint::Babashka for Clojure scripting"},{"location":"alternative-tools/clojure-cli/evaluate-an-expression/","text":"Evaluating an expression with Clojure CLI tools \u03bb\ufe0e An expression is a piece of Clojure code that can be evaluated and return a result This expression calls the + function with the arguments 1 2 3 4 5 . As this code works, we get a result. (+ 1 2 3 4 5) Using the -e option an expression can be passed to the Clojure CLI tools and a value returned clojure -e ( + 1 2 3 4 5 ) Expressions returning nil \u03bb\ufe0e If the expressing used returns a value of nil , a legal value in Clojure, then no result is printed out. When to use this? \u03bb\ufe0e clojure -e is a quick way to see what an expression does without having to set anything up (although starting a REPL is very little extra effort). Using the -e option is useful for running simple scripts written in Clojure, especially on servers and remote environments. The lack of return value for nil is very useful when using Clojure CLI tools to evaluate Clojure code within another script.","title":"Evaluating an expression with Clojure CLI tools"},{"location":"alternative-tools/clojure-cli/evaluate-an-expression/#evaluating-an-expression-with-clojure-cli-tools","text":"An expression is a piece of Clojure code that can be evaluated and return a result This expression calls the + function with the arguments 1 2 3 4 5 . As this code works, we get a result. (+ 1 2 3 4 5) Using the -e option an expression can be passed to the Clojure CLI tools and a value returned clojure -e ( + 1 2 3 4 5 )","title":"Evaluating an expression with Clojure CLI tools"},{"location":"alternative-tools/clojure-cli/evaluate-an-expression/#expressions-returning-nil","text":"If the expressing used returns a value of nil , a legal value in Clojure, then no result is printed out.","title":"Expressions returning nil"},{"location":"alternative-tools/clojure-cli/evaluate-an-expression/#when-to-use-this","text":"clojure -e is a quick way to see what an expression does without having to set anything up (although starting a REPL is very little extra effort). Using the -e option is useful for running simple scripts written in Clojure, especially on servers and remote environments. The lack of return value for nil is very useful when using Clojure CLI tools to evaluate Clojure code within another script.","title":"When to use this?"},{"location":"alternative-tools/clojure-cli/set-namespace-on-repl-startup/","text":"Set namespace on REPL startup \u03bb\ufe0e The REPL process does not evaluate project code on start-up. If it did and that code had a error, it could prevent the REPL from starting. The common approach is to require the main namespace for the project, making the functions in that namespace available. This will also make available functions from those namespaces. Switching to a specific namespace in the REPL allows calling functions by name, without the fully qualified name. Set namespace via the command line \u03bb\ufe0e To require and switch to a namespace on startup, use the clojure or clj commands with the --eval option to run the specific commands. The --repl option will ensure the repl starts. clj --eval \"(require 'practicalli.random-clojure-core-function)\" --eval \"(in-ns 'practicalli.random-clojure-core-function)\" --repl -r or (clojure.main/repl) are the same as using the --repl option clj -e \"(ns foo.bar) (alter-var-root #'*ns* (constantly 'foo.bar))\" -r clj -e \"(ns foo.bar) (alter-var-root #'*ns* (constantly 'foo.bar)) (clojure.main/repl)\" Set namespace with Rebel Readline \u03bb\ufe0e Set the namespace using Rebel Readline alias from practicalli/clojure-deps-edn clj -M :lib/rebel -e \"(ns foo.bar) (alter-var-root #'*ns* (constantly (find-ns 'foo.bar)))\" -m rebel-readline.main # object [ clojure.lang.Namespace 0 x46cf05f7 \"foo.bar\" ] [ Rebel readline ] Type :repl/help for online help info foo.bar=> The :lib/rebel alias adds the rebel library as a dependency without calling clojure main on the rebel namespace. alter-var-root sets the namespace. The -m flag defines the namespace which Clojure main will run the -main function from, starting the rebel UI on the command line. The --eval approach will be blocked if used with aliases that set the main namespace, such as :repl/rebel . Set namespace using an editor \u03bb\ufe0e It is not necessary to set the namespace when evaluating code in a Clojure aware editor. Expressions are evaluated within the scope of the namespace in which they are defined. Using an editor to evaluate Clojure is much simpler and quicker than using a command line REPL, especially when working with Clojure projects with more than one namespace.","title":"Set namespace on REPL startup"},{"location":"alternative-tools/clojure-cli/set-namespace-on-repl-startup/#set-namespace-on-repl-startup","text":"The REPL process does not evaluate project code on start-up. If it did and that code had a error, it could prevent the REPL from starting. The common approach is to require the main namespace for the project, making the functions in that namespace available. This will also make available functions from those namespaces. Switching to a specific namespace in the REPL allows calling functions by name, without the fully qualified name.","title":"Set namespace on REPL startup"},{"location":"alternative-tools/clojure-cli/set-namespace-on-repl-startup/#set-namespace-via-the-command-line","text":"To require and switch to a namespace on startup, use the clojure or clj commands with the --eval option to run the specific commands. The --repl option will ensure the repl starts. clj --eval \"(require 'practicalli.random-clojure-core-function)\" --eval \"(in-ns 'practicalli.random-clojure-core-function)\" --repl -r or (clojure.main/repl) are the same as using the --repl option clj -e \"(ns foo.bar) (alter-var-root #'*ns* (constantly 'foo.bar))\" -r clj -e \"(ns foo.bar) (alter-var-root #'*ns* (constantly 'foo.bar)) (clojure.main/repl)\"","title":"Set namespace via the command line"},{"location":"alternative-tools/clojure-cli/set-namespace-on-repl-startup/#set-namespace-with-rebel-readline","text":"Set the namespace using Rebel Readline alias from practicalli/clojure-deps-edn clj -M :lib/rebel -e \"(ns foo.bar) (alter-var-root #'*ns* (constantly (find-ns 'foo.bar)))\" -m rebel-readline.main # object [ clojure.lang.Namespace 0 x46cf05f7 \"foo.bar\" ] [ Rebel readline ] Type :repl/help for online help info foo.bar=> The :lib/rebel alias adds the rebel library as a dependency without calling clojure main on the rebel namespace. alter-var-root sets the namespace. The -m flag defines the namespace which Clojure main will run the -main function from, starting the rebel UI on the command line. The --eval approach will be blocked if used with aliases that set the main namespace, such as :repl/rebel .","title":"Set namespace with Rebel Readline"},{"location":"alternative-tools/clojure-cli/set-namespace-on-repl-startup/#set-namespace-using-an-editor","text":"It is not necessary to set the namespace when evaluating code in a Clojure aware editor. Expressions are evaluated within the scope of the namespace in which they are defined. Using an editor to evaluate Clojure is much simpler and quicker than using a command line REPL, especially when working with Clojure projects with more than one namespace.","title":"Set namespace using an editor"},{"location":"alternative-tools/leiningen/","text":"Leiningen build automation tool for Clojure \u03bb\ufe0e Leiningen will help you create, build and deploy your Clojure projects. Hint::Practicalli recommends using Clojure CLI tools \u03bb\ufe0e For new project, Clojure CLI tools is recommended as it requires fewer resources and enables a more customisable approach to configuring project and running tools to support Clojure development. Install Leiningen \u03bb\ufe0e Install the Leiningen tool using the specific instructions for your Operating System {% tabs first=\"Linux\", second=\"Homebrew\", third=\"GitBash\", forth=\"Chocolatey\", fifth=\"Windows Manual\" %} {% content \"first\" %} Download the lein script to your local bin directory. Then make the lein script executable and run lein to download the full version. mkdir ~/bin curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein > ~/bin/lein chmod u+x ~/bin/lein lein If the command lein is not found, run source ~/.bashrc to ensure your bin directory is on the path. {% content \"second\" %} If you have Homebrew installed, run the following command in a terminal window. brew install leiningen Windows Chocolatey \u03bb\ufe0e {% content \"third\" %} If you have Chocolatey installed, add the Leiningen package by running the following command in a terminal window. choco install lein {% content \"forth\" %} GitBash allows you to use the Linux lein script, which may have less issues when installing. Create a directory called C:\\Users\\your-user-name\\AppData\\Local\\Programs\\Leiningen Download the lein file and save it to the above directory Open Environment variables for your account and add the directory to your path Open a command window and run the command: lein The full version of Leiningen will be downloaded and Leiningen is ready to use. {% content \"fifth\" %} Create a directory called C:\\Users\\your-user-name\\AppData\\Local\\Programs\\Leiningen Download the lein.bat file and save it to the above directory Open Environment variables for your account and add the directory to your path Open a command window and run the command: lein.bat The full version of Leiningen will be downloaded and Leiningen is ready to use. {% endtabs %} Check Leiningen is working \u03bb\ufe0e Open a terminal and use the following command lein If a list of Leiningen commands is shown then it is working correctly.","title":"Leiningen build automation tool for Clojure"},{"location":"alternative-tools/leiningen/#leiningen-build-automation-tool-for-clojure","text":"Leiningen will help you create, build and deploy your Clojure projects.","title":"Leiningen build automation tool for Clojure"},{"location":"alternative-tools/leiningen/#hintpracticalli-recommends-using-clojure-cli-tools","text":"For new project, Clojure CLI tools is recommended as it requires fewer resources and enables a more customisable approach to configuring project and running tools to support Clojure development.","title":"Hint::Practicalli recommends using Clojure CLI tools"},{"location":"alternative-tools/leiningen/#install-leiningen","text":"Install the Leiningen tool using the specific instructions for your Operating System {% tabs first=\"Linux\", second=\"Homebrew\", third=\"GitBash\", forth=\"Chocolatey\", fifth=\"Windows Manual\" %} {% content \"first\" %} Download the lein script to your local bin directory. Then make the lein script executable and run lein to download the full version. mkdir ~/bin curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein > ~/bin/lein chmod u+x ~/bin/lein lein If the command lein is not found, run source ~/.bashrc to ensure your bin directory is on the path. {% content \"second\" %} If you have Homebrew installed, run the following command in a terminal window. brew install leiningen","title":"Install Leiningen"},{"location":"alternative-tools/leiningen/#windows-chocolatey","text":"{% content \"third\" %} If you have Chocolatey installed, add the Leiningen package by running the following command in a terminal window. choco install lein {% content \"forth\" %} GitBash allows you to use the Linux lein script, which may have less issues when installing. Create a directory called C:\\Users\\your-user-name\\AppData\\Local\\Programs\\Leiningen Download the lein file and save it to the above directory Open Environment variables for your account and add the directory to your path Open a command window and run the command: lein The full version of Leiningen will be downloaded and Leiningen is ready to use. {% content \"fifth\" %} Create a directory called C:\\Users\\your-user-name\\AppData\\Local\\Programs\\Leiningen Download the lein.bat file and save it to the above directory Open Environment variables for your account and add the directory to your path Open a command window and run the command: lein.bat The full version of Leiningen will be downloaded and Leiningen is ready to use. {% endtabs %}","title":"Windows Chocolatey"},{"location":"alternative-tools/leiningen/#check-leiningen-is-working","text":"Open a terminal and use the following command lein If a list of Leiningen commands is shown then it is working correctly.","title":"Check Leiningen is working"},{"location":"alternative-tools/leiningen/create-a-project/","text":"Creating a project \u03bb\ufe0e Its easy to create a new Clojure project with Leiningen, simply run the command lein new template-name domain/project-name . The template-name can be app, lib or one of the templates on Clojars (more on this later). Note Create a new project called practicalli Open a terminal window and in a directory where you usually keep your projects, run the following command lein new app practicalli A new directory will be created called practicalli and the contents of the directory should be as follows: fixme add screenshot of project structure inside the practicalli directory, including the source tree to show the namespace. Comment The domain and project-name will also be the namespace used for the project. Core is consider a little dated as a name.","title":"Creating a project"},{"location":"alternative-tools/leiningen/create-a-project/#creating-a-project","text":"Its easy to create a new Clojure project with Leiningen, simply run the command lein new template-name domain/project-name . The template-name can be app, lib or one of the templates on Clojars (more on this later). Note Create a new project called practicalli Open a terminal window and in a directory where you usually keep your projects, run the following command lein new app practicalli A new directory will be created called practicalli and the contents of the directory should be as follows: fixme add screenshot of project structure inside the practicalli directory, including the source tree to show the namespace. Comment The domain and project-name will also be the namespace used for the project. Core is consider a little dated as a name.","title":"Creating a project"},{"location":"alternative-tools/leiningen/testing/configure-project/","text":"Configure Leiningen for Unit Testing \u03bb\ufe0e Leiningen automatically includes the test directory when running, so no additional configuration is required if all tests reside inside the test directory. Run all the tests saved to file: lein test Run just the unit tests in a specific namepsace. lein test :only domain.namespace-test Test related Plugins \u03bb\ufe0e The following Leiningen plugins watch the file system and will run tests when a file change is detected in the project files. * lein-test-refresh * lein-auto Using different test paths \u03bb\ufe0e :test-paths added as a top level key to the defproject configuration in the project.clj file will configure specific paths for tests For example, if the tests are defined under project-name/clj/tests then the project.clj file would look as follows: ( defproject my-project \"0.5.0-SNAPSHOT\" :description \"A project for doing things.\" :license \"Creative Commons Zero\" :url \"http://github.com/practicalli/my-project\" :dependencies [[ org.clojure/clojure \"1.10.1\" ]] :test-paths [ \"clj/test\" \"src/test/clojure\" ] :plugins [[ lein-auto \"0.1.3\" ]]) :source-paths can also be used to define the location of the source code files in the same manner.","title":"Configure Leiningen for Unit Testing"},{"location":"alternative-tools/leiningen/testing/configure-project/#configure-leiningen-for-unit-testing","text":"Leiningen automatically includes the test directory when running, so no additional configuration is required if all tests reside inside the test directory. Run all the tests saved to file: lein test Run just the unit tests in a specific namepsace. lein test :only domain.namespace-test","title":"Configure Leiningen for Unit Testing"},{"location":"alternative-tools/leiningen/testing/configure-project/#test-related-plugins","text":"The following Leiningen plugins watch the file system and will run tests when a file change is detected in the project files. * lein-test-refresh * lein-auto","title":"Test related Plugins"},{"location":"alternative-tools/leiningen/testing/configure-project/#using-different-test-paths","text":":test-paths added as a top level key to the defproject configuration in the project.clj file will configure specific paths for tests For example, if the tests are defined under project-name/clj/tests then the project.clj file would look as follows: ( defproject my-project \"0.5.0-SNAPSHOT\" :description \"A project for doing things.\" :license \"Creative Commons Zero\" :url \"http://github.com/practicalli/my-project\" :dependencies [[ org.clojure/clojure \"1.10.1\" ]] :test-paths [ \"clj/test\" \"src/test/clojure\" ] :plugins [[ lein-auto \"0.1.3\" ]]) :source-paths can also be used to define the location of the source code files in the same manner.","title":"Using different test paths"},{"location":"assets/images/social/","text":"Social Cards \u03bb\ufe0e Social Cards are visual previews of the website that are included when sending links via social media platforms. Material for MkDocs is configured to generate beautiful social cards automatically , using the colors, fonts and logos defined in mkdocs.yml Generated images are stored in this directory.","title":"Social Cards"},{"location":"assets/images/social/#social-cards","text":"Social Cards are visual previews of the website that are included when sending links via social media platforms. Material for MkDocs is configured to generate beautiful social cards automatically , using the colors, fonts and logos defined in mkdocs.yml Generated images are stored in this directory.","title":"Social Cards"},{"location":"clojure-cli/","text":"Clojure CLI \u03bb\ufe0e Clojure CLI (command line interface) is the latest approach to working with Clojure projects, libraries an tools. The Clojure CLI focuses on: running Clojure code (applications and tools) starting a REPL process (Read-Eval-Print Loop) for interactive development with a Clojure editor or a command line REPL UI . managing dependencies (via tools.deps) and downloads from Maven and Git repositories building Clojure projects (when including tools.build) to create deployable Clojure services The Clojure CLI is extended by adding aliases for community libraries and tools, e.g. practicalli/clojure-deps-edn Common tasks for Clojure development \u03bb\ufe0e Commands to use for common tasks and where their aliases are included in Clojure CLI tools or require an alias (either in a project or user-wide deps.edn file). Task Command Defined In Basic terminal UI REPL clojure or clj if rlwrap binary installed Clojure CLI Enhanced terminal UI REPL (Rebel and nREPL) clojure -M:repl/rebel Practicalli Create project (clojure exec) clojure -T:project/new :template app :name domain/appname :args '[\"+h2\"]' Practicalli Run unit tests / watch for changes clojure -X:test/run or clojure -X:test/watch Practicalli Run the project (clojure.main) clojure -M -m domain.main-namespace No Alias Run a function from the project (clojure.exec) clojure -X:run/greet Project Find libraries (mvn & git) clojure -M:search/library library-name Practicalli Download dependencies clojure -P (plus optional execution flags with aliases) CLojure CLI Check for new dependency versions clojure -T:search/outdated Practicalli Package library clojure -X:build/jars Practicalli Deploy library locally clojure -X:deps mvn-install Clojure CLI Package application clojure -X:build/uberjar Project Check code for unused vars clojure -X:search/unused Practicalli Clojure CLI can also be used for evaluating an expressions or running Clojure from files as scripts , although these approaches are less common. clojure -M:lib/hotload:repl/rebel runs a rich terminal UI REPL which can use add-libs to hotload dependencies into a running REPL process . Clojure CLI version \u03bb\ufe0e clojure -Sdescribe shows the version of Clojure CLI currently installed. The -Sverbose flag shows the Clojure CLI version and basic configuration before running any task, e.g. clojure -Sverbose -M:repl/rebel will show the Clojure CLI details and then run Rebel terminal UI. Clojure CLI execution option flags \u03bb\ufe0e The execution option flags for the clojure command define how to run Clojure code. Flag Purpose -A Pass alias to built-in terminal UI REPL ( clojure or clj ) -M Run Clojure project with clojure.main -P Prepare / dry run (Build scripts, CI servers, Containers) -X Execute a fully qualified function, optional default arguments -T Run a tool independently from a project configurations -J Java Virtual Machine specific options (heap size, etc) Which flag to use? The -M flag is used when calling a -main function from a specified namespace. Arguments can be passed as free-form string options. The -X flag is used to call a fully qualified function, which can be any function on the command line. Arguments are passed as key/value pairs and strings / collection syntax should be escaped with single quotes. -X can use :replace-deps and :replace-paths values to remove project :deps and :paths -T flag removes project paths and deps, so is run independent of a Clojure project configuration. Tools can be installed and referred to by name, or used via an alias name and have default configuration attached. Read the article: Clojure CLI - which execution option to use Which version of Clojure \u03bb\ufe0e Evaluate *clojure-version* in a REPL shows which version of the Clojure language is currently being used. Including org.clojure/clojure in the project deps.edn file allows specification of a particular version of the Clojure language. The Clojure CLI also has a default version of the Clojure dependency, which is used if no other dependency is specified.","title":"Clojure CLI"},{"location":"clojure-cli/#clojure-cli","text":"Clojure CLI (command line interface) is the latest approach to working with Clojure projects, libraries an tools. The Clojure CLI focuses on: running Clojure code (applications and tools) starting a REPL process (Read-Eval-Print Loop) for interactive development with a Clojure editor or a command line REPL UI . managing dependencies (via tools.deps) and downloads from Maven and Git repositories building Clojure projects (when including tools.build) to create deployable Clojure services The Clojure CLI is extended by adding aliases for community libraries and tools, e.g. practicalli/clojure-deps-edn","title":"Clojure CLI"},{"location":"clojure-cli/#common-tasks-for-clojure-development","text":"Commands to use for common tasks and where their aliases are included in Clojure CLI tools or require an alias (either in a project or user-wide deps.edn file). Task Command Defined In Basic terminal UI REPL clojure or clj if rlwrap binary installed Clojure CLI Enhanced terminal UI REPL (Rebel and nREPL) clojure -M:repl/rebel Practicalli Create project (clojure exec) clojure -T:project/new :template app :name domain/appname :args '[\"+h2\"]' Practicalli Run unit tests / watch for changes clojure -X:test/run or clojure -X:test/watch Practicalli Run the project (clojure.main) clojure -M -m domain.main-namespace No Alias Run a function from the project (clojure.exec) clojure -X:run/greet Project Find libraries (mvn & git) clojure -M:search/library library-name Practicalli Download dependencies clojure -P (plus optional execution flags with aliases) CLojure CLI Check for new dependency versions clojure -T:search/outdated Practicalli Package library clojure -X:build/jars Practicalli Deploy library locally clojure -X:deps mvn-install Clojure CLI Package application clojure -X:build/uberjar Project Check code for unused vars clojure -X:search/unused Practicalli Clojure CLI can also be used for evaluating an expressions or running Clojure from files as scripts , although these approaches are less common. clojure -M:lib/hotload:repl/rebel runs a rich terminal UI REPL which can use add-libs to hotload dependencies into a running REPL process .","title":"Common tasks for Clojure development"},{"location":"clojure-cli/#clojure-cli-version","text":"clojure -Sdescribe shows the version of Clojure CLI currently installed. The -Sverbose flag shows the Clojure CLI version and basic configuration before running any task, e.g. clojure -Sverbose -M:repl/rebel will show the Clojure CLI details and then run Rebel terminal UI.","title":"Clojure CLI version"},{"location":"clojure-cli/#clojure-cli-execution-option-flags","text":"The execution option flags for the clojure command define how to run Clojure code. Flag Purpose -A Pass alias to built-in terminal UI REPL ( clojure or clj ) -M Run Clojure project with clojure.main -P Prepare / dry run (Build scripts, CI servers, Containers) -X Execute a fully qualified function, optional default arguments -T Run a tool independently from a project configurations -J Java Virtual Machine specific options (heap size, etc) Which flag to use? The -M flag is used when calling a -main function from a specified namespace. Arguments can be passed as free-form string options. The -X flag is used to call a fully qualified function, which can be any function on the command line. Arguments are passed as key/value pairs and strings / collection syntax should be escaped with single quotes. -X can use :replace-deps and :replace-paths values to remove project :deps and :paths -T flag removes project paths and deps, so is run independent of a Clojure project configuration. Tools can be installed and referred to by name, or used via an alias name and have default configuration attached. Read the article: Clojure CLI - which execution option to use","title":"Clojure CLI execution option flags"},{"location":"clojure-cli/#which-version-of-clojure","text":"Evaluate *clojure-version* in a REPL shows which version of the Clojure language is currently being used. Including org.clojure/clojure in the project deps.edn file allows specification of a particular version of the Clojure language. The Clojure CLI also has a default version of the Clojure dependency, which is used if no other dependency is specified.","title":"Which version of Clojure"},{"location":"clojure-cli/built-in-aliases/","text":"Clojure CLI Built-in alaises \u03bb\ufe0e The :deps alias is used as the root of all built-in commands in the Clojure CLI tools. -X execution option is used for all built-in aliases, running them via clojure.exec aliases Description clojure -X:deps tree download dependencies & print dependency tree, indenting libraries that are dependencies of dependencies clojure -X:deps mvn-pom generate / update pom.xml with the dependencies and class path for the current project clojure -X:deps git-resolve-tags update deps.edn git based dependencies that used tags with the equivalent SHA commit values clojure -X:deps mvn-install :jar '\"/path/to.jar\"' install a given jar file into the local maven repository, eg. ~/.m2/repository Dependency tree \u03bb\ufe0e Update project pom.xml \u03bb\ufe0e Resolve Git tags \u03bb\ufe0e Local library install \u03bb\ufe0e Add a jar file for a library to the local Maven repository, e.g. ~/.m2/repository , making that library accessible to all other local projects. clojure -X:deps mvn-install :jar '\"/path/to.jar\"' `","title":"Clojure CLI Built-in alaises"},{"location":"clojure-cli/built-in-aliases/#clojure-cli-built-in-alaises","text":"The :deps alias is used as the root of all built-in commands in the Clojure CLI tools. -X execution option is used for all built-in aliases, running them via clojure.exec aliases Description clojure -X:deps tree download dependencies & print dependency tree, indenting libraries that are dependencies of dependencies clojure -X:deps mvn-pom generate / update pom.xml with the dependencies and class path for the current project clojure -X:deps git-resolve-tags update deps.edn git based dependencies that used tags with the equivalent SHA commit values clojure -X:deps mvn-install :jar '\"/path/to.jar\"' install a given jar file into the local maven repository, eg. ~/.m2/repository","title":"Clojure CLI Built-in alaises"},{"location":"clojure-cli/built-in-aliases/#dependency-tree","text":"","title":"Dependency tree"},{"location":"clojure-cli/built-in-aliases/#update-project-pomxml","text":"","title":"Update project pom.xml"},{"location":"clojure-cli/built-in-aliases/#resolve-git-tags","text":"","title":"Resolve Git tags"},{"location":"clojure-cli/built-in-aliases/#local-library-install","text":"Add a jar file for a library to the local Maven repository, e.g. ~/.m2/repository , making that library accessible to all other local projects. clojure -X:deps mvn-install :jar '\"/path/to.jar\"' `","title":"Local library install"},{"location":"clojure-cli/common-tasks/","text":"Common Development Tasks \u03bb\ufe0e Clojure CLI tools can be used for a number of tasks, especially when combined with the community tools available via practicalli/clojure-deps-edn configuration . Run a REPL (clj, rebel, reveal) Create a new project from a template Run a specific function - taking hash-map as argument (simple function, scripts, applications) Run a Clojure application, optionally providing arguments Download project dependencies (dry run, CI service task) Run tests locally and via CI server (using community tools) Package an application for deployment Run project scripts - database migrations, reports, etc. Run a range community tools (~/.clojure/deps.edn) Common development tasks \u03bb\ufe0e Built-in tasks require no additional configuration. User aliases are from the user level configuration, e.g. ~/.clojure/deps.edn . Project aliases are contained in the project deps.edn file User/Project alias can be defined in both user and project deps.edn files (typically added to project deps.edn for external running such as Continuous Integration) Task Command Configuration Create project (clojure exec) clojure -X:project/new :template app :name practicalli/my-app User alias Run REPL (rebel readline) clojure -M:repl/rebel User alias Run REPL (rebel and nrepl) clojure -M:repl/rebel-nrepl User alias Run REPL (rebel and reveal data visualization) clojure -M:repl/rebel-reveal User alias Download dependencies clojure -Spath or clojure -P (plus optional aliases) Built-in Find libraries (mvn & git) clojure -M:project/find-deps library-name User alias Generate image of project dependency graph clojure -X:project/graph-deps User alias Check for new dependency versions clojure -M:project/outdated User alias Run tests clojure -M:test/runner User/Project alias Run the project clojure -M -m domain.main-namespace Built-in Run the project * clojure -X:project/run Project alias Package library clojure -X:project/jar User/Project alias Deploy library locally clojure -X:deps mvn-install Built-in Package application clojure -X:project/uberjar User/Project alias Add alias :project/run to the deps.edn file in the root of a project: :project/run {:ns-default domain.namespace :exec-fn -main} - see this video for an example https://youtu.be/u5VoFpsntXc?t=2166 Most aliases use the -M flag. Only use the -X flag when you know it is supported by that task","title":"Common Development Tasks"},{"location":"clojure-cli/common-tasks/#common-development-tasks","text":"Clojure CLI tools can be used for a number of tasks, especially when combined with the community tools available via practicalli/clojure-deps-edn configuration . Run a REPL (clj, rebel, reveal) Create a new project from a template Run a specific function - taking hash-map as argument (simple function, scripts, applications) Run a Clojure application, optionally providing arguments Download project dependencies (dry run, CI service task) Run tests locally and via CI server (using community tools) Package an application for deployment Run project scripts - database migrations, reports, etc. Run a range community tools (~/.clojure/deps.edn)","title":"Common Development Tasks"},{"location":"clojure-cli/common-tasks/#common-development-tasks_1","text":"Built-in tasks require no additional configuration. User aliases are from the user level configuration, e.g. ~/.clojure/deps.edn . Project aliases are contained in the project deps.edn file User/Project alias can be defined in both user and project deps.edn files (typically added to project deps.edn for external running such as Continuous Integration) Task Command Configuration Create project (clojure exec) clojure -X:project/new :template app :name practicalli/my-app User alias Run REPL (rebel readline) clojure -M:repl/rebel User alias Run REPL (rebel and nrepl) clojure -M:repl/rebel-nrepl User alias Run REPL (rebel and reveal data visualization) clojure -M:repl/rebel-reveal User alias Download dependencies clojure -Spath or clojure -P (plus optional aliases) Built-in Find libraries (mvn & git) clojure -M:project/find-deps library-name User alias Generate image of project dependency graph clojure -X:project/graph-deps User alias Check for new dependency versions clojure -M:project/outdated User alias Run tests clojure -M:test/runner User/Project alias Run the project clojure -M -m domain.main-namespace Built-in Run the project * clojure -X:project/run Project alias Package library clojure -X:project/jar User/Project alias Deploy library locally clojure -X:deps mvn-install Built-in Package application clojure -X:project/uberjar User/Project alias Add alias :project/run to the deps.edn file in the root of a project: :project/run {:ns-default domain.namespace :exec-fn -main} - see this video for an example https://youtu.be/u5VoFpsntXc?t=2166 Most aliases use the -M flag. Only use the -X flag when you know it is supported by that task","title":"Common development tasks"},{"location":"clojure-cli/community-tools/","text":"Practicalli Community Tools for Clojure CLI \u03bb\ufe0e practicalli/clojure-deps-edn practicalli/clojure-deps-edn is a user configuration for Clojure CLI tools providing a range of community tools via meaningful aliases, supporting Clojure and ClojureScript development. Alias names are designed with qualified keywords that provide context for the use of an alias ( project , repl , env , test , inspect ). These keywords help with discovery and reduce cognitive load required to remember their purpose. Commonly used arguments are included in many alias via :main-opts or :exec-args which can be overridden on the command line. Minimum Clojure CLI Version - 1.10.3.1040 Clojure CLI version 1.10.3.1040 is the minimum version, although the latest available version is recommended. Check the version of Clojure CLI currently installed via clojure --version or clojure -Sdescribe Remote Environments or Continuous Integration For remote environments or Continuous Integration services , include practicalli/clojure-deps-edn in the environment build or copy specific aliases to the Clojure project deps.edn configuration. Install \u03bb\ufe0e Fork or clone practicalli/clojure-deps-edn GitHub repository, first removing the $XDG_CONFIG_HOME/clojure or $HOME/.clojure directory if they exist. Check Clojure CLI configuration location Check the location of your Clojure configuration directory by running clojure -Sdescribe and checking the :user-config value. Free Desktop XDG CONFIG Classic Config If XDG_CONFIG_HOME environment variable is set, clone the repository to $XDG_CONFIG_HOME/clojure git clone https://github.com/practicalli/clojure-deps-edn.git $XDG_CONFIG_HOME /clojure Clojure CLI will look for its configuration in $HOME/.clojure directory if $XDG_CONFIG_HOME and CLJ_CONFIG environment variables not set. git clone https://github.com/practicalli/clojure-deps-edn.git $HOME /.clojure Community Tools available \u03bb\ufe0e The Clojure configuration directory contains a deps.edn file containing a substantial :aliases section with a long list of aliases. These aliases are described in the README of the project . All tools are provided via libraries and are only installed on first use. Unused aliases will therefore not install their libraries. REPL experience \u03bb\ufe0e Rebel readline provides a feature rich REPL experience, far beyond the basic clojure and clj commands. Command Description clojure -M:repl/rebel Run a Clojure REPL using Rebel Readline clojure -M:alias:repl/rebel Run a Clojure REPL using Rebel Readline, including deps and path from alias clojure -M:env/dev:repl/rebel Run a Clojure REPL using Rebel Readline, including deps and path from :env/dev alias to configure REPL start clojure -M:repl/rebel-nrepl Run a Clojure REPL using Rebel Readline, starting an nREPL server clojure -M:repl/rebel-cljs Run a ClojureScript REPL using Rebel Readline clojure -M:alias:repl/rebel-cljs Run a ClojureScript REPL using Rebel Readline, including deps and path from alias :repl/help in the REPL for help and available commands. :repl/quit to close the REPL. Clojure Projects \u03bb\ufe0e Create projects from deps, leiningen and boot templates with clj-new Check and update project dependencies Package projects as jar and uberjars Deploy projects locally and to Clojars Create a new project using a wide range of templates from the community Command Description clojure -X:project/new library project called playground clojure -X:project/new :name practicalli/my-library library project with given name clojure -X:project/new :template app :name practicalli/my-application App project with given name clojure -X:project/new :template luminus :name practicalli/full-stack-app +http-kit +h2 Luminus project with given name and template options Run projects \u03bb\ufe0e Run project with or without an alias: clojure -M:alias -m domain.app-name clojure -M -m domain.app-name The -M flag is required even if an alias is not included in the running of the application. A warning will be displayed if the -M option is missing. In the project deps.edn file it could be useful to define an alias to run the project, specifying the main namespace, the function to run and optionally any default arguments that are passed to that function. :project/run { :ns-default domain.main-namespace :exec-fn -main :exec-args { :port 8888 }} Then the project can be run using clojure -X:project/run and arguments can optionally be included in this command line, to complement or replace any default arguments in exec-args . Project dependencies \u03bb\ufe0e Command Description clojure -M:project/check detailed report of compilation errors for a project clojure -M:project/find-deps library-name fuzzy search Maven & Clojars clojure -M:project/find-deps -F:merge library-name fuzzy search Maven & Clojars and save to project deps.edn clojure -M:project/outdated report newer versions for maven and git dependencies clojure -M:project/outdated-mvn check for newer dependencies (maven only) Project packaging \u03bb\ufe0e Build a project archive file for deployment Command Description clojure -X:project/jar :main-class domain.app-name package project.jar for deps.edn project (publish library) clojure -X:project/uberjar :main-class domain.app-name package uber.jar for deps.edn project (deploy application) Additionally specify :jar name and if ahead of time compilation should be used (default true) clojure -X :project/jar :jar ' \"practicalli.app.jar\" ' :aot false :main-class domain.app-name Project Deployment \u03bb\ufe0e Deploy a project archive file locally or to Clojars.org Command Description clojure -X:deps mvn-install project.jar [NEW] deploy jar file to local maven repository, i.e. ~/.m2/repository clojure -M:project/clojars project.jar deploy jar file to Clojars clojure -M:project/clojars-signed project.jar deploy signed jar file to Clojars Set Clojars username/token in CLOJARS_USERNAME and CLOJARS_PASSWORD environment variables. Set fully qualified artifact-name and version in project pom.xml file Path to project.jar can also be set in alias to simplify the Clojure command. clojure -X:deps mvn-install project.jar for local deployment of jars is part of the 1.10.1.697 release of the Clojure CLI tools in September 2020. Java Sources \u03bb\ufe0e Include Java source on the classpath to look up Java Class and method definitions, e.g. cider-find-var in Emacs Requires: Java sources installed locally (e.g. \"/usr/lib/jvm/openjdk-11/lib/src.zip\") :lib/java8-source :lib/java11-source Use the aliases with either -M or -X flags on the Clojure command line. Databases and drivers \u03bb\ufe0e Databases and drivers, typically for development time inclusion such as embedded databases :database/h2 - H2 embedded database library and next.jdbc clojure -M:database/h2 - run a REPL with an embedded H2 database and next.jdbc libraries https://cljdoc.org/d/seancorfield/next.jdbc/CURRENT/doc/getting-started#create--populate-a-database Use the aliases with either -M or -X flags on the Clojure command line. Visualizing projects \u03bb\ufe0e Create Graphviz graphs of project and library dependencies Morpheus creates grahps of project vars and their relationships :graph/vars - generate graph of vars in a project as a .dot file :graph/vars-png - generate graph of vars in a project as a .png file using src and test paths :graph/vars-svg - generate graph of vars in a project as a .svg file using src and test paths Install Graphviz to generate PNG and SVG images. Or use the Edotor website to convert .dot files to PNG or SVG images and select different graph layout engines. Vizns creates graphs of relationships between library dependencies and project namespaces :graph/deps :graph/deps-png - generate a single deps-graph png image Other options: * clojure -M:graph/deps navigate # navigable folder of SVGs * clojure -M:graph/deps single # deps-graph.dot file * clojure -M:graph/deps single -o deps-graph.png -f png * clojure -M:graph/deps single -o deps-graph.svg -f svg * clojure -M:graph/deps single --show # View graph without saving Data Inspectors \u03bb\ufe0e REPL driven data inspectors and tap> sources for visualizing data. Portal \u03bb\ufe0e Portal Navigate data in the form of edn, json and transit Practicalli Clojure - data browsers section - portal Command Description clojure -M:inspect/portal-cli Clojure REPL with Portal dependency clojure -M:inspect/portal-web ClojureScript web browser REPL with Portal dependency clojure -M:inspect/portal-node ClojureScript node.js REPL with Portal dependency Using Portal once running (require '[portal.api :as portal]) once the REPL starts. For inspect/portal-web use (require '[portal.web :as portal]) instead (portal/open) to open the web based inspector window in a browser. (portal/tap) to add portal as a tap target (add-tap) (tap> {:accounts [{:name \"jen\" :email \"jen@jen.com\"} {:name \"sara\" :email \"sara@sara.com\"}]}) to send data to the portal inspector window (or any other data you wish to send) (portal/clear) to clear all values from the portal inspector window. (portal/close) to close the inspector window. Reveal \u03bb\ufe0e Reveal is a semi-commercial data visualization tool which includes its own REPL and can also be used as a tap> source inspector/reveal - repl and data visualization tool inspector/reveal-nrepl - repl and data visualization tool with nrepl server, for connection from Clojure aware editors Command Description clojure -M:inspect/reveal start a Reveal repl with data visualization window (clojure.main) clojure -M:inspect/reveal-light as above with light theme and large font clojure -X:inspect/reveal start a Reveal repl with data visualization window (clojure exec) clojure -X:inspect/reveal-light as above with light theme and large font clojure -M:inspect/reveal:repl/rebel Start a Rebel REPL with Reveal dependency. Add reveal as tap> source clojure -M:inspect/reveal-light:repl/rebel Start a Rebel REPL with Reveal dependency & light theme. Add reveal as tap> source Running different types of repl Using Clojure exec -X flag, the default repl function can be over-ridden on the command line, supplying the io-prepl or remote-prepl functions. clojure -X:inspect/reveal io-prepl :title '\"I am a prepl repl\" clojure -X:inspect/reveal remote-prepl :title '\"I am a remote prepl repl\"' Configure theme & font Add a custom theme and font via the -J command line option or create an alias using :inspect/reveal-light as an example. clojure -M:inspect/reveal -J-Dvlaaad.reveal.prefs = '{:theme :light :font-family \"Ubuntu Mono\" :font-size 32}' Rebel Readline & Reveal: Add Reveal as tap> source Evaluate (add-tap ((requiring-resolve 'vlaaad.reveal/ui))) when using Rebel Readline to add Reveal as a tap source, showing (tap> ,,,) expressions in the reveal window, eg. (tap> (map inc [1 2 3 4 5])) . Practicalli Clojure - data browsers section has more details on using reveal. Middleware \u03bb\ufe0e Aliases for libraries that combine community tools and REPL protocols (nREPL, SocketREPL). Run a REPL on the command line for access by cider-connect- commands, providing the require cider middleware libraries that are auto-injected in cider-jack-in- commands. nREPL \u03bb\ufe0e Use the aliases with either -M or -X flags on the Clojure command line. Command Description clojure -M:middleware/nrepl Run a Clojure REPL that includes nREPL server clojure -M:middleware/cider-clj Run a Clojure REPL that includes nREPL server and CIDER connection dependencies clojure -M:middleware/cider-cljs Run a ClojureScript REPL that includes nREPL server and CIDER connection dependencies Cognitect REBL with CIDER \u03bb\ufe0e Run the REBL REPL with nREPL server so editors such as CIDER and Calva can connect. clojure -M:lib/cider-nrepl:inspect/rebl:middleware/nrebl cider-connect-clj in Spacemacs / Emacs and CIDER successfully connects to the nREPL port and evaluated code is sent to REBL. To start a REBL REPL from cider-jack-in-clj add a .dir-locals.el file to the root of a Clojure project. The .dir-locals.el configuration adds the nREBL aliases set via cider-clojure-cli-global-options and all other automatically injected configuration is disabled (to prevent those dependencies over-riding the nREBL aliases). (( clojure-mode . (( cider-preferred-build-tool . clojure-cli ) ( cider-clojure-cli-global-options . \"-M:lib/cider-nrepl:inspect/rebl:middleware/nrebl\" ) ( cider-jack-in-dependencies . nil ) ( cider-jack-in-nrepl-middlewares . nil ) ( cider-jack-in-lein-plugins . nil ) ( cider-clojure-cli-parameters . \"\" )))) REBL data visualization: run REBL with nREPL based editors Clojure Specification \u03bb\ufe0e Clojure spec, generators and test.check :lib/spec-test - generative testing with Clojure test.check :lib/spec2 - experiment with the next version of Clojure spec - alpha: design may change Unit Testing frameworks \u03bb\ufe0e Unit test libraries and configuration. The Clojure standard library includes the clojure.test namespace, so no alias is required. :env/test - add test directory to classpath :lib/expectations - clojure.test with expectations :lib/expectations-classic - expectations framework Use expectations in a project clojure -M:test:expectations or from the command line with a test runner, e.g. clojure -M:lib/expectations:test/runner Test runners and Test Coverage \u03bb\ufe0e Tools to run unit tests in a project which are defined under test path. Run clojure with the specific test runner alias: clojure -M:test-runner-alias Command Description clojure -M:test/cognitect Cognitect Clojure test runner clojure -M:test/cljs ClojureScript test runner (Olical) clojure -M:test/runner Kaocha - comprehensive test runner for Clojure (same as :test/kaocha) clojure -M:test/kaocha Kaocha - comprehensive test runner for Clojure clojure -M:test/kaocha-cljs Kaocha - comprehensive test runner for ClojureScript clojure -M:test/kaocha-cucumber Kaocha - comprehensive test runner with BDD Cucumber tests clojure -M:test/kaocha-junit-xml Kaocha - comprehensive test runner with Junit XML reporting for CI dashboards clojure -M:test/kaocha-cloverage Kaocha - comprehensive test runner with test coverage reporting clojure -M:test/midje Midje test runner for BDD style tests clojure -M:test/eftest Fast Clojure test runner, pretty output, parallel tests clojure -M:test/coverage Cloverage clojure.test coverage report Lint tools \u03bb\ufe0e Static analysis tools to help maintain code quality and suggest Clojure idioms. Command Description clojure -M:lint/kondo comprehensive and fast static analysis lint tool clojure -M:lint/eastwood classic lint tool for Clojure clojure -M:lint/idiom Suggest idiomatic Clojure code Performance testing \u03bb\ufe0e Performance testing tools for the REPL :performance/benchmark Use the aliases with either -M or -X flags on the Clojure command line. TODO: check these alias combinations are correct clojure -M:performance/benchmark:repl/rebel ( require ' [ criterium.core :refer [ bench quick-bench ]]) ( bench ( adhoc-expression )) TODO: check these alias combinations are correct Performance test a project in the REPL clojure -M:performance/benchmark:repl/rebel ( require '[practicalli/namespace-name]) ; require project code (in-ns ' practicalli/namespace-name ) ( quick-bench ( project-function args )) :performance/memory-meter - memory usage Use the aliases with either -M or -X flags on the Clojure command line. In the REPL: ( require ' [ clj-memory-meter.core :as memory-meter ]) ( memory-meter/measure ( your-expression ))","title":"Community Tools"},{"location":"clojure-cli/community-tools/#practicalli-community-tools-for-clojure-cli","text":"practicalli/clojure-deps-edn practicalli/clojure-deps-edn is a user configuration for Clojure CLI tools providing a range of community tools via meaningful aliases, supporting Clojure and ClojureScript development. Alias names are designed with qualified keywords that provide context for the use of an alias ( project , repl , env , test , inspect ). These keywords help with discovery and reduce cognitive load required to remember their purpose. Commonly used arguments are included in many alias via :main-opts or :exec-args which can be overridden on the command line. Minimum Clojure CLI Version - 1.10.3.1040 Clojure CLI version 1.10.3.1040 is the minimum version, although the latest available version is recommended. Check the version of Clojure CLI currently installed via clojure --version or clojure -Sdescribe Remote Environments or Continuous Integration For remote environments or Continuous Integration services , include practicalli/clojure-deps-edn in the environment build or copy specific aliases to the Clojure project deps.edn configuration.","title":"Practicalli Community Tools for Clojure CLI"},{"location":"clojure-cli/community-tools/#install","text":"Fork or clone practicalli/clojure-deps-edn GitHub repository, first removing the $XDG_CONFIG_HOME/clojure or $HOME/.clojure directory if they exist. Check Clojure CLI configuration location Check the location of your Clojure configuration directory by running clojure -Sdescribe and checking the :user-config value. Free Desktop XDG CONFIG Classic Config If XDG_CONFIG_HOME environment variable is set, clone the repository to $XDG_CONFIG_HOME/clojure git clone https://github.com/practicalli/clojure-deps-edn.git $XDG_CONFIG_HOME /clojure Clojure CLI will look for its configuration in $HOME/.clojure directory if $XDG_CONFIG_HOME and CLJ_CONFIG environment variables not set. git clone https://github.com/practicalli/clojure-deps-edn.git $HOME /.clojure","title":"Install"},{"location":"clojure-cli/community-tools/#community-tools-available","text":"The Clojure configuration directory contains a deps.edn file containing a substantial :aliases section with a long list of aliases. These aliases are described in the README of the project . All tools are provided via libraries and are only installed on first use. Unused aliases will therefore not install their libraries.","title":"Community Tools available"},{"location":"clojure-cli/community-tools/#repl-experience","text":"Rebel readline provides a feature rich REPL experience, far beyond the basic clojure and clj commands. Command Description clojure -M:repl/rebel Run a Clojure REPL using Rebel Readline clojure -M:alias:repl/rebel Run a Clojure REPL using Rebel Readline, including deps and path from alias clojure -M:env/dev:repl/rebel Run a Clojure REPL using Rebel Readline, including deps and path from :env/dev alias to configure REPL start clojure -M:repl/rebel-nrepl Run a Clojure REPL using Rebel Readline, starting an nREPL server clojure -M:repl/rebel-cljs Run a ClojureScript REPL using Rebel Readline clojure -M:alias:repl/rebel-cljs Run a ClojureScript REPL using Rebel Readline, including deps and path from alias :repl/help in the REPL for help and available commands. :repl/quit to close the REPL.","title":"REPL experience"},{"location":"clojure-cli/community-tools/#clojure-projects","text":"Create projects from deps, leiningen and boot templates with clj-new Check and update project dependencies Package projects as jar and uberjars Deploy projects locally and to Clojars Create a new project using a wide range of templates from the community Command Description clojure -X:project/new library project called playground clojure -X:project/new :name practicalli/my-library library project with given name clojure -X:project/new :template app :name practicalli/my-application App project with given name clojure -X:project/new :template luminus :name practicalli/full-stack-app +http-kit +h2 Luminus project with given name and template options","title":"Clojure Projects"},{"location":"clojure-cli/community-tools/#run-projects","text":"Run project with or without an alias: clojure -M:alias -m domain.app-name clojure -M -m domain.app-name The -M flag is required even if an alias is not included in the running of the application. A warning will be displayed if the -M option is missing. In the project deps.edn file it could be useful to define an alias to run the project, specifying the main namespace, the function to run and optionally any default arguments that are passed to that function. :project/run { :ns-default domain.main-namespace :exec-fn -main :exec-args { :port 8888 }} Then the project can be run using clojure -X:project/run and arguments can optionally be included in this command line, to complement or replace any default arguments in exec-args .","title":"Run projects"},{"location":"clojure-cli/community-tools/#project-dependencies","text":"Command Description clojure -M:project/check detailed report of compilation errors for a project clojure -M:project/find-deps library-name fuzzy search Maven & Clojars clojure -M:project/find-deps -F:merge library-name fuzzy search Maven & Clojars and save to project deps.edn clojure -M:project/outdated report newer versions for maven and git dependencies clojure -M:project/outdated-mvn check for newer dependencies (maven only)","title":"Project dependencies"},{"location":"clojure-cli/community-tools/#project-packaging","text":"Build a project archive file for deployment Command Description clojure -X:project/jar :main-class domain.app-name package project.jar for deps.edn project (publish library) clojure -X:project/uberjar :main-class domain.app-name package uber.jar for deps.edn project (deploy application) Additionally specify :jar name and if ahead of time compilation should be used (default true) clojure -X :project/jar :jar ' \"practicalli.app.jar\" ' :aot false :main-class domain.app-name","title":"Project packaging"},{"location":"clojure-cli/community-tools/#project-deployment","text":"Deploy a project archive file locally or to Clojars.org Command Description clojure -X:deps mvn-install project.jar [NEW] deploy jar file to local maven repository, i.e. ~/.m2/repository clojure -M:project/clojars project.jar deploy jar file to Clojars clojure -M:project/clojars-signed project.jar deploy signed jar file to Clojars Set Clojars username/token in CLOJARS_USERNAME and CLOJARS_PASSWORD environment variables. Set fully qualified artifact-name and version in project pom.xml file Path to project.jar can also be set in alias to simplify the Clojure command. clojure -X:deps mvn-install project.jar for local deployment of jars is part of the 1.10.1.697 release of the Clojure CLI tools in September 2020.","title":"Project Deployment"},{"location":"clojure-cli/community-tools/#java-sources","text":"Include Java source on the classpath to look up Java Class and method definitions, e.g. cider-find-var in Emacs Requires: Java sources installed locally (e.g. \"/usr/lib/jvm/openjdk-11/lib/src.zip\") :lib/java8-source :lib/java11-source Use the aliases with either -M or -X flags on the Clojure command line.","title":"Java Sources"},{"location":"clojure-cli/community-tools/#databases-and-drivers","text":"Databases and drivers, typically for development time inclusion such as embedded databases :database/h2 - H2 embedded database library and next.jdbc clojure -M:database/h2 - run a REPL with an embedded H2 database and next.jdbc libraries https://cljdoc.org/d/seancorfield/next.jdbc/CURRENT/doc/getting-started#create--populate-a-database Use the aliases with either -M or -X flags on the Clojure command line.","title":"Databases and drivers"},{"location":"clojure-cli/community-tools/#visualizing-projects","text":"Create Graphviz graphs of project and library dependencies Morpheus creates grahps of project vars and their relationships :graph/vars - generate graph of vars in a project as a .dot file :graph/vars-png - generate graph of vars in a project as a .png file using src and test paths :graph/vars-svg - generate graph of vars in a project as a .svg file using src and test paths Install Graphviz to generate PNG and SVG images. Or use the Edotor website to convert .dot files to PNG or SVG images and select different graph layout engines. Vizns creates graphs of relationships between library dependencies and project namespaces :graph/deps :graph/deps-png - generate a single deps-graph png image Other options: * clojure -M:graph/deps navigate # navigable folder of SVGs * clojure -M:graph/deps single # deps-graph.dot file * clojure -M:graph/deps single -o deps-graph.png -f png * clojure -M:graph/deps single -o deps-graph.svg -f svg * clojure -M:graph/deps single --show # View graph without saving","title":"Visualizing projects"},{"location":"clojure-cli/community-tools/#data-inspectors","text":"REPL driven data inspectors and tap> sources for visualizing data.","title":"Data Inspectors"},{"location":"clojure-cli/community-tools/#portal","text":"Portal Navigate data in the form of edn, json and transit Practicalli Clojure - data browsers section - portal Command Description clojure -M:inspect/portal-cli Clojure REPL with Portal dependency clojure -M:inspect/portal-web ClojureScript web browser REPL with Portal dependency clojure -M:inspect/portal-node ClojureScript node.js REPL with Portal dependency Using Portal once running (require '[portal.api :as portal]) once the REPL starts. For inspect/portal-web use (require '[portal.web :as portal]) instead (portal/open) to open the web based inspector window in a browser. (portal/tap) to add portal as a tap target (add-tap) (tap> {:accounts [{:name \"jen\" :email \"jen@jen.com\"} {:name \"sara\" :email \"sara@sara.com\"}]}) to send data to the portal inspector window (or any other data you wish to send) (portal/clear) to clear all values from the portal inspector window. (portal/close) to close the inspector window.","title":"Portal"},{"location":"clojure-cli/community-tools/#reveal","text":"Reveal is a semi-commercial data visualization tool which includes its own REPL and can also be used as a tap> source inspector/reveal - repl and data visualization tool inspector/reveal-nrepl - repl and data visualization tool with nrepl server, for connection from Clojure aware editors Command Description clojure -M:inspect/reveal start a Reveal repl with data visualization window (clojure.main) clojure -M:inspect/reveal-light as above with light theme and large font clojure -X:inspect/reveal start a Reveal repl with data visualization window (clojure exec) clojure -X:inspect/reveal-light as above with light theme and large font clojure -M:inspect/reveal:repl/rebel Start a Rebel REPL with Reveal dependency. Add reveal as tap> source clojure -M:inspect/reveal-light:repl/rebel Start a Rebel REPL with Reveal dependency & light theme. Add reveal as tap> source Running different types of repl Using Clojure exec -X flag, the default repl function can be over-ridden on the command line, supplying the io-prepl or remote-prepl functions. clojure -X:inspect/reveal io-prepl :title '\"I am a prepl repl\" clojure -X:inspect/reveal remote-prepl :title '\"I am a remote prepl repl\"' Configure theme & font Add a custom theme and font via the -J command line option or create an alias using :inspect/reveal-light as an example. clojure -M:inspect/reveal -J-Dvlaaad.reveal.prefs = '{:theme :light :font-family \"Ubuntu Mono\" :font-size 32}' Rebel Readline & Reveal: Add Reveal as tap> source Evaluate (add-tap ((requiring-resolve 'vlaaad.reveal/ui))) when using Rebel Readline to add Reveal as a tap source, showing (tap> ,,,) expressions in the reveal window, eg. (tap> (map inc [1 2 3 4 5])) . Practicalli Clojure - data browsers section has more details on using reveal.","title":"Reveal"},{"location":"clojure-cli/community-tools/#middleware","text":"Aliases for libraries that combine community tools and REPL protocols (nREPL, SocketREPL). Run a REPL on the command line for access by cider-connect- commands, providing the require cider middleware libraries that are auto-injected in cider-jack-in- commands.","title":"Middleware"},{"location":"clojure-cli/community-tools/#nrepl","text":"Use the aliases with either -M or -X flags on the Clojure command line. Command Description clojure -M:middleware/nrepl Run a Clojure REPL that includes nREPL server clojure -M:middleware/cider-clj Run a Clojure REPL that includes nREPL server and CIDER connection dependencies clojure -M:middleware/cider-cljs Run a ClojureScript REPL that includes nREPL server and CIDER connection dependencies","title":"nREPL"},{"location":"clojure-cli/community-tools/#cognitect-rebl-with-cider","text":"Run the REBL REPL with nREPL server so editors such as CIDER and Calva can connect. clojure -M:lib/cider-nrepl:inspect/rebl:middleware/nrebl cider-connect-clj in Spacemacs / Emacs and CIDER successfully connects to the nREPL port and evaluated code is sent to REBL. To start a REBL REPL from cider-jack-in-clj add a .dir-locals.el file to the root of a Clojure project. The .dir-locals.el configuration adds the nREBL aliases set via cider-clojure-cli-global-options and all other automatically injected configuration is disabled (to prevent those dependencies over-riding the nREBL aliases). (( clojure-mode . (( cider-preferred-build-tool . clojure-cli ) ( cider-clojure-cli-global-options . \"-M:lib/cider-nrepl:inspect/rebl:middleware/nrebl\" ) ( cider-jack-in-dependencies . nil ) ( cider-jack-in-nrepl-middlewares . nil ) ( cider-jack-in-lein-plugins . nil ) ( cider-clojure-cli-parameters . \"\" )))) REBL data visualization: run REBL with nREPL based editors","title":"Cognitect REBL with CIDER"},{"location":"clojure-cli/community-tools/#clojure-specification","text":"Clojure spec, generators and test.check :lib/spec-test - generative testing with Clojure test.check :lib/spec2 - experiment with the next version of Clojure spec - alpha: design may change","title":"Clojure Specification"},{"location":"clojure-cli/community-tools/#unit-testing-frameworks","text":"Unit test libraries and configuration. The Clojure standard library includes the clojure.test namespace, so no alias is required. :env/test - add test directory to classpath :lib/expectations - clojure.test with expectations :lib/expectations-classic - expectations framework Use expectations in a project clojure -M:test:expectations or from the command line with a test runner, e.g. clojure -M:lib/expectations:test/runner","title":"Unit Testing frameworks"},{"location":"clojure-cli/community-tools/#test-runners-and-test-coverage","text":"Tools to run unit tests in a project which are defined under test path. Run clojure with the specific test runner alias: clojure -M:test-runner-alias Command Description clojure -M:test/cognitect Cognitect Clojure test runner clojure -M:test/cljs ClojureScript test runner (Olical) clojure -M:test/runner Kaocha - comprehensive test runner for Clojure (same as :test/kaocha) clojure -M:test/kaocha Kaocha - comprehensive test runner for Clojure clojure -M:test/kaocha-cljs Kaocha - comprehensive test runner for ClojureScript clojure -M:test/kaocha-cucumber Kaocha - comprehensive test runner with BDD Cucumber tests clojure -M:test/kaocha-junit-xml Kaocha - comprehensive test runner with Junit XML reporting for CI dashboards clojure -M:test/kaocha-cloverage Kaocha - comprehensive test runner with test coverage reporting clojure -M:test/midje Midje test runner for BDD style tests clojure -M:test/eftest Fast Clojure test runner, pretty output, parallel tests clojure -M:test/coverage Cloverage clojure.test coverage report","title":"Test runners and Test Coverage"},{"location":"clojure-cli/community-tools/#lint-tools","text":"Static analysis tools to help maintain code quality and suggest Clojure idioms. Command Description clojure -M:lint/kondo comprehensive and fast static analysis lint tool clojure -M:lint/eastwood classic lint tool for Clojure clojure -M:lint/idiom Suggest idiomatic Clojure code","title":"Lint tools"},{"location":"clojure-cli/community-tools/#performance-testing","text":"Performance testing tools for the REPL :performance/benchmark Use the aliases with either -M or -X flags on the Clojure command line. TODO: check these alias combinations are correct clojure -M:performance/benchmark:repl/rebel ( require ' [ criterium.core :refer [ bench quick-bench ]]) ( bench ( adhoc-expression )) TODO: check these alias combinations are correct Performance test a project in the REPL clojure -M:performance/benchmark:repl/rebel ( require '[practicalli/namespace-name]) ; require project code (in-ns ' practicalli/namespace-name ) ( quick-bench ( project-function args )) :performance/memory-meter - memory usage Use the aliases with either -M or -X flags on the Clojure command line. In the REPL: ( require ' [ clj-memory-meter.core :as memory-meter ]) ( memory-meter/measure ( your-expression ))","title":"Performance testing"},{"location":"clojure-cli/configure/","text":"Configure Clojure CLI \u03bb\ufe0e A deps.edn file configures the Clojure CLI, using extensible data notation (EDN), the underlying language for Clojure itself. Configuration is defined using a hash-map with the following top-level keys: :deps - library dependencies :paths - directories to search for code and resources (Java classpath) :aliases - named configuration defining extra paths, extra deps and configuration to run Clojure :mvn/repos - library dependency sources, remote and local (e.g. Clojars, Maven, Artifactory, etc). :aliases configuration is only included when using the alias name with the Clojure CLI, e.g. :repl/rebel alias in practicalli/clojure-deps-edn adds library dependencies only used during development to run a rich terminal UI REPL. clojure -M:repl/rebel Install Practicalli Community Tool aliases practicalli/clojure-deps-edn provides aliases for a wide range of tools for use with Clojure CLI to support Clojure software development. Precedence Order \u03bb\ufe0e Clojure CLI Configuration can be used from several different sources. Configuration Description Command line arguments string or edn (key value) arguments passed to the clojure command project deps.edn Project specific configuration: paths, dependencies, aliases .config/clojure/deps.edn or .clojure/deps.edn User level configuration for use with all projects Clojure CLI install Includes Clojure standard library, src path and built-in :deps aliases User level configuration location Clojure CLI tools creates a configuration directory called .clojure , which by default is placed in the root of the operating system user account directory, e.g. $HOME/.clojure . XDG_CONFIG_HOME may be set by your operating system and over-rides the default location, e.g. $HOME/.config/.clojure CLJ_CONFIG can be used to over-ride all other location settings Run clojure -Sdescribe in a terminal and checking the :user-config value to see the location of your Clojure configuration directory The installation of Clojure CLI tools has a built-in configuration that contains a dependency for the Clojure standard library, effectively setting the default version of Clojure so the Clojure CLI tools can run. .clojure/deps.edn is a user level configuration that will apply to all projects used by the operating system user account. practicalli/clojure-deps-edn is an example configuration that contains a set of unique aliases to ensure that common tools are available in every Clojure project. Scope of configuration files \u03bb\ufe0e ~/.clojure/deps.edn is user scope and is available with all the projects a specific developer works with. project-directory/deps.edn is for project specific configuration, shared by anyone using the project. The project deps.edn is merged into the ~/.clojure/deps.edn , replacing any keys that are the same with project specific values. The exception is the :paths key, where only the last one found is used (they are not combined). You can use the -Sverbose option to see all of the actual directory locations. clojure -Sverbose User deps.edn configuration \u03bb\ufe0e A basic example of a user configuration for Clojure CLI { :aliases { :env/test { :extra-paths [ \"test\" ]} :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.0.199\" }} :main-opts [ \"-m\" \"clj-new.create\" ]} } :mvn/repos { \"central\" { :url \"https://repo1.maven.org/maven2/\" } \"clojars\" { :url \"https://repo.clojars.org/\" } } } Clojure Tools install sets Clojure version A default version of Clojure is set by the Clojure tools install, enabling the clojure command to know what version of Clojure library to use. This version will be over-ridden by the user or project specific deps.edn configuration files if set. References \u03bb\ufe0e deps and cli","title":"Configure"},{"location":"clojure-cli/configure/#configure-clojure-cli","text":"A deps.edn file configures the Clojure CLI, using extensible data notation (EDN), the underlying language for Clojure itself. Configuration is defined using a hash-map with the following top-level keys: :deps - library dependencies :paths - directories to search for code and resources (Java classpath) :aliases - named configuration defining extra paths, extra deps and configuration to run Clojure :mvn/repos - library dependency sources, remote and local (e.g. Clojars, Maven, Artifactory, etc). :aliases configuration is only included when using the alias name with the Clojure CLI, e.g. :repl/rebel alias in practicalli/clojure-deps-edn adds library dependencies only used during development to run a rich terminal UI REPL. clojure -M:repl/rebel Install Practicalli Community Tool aliases practicalli/clojure-deps-edn provides aliases for a wide range of tools for use with Clojure CLI to support Clojure software development.","title":"Configure Clojure CLI"},{"location":"clojure-cli/configure/#precedence-order","text":"Clojure CLI Configuration can be used from several different sources. Configuration Description Command line arguments string or edn (key value) arguments passed to the clojure command project deps.edn Project specific configuration: paths, dependencies, aliases .config/clojure/deps.edn or .clojure/deps.edn User level configuration for use with all projects Clojure CLI install Includes Clojure standard library, src path and built-in :deps aliases User level configuration location Clojure CLI tools creates a configuration directory called .clojure , which by default is placed in the root of the operating system user account directory, e.g. $HOME/.clojure . XDG_CONFIG_HOME may be set by your operating system and over-rides the default location, e.g. $HOME/.config/.clojure CLJ_CONFIG can be used to over-ride all other location settings Run clojure -Sdescribe in a terminal and checking the :user-config value to see the location of your Clojure configuration directory The installation of Clojure CLI tools has a built-in configuration that contains a dependency for the Clojure standard library, effectively setting the default version of Clojure so the Clojure CLI tools can run. .clojure/deps.edn is a user level configuration that will apply to all projects used by the operating system user account. practicalli/clojure-deps-edn is an example configuration that contains a set of unique aliases to ensure that common tools are available in every Clojure project.","title":"Precedence Order"},{"location":"clojure-cli/configure/#scope-of-configuration-files","text":"~/.clojure/deps.edn is user scope and is available with all the projects a specific developer works with. project-directory/deps.edn is for project specific configuration, shared by anyone using the project. The project deps.edn is merged into the ~/.clojure/deps.edn , replacing any keys that are the same with project specific values. The exception is the :paths key, where only the last one found is used (they are not combined). You can use the -Sverbose option to see all of the actual directory locations. clojure -Sverbose","title":"Scope of configuration files"},{"location":"clojure-cli/configure/#user-depsedn-configuration","text":"A basic example of a user configuration for Clojure CLI { :aliases { :env/test { :extra-paths [ \"test\" ]} :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.0.199\" }} :main-opts [ \"-m\" \"clj-new.create\" ]} } :mvn/repos { \"central\" { :url \"https://repo1.maven.org/maven2/\" } \"clojars\" { :url \"https://repo.clojars.org/\" } } } Clojure Tools install sets Clojure version A default version of Clojure is set by the Clojure tools install, enabling the clojure command to know what version of Clojure library to use. This version will be over-ridden by the user or project specific deps.edn configuration files if set.","title":"User deps.edn configuration"},{"location":"clojure-cli/configure/#references","text":"deps and cli","title":"References"},{"location":"clojure-cli/design-journal/","text":"Design Journal \u03bb\ufe0e A design journal captures with code and comments the decisions taken for a project, invaluable to anyone trying to get up to speed with a project. Using a design-journal namespace \u03bb\ufe0e A single namespace encourages the journal to flow as the design of the application flows. So onboarding onto a project is essentially reading and evaluating code from top to bottom. Using comment blocks \u03bb\ufe0e It is useful to include examples of how you expect key parts of the system to be called and the kind of arguments they receive. Placing these examples in a (comment ,,,) expression ensures they are not accidentally evaluated whilst showing the most important function calls in a particular namespace.","title":"Design Journal"},{"location":"clojure-cli/design-journal/#design-journal","text":"A design journal captures with code and comments the decisions taken for a project, invaluable to anyone trying to get up to speed with a project.","title":"Design Journal"},{"location":"clojure-cli/design-journal/#using-a-design-journal-namespace","text":"A single namespace encourages the journal to flow as the design of the application flows. So onboarding onto a project is essentially reading and evaluating code from top to bottom.","title":"Using a design-journal namespace"},{"location":"clojure-cli/design-journal/#using-comment-blocks","text":"It is useful to include examples of how you expect key parts of the system to be called and the kind of arguments they receive. Placing these examples in a (comment ,,,) expression ensures they are not accidentally evaluated whilst showing the most important function calls in a particular namespace.","title":"Using comment blocks"},{"location":"clojure-cli/hotload-libraries-terminal-ui/","text":"Hotload libraries in a terminal REPL UI \u03bb\ufe0e Start a REPL session using the Clojure CLI tools with the hotload alias , including rebel readline for an enhance REPL UI. clojure -M:lib/hotload:repl/rebel The required libraries for the :hotload-libs alias are downloaded (if not already available locally in ~/.m2 maven cache on first run). The REPL process with start and the terminal will show the Rebel UI. Require the clojure.tools.deps.alpha library and refer the add-libs function. The add-libs function can then be called without having to use an alias or the fully qualified name. ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) Hotload a library into the REPL using the add-lib function in the following form, where domain/library is the fully qualified name of the library and RELEASE is a string of the version number of that library to use. ( add-libs ' { domain/library { :mvn/version \"RELEASE\" }}) Multiple libraries can be hot-loaded in a single add-libs expression ( add-libs ' { hhgttg/meaning { :mvn/version \"4.2.0\" } eternity/room { :mvn/version \"1.0.1\" }}) Hotload hiccup in a terminal REPL \u03bb\ufe0e The hiccup library converts clojure structures into html, where vectors represent the scope of keywords that represent html tags. Load the hiccup library using add-libs ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) Require the hiccup library so its functions are accessible from the current namespace in the REPL. ( require ' [ hiccup.core :as hiccup ]) Enter an expression using the hiccup/html function to convert a clojure data structure to html. ( hiccup/html [ :div { :class \"right-aligned\" }]) The hiccup expression returns a string of the html code.","title":"Hotload libraries terminal ui"},{"location":"clojure-cli/hotload-libraries-terminal-ui/#hotload-libraries-in-a-terminal-repl-ui","text":"Start a REPL session using the Clojure CLI tools with the hotload alias , including rebel readline for an enhance REPL UI. clojure -M:lib/hotload:repl/rebel The required libraries for the :hotload-libs alias are downloaded (if not already available locally in ~/.m2 maven cache on first run). The REPL process with start and the terminal will show the Rebel UI. Require the clojure.tools.deps.alpha library and refer the add-libs function. The add-libs function can then be called without having to use an alias or the fully qualified name. ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) Hotload a library into the REPL using the add-lib function in the following form, where domain/library is the fully qualified name of the library and RELEASE is a string of the version number of that library to use. ( add-libs ' { domain/library { :mvn/version \"RELEASE\" }}) Multiple libraries can be hot-loaded in a single add-libs expression ( add-libs ' { hhgttg/meaning { :mvn/version \"4.2.0\" } eternity/room { :mvn/version \"1.0.1\" }})","title":"Hotload libraries in a terminal REPL UI"},{"location":"clojure-cli/hotload-libraries-terminal-ui/#hotload-hiccup-in-a-terminal-repl","text":"The hiccup library converts clojure structures into html, where vectors represent the scope of keywords that represent html tags. Load the hiccup library using add-libs ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) Require the hiccup library so its functions are accessible from the current namespace in the REPL. ( require ' [ hiccup.core :as hiccup ]) Enter an expression using the hiccup/html function to convert a clojure data structure to html. ( hiccup/html [ :div { :class \"right-aligned\" }]) The hiccup expression returns a string of the html code.","title":"Hotload hiccup in a terminal REPL"},{"location":"clojure-cli/hotload-libraries/","text":"Hotload Libraries into a running REPL \u03bb\ufe0e add-libs \"hot-loads\" one or more libraries into a running REPL, avoiding the need to restart the REPL and loosing any state just to use a new library with the project. add-libs is typically called from a rich comment block or a separate dev/user.clj file to avoid being loaded with application code. Once hot-loaded, a library namespace can be required as if the dependency had been added to the project configuration before the REPL started. practicalli/clojure-webapp-hotload-libraries is an example project that uses REPL driven development and hot loading of libraries to build a very simple web server using http-kit and hiccup. Add-libs is an experimental feature The add-libs function is regarded as an experimental feature of clojure.tools.deps.alpha library and is currently part of the add-libs3 branch . The add-libs implementation and function signature may change in future. add-libs dependency \u03bb\ufe0e The clojure/tools.deps.alpha library defines the add-libs function on the add-libs3 branch and the latest SHA must be included as a dependency when starting the REPL. add-libs is a development tool which should be added via an alias, either in the project deps.edn or user config for use with all projects. Practicalli Clojure CLI Config manual :lib/hotload alias defined in practicalli/clojure-deps-edn adds the latest SHA commit from the add-libs3 branch of clojure.tools.deps.alpha library as an extra dependency. Include the :lib/hotload alias when starting the REPL, using any of the available Clojure CLI execution options ( -A , -M , -X , -T ). See Terminal REPL and Clojure Editor pages for examples. Edit the project deps.edn configuration and add an :lib/hotload alias for the clojure.tools.deps.alpha.repl library. Or add an alias to the user level configuration for use with any Clojure CLI project. The add-libs code is on a separate add-libs3 branch , so requires the SHA from the head of add-libs3 branch :lib/hotload { :extra-deps { org.clojure/tools.deps.alpha { :git/url \"https://github.com/clojure/tools.deps.alpha\" :git/sha \"e4fb92eef724fa39e29b39cc2b1a850567d490dd\" }}} Alias example from practicalli/clojure-deps-edn Using add-libs to hotload libraries \u03bb\ufe0e There are several approaches taken for hotloading libraries, including: Rich terminal UI REPL Hotload in a Project","title":"HotLoad Libraries"},{"location":"clojure-cli/hotload-libraries/#hotload-libraries-into-a-running-repl","text":"add-libs \"hot-loads\" one or more libraries into a running REPL, avoiding the need to restart the REPL and loosing any state just to use a new library with the project. add-libs is typically called from a rich comment block or a separate dev/user.clj file to avoid being loaded with application code. Once hot-loaded, a library namespace can be required as if the dependency had been added to the project configuration before the REPL started. practicalli/clojure-webapp-hotload-libraries is an example project that uses REPL driven development and hot loading of libraries to build a very simple web server using http-kit and hiccup. Add-libs is an experimental feature The add-libs function is regarded as an experimental feature of clojure.tools.deps.alpha library and is currently part of the add-libs3 branch . The add-libs implementation and function signature may change in future.","title":"Hotload Libraries into a running REPL"},{"location":"clojure-cli/hotload-libraries/#add-libs-dependency","text":"The clojure/tools.deps.alpha library defines the add-libs function on the add-libs3 branch and the latest SHA must be included as a dependency when starting the REPL. add-libs is a development tool which should be added via an alias, either in the project deps.edn or user config for use with all projects. Practicalli Clojure CLI Config manual :lib/hotload alias defined in practicalli/clojure-deps-edn adds the latest SHA commit from the add-libs3 branch of clojure.tools.deps.alpha library as an extra dependency. Include the :lib/hotload alias when starting the REPL, using any of the available Clojure CLI execution options ( -A , -M , -X , -T ). See Terminal REPL and Clojure Editor pages for examples. Edit the project deps.edn configuration and add an :lib/hotload alias for the clojure.tools.deps.alpha.repl library. Or add an alias to the user level configuration for use with any Clojure CLI project. The add-libs code is on a separate add-libs3 branch , so requires the SHA from the head of add-libs3 branch :lib/hotload { :extra-deps { org.clojure/tools.deps.alpha { :git/url \"https://github.com/clojure/tools.deps.alpha\" :git/sha \"e4fb92eef724fa39e29b39cc2b1a850567d490dd\" }}} Alias example from practicalli/clojure-deps-edn","title":"add-libs dependency"},{"location":"clojure-cli/hotload-libraries/#using-add-libs-to-hotload-libraries","text":"There are several approaches taken for hotloading libraries, including: Rich terminal UI REPL Hotload in a Project","title":"Using add-libs to hotload libraries"},{"location":"clojure-cli/repl-startup/","text":"Configure REPL on Startup \u03bb\ufe0e A Clojure REPL starts in the user namespace by default. Clojure automatically loads code from a user.clj file when found on the class path. The user.clj file typically contains tools to support development, such as: loading project code into the REPL by requiring namespaces hotload libraries into the REPL process without restart call functions to run an application or service start components (i.e for mount, component, integrant) adding development tools - portal data inspector The user.clj is typically placed in a dev folder within the root of the project, to keep it separated from production code. Example project practicalli/clojure-configure-repl project contains example code for configuring the REPL start up juxt/edge has example projects using the same technique. dev/user.clj and :env/dev alias \u03bb\ufe0e Create a dev/user.clj file with a namespace called user . dev/user.clj ( ns user ) Create an alias to include the dev path when running a REPL process Practicalli Clojure CLI Config Manual Practicalli Clojure CLI Config includes a :env/dev alias which adds the dev directory to the project classpath. Add an alias to the user deps.edn configuration, i.e. $XDG_CONFIG_HOME/clojure/deps.edn or $HOME/.clojure/deps.edn Clojure User Config :env/dev { :extra-paths [ \"dev\" ]} Running a Clojure REPL with the :env/dev alias will add the dev/user.clj file to the class path and be loaded by the REPL. In this example the dev/ path is added to the project and then the REPL is run using Rebel. clojure -M:env/dev:repl/rebel Using the dev/ directory The user.clj code should not be included in live deployments, such as jars and uberjars. Including the dev/ directory via the :env/dev alias keeps the user.clj and any other development only code separate from deployment actions. Requiring namespaces \u03bb\ufe0e By requiring a namespace in the dev/user.clj file, the code defined in that namespace will be loaded into the REPL once started. Functions (defn) and data (def) are immediately available. Add a require expression to the namespace definition in dev/user.clj dev/user.clj ( ns user ( :require [ practicalli.project-namespace ])) (require '[practicalli.project-namespace]) form can also be used instead and placed in a (comment ,,,) form if the require is only to be called by the developer dev/user.clj ( ns user ) ( comment ( require ' [ practicalli.project-namespace ]) # _ ()) Calling functions \u03bb\ufe0e Use the fully qualified function name from the required namespace can be called, to start the application for example. dev/user.clj ( ns user ( :require [ practicalli.project-namespace ])) ( practicalli.project-namespace/-main ) An alias can be used in the require expression, useful if multiple functions from a namespace are to be called dev/user.clj ( ns user ( :require [ practicalli.service :as service ])) ( service/-main ) Search for library dependencies \u03bb\ufe0e The find-deps project fuzzy searches Maven Central and Clojars for dependencies when given a name. Practicalli Clojure CLI Config Manual The :search/libraries in Practicalli Clojure CLI Config will add the find-deps library. Add the find-deps project to and alias called :search/libraries in the user level deps.edn file, i.e. $XDG_CONFIG_HOME/clojure/deps.edn or $HOME/.clojure/deps.edn Clojure User Config :search/libraries { :extra-deps { find-deps/find-deps { :git/url \"https://github.com/hagmonk/find-deps\" :git/sha \"9bf23a52cb0a8190c9c2c7ad1d796da802f8ce7a\" }} :main-opts [ \"-m\" \"find-deps.core\" ]} Require the find-deps.core namespace in the dev/user.clj file to use its deps and print-deps functions dev/user.clj ( ns user ( :require [ find-deps.core :as find-lib ])) Start a REPL using the :env/dev and :search/libraries aliases. To start a Rebel REPL, use the following command in a terminal clojure -M:env/dev:search/libraries:repl/rebel Call the (find-lib/deps \"library-name\") to return a map of the matching dependency, or (find-libs/print-deps \"library name\") to print dependencies in a table. dev/user.clj ( comment ( find-lib/deps \"library-name\" ) ( find-lib/print-deps \"library name\" )) Hotload libraries \u03bb\ufe0e Hotload is a way to add libraries to a running REPL process that were not incldude as a dependency on REPL startup. Practicalli Clojure CLI Config Manual :lib/hotload and :lib/reloaded aliases in Practicalli Clojure CLI Config will add the add-libs3 branch of tools.deps.alpha which provides the add-libs function. Edit the project deps.edn configuration and add an :lib/hotload alias for the clojure.tools.deps.alpha.repl library. Or add an alias to the user level configuration for use with any Clojure CLI project. The add-libs code is on a separate add-libs3 branch , so requires the SHA from the head of add-libs3 branch :lib/hotload { :extra-deps { org.clojure/tools.deps.alpha { :git/url \"https://github.com/clojure/tools.deps.alpha\" :git/sha \"e4fb92eef724fa39e29b39cc2b1a850567d490dd\" }}} Alias example from practicalli/clojure-deps-edn Start a REPL session using Clojure CLI with the :lib/hotload alias , including rebel readline for an enhance REPL terminal UI. clojure -M:lib/hotload:repl/rebel Require the clojure.tools.deps.alpha library and refer the add-libs function. The add-libs function can then be called without having to use an alias or the fully qualified name. ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) Hotload one or more libraries into the REPL using the add-lib function, including the fully qualified name of the library and version string. The hiccup library converts clojure structures into html, where vectors represent the scope of keywords that represent html tags. Load the hiccup library using add-libs ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) Require the hiccup library so its functions are accessible from the current namespace in the REPL. ( require ' [ hiccup.core :as hiccup ]) Enter an expression using the hiccup/html function to convert a clojure data structure to html. ( hiccup/html [ :div { :class \"right-aligned\" }]) Life-cycle Services \u03bb\ufe0e Clojure has several library to manage the life-cycle of components that make up the application, especially those components with state. Components can be started and stopped in a specific order. Example component life-cycle libraries included mount integrant component In Clojure it is idiomatic to define the component life-cycle services in a namespace called dev . In the dev/user.clj file, add the following ns declaration to require the dev namespace and change to that namespace with in-ns dev/user.clj ( ns user ( :require [ dev ])) ( dev/go ) Now define code in the dev/dev.clj file that controls the component life-cycle services library for the project. Example project with component life-cycle \u03bb\ufe0e Start, stop and restart the components that a system is composed of, e.g. app server, database pool, log publisher, message queue, etc. === \"mount\" Define a `dev.clj` file with `go`, `stop` and `restart` functions that manage the life-cycle of mount components. A `start` function contains the list of components with optional state. Require the mount namespace and the main namespace for the project, which should contain all the code to start and stop services. ```clojure title=\"dev/user.clj\" (ns user :require [mount.core :refer [defstate]] [practicalli.app.main]) ``` Define a start function to start all services ```clojure title=\"dev/user.clj\" (defn start [] (with-logging-status) (mount/start #'practicalli.app.conf/environment #'practicalli.app.db/connection #'practicalli.app.www/business-app #'practicalli.app.service/nrepl)) ``` The `go` function calls `start` and marks all components as ready. ```clojure title=\"dev/user.clj\" (defn go \"Start all states defined by defstate\" [] (start) :ready) ``` The `stop` function stops all components, removing all non-persistent state. ```clojure (defn stop [] (mount/stop)) ``` The reset function that calls `stop`, refreshes the namespaces so that stale definitions are removed and starts all components (loading in any new code). ```clojure title=\"dev/user.clj\" (defn reset \"Stop all states defined by defstate. Reload modified source files and restart all states\" [] (stop) (namespace/refresh :after 'dev/go)) ``` * [Example dev.clj file for mount](https://github.com/tolitius/mount/blob/master/dev/clj/dev.clj) !!! Hint \"Use `dev` namespace during development\" Require `practicalli.app.dev` namespace rather than main, to start components in a development environment. Integrant REPL Component Donut System See the detailed example of Integrant REPL in Practicalli Clojure Web Services Usermanager example project using Integrant. seancorfield/usermanager-example is an example project that uses Component for lifecycle management donut.system is a dependency injection library for Clojure and ClojureScript using system and component abstractions to organise and manage startup & shutdown behaviour. Basic usage guide shows how to define a donut.system Reference \u03bb\ufe0e Mount project on GitHub Mount - collection of Clojure/Script mount apps donut.system Component A tutorial to Stuart Sierra's Component Refactoring to Components - Walmart Labs Lacinia Integrant Compojure and Integrant Build a Clojure web app using Duct - CircleCI Reloading Woes - Lambda island","title":"REPL Startup"},{"location":"clojure-cli/repl-startup/#configure-repl-on-startup","text":"A Clojure REPL starts in the user namespace by default. Clojure automatically loads code from a user.clj file when found on the class path. The user.clj file typically contains tools to support development, such as: loading project code into the REPL by requiring namespaces hotload libraries into the REPL process without restart call functions to run an application or service start components (i.e for mount, component, integrant) adding development tools - portal data inspector The user.clj is typically placed in a dev folder within the root of the project, to keep it separated from production code. Example project practicalli/clojure-configure-repl project contains example code for configuring the REPL start up juxt/edge has example projects using the same technique.","title":"Configure REPL on Startup"},{"location":"clojure-cli/repl-startup/#devuserclj-and-envdev-alias","text":"Create a dev/user.clj file with a namespace called user . dev/user.clj ( ns user ) Create an alias to include the dev path when running a REPL process Practicalli Clojure CLI Config Manual Practicalli Clojure CLI Config includes a :env/dev alias which adds the dev directory to the project classpath. Add an alias to the user deps.edn configuration, i.e. $XDG_CONFIG_HOME/clojure/deps.edn or $HOME/.clojure/deps.edn Clojure User Config :env/dev { :extra-paths [ \"dev\" ]} Running a Clojure REPL with the :env/dev alias will add the dev/user.clj file to the class path and be loaded by the REPL. In this example the dev/ path is added to the project and then the REPL is run using Rebel. clojure -M:env/dev:repl/rebel Using the dev/ directory The user.clj code should not be included in live deployments, such as jars and uberjars. Including the dev/ directory via the :env/dev alias keeps the user.clj and any other development only code separate from deployment actions.","title":"dev/user.clj and :env/dev alias"},{"location":"clojure-cli/repl-startup/#requiring-namespaces","text":"By requiring a namespace in the dev/user.clj file, the code defined in that namespace will be loaded into the REPL once started. Functions (defn) and data (def) are immediately available. Add a require expression to the namespace definition in dev/user.clj dev/user.clj ( ns user ( :require [ practicalli.project-namespace ])) (require '[practicalli.project-namespace]) form can also be used instead and placed in a (comment ,,,) form if the require is only to be called by the developer dev/user.clj ( ns user ) ( comment ( require ' [ practicalli.project-namespace ]) # _ ())","title":"Requiring namespaces"},{"location":"clojure-cli/repl-startup/#calling-functions","text":"Use the fully qualified function name from the required namespace can be called, to start the application for example. dev/user.clj ( ns user ( :require [ practicalli.project-namespace ])) ( practicalli.project-namespace/-main ) An alias can be used in the require expression, useful if multiple functions from a namespace are to be called dev/user.clj ( ns user ( :require [ practicalli.service :as service ])) ( service/-main )","title":"Calling functions"},{"location":"clojure-cli/repl-startup/#search-for-library-dependencies","text":"The find-deps project fuzzy searches Maven Central and Clojars for dependencies when given a name. Practicalli Clojure CLI Config Manual The :search/libraries in Practicalli Clojure CLI Config will add the find-deps library. Add the find-deps project to and alias called :search/libraries in the user level deps.edn file, i.e. $XDG_CONFIG_HOME/clojure/deps.edn or $HOME/.clojure/deps.edn Clojure User Config :search/libraries { :extra-deps { find-deps/find-deps { :git/url \"https://github.com/hagmonk/find-deps\" :git/sha \"9bf23a52cb0a8190c9c2c7ad1d796da802f8ce7a\" }} :main-opts [ \"-m\" \"find-deps.core\" ]} Require the find-deps.core namespace in the dev/user.clj file to use its deps and print-deps functions dev/user.clj ( ns user ( :require [ find-deps.core :as find-lib ])) Start a REPL using the :env/dev and :search/libraries aliases. To start a Rebel REPL, use the following command in a terminal clojure -M:env/dev:search/libraries:repl/rebel Call the (find-lib/deps \"library-name\") to return a map of the matching dependency, or (find-libs/print-deps \"library name\") to print dependencies in a table. dev/user.clj ( comment ( find-lib/deps \"library-name\" ) ( find-lib/print-deps \"library name\" ))","title":"Search for library dependencies"},{"location":"clojure-cli/repl-startup/#hotload-libraries","text":"Hotload is a way to add libraries to a running REPL process that were not incldude as a dependency on REPL startup. Practicalli Clojure CLI Config Manual :lib/hotload and :lib/reloaded aliases in Practicalli Clojure CLI Config will add the add-libs3 branch of tools.deps.alpha which provides the add-libs function. Edit the project deps.edn configuration and add an :lib/hotload alias for the clojure.tools.deps.alpha.repl library. Or add an alias to the user level configuration for use with any Clojure CLI project. The add-libs code is on a separate add-libs3 branch , so requires the SHA from the head of add-libs3 branch :lib/hotload { :extra-deps { org.clojure/tools.deps.alpha { :git/url \"https://github.com/clojure/tools.deps.alpha\" :git/sha \"e4fb92eef724fa39e29b39cc2b1a850567d490dd\" }}} Alias example from practicalli/clojure-deps-edn Start a REPL session using Clojure CLI with the :lib/hotload alias , including rebel readline for an enhance REPL terminal UI. clojure -M:lib/hotload:repl/rebel Require the clojure.tools.deps.alpha library and refer the add-libs function. The add-libs function can then be called without having to use an alias or the fully qualified name. ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) Hotload one or more libraries into the REPL using the add-lib function, including the fully qualified name of the library and version string. The hiccup library converts clojure structures into html, where vectors represent the scope of keywords that represent html tags. Load the hiccup library using add-libs ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) Require the hiccup library so its functions are accessible from the current namespace in the REPL. ( require ' [ hiccup.core :as hiccup ]) Enter an expression using the hiccup/html function to convert a clojure data structure to html. ( hiccup/html [ :div { :class \"right-aligned\" }])","title":"Hotload libraries"},{"location":"clojure-cli/repl-startup/#life-cycle-services","text":"Clojure has several library to manage the life-cycle of components that make up the application, especially those components with state. Components can be started and stopped in a specific order. Example component life-cycle libraries included mount integrant component In Clojure it is idiomatic to define the component life-cycle services in a namespace called dev . In the dev/user.clj file, add the following ns declaration to require the dev namespace and change to that namespace with in-ns dev/user.clj ( ns user ( :require [ dev ])) ( dev/go ) Now define code in the dev/dev.clj file that controls the component life-cycle services library for the project.","title":"Life-cycle Services"},{"location":"clojure-cli/repl-startup/#example-project-with-component-life-cycle","text":"Start, stop and restart the components that a system is composed of, e.g. app server, database pool, log publisher, message queue, etc. === \"mount\" Define a `dev.clj` file with `go`, `stop` and `restart` functions that manage the life-cycle of mount components. A `start` function contains the list of components with optional state. Require the mount namespace and the main namespace for the project, which should contain all the code to start and stop services. ```clojure title=\"dev/user.clj\" (ns user :require [mount.core :refer [defstate]] [practicalli.app.main]) ``` Define a start function to start all services ```clojure title=\"dev/user.clj\" (defn start [] (with-logging-status) (mount/start #'practicalli.app.conf/environment #'practicalli.app.db/connection #'practicalli.app.www/business-app #'practicalli.app.service/nrepl)) ``` The `go` function calls `start` and marks all components as ready. ```clojure title=\"dev/user.clj\" (defn go \"Start all states defined by defstate\" [] (start) :ready) ``` The `stop` function stops all components, removing all non-persistent state. ```clojure (defn stop [] (mount/stop)) ``` The reset function that calls `stop`, refreshes the namespaces so that stale definitions are removed and starts all components (loading in any new code). ```clojure title=\"dev/user.clj\" (defn reset \"Stop all states defined by defstate. Reload modified source files and restart all states\" [] (stop) (namespace/refresh :after 'dev/go)) ``` * [Example dev.clj file for mount](https://github.com/tolitius/mount/blob/master/dev/clj/dev.clj) !!! Hint \"Use `dev` namespace during development\" Require `practicalli.app.dev` namespace rather than main, to start components in a development environment. Integrant REPL Component Donut System See the detailed example of Integrant REPL in Practicalli Clojure Web Services Usermanager example project using Integrant. seancorfield/usermanager-example is an example project that uses Component for lifecycle management donut.system is a dependency injection library for Clojure and ClojureScript using system and component abstractions to organise and manage startup & shutdown behaviour. Basic usage guide shows how to define a donut.system","title":"Example project with component life-cycle"},{"location":"clojure-cli/repl-startup/#reference","text":"Mount project on GitHub Mount - collection of Clojure/Script mount apps donut.system Component A tutorial to Stuart Sierra's Component Refactoring to Components - Walmart Labs Lacinia Integrant Compojure and Integrant Build a Clojure web app using Duct - CircleCI Reloading Woes - Lambda island","title":"Reference"},{"location":"clojure-cli/wip/","text":"Clojure Tools overview \u03bb\ufe0e Adding Libraries of code \u03bb\ufe0e Clojure CLI tools allow you to use other libraries to, referred to as dependencies or 'deps'. These may be libraries you are writing locally, projects in git (e.g. on GitHub) or libraries published to Maven Central or Clojars . Clojure is packaged as a complete library, a Java Virtual machine JAR file (zip file format), that is simply included in the project like any other library you would use. Hosted Language \u03bb\ufe0e Clojure is a hosted language and requires a Java runtime environment . When Clojure expressions are evaluated, the Clojure code is turned into Java Bytecode and run in the Java Virtual Machine. This process happens in the background and the developer is not exposed to a separate code-compile-run cycle. Installing Clojure guides cover how to install Java 11 for various operating systems, although it may already be installed.","title":"Clojure Tools overview"},{"location":"clojure-cli/wip/#clojure-tools-overview","text":"","title":"Clojure Tools overview"},{"location":"clojure-cli/wip/#adding-libraries-of-code","text":"Clojure CLI tools allow you to use other libraries to, referred to as dependencies or 'deps'. These may be libraries you are writing locally, projects in git (e.g. on GitHub) or libraries published to Maven Central or Clojars . Clojure is packaged as a complete library, a Java Virtual machine JAR file (zip file format), that is simply included in the project like any other library you would use.","title":"Adding Libraries of code"},{"location":"clojure-cli/wip/#hosted-language","text":"Clojure is a hosted language and requires a Java runtime environment . When Clojure expressions are evaluated, the Clojure code is turned into Java Bytecode and run in the Java Virtual Machine. This process happens in the background and the developer is not exposed to a separate code-compile-run cycle. Installing Clojure guides cover how to install Java 11 for various operating systems, although it may already be installed.","title":"Hosted Language"},{"location":"clojure-cli/projects/","text":"Clojure projects \u03bb\ufe0e A Clojure CLI project is defined by a deps.edn file that specifies source and library paths to use for the project. The deps.edn file can also define aliases which can optionally be included when running the REPL to support development related tasks. Generate a project from a template Create a project from a template to save time creating a common project structure. Practicalli clojure-app-template example project practicalli/clojure-app-template provides a production grade example of a project starting point, with additional configuration files for building and deploying the project. Create a minimal project \u03bb\ufe0e Create a deps.edn file containing {} in the root of a directory for a minimal configuration. Create a src directory as the root of the source code, and test directory to contain unit test code. Linux command to create a minimal clojure project Run these Linux commands in the root of a directory to create a minimal Clojure project structure. touch deps.edn && echo '{}' > deps.edn && mkdir src test The project can now be run with a REPL via a terminal UI or Clojure aware Editor . Migrate project to Clojure CLI Guide to Migrating a project to Clojure CLI General form of a Clojure project \u03bb\ufe0e The essence of most Clojure CLI projects contains the following files and directories. path purpose deps.edn core project configuration, paths, dependencies and aliases build.clj build specific configuration, create jars and uberjars src root directory of Clojure source files test root directory for Clojure test source files README.md Description of the project and how to develop / maintain it CHANGELOG.md Meaningful history of changes to the project organised by release .git Local git repository and configuration .gitignore Git ignore patterns for the project Practicalli clojure-app-template example project practicalli/clojure-app-template provides a production grade example of a project starting point, with additional configuration files for building and deploying the project.","title":"Clojure projects"},{"location":"clojure-cli/projects/#clojure-projects","text":"A Clojure CLI project is defined by a deps.edn file that specifies source and library paths to use for the project. The deps.edn file can also define aliases which can optionally be included when running the REPL to support development related tasks. Generate a project from a template Create a project from a template to save time creating a common project structure. Practicalli clojure-app-template example project practicalli/clojure-app-template provides a production grade example of a project starting point, with additional configuration files for building and deploying the project.","title":"Clojure projects"},{"location":"clojure-cli/projects/#create-a-minimal-project","text":"Create a deps.edn file containing {} in the root of a directory for a minimal configuration. Create a src directory as the root of the source code, and test directory to contain unit test code. Linux command to create a minimal clojure project Run these Linux commands in the root of a directory to create a minimal Clojure project structure. touch deps.edn && echo '{}' > deps.edn && mkdir src test The project can now be run with a REPL via a terminal UI or Clojure aware Editor . Migrate project to Clojure CLI Guide to Migrating a project to Clojure CLI","title":"Create a minimal project"},{"location":"clojure-cli/projects/#general-form-of-a-clojure-project","text":"The essence of most Clojure CLI projects contains the following files and directories. path purpose deps.edn core project configuration, paths, dependencies and aliases build.clj build specific configuration, create jars and uberjars src root directory of Clojure source files test root directory for Clojure test source files README.md Description of the project and how to develop / maintain it CHANGELOG.md Meaningful history of changes to the project organised by release .git Local git repository and configuration .gitignore Git ignore patterns for the project Practicalli clojure-app-template example project practicalli/clojure-app-template provides a production grade example of a project starting point, with additional configuration files for building and deploying the project.","title":"General form of a Clojure project"},{"location":"clojure-cli/projects/add-libraries/","text":"Add libraries to a project \u03bb\ufe0e Add dependencies to the project deps.edn file to make use of software libraries developed by the Clojure community or organisations engineering teams. There are thousands of community Clojure and ClojureScript libraries available via clojars.org . :deps top level key contains a hash-map of dependencies, each dependency of the form domain/name {:mvn/version \"version-number\"} Project deps.edn { :deps { org.clojure/clojure { :mvn/version \"1.11.1\" } hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}} Use Clojure CLI to search for libraries by name clojure -M:search/libraries pattern where pattern is the name of the library to search for. Copy the relevant results into the project deps.edn file. clojure -M:search/libraries --format:merge pattern will automatically add the library into the deps.edn file. Hotload libraries \u03bb\ufe0e Use a rich comment block or a dev/user.clj file to require the clojure.tools.deps.alpha.repl namespace and write add-libs expressions to hot-load libraries. A rich comment block ensures add-libs code is only evaluated manually by a developer. ( comment ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ( add-libs ' { http-kit/http-kit { :mvn/version \"2.5.1\" }}) ) Clojure LSP snippets Snippets provided by Clojure LSP include rich-comment-hotload , to add a rich comment block with a require for clojure.tools.deps.alpha and an add-libs expression, making it very quick to add this code. deps-maven and deps-git snippets help ensure the correct syntax is used for the add-libs expression for each library dependency to be added. Hotload Example \u03bb\ufe0e Create a web server from scratch, serving pages generated from hiccup, with all libraries hot-loaded as the code is being written. Demonstrates that it is possible to write an application when only starting the REPL once. ( comment ;; run REPL with :lib/hotload alias ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ;; hotload the libraries required for the server ## Excluding dependencies Adding several libraries as dependencies to a project may cause conflicts. The ` :exclusions ` key will prevent libraries within a library dependency from being included in the project For example , library-a and library-b both have a dependency on library-c , as defined in the project configuration for library-a and library-b. When including library-a and library-b in the project as dependencies , there could be a conflict if the both libraries use a different version of library-c. Adding an exclude to library-a or library-b will stop library-c being included twice. A Library that is self-contained and does not itself include any dependencies on any other libraries is unlikely to cause conflicts. Using these self-contained libraries simplifies the overall application design. ``` clojure { :deps { :org.clojure/clojure { :mvn/version \"1.10.2\" } :cheshire/cheshire { :mvn/version \"5.10.0\" :exclusions \"com.fasterxml.jackson.core/jackson-core\" }}}","title":"Add Libraries"},{"location":"clojure-cli/projects/add-libraries/#add-libraries-to-a-project","text":"Add dependencies to the project deps.edn file to make use of software libraries developed by the Clojure community or organisations engineering teams. There are thousands of community Clojure and ClojureScript libraries available via clojars.org . :deps top level key contains a hash-map of dependencies, each dependency of the form domain/name {:mvn/version \"version-number\"} Project deps.edn { :deps { org.clojure/clojure { :mvn/version \"1.11.1\" } hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}} Use Clojure CLI to search for libraries by name clojure -M:search/libraries pattern where pattern is the name of the library to search for. Copy the relevant results into the project deps.edn file. clojure -M:search/libraries --format:merge pattern will automatically add the library into the deps.edn file.","title":"Add libraries to a project"},{"location":"clojure-cli/projects/add-libraries/#hotload-libraries","text":"Use a rich comment block or a dev/user.clj file to require the clojure.tools.deps.alpha.repl namespace and write add-libs expressions to hot-load libraries. A rich comment block ensures add-libs code is only evaluated manually by a developer. ( comment ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ( add-libs ' { http-kit/http-kit { :mvn/version \"2.5.1\" }}) ) Clojure LSP snippets Snippets provided by Clojure LSP include rich-comment-hotload , to add a rich comment block with a require for clojure.tools.deps.alpha and an add-libs expression, making it very quick to add this code. deps-maven and deps-git snippets help ensure the correct syntax is used for the add-libs expression for each library dependency to be added.","title":"Hotload libraries"},{"location":"clojure-cli/projects/add-libraries/#hotload-example","text":"Create a web server from scratch, serving pages generated from hiccup, with all libraries hot-loaded as the code is being written. Demonstrates that it is possible to write an application when only starting the REPL once. ( comment ;; run REPL with :lib/hotload alias ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ;; hotload the libraries required for the server ## Excluding dependencies Adding several libraries as dependencies to a project may cause conflicts. The ` :exclusions ` key will prevent libraries within a library dependency from being included in the project For example , library-a and library-b both have a dependency on library-c , as defined in the project configuration for library-a and library-b. When including library-a and library-b in the project as dependencies , there could be a conflict if the both libraries use a different version of library-c. Adding an exclude to library-a or library-b will stop library-c being included twice. A Library that is self-contained and does not itself include any dependencies on any other libraries is unlikely to cause conflicts. Using these self-contained libraries simplifies the overall application design. ``` clojure { :deps { :org.clojure/clojure { :mvn/version \"1.10.2\" } :cheshire/cheshire { :mvn/version \"5.10.0\" :exclusions \"com.fasterxml.jackson.core/jackson-core\" }}}","title":"Hotload Example"},{"location":"clojure-cli/projects/create-from-template/","text":"Creating Clojure projects \u03bb\ufe0e Creating Clojure projects save code as you are learning or developing applications. Using a project is the quickest way to test development tools are configured correctly. Creating projects using a template is the quickest way to get started, as the template will create the project structure and add libraries the project. Practicalli recommends the Clojure CLI tools and clj-new to create projects. Clojure Aliases for creating projects from templates Practicalli Clojure CLI Config to provide aliases :project/create for seancorfield/deps-new project and :project/new for seancorfield/clj-new deps.edn :project/create { :replace-deps { io.github.seancorfield/deps-new { :git/tag \"v0.4.13\" :git/sha \"879c4eb\" }} :exec-fn org.corfield.new/create :exec-args { :template app :name practicalli/playground }} :project/new { :replace-deps { com.github.seancorfield/clj-new { :mvn/version \"1.2.399\" }} :exec-fn clj-new/create :exec-args { :template app :name practicalli/playground } :main-opts [ \"-m\" \"clj-new.create\" ]} deps-new clj-new Open a terminal window and change to a suitable folder and create a project. Use the app template to create a runnable application or lib template if writing a library to be used by other applications. Both can run code in the REPL during development. The name of the project is of the form domain/app-lib-name . Use a company name or Git Service account name as the domain . clojure -T:project/create :template app :name practicalli/playground The -T execution option runs the tool with Clojure.exec which uses keywords to specify the options for creating the project. Open a terminal window and change to a suitable folder and create a project. Use the app template to create a runnable application or lib template if writing a library to be used by other applications. Both can run code in the REPL during development. The name of the project is of the form domain/app-lib-name . Use a company name or Git Service account name as the domain . Clojure.exec Clojure.main The -X flag runs the tool with Clojure.exec which uses keywords to specify the options for creating the project. clojure -X:project/new :template app :name practicalli/playground The -M execution option calls Clojure.main which takes string options of the form: clojure -M:project/new template-name domain/app-lib-name clojure -M:project/new app practicalli/playground Run Project in a REPL \u03bb\ufe0e Change into the directory and test the project runs by starting a REPL with rebel readline cd playground && clojure -M:repl/rebel A repl prompt should appear. Type code expressions at the repl prompt and press RETURN to evaluate them. ( + 1 2 3 4 5 ) Try the project with your preferred editor Using a Clojure aware editor , open the playground project and run the REPL. Then write code expressions in the editor and evaluate them to see the result instantly. Running the project \u03bb\ufe0e Run project with or without an alias: clojure -M:alias -m domain.app-name clojure -M -m domain.app-name In the project deps.edn file it can be useful to define an alias to run the project, specifying the main namespace, the function to run and optionally any default arguments that are passed to that function. :project/run { :ns-default domain.main-namespace :exec-fn -main :exec-args { :port 8888 }} Then the project can be run using clojure -X:project/run and arguments can optionally be included in this command line, to complement or replace any default arguments in exec-args . Other templates \u03bb\ufe0e deps-new and clj-new have 3 templates that create deps.edn based projects app - a project that will run on the command line lib - a project that will be used as a library (added to other projects as a dependency) template - a project for creating your own custom templates. clj-new can create projects from deps.edn , Leiningen and Boot templates. A wide range of templates have been created by the Clojure community which can be found by searching on Clojars.org: clj-templates website - leiningen and boot templates deps.edn projects Leiningen projects Boot projects . clj-deps does not change Leiningen or Boot templates into deps.edn projects. Migrate to a Clojure CLI project if the template does not include a deps.edn file","title":"From Template"},{"location":"clojure-cli/projects/create-from-template/#creating-clojure-projects","text":"Creating Clojure projects save code as you are learning or developing applications. Using a project is the quickest way to test development tools are configured correctly. Creating projects using a template is the quickest way to get started, as the template will create the project structure and add libraries the project. Practicalli recommends the Clojure CLI tools and clj-new to create projects. Clojure Aliases for creating projects from templates Practicalli Clojure CLI Config to provide aliases :project/create for seancorfield/deps-new project and :project/new for seancorfield/clj-new deps.edn :project/create { :replace-deps { io.github.seancorfield/deps-new { :git/tag \"v0.4.13\" :git/sha \"879c4eb\" }} :exec-fn org.corfield.new/create :exec-args { :template app :name practicalli/playground }} :project/new { :replace-deps { com.github.seancorfield/clj-new { :mvn/version \"1.2.399\" }} :exec-fn clj-new/create :exec-args { :template app :name practicalli/playground } :main-opts [ \"-m\" \"clj-new.create\" ]} deps-new clj-new Open a terminal window and change to a suitable folder and create a project. Use the app template to create a runnable application or lib template if writing a library to be used by other applications. Both can run code in the REPL during development. The name of the project is of the form domain/app-lib-name . Use a company name or Git Service account name as the domain . clojure -T:project/create :template app :name practicalli/playground The -T execution option runs the tool with Clojure.exec which uses keywords to specify the options for creating the project. Open a terminal window and change to a suitable folder and create a project. Use the app template to create a runnable application or lib template if writing a library to be used by other applications. Both can run code in the REPL during development. The name of the project is of the form domain/app-lib-name . Use a company name or Git Service account name as the domain . Clojure.exec Clojure.main The -X flag runs the tool with Clojure.exec which uses keywords to specify the options for creating the project. clojure -X:project/new :template app :name practicalli/playground The -M execution option calls Clojure.main which takes string options of the form: clojure -M:project/new template-name domain/app-lib-name clojure -M:project/new app practicalli/playground","title":"Creating Clojure projects"},{"location":"clojure-cli/projects/create-from-template/#run-project-in-a-repl","text":"Change into the directory and test the project runs by starting a REPL with rebel readline cd playground && clojure -M:repl/rebel A repl prompt should appear. Type code expressions at the repl prompt and press RETURN to evaluate them. ( + 1 2 3 4 5 ) Try the project with your preferred editor Using a Clojure aware editor , open the playground project and run the REPL. Then write code expressions in the editor and evaluate them to see the result instantly.","title":"Run Project in a REPL"},{"location":"clojure-cli/projects/create-from-template/#running-the-project","text":"Run project with or without an alias: clojure -M:alias -m domain.app-name clojure -M -m domain.app-name In the project deps.edn file it can be useful to define an alias to run the project, specifying the main namespace, the function to run and optionally any default arguments that are passed to that function. :project/run { :ns-default domain.main-namespace :exec-fn -main :exec-args { :port 8888 }} Then the project can be run using clojure -X:project/run and arguments can optionally be included in this command line, to complement or replace any default arguments in exec-args .","title":"Running the project"},{"location":"clojure-cli/projects/create-from-template/#other-templates","text":"deps-new and clj-new have 3 templates that create deps.edn based projects app - a project that will run on the command line lib - a project that will be used as a library (added to other projects as a dependency) template - a project for creating your own custom templates. clj-new can create projects from deps.edn , Leiningen and Boot templates. A wide range of templates have been created by the Clojure community which can be found by searching on Clojars.org: clj-templates website - leiningen and boot templates deps.edn projects Leiningen projects Boot projects . clj-deps does not change Leiningen or Boot templates into deps.edn projects. Migrate to a Clojure CLI project if the template does not include a deps.edn file","title":"Other templates"},{"location":"clojure-cli/projects/hotload-in-project/","text":"Hotload libraries in Clojure Projects \u03bb\ufe0e Run a Clojure REPL configured with the :lib/hotload alias to include the library dependencies . Use a rich comment block or a dev/user.clj file to require the clojure.tools.deps.alpha.repl namespace and write add-libs expressions to hot-load libraries. Hotload Alias \u03bb\ufe0e Practicalli Clojure CLI Config Manual :lib/hotload alias defined in practicalli/clojure-deps-edn adds the latest SHA commit from the add-libs3 branch of clojure.tools.deps.alpha library as an extra dependency. Include the :lib/hotload alias when starting the REPL, using any of the available Clojure CLI execution options ( -A , -M , -X , -T ). See Terminal REPL and Clojure Editor pages for examples. Edit the project deps.edn configuration and add an :lib/hotload alias for the clojure.tools.deps.alpha.repl library. Or add an alias to the user level configuration for use with any Clojure CLI project. The add-libs code is on a separate add-libs3 branch , so requires the SHA from the head of add-libs3 branch :lib/hotload { :extra-deps { org.clojure/tools.deps.alpha { :git/url \"https://github.com/clojure/tools.deps.alpha\" :git/sha \"e4fb92eef724fa39e29b39cc2b1a850567d490dd\" }}} Alias example from practicalli/clojure-deps-edn Rich Comment Block \u03bb\ufe0e A rich comment block ensures add-libs code is only evaluated manually by a developer. ( comment ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ( add-libs ' { http-kit/http-kit { :mvn/version \"2.5.1\" }}) ) Clojure LSP snippets \u03bb\ufe0e Snippets provided by Clojure LSP include rich-comment-hotload , to add a rich comment block with a require for clojure.tools.deps.alpha and an add-libs expression, making it very quick to add this code. deps-maven and deps-git snippets help ensure the correct syntax is used for the add-libs expression for each library dependency to be added. Hotload Example \u03bb\ufe0e Create a web server from scratch, serving pages generated from hiccup, with all libraries hot-loaded as the code is being written. Demonstrates that it is possible to write an application when only starting the REPL once. ( comment ;; run REPL with :lib/hotload alias ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ;; hotload the libraries required for the server ( add-libs ' { http-kit/http-kit { :mvn/version \"2.5.1\" }}) ;; => (http-kit/http-kit) ;; Require the namespace from the http-kit library ( require ' [ org.httpkit.server :as app-server ]) ;; Define a handler for http requests ( defn welcome-page [ request ] { :status 200 :body \"Welcome to the world of Clojure CLI hotloading\" :headers {}}) ;; Start the application server with the handler ( app-server/run-server # 'welcome-page { :port ( or ( System/getenv \"PORT\" ) 8888 )}) ;; Visit http://localhost:8888/ to see the welcome-page ;; Hotload Hiccup to generate html for the welcome page ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) ( require ' [ hiccup.core :as hiccup ]) ( require ' [ hiccup.page :as hiccup-page ]) ;; Create a page template ( defn page-template [ content ] ( hiccup-page/html5 { :lang \"en\" } [ :head ( hiccup-page/include-css \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\" )] [ :body [ :section { :class \"hero is-info\" } [ :div { :class \"hero-body\" } [ :div { :class \"container\" } [ :h1 { :class \"title\" } ( :title content ) ] [ :p { :class \"subtitle\" } ( :sub-title content )]]]]])) ;; Check the page template returns HTML ( page-template { :title \"Hotload Libraries in the REPL\" :sub-title \"REPL driven development enables experimentation with designs\" }) ;; redefine the welcome page to call the page template ( defn welcome-page [ request ] { :status 200 :body ( page-template { :title \"Hotload Libraries in the REPL\" :sub-title \"REPL driven development enables experimentation with designs\" }) :headers {}}) ;; Visit http://localhost:8888/ and refresh the page to see the new welcome-page ) Using add-libs with project deps.edn \u03bb\ufe0e A project deps.edn file can also be used to hotload libraries with add-lib . This has the advantage that newly added libraries become part of the normal project dependency configuration. Add a namespace definition to the deps.edn file to help editors understand the deps.edn file is being used for code. Use the #_ comment reader macro with the namespace definition to only evaluate this code manually as a developer. Add the add-libs expression after the :deps key so that it is easy to slurp in the existing and new dependencies as a single hash-map. Use the comment reader macro #_ to only evaluate this code manually. To hotload, remove the #_ temporarily and slurp in the hash-map of dependencies, placing a ' at the start of the hash-map. Add the name and version of libraries to hotload in the hash-map. Evaluate the add-libs expression which should return a list of new namespaces added. Once hotload has finished, barf the hash-maps of dependencies from the add-libs expression, removing the ' . Add the #_ to the add-libs expression and save the file. The hotloaded libraries are now available by requiring their namespaces. If the REPL is restarted, the new dependencies will be included in the Classpath as they are now part of the project configuration. ;; --------------------------------------- ;; Project Configuration with Hotload ;; --------------------------------------- ;; Hotload requires # _ ( ns deps.edn ( :require [ clojure.tools.deps.alpha.repl :refer [ add-libs ]])) ;; Project configuration { :paths [ \"src\" \"resources\" ] :deps # _ ( add-libs ) { org.clojure/clojure { :mvn/version \"1.10.1\" } http-kit/http-kit { :mvn/version \"2.5.1\" } hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }} :aliases {} Example video \u03bb\ufe0e See the REPL driven development video by Sean Corfield for this technique. Jump to 23 minutes into the video to see this form of hotload in action.","title":"Hotload in Project"},{"location":"clojure-cli/projects/hotload-in-project/#hotload-libraries-in-clojure-projects","text":"Run a Clojure REPL configured with the :lib/hotload alias to include the library dependencies . Use a rich comment block or a dev/user.clj file to require the clojure.tools.deps.alpha.repl namespace and write add-libs expressions to hot-load libraries.","title":"Hotload libraries in Clojure Projects"},{"location":"clojure-cli/projects/hotload-in-project/#hotload-alias","text":"Practicalli Clojure CLI Config Manual :lib/hotload alias defined in practicalli/clojure-deps-edn adds the latest SHA commit from the add-libs3 branch of clojure.tools.deps.alpha library as an extra dependency. Include the :lib/hotload alias when starting the REPL, using any of the available Clojure CLI execution options ( -A , -M , -X , -T ). See Terminal REPL and Clojure Editor pages for examples. Edit the project deps.edn configuration and add an :lib/hotload alias for the clojure.tools.deps.alpha.repl library. Or add an alias to the user level configuration for use with any Clojure CLI project. The add-libs code is on a separate add-libs3 branch , so requires the SHA from the head of add-libs3 branch :lib/hotload { :extra-deps { org.clojure/tools.deps.alpha { :git/url \"https://github.com/clojure/tools.deps.alpha\" :git/sha \"e4fb92eef724fa39e29b39cc2b1a850567d490dd\" }}} Alias example from practicalli/clojure-deps-edn","title":"Hotload Alias"},{"location":"clojure-cli/projects/hotload-in-project/#rich-comment-block","text":"A rich comment block ensures add-libs code is only evaluated manually by a developer. ( comment ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ( add-libs ' { http-kit/http-kit { :mvn/version \"2.5.1\" }}) )","title":"Rich Comment Block"},{"location":"clojure-cli/projects/hotload-in-project/#clojure-lsp-snippets","text":"Snippets provided by Clojure LSP include rich-comment-hotload , to add a rich comment block with a require for clojure.tools.deps.alpha and an add-libs expression, making it very quick to add this code. deps-maven and deps-git snippets help ensure the correct syntax is used for the add-libs expression for each library dependency to be added.","title":"Clojure LSP snippets"},{"location":"clojure-cli/projects/hotload-in-project/#hotload-example","text":"Create a web server from scratch, serving pages generated from hiccup, with all libraries hot-loaded as the code is being written. Demonstrates that it is possible to write an application when only starting the REPL once. ( comment ;; run REPL with :lib/hotload alias ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) ;; hotload the libraries required for the server ( add-libs ' { http-kit/http-kit { :mvn/version \"2.5.1\" }}) ;; => (http-kit/http-kit) ;; Require the namespace from the http-kit library ( require ' [ org.httpkit.server :as app-server ]) ;; Define a handler for http requests ( defn welcome-page [ request ] { :status 200 :body \"Welcome to the world of Clojure CLI hotloading\" :headers {}}) ;; Start the application server with the handler ( app-server/run-server # 'welcome-page { :port ( or ( System/getenv \"PORT\" ) 8888 )}) ;; Visit http://localhost:8888/ to see the welcome-page ;; Hotload Hiccup to generate html for the welcome page ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) ( require ' [ hiccup.core :as hiccup ]) ( require ' [ hiccup.page :as hiccup-page ]) ;; Create a page template ( defn page-template [ content ] ( hiccup-page/html5 { :lang \"en\" } [ :head ( hiccup-page/include-css \"https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css\" )] [ :body [ :section { :class \"hero is-info\" } [ :div { :class \"hero-body\" } [ :div { :class \"container\" } [ :h1 { :class \"title\" } ( :title content ) ] [ :p { :class \"subtitle\" } ( :sub-title content )]]]]])) ;; Check the page template returns HTML ( page-template { :title \"Hotload Libraries in the REPL\" :sub-title \"REPL driven development enables experimentation with designs\" }) ;; redefine the welcome page to call the page template ( defn welcome-page [ request ] { :status 200 :body ( page-template { :title \"Hotload Libraries in the REPL\" :sub-title \"REPL driven development enables experimentation with designs\" }) :headers {}}) ;; Visit http://localhost:8888/ and refresh the page to see the new welcome-page )","title":"Hotload Example"},{"location":"clojure-cli/projects/hotload-in-project/#using-add-libs-with-project-depsedn","text":"A project deps.edn file can also be used to hotload libraries with add-lib . This has the advantage that newly added libraries become part of the normal project dependency configuration. Add a namespace definition to the deps.edn file to help editors understand the deps.edn file is being used for code. Use the #_ comment reader macro with the namespace definition to only evaluate this code manually as a developer. Add the add-libs expression after the :deps key so that it is easy to slurp in the existing and new dependencies as a single hash-map. Use the comment reader macro #_ to only evaluate this code manually. To hotload, remove the #_ temporarily and slurp in the hash-map of dependencies, placing a ' at the start of the hash-map. Add the name and version of libraries to hotload in the hash-map. Evaluate the add-libs expression which should return a list of new namespaces added. Once hotload has finished, barf the hash-maps of dependencies from the add-libs expression, removing the ' . Add the #_ to the add-libs expression and save the file. The hotloaded libraries are now available by requiring their namespaces. If the REPL is restarted, the new dependencies will be included in the Classpath as they are now part of the project configuration. ;; --------------------------------------- ;; Project Configuration with Hotload ;; --------------------------------------- ;; Hotload requires # _ ( ns deps.edn ( :require [ clojure.tools.deps.alpha.repl :refer [ add-libs ]])) ;; Project configuration { :paths [ \"src\" \"resources\" ] :deps # _ ( add-libs ) { org.clojure/clojure { :mvn/version \"1.10.1\" } http-kit/http-kit { :mvn/version \"2.5.1\" } hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }} :aliases {}","title":"Using add-libs with project deps.edn"},{"location":"clojure-cli/projects/hotload-in-project/#example-video","text":"See the REPL driven development video by Sean Corfield for this technique. Jump to 23 minutes into the video to see this form of hotload in action.","title":"Example video"},{"location":"clojure-cli/projects/migrate-project/","text":"Migrating Project To Clojure CLI \u03bb\ufe0e Migrating an existing project to Clojure CLI can be as simple as the addition of a deps.edn configuration file. A user configuration containing a collection of community tools minimizes the project configuration required. Leiningen plugins that change code Some Leiningen plugins inject code into a project to make it work. For example, lein-ring injects clojure code into the project to run an application server. These type of plugins may require updates to the Clojure code in the project. Minimal approach \u03bb\ufe0e Create a deps.edn file in the root of the project directory, containing an empty hash-map, {} The Clojure version will be taken from the Clojure CLI tools install configuration. This configuration is enough to run a terminal REPL UI for the project, although requiring namespaces from the project may require libraries to be added as dependencies first. Use addlibs to hotload dependencies addlibs will hotload libraries into the running REPL so can be used to determine which libraries are reqiured to make the project work. This approach can be useful for diagnosing conflicts in dependencies by loading them in stages and narrowing down the conflict. Adding dependencies \u03bb\ufe0e All Clojure projects require the org.clojure/clojure library and a specific version is defined in the configuration that comes with the Clojure CLI install. Use the :deps key in deps.edn to specify a version of the org.clojure/clojure library, along with any dependencies required for the Clojure code to run. { :deps { org.clojure/clojure { :mvn/version \"1.10.2\" } integrant/integrant { :mvn/version \"0.8.0\" }}} Hot loading dependencies add-lib can hot-load a Clojure dependency into a running REPL process, avoiding the need to restart. Adding paths \u03bb\ufe0e It is advisable to specify the directory paths to define the location of the source code in the project, especially when running the project in other environments such as a continuous integration server. Edit the deps.edn file in the root of the project directory and add source directory and if relevant the resources directory. { :paths [ \"src\" ` resource ` ]} Adding a test runner \u03bb\ufe0e Tests can be run locally using a test runner alias from the user wide configuration . A Continuous Integration server requires an alias in the project deps.edn file to define a test runner. A selection of test runners are provided by practicalli/clojure-deps-edn . Copy a test runner alias to the project deps.edn file. Building a jar or uberjar from the project \u03bb\ufe0e The depstar project is provided in practicalli/clojure-deps-edn for building jars for libraries and uberjars for applications. When pushing a project to a Continuous Server, the relevant alias should be included in the Clojure projects deps.edn file so the project can be built Deployment \u03bb\ufe0e A Continuous Delivery pipeline will require an alias in the project deps.edn file to define how to build a jar or uberjar to package the Clojure project. Tools for migration \u03bb\ufe0e Several tools exist to support migration lein-to-deps - create a deps.edn configuration from a project.clj configuration lein-tools-deps - share Clojure CLI dependencies with Leiningen project configuration.","title":"Migrate projects"},{"location":"clojure-cli/projects/migrate-project/#migrating-project-to-clojure-cli","text":"Migrating an existing project to Clojure CLI can be as simple as the addition of a deps.edn configuration file. A user configuration containing a collection of community tools minimizes the project configuration required. Leiningen plugins that change code Some Leiningen plugins inject code into a project to make it work. For example, lein-ring injects clojure code into the project to run an application server. These type of plugins may require updates to the Clojure code in the project.","title":"Migrating Project To Clojure CLI"},{"location":"clojure-cli/projects/migrate-project/#minimal-approach","text":"Create a deps.edn file in the root of the project directory, containing an empty hash-map, {} The Clojure version will be taken from the Clojure CLI tools install configuration. This configuration is enough to run a terminal REPL UI for the project, although requiring namespaces from the project may require libraries to be added as dependencies first. Use addlibs to hotload dependencies addlibs will hotload libraries into the running REPL so can be used to determine which libraries are reqiured to make the project work. This approach can be useful for diagnosing conflicts in dependencies by loading them in stages and narrowing down the conflict.","title":"Minimal approach"},{"location":"clojure-cli/projects/migrate-project/#adding-dependencies","text":"All Clojure projects require the org.clojure/clojure library and a specific version is defined in the configuration that comes with the Clojure CLI install. Use the :deps key in deps.edn to specify a version of the org.clojure/clojure library, along with any dependencies required for the Clojure code to run. { :deps { org.clojure/clojure { :mvn/version \"1.10.2\" } integrant/integrant { :mvn/version \"0.8.0\" }}} Hot loading dependencies add-lib can hot-load a Clojure dependency into a running REPL process, avoiding the need to restart.","title":"Adding dependencies"},{"location":"clojure-cli/projects/migrate-project/#adding-paths","text":"It is advisable to specify the directory paths to define the location of the source code in the project, especially when running the project in other environments such as a continuous integration server. Edit the deps.edn file in the root of the project directory and add source directory and if relevant the resources directory. { :paths [ \"src\" ` resource ` ]}","title":"Adding paths"},{"location":"clojure-cli/projects/migrate-project/#adding-a-test-runner","text":"Tests can be run locally using a test runner alias from the user wide configuration . A Continuous Integration server requires an alias in the project deps.edn file to define a test runner. A selection of test runners are provided by practicalli/clojure-deps-edn . Copy a test runner alias to the project deps.edn file.","title":"Adding a test runner"},{"location":"clojure-cli/projects/migrate-project/#building-a-jar-or-uberjar-from-the-project","text":"The depstar project is provided in practicalli/clojure-deps-edn for building jars for libraries and uberjars for applications. When pushing a project to a Continuous Server, the relevant alias should be included in the Clojure projects deps.edn file so the project can be built","title":"Building a jar or uberjar from the project"},{"location":"clojure-cli/projects/migrate-project/#deployment","text":"A Continuous Delivery pipeline will require an alias in the project deps.edn file to define how to build a jar or uberjar to package the Clojure project.","title":"Deployment"},{"location":"clojure-cli/projects/migrate-project/#tools-for-migration","text":"Several tools exist to support migration lein-to-deps - create a deps.edn configuration from a project.clj configuration lein-tools-deps - share Clojure CLI dependencies with Leiningen project configuration.","title":"Tools for migration"},{"location":"clojure-cli/projects/namespace-refactoring/","text":"Namespace refactor \u03bb\ufe0e When starting a new project all the code is typically in one namespace, unless you are using a template that creates multiple namespaces. Practicalli recommends adding comment sections as the code is developed, grouping code by its purpose. A few common sections include: ;; State ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Data Generators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Helper functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Feature / logic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; System / Lifecycle ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Hint::One pass evaluation \u03bb\ufe0e Clojure is evaluated from top to bottom, so var ( def , defn ) definitions should come before that var is used in the code.","title":"Namespace refactor"},{"location":"clojure-cli/projects/namespace-refactoring/#namespace-refactor","text":"When starting a new project all the code is typically in one namespace, unless you are using a template that creates multiple namespaces. Practicalli recommends adding comment sections as the code is developed, grouping code by its purpose. A few common sections include: ;; State ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Data Generators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Helper functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Feature / logic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; System / Lifecycle ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","title":"Namespace refactor"},{"location":"clojure-cli/projects/namespace-refactoring/#hintone-pass-evaluation","text":"Clojure is evaluated from top to bottom, so var ( def , defn ) definitions should come before that var is used in the code.","title":"Hint::One pass evaluation"},{"location":"clojure-cli/projects/namespace/","text":"Namespaces \u03bb\ufe0e Using namespaces makes code easier to work with by provide levels of abstraction that convey the overall design of the project. Clearly organized namespaces support a simple design approach for a project and make it easier to maintain. A namespace is a logical separation of code, usually along features of the projects. Think of all namespaces as creating an API's within the project that communicate the architecture of the system. Controlling scope \u03bb\ufe0e A namespace contains related data structures and functions, limiting their scope to that function. Namespaces should limit their interdependence on each other (limited number of required namespaces) to avoid a highly coupled design. Within a namespace a var ( def , defn ) can be called by its name. Outside of the namespace, a fully qualified name must be used. Vars can be marked as private ( defn- name , def ^private name ), so they can be accessed only by functions in their own namespace. Including another namespace \u03bb\ufe0e (ns namespace.name (:require [domain/filename :as purpose])) is used to enable access to the functions & named data structures in another namespace than the current one. The included namespace is given an alias so its clear which code comes from that namespace. Practicalli recommends using a meaningful alias that defines the purpose of the library you are including. This helps with the understanding and maintainability of the code, especially if you wish to refactor and replace the included library with an alternative. An alias name should be meaningful and you should avoid single character and cryptic aliases. ( ns my-namespace.core :require [ clojure.java.io :as java-io ]) ( defn read-the-file [ filename ] ( line-seq ( java-io/reader filename ))) ( read-the-file \"project.clj\" ) Hint::Trying out a namespace \u03bb\ufe0e (require '[domain/filename]) can be used within you code if testing that namespace functions to see if they are useful to the project. Using a live linter such as clj-kondo will also advise you when to refer namespaces. Including specific parts of a namespace \u03bb\ufe0e If the library you are including is the predominant purpose of that namespace, a good example is clojure.test, then you can include specific functions from that namespace. Using :refer in the require expression provides a way to include specific vars directly in the current namespace, as if it had been defined there. Referring a var means it no longer requires a namespace qualifier. ( ns my-namespace.core :require [ clojure.java.io :refer [ reader ]]) ( defn read-the-file [ filename ] ( line-seq ( reader filename ))) ( read-the-file \"project.clj\" ) Info::Including / Excluding / renaming vars \u03bb\ufe0e These other options on required functions are rarely used in practice. They tend to cause more issues than they solve, so use with care. :exclude will prevent a var from being used from a required namespace. :only will include only that var from the required namespace. :rename changes the name of the original function, if there conflicts Adding multiple namespaces \u03bb\ufe0e The idiom in Clojure is to include multiple namespaces with just one :require statement Here is an example namespace expression with multiple require statements from the duct web framework template ( ns duct-test.main ( :require [ clojure.java.io :as io ] [ com.stuartsierra.component :as component ] [ duct.middleware.errors :refer [ wrap-hide-errors ]] [ meta-merge.core :refer [ meta-merge ]] [ duct-test.config :as config ] [ duct-test.system :refer [ new-system ]])) Info::Avoid use in Clojure code \u03bb\ufe0e The use or :use expression should not be used in Clojure code as it pulls in everything the namespace and everything that the included namespace also included. This can lead to conflicts, especially in larger projects. This is seen as a bad practice especially when writing libraries, as you can end up including a great many unused functions into the namespace. As Clojure is typically composed of many libraries, its prudent to only include the specific things you need from another namespace. This also helps reduce conflicts when including multiple libraries in your project.","title":"Namespaces"},{"location":"clojure-cli/projects/namespace/#namespaces","text":"Using namespaces makes code easier to work with by provide levels of abstraction that convey the overall design of the project. Clearly organized namespaces support a simple design approach for a project and make it easier to maintain. A namespace is a logical separation of code, usually along features of the projects. Think of all namespaces as creating an API's within the project that communicate the architecture of the system.","title":"Namespaces"},{"location":"clojure-cli/projects/namespace/#controlling-scope","text":"A namespace contains related data structures and functions, limiting their scope to that function. Namespaces should limit their interdependence on each other (limited number of required namespaces) to avoid a highly coupled design. Within a namespace a var ( def , defn ) can be called by its name. Outside of the namespace, a fully qualified name must be used. Vars can be marked as private ( defn- name , def ^private name ), so they can be accessed only by functions in their own namespace.","title":"Controlling scope"},{"location":"clojure-cli/projects/namespace/#including-another-namespace","text":"(ns namespace.name (:require [domain/filename :as purpose])) is used to enable access to the functions & named data structures in another namespace than the current one. The included namespace is given an alias so its clear which code comes from that namespace. Practicalli recommends using a meaningful alias that defines the purpose of the library you are including. This helps with the understanding and maintainability of the code, especially if you wish to refactor and replace the included library with an alternative. An alias name should be meaningful and you should avoid single character and cryptic aliases. ( ns my-namespace.core :require [ clojure.java.io :as java-io ]) ( defn read-the-file [ filename ] ( line-seq ( java-io/reader filename ))) ( read-the-file \"project.clj\" )","title":"Including another namespace"},{"location":"clojure-cli/projects/namespace/#hinttrying-out-a-namespace","text":"(require '[domain/filename]) can be used within you code if testing that namespace functions to see if they are useful to the project. Using a live linter such as clj-kondo will also advise you when to refer namespaces.","title":"Hint::Trying out a namespace"},{"location":"clojure-cli/projects/namespace/#including-specific-parts-of-a-namespace","text":"If the library you are including is the predominant purpose of that namespace, a good example is clojure.test, then you can include specific functions from that namespace. Using :refer in the require expression provides a way to include specific vars directly in the current namespace, as if it had been defined there. Referring a var means it no longer requires a namespace qualifier. ( ns my-namespace.core :require [ clojure.java.io :refer [ reader ]]) ( defn read-the-file [ filename ] ( line-seq ( reader filename ))) ( read-the-file \"project.clj\" )","title":"Including specific parts of a namespace"},{"location":"clojure-cli/projects/namespace/#infoincluding-excluding-renaming-vars","text":"These other options on required functions are rarely used in practice. They tend to cause more issues than they solve, so use with care. :exclude will prevent a var from being used from a required namespace. :only will include only that var from the required namespace. :rename changes the name of the original function, if there conflicts","title":"Info::Including / Excluding / renaming vars"},{"location":"clojure-cli/projects/namespace/#adding-multiple-namespaces","text":"The idiom in Clojure is to include multiple namespaces with just one :require statement Here is an example namespace expression with multiple require statements from the duct web framework template ( ns duct-test.main ( :require [ clojure.java.io :as io ] [ com.stuartsierra.component :as component ] [ duct.middleware.errors :refer [ wrap-hide-errors ]] [ meta-merge.core :refer [ meta-merge ]] [ duct-test.config :as config ] [ duct-test.system :refer [ new-system ]]))","title":"Adding multiple namespaces"},{"location":"clojure-cli/projects/namespace/#infoavoid-use-in-clojure-code","text":"The use or :use expression should not be used in Clojure code as it pulls in everything the namespace and everything that the included namespace also included. This can lead to conflicts, especially in larger projects. This is seen as a bad practice especially when writing libraries, as you can end up including a great many unused functions into the namespace. As Clojure is typically composed of many libraries, its prudent to only include the specific things you need from another namespace. This also helps reduce conflicts when including multiple libraries in your project.","title":"Info::Avoid use in Clojure code"},{"location":"clojure-cli/projects/rich-comments/","text":"Rich Comments for REPL Driven Development \u03bb\ufe0e The (comment ,,,) form is commonly used to contain living experimental code, so it is often referred to as a rich comment as its purpose is more than just commenting out code. Experimental design \u03bb\ufe0e Whilst iterating through designs, much experimental code can be created which is not (yet) ready to be part of the main namespace. Experimental code can be written in a (comment ,,,) form to keep it separate from more finalised implementations. When a namespace is evaluted, code within the (comment ,,,) form is not automatically loaded. Most editors support evaluation of Clojure code within the (comment ,,,) form, allowing a range of design implementations to be evaluated against each other. Rich comment blocks are very useful for rapidly iterating over different design decisions by including the same function but with different implementations. Hide clj-kondo linter warnings for redefined vars ( def , defn ) when using this approach. ;; Rich comment block with redefined vars ignored # _ { :clj-kondo/ignore [ :redefined-var ]} ( comment ( def data-model { :nested { :hash \"map\" :design \"choice\" }}) ( def data-model [{ :collection \"of\" :hash \"maps\" :design \"choice\" } { :collection \"of\" :hash \"maps\" :design \"choice\" }]) ( defn value-added-tax [] ;; algorithm - initial design) ( defn value-added-tax [] ;; algorithm - alternate design) ) ;; End of rich comment block Design Journal \u03bb\ufe0e When the problem domain or libraries selected are relatively unknown, a significant amount of learning and experimentation may be required. This learning can be captured in a separate namespace, often referred to as a design journal. Creating a journal of the decisions made as code is designed makes the project easier to understand and maintain. Journals avoid the need for long hand-over or painful developer on-boarding processes as the journey through design decisions are already documented. A design journal can be added as a (comment ,,,) section at the bottom of each namespace, or more typically in its own namespace. A journal should cover the following aspects Relevant expressions use to test assumptions about design options. Examples of design choices not taken and discussions why (saves repeating the same design discussions) Expressions that can be evaluated to explain how a function or parts of a function work The design journal can be used to create meaningful documentation for the project very easily and should prevent time spent on repeating the same conversations. HINT::Practicalli example journal \u03bb\ufe0e Design journal for TicTacToe game using Reagent, ClojureScript and Scalable Vector Graphics Snippets \u03bb\ufe0e clojure-lsp contains a number of snippets to create variations of a comment form. rich-comment a basic comment form rich-comment-rdd comment form that informs clj-kondo to ignore duplicate function definitions, avoids warnings when testing multiple implementations of the same function rich-comment-hotload - comment form with Clojure CLI library dependency hotloading via add-libs Migrating design to tests \u03bb\ufe0e Code within rich comment blocks is often a good source of code that can be put into formal unit tests, using clojure.test Live examples \u03bb\ufe0e A rich comment at the end of a namespace can include code that demonstrates how to use the key aspects of the namespace API.","title":"Rich Comment"},{"location":"clojure-cli/projects/rich-comments/#rich-comments-for-repl-driven-development","text":"The (comment ,,,) form is commonly used to contain living experimental code, so it is often referred to as a rich comment as its purpose is more than just commenting out code.","title":"Rich Comments for REPL Driven Development"},{"location":"clojure-cli/projects/rich-comments/#experimental-design","text":"Whilst iterating through designs, much experimental code can be created which is not (yet) ready to be part of the main namespace. Experimental code can be written in a (comment ,,,) form to keep it separate from more finalised implementations. When a namespace is evaluted, code within the (comment ,,,) form is not automatically loaded. Most editors support evaluation of Clojure code within the (comment ,,,) form, allowing a range of design implementations to be evaluated against each other. Rich comment blocks are very useful for rapidly iterating over different design decisions by including the same function but with different implementations. Hide clj-kondo linter warnings for redefined vars ( def , defn ) when using this approach. ;; Rich comment block with redefined vars ignored # _ { :clj-kondo/ignore [ :redefined-var ]} ( comment ( def data-model { :nested { :hash \"map\" :design \"choice\" }}) ( def data-model [{ :collection \"of\" :hash \"maps\" :design \"choice\" } { :collection \"of\" :hash \"maps\" :design \"choice\" }]) ( defn value-added-tax [] ;; algorithm - initial design) ( defn value-added-tax [] ;; algorithm - alternate design) ) ;; End of rich comment block","title":"Experimental design"},{"location":"clojure-cli/projects/rich-comments/#design-journal","text":"When the problem domain or libraries selected are relatively unknown, a significant amount of learning and experimentation may be required. This learning can be captured in a separate namespace, often referred to as a design journal. Creating a journal of the decisions made as code is designed makes the project easier to understand and maintain. Journals avoid the need for long hand-over or painful developer on-boarding processes as the journey through design decisions are already documented. A design journal can be added as a (comment ,,,) section at the bottom of each namespace, or more typically in its own namespace. A journal should cover the following aspects Relevant expressions use to test assumptions about design options. Examples of design choices not taken and discussions why (saves repeating the same design discussions) Expressions that can be evaluated to explain how a function or parts of a function work The design journal can be used to create meaningful documentation for the project very easily and should prevent time spent on repeating the same conversations.","title":"Design Journal"},{"location":"clojure-cli/projects/rich-comments/#hintpracticalli-example-journal","text":"Design journal for TicTacToe game using Reagent, ClojureScript and Scalable Vector Graphics","title":"HINT::Practicalli example journal"},{"location":"clojure-cli/projects/rich-comments/#snippets","text":"clojure-lsp contains a number of snippets to create variations of a comment form. rich-comment a basic comment form rich-comment-rdd comment form that informs clj-kondo to ignore duplicate function definitions, avoids warnings when testing multiple implementations of the same function rich-comment-hotload - comment form with Clojure CLI library dependency hotloading via add-libs","title":"Snippets"},{"location":"clojure-cli/projects/rich-comments/#migrating-design-to-tests","text":"Code within rich comment blocks is often a good source of code that can be put into formal unit tests, using clojure.test","title":"Migrating design to tests"},{"location":"clojure-cli/projects/rich-comments/#live-examples","text":"A rich comment at the end of a namespace can include code that demonstrates how to use the key aspects of the namespace API.","title":"Live examples"},{"location":"clojure-cli/projects/tools-build/","text":"tools.build \u03bb\ufe0e Build jar files to deploy and run Clojure projects, defining custom tasks with Clojure code. build.clj contains a namespace with tasks :project/build alias containing tools.build library and sets the default namespace clojure -T:build task-name to run any of the tasks defined in the default build namespaces. Java ARchive - jar file A .jar file is a zip archive of the project containing all the files for running a Clojure project. The archive should contain metatdata files such as Manifest and pom.xml and can contain Clojure sources or compiled class files from the project (or both). An ubjerjar is .jar file that also contains all the project dependencies (including Clojure). The uberjar is a self-contained file that can be easily deployed and requiring only a Java run-time (Java Virtual Machine). Define a build alias \u03bb\ufe0e Add an alias to the project deps.edn file that includes the org.clojure/tools.build project. :project/build { :replace-deps { io.github.clojure/tools.build { :git/tag \"v0.9.2\" :git/sha \"fe6b140\" }} :ns-default build } Release information shows the current values for git/tag and :git/sha Build tasks \u03bb\ufe0e Create a build.clj file to contain the build configuration and tasks. Define the namespace and require the clojure.tools.build.api library ( ns build ( :require [ clojure.tools.build.api :as build-api ])) Define a configuration for the build with values used in the build tasks. build.clj ;; --------------------------------------------------------- ;; Build configuration ( def config ( let [ library-name 'practicalli/build-me version ( format \"1.0.%s\" ( build-api/git-count-revs nil ))] { :library-name library-name :main-ns library-name :version version :class-directory \"target/classes\" :project-basis ( build-api/create-basis ) :jar-file ( format \"target/%s-%s.jar\" ( name library-name ) version ) :uberjar-file ( format \"target/%s-%s-standalone.jar\" ( name library-name ) version )})) ;; End of Build configuration ;; --------------------------------------------------------- Write functions to support common tasks clean , jar , uberjar ;; --------------------------------------------------------- ;; Build tasks ( defn clean \"Remove the given directory. If directory path nil, delect `target` directory used to compile build artefacts\" [ directory ] ( build-api/delete { :path ( or ( :path directory ) \"target\" )})) ( defn jar [ _ ] ( let [{ :keys [ class-directory jar-file library-name project-basis version ]} config ] ( build-api/write-pom { :class-dir class-directory :lib library-name :version version :basis project-basis :src-dirs [ \"src\" ]}) ( build-api/copy-dir { :src-dirs [ \"src\" \"resources\" ] :target-dir class-directory }) ( build-api/jar { :class-dir class-directory :jar-file jar-file }))) ( defn uber [ _ ] ( let [{ :keys [ class-directory main-ns project-basis uberjar-file ]} config ] ( clean nil ) ( build-api/copy-dir { :src-dirs [ \"src\" \"resources\" ] :target-dir class-directory }) ( build-api/compile-clj { :basis project-basis :src-dirs [ \"src\" ] :class-dir class-directory }) ( build-api/uber { :class-dir class-directory :uber-file uberjar-file :basis project-basis :main main-ns }))) ;; End of Build tasks ;; --------------------------------------------------------- Resources \u03bb\ufe0e tools.build - Clojure.org","title":"Package"},{"location":"clojure-cli/projects/tools-build/#toolsbuild","text":"Build jar files to deploy and run Clojure projects, defining custom tasks with Clojure code. build.clj contains a namespace with tasks :project/build alias containing tools.build library and sets the default namespace clojure -T:build task-name to run any of the tasks defined in the default build namespaces. Java ARchive - jar file A .jar file is a zip archive of the project containing all the files for running a Clojure project. The archive should contain metatdata files such as Manifest and pom.xml and can contain Clojure sources or compiled class files from the project (or both). An ubjerjar is .jar file that also contains all the project dependencies (including Clojure). The uberjar is a self-contained file that can be easily deployed and requiring only a Java run-time (Java Virtual Machine).","title":"tools.build"},{"location":"clojure-cli/projects/tools-build/#define-a-build-alias","text":"Add an alias to the project deps.edn file that includes the org.clojure/tools.build project. :project/build { :replace-deps { io.github.clojure/tools.build { :git/tag \"v0.9.2\" :git/sha \"fe6b140\" }} :ns-default build } Release information shows the current values for git/tag and :git/sha","title":"Define a build alias"},{"location":"clojure-cli/projects/tools-build/#build-tasks","text":"Create a build.clj file to contain the build configuration and tasks. Define the namespace and require the clojure.tools.build.api library ( ns build ( :require [ clojure.tools.build.api :as build-api ])) Define a configuration for the build with values used in the build tasks. build.clj ;; --------------------------------------------------------- ;; Build configuration ( def config ( let [ library-name 'practicalli/build-me version ( format \"1.0.%s\" ( build-api/git-count-revs nil ))] { :library-name library-name :main-ns library-name :version version :class-directory \"target/classes\" :project-basis ( build-api/create-basis ) :jar-file ( format \"target/%s-%s.jar\" ( name library-name ) version ) :uberjar-file ( format \"target/%s-%s-standalone.jar\" ( name library-name ) version )})) ;; End of Build configuration ;; --------------------------------------------------------- Write functions to support common tasks clean , jar , uberjar ;; --------------------------------------------------------- ;; Build tasks ( defn clean \"Remove the given directory. If directory path nil, delect `target` directory used to compile build artefacts\" [ directory ] ( build-api/delete { :path ( or ( :path directory ) \"target\" )})) ( defn jar [ _ ] ( let [{ :keys [ class-directory jar-file library-name project-basis version ]} config ] ( build-api/write-pom { :class-dir class-directory :lib library-name :version version :basis project-basis :src-dirs [ \"src\" ]}) ( build-api/copy-dir { :src-dirs [ \"src\" \"resources\" ] :target-dir class-directory }) ( build-api/jar { :class-dir class-directory :jar-file jar-file }))) ( defn uber [ _ ] ( let [{ :keys [ class-directory main-ns project-basis uberjar-file ]} config ] ( clean nil ) ( build-api/copy-dir { :src-dirs [ \"src\" \"resources\" ] :target-dir class-directory }) ( build-api/compile-clj { :basis project-basis :src-dirs [ \"src\" ] :class-dir class-directory }) ( build-api/uber { :class-dir class-directory :uber-file uberjar-file :basis project-basis :main main-ns }))) ;; End of Build tasks ;; ---------------------------------------------------------","title":"Build tasks"},{"location":"clojure-cli/projects/tools-build/#resources","text":"tools.build - Clojure.org","title":"Resources"},{"location":"clojure-cli/repl/","text":"Rebel REPL Terminal UI \u03bb\ufe0e The REPL is the environment in which all Clojure code runs, whether that be during development, testing or in production systems. Rebel is a REPL terminal UI that provides auto-completion, function call syntax help, themes and key binding styles to enhance the development experience. Clojure tools also include a REPL with a minimal interface by default. Install rebel readline \u03bb\ufe0e Practicalli Clojure CLI Config contains an alias to run rebel readline. Add a Rebel terminal UI alias If not using Practicalli Clojure CLI Config then add an alias called :repl/rebel to your own user deps.edn configuration :repl/rebel { :extra-deps { com.bhauman/rebel-readline { :mvn/version \"0.1.4\" }} :main-opts [ \"-m\" \"rebel-readline.main\" ]} Running the rebel REPL \u03bb\ufe0e Start a Clojure REPL with Rebel terminal UI, optionally in the root of a Clojure project. clojure -M:repl/rebel A REPL prompt displays and will evaluate code entered. Evaluate Clojure code by typing at the => user prompt pressing Return , the results of evaluating the code are printed on the next line. :repl/quit as the prompt will end the REPL session and all changes not saved to a file will be lost. Ctrl + c if the repl process does not return to the shell prompt. Customize Rebel Readline \u03bb\ufe0e :repl/help in the repl prompt shows the Rebel configuration options Set configuration options in a rebel_readline.edn file, in $XDG_CONFIG_HOME/clojure/ or $HOME/.clojure :key-map - either :viins or :emacs. Defaults to :emacs :color-theme - either :light-screen-theme or :dark-screen-theme :highlight - boolean, whether to syntax highlight or not. Defaults to true :completion - boolean, whether to complete on tab. Defaults to true :eldoc - boolean, whether to display function docs as you type. Defaults to true :indent - boolean, whether to auto indent code on newline. Defaults to true :redirect-output - boolean, rebinds root *out* during read to protect linereader Defaults to true :key-bindings - map of key-bindings that get applied after all other key bindings have been applied For example, to change the default keybindings to vi: {:key-map :viins}","title":"Rebel REPL Terminal UI"},{"location":"clojure-cli/repl/#rebel-repl-terminal-ui","text":"The REPL is the environment in which all Clojure code runs, whether that be during development, testing or in production systems. Rebel is a REPL terminal UI that provides auto-completion, function call syntax help, themes and key binding styles to enhance the development experience. Clojure tools also include a REPL with a minimal interface by default.","title":"Rebel REPL Terminal UI"},{"location":"clojure-cli/repl/#install-rebel-readline","text":"Practicalli Clojure CLI Config contains an alias to run rebel readline. Add a Rebel terminal UI alias If not using Practicalli Clojure CLI Config then add an alias called :repl/rebel to your own user deps.edn configuration :repl/rebel { :extra-deps { com.bhauman/rebel-readline { :mvn/version \"0.1.4\" }} :main-opts [ \"-m\" \"rebel-readline.main\" ]}","title":"Install rebel readline"},{"location":"clojure-cli/repl/#running-the-rebel-repl","text":"Start a Clojure REPL with Rebel terminal UI, optionally in the root of a Clojure project. clojure -M:repl/rebel A REPL prompt displays and will evaluate code entered. Evaluate Clojure code by typing at the => user prompt pressing Return , the results of evaluating the code are printed on the next line. :repl/quit as the prompt will end the REPL session and all changes not saved to a file will be lost. Ctrl + c if the repl process does not return to the shell prompt.","title":"Running the rebel REPL"},{"location":"clojure-cli/repl/#customize-rebel-readline","text":":repl/help in the repl prompt shows the Rebel configuration options Set configuration options in a rebel_readline.edn file, in $XDG_CONFIG_HOME/clojure/ or $HOME/.clojure :key-map - either :viins or :emacs. Defaults to :emacs :color-theme - either :light-screen-theme or :dark-screen-theme :highlight - boolean, whether to syntax highlight or not. Defaults to true :completion - boolean, whether to complete on tab. Defaults to true :eldoc - boolean, whether to display function docs as you type. Defaults to true :indent - boolean, whether to auto indent code on newline. Defaults to true :redirect-output - boolean, rebinds root *out* during read to protect linereader Defaults to true :key-bindings - map of key-bindings that get applied after all other key bindings have been applied For example, to change the default keybindings to vi: {:key-map :viins}","title":"Customize Rebel Readline"},{"location":"clojure-cli/repl/coding/","text":"Coding in the REPL \u03bb\ufe0e Starting a REPL is a fast way to start experimenting with Clojure. Clojure code can be typed into the REPL directly and the result instantly returned. Code can also be evaluated from a project allowing pre-written code to be run. Clojure Editors are the main tool for writing code An editor connected a a Clojure REPL is far more effective for writing code than typing into the command line REPL directly. Evaluating code in an editor will automatically use the correct namespace. Evaluating code \u03bb\ufe0e Type Clojure code at the REPL prompt, e.g (map inc [1 2 3 4 5]) . Press Enter to evaluate the code and see the result. Up and Down navigate the REPL history, providing an efficient way to evaluate the same code many times. Typing part of function name shows matches available, Tab to cycle through the choices, Enter to select. Including code from a file \u03bb\ufe0e Clojure code is usually saved in files and each file has a namespace definition that matches the file path, using the ns function. The file src/practicalli/playground.clj has the namespace practicalli.playground ( ns practicalli.playground ) Requiring the namespace of a file will evaluate the code from that file in the REPL. ( require 'practicalli.playground ) Functions from the file can be called using their fully qualified names. Assuming the namespace contains a function called main , that function can be called using (practicalli.playground/main) . Changing namespaces \u03bb\ufe0e If the default user namespace is change to practicalli.playground then functions in that namespace can be called by just the function name, eg. (main) . in-ns will change change the current namespace to the one specified as an argument. ( in-ns 'practicalli.playground ) Now the (main) function can be called without having to include the full namespace name. Reloading code changes from a file \u03bb\ufe0e The :reload option to require will load in any changes to a namespace that happened outside of the REPL, eg. using an editor to change the source code in the file. ( require 'practicalli.playground :reload ) When using an editor that is not connected to the Clojure REPL, then reloading is an effective way of updating the code with all the changes saved in the file. Clojure projects \u03bb\ufe0e A REPL can run without a Clojure project, however, libraries and code are simpler to manage within project source and configuration files. Clojure projects guide Or jump to simple projects to start writing example applications.","title":"REPL Coding"},{"location":"clojure-cli/repl/coding/#coding-in-the-repl","text":"Starting a REPL is a fast way to start experimenting with Clojure. Clojure code can be typed into the REPL directly and the result instantly returned. Code can also be evaluated from a project allowing pre-written code to be run. Clojure Editors are the main tool for writing code An editor connected a a Clojure REPL is far more effective for writing code than typing into the command line REPL directly. Evaluating code in an editor will automatically use the correct namespace.","title":"Coding in the REPL"},{"location":"clojure-cli/repl/coding/#evaluating-code","text":"Type Clojure code at the REPL prompt, e.g (map inc [1 2 3 4 5]) . Press Enter to evaluate the code and see the result. Up and Down navigate the REPL history, providing an efficient way to evaluate the same code many times. Typing part of function name shows matches available, Tab to cycle through the choices, Enter to select.","title":"Evaluating code"},{"location":"clojure-cli/repl/coding/#including-code-from-a-file","text":"Clojure code is usually saved in files and each file has a namespace definition that matches the file path, using the ns function. The file src/practicalli/playground.clj has the namespace practicalli.playground ( ns practicalli.playground ) Requiring the namespace of a file will evaluate the code from that file in the REPL. ( require 'practicalli.playground ) Functions from the file can be called using their fully qualified names. Assuming the namespace contains a function called main , that function can be called using (practicalli.playground/main) .","title":"Including code from a file"},{"location":"clojure-cli/repl/coding/#changing-namespaces","text":"If the default user namespace is change to practicalli.playground then functions in that namespace can be called by just the function name, eg. (main) . in-ns will change change the current namespace to the one specified as an argument. ( in-ns 'practicalli.playground ) Now the (main) function can be called without having to include the full namespace name.","title":"Changing namespaces"},{"location":"clojure-cli/repl/coding/#reloading-code-changes-from-a-file","text":"The :reload option to require will load in any changes to a namespace that happened outside of the REPL, eg. using an editor to change the source code in the file. ( require 'practicalli.playground :reload ) When using an editor that is not connected to the Clojure REPL, then reloading is an effective way of updating the code with all the changes saved in the file.","title":"Reloading code changes from a file"},{"location":"clojure-cli/repl/coding/#clojure-projects","text":"A REPL can run without a Clojure project, however, libraries and code are simpler to manage within project source and configuration files. Clojure projects guide Or jump to simple projects to start writing example applications.","title":"Clojure projects"},{"location":"clojure-cli/repl/help/","text":"Help at the REPL \u03bb\ufe0e rebel readline provides tools to help you discover and use functions from clojure.core and any other libraries you add to the REPL. :repl/help will show all the commands available for rebel readline Tab to autocomplete the current characters into a function name. All functions that match the characters will be show, allowing quick discovery of functions available. Typing in the first few characters of a function and press Moving the cursor after the name of a function will show the signatures available, so a function can be called with the correct number and form of arguments. Ctrl + C + Ctrl + d on a function name shows the docstring to help understand the functions purpose. clojure.repl/doc function also shows the docstring of a function (clojure.repl/doc doc) Ctrl + C + Ctrl + a on a name shows all the possible matching functions to help you discover what is available. Tab through the list of matches, Enter to select a function Rebel Commands \u03bb\ufe0e Type :repl/help or :repl TAB to see a list of available commands. Keybinding Description :repl/help Prints the documentation for all available commands. :repl/key-bindings search or list current key bindings :repl/quit Quits the REPL :repl/set-color-theme Change the color theme :dark-screen-theme :light-screen-theme :repl/set-key-map Change key bindings to given key-map, :emacs :vicmd :viins :repl/toggle-color Toggle ANSI text coloration on and off :repl/toggle-completion Toggle the completion functionality on and off :repl/toggle-eldoc Toggle the auto display of function signatures on and off :repl/toggle-highlight Toggle readline syntax highlighting on and off :repl/toggle-indent Toggle the automatic indenting of Clojure code on and off Key-bindings \u03bb\ufe0e Keybinding Description Ctrl-C aborts editing the current line Ctrl-D at the start of a line => sends an end of stream message TAB word completion or code indent when cursor in whitespace at the start of line Ctrl-X_Ctrl-D Show documentation for word at point Ctrl-X_Ctrl-S Show source for word at point Ctrl-X_Ctrl-A Show apropos for word at point Ctrl-X_Ctrl-E Inline eval for SEXP before the point Examine key-bindings with the :repl/key-bindings command.","title":"REPL Help"},{"location":"clojure-cli/repl/help/#help-at-the-repl","text":"rebel readline provides tools to help you discover and use functions from clojure.core and any other libraries you add to the REPL. :repl/help will show all the commands available for rebel readline Tab to autocomplete the current characters into a function name. All functions that match the characters will be show, allowing quick discovery of functions available. Typing in the first few characters of a function and press Moving the cursor after the name of a function will show the signatures available, so a function can be called with the correct number and form of arguments. Ctrl + C + Ctrl + d on a function name shows the docstring to help understand the functions purpose. clojure.repl/doc function also shows the docstring of a function (clojure.repl/doc doc) Ctrl + C + Ctrl + a on a name shows all the possible matching functions to help you discover what is available. Tab through the list of matches, Enter to select a function","title":"Help at the REPL"},{"location":"clojure-cli/repl/help/#rebel-commands","text":"Type :repl/help or :repl TAB to see a list of available commands. Keybinding Description :repl/help Prints the documentation for all available commands. :repl/key-bindings search or list current key bindings :repl/quit Quits the REPL :repl/set-color-theme Change the color theme :dark-screen-theme :light-screen-theme :repl/set-key-map Change key bindings to given key-map, :emacs :vicmd :viins :repl/toggle-color Toggle ANSI text coloration on and off :repl/toggle-completion Toggle the completion functionality on and off :repl/toggle-eldoc Toggle the auto display of function signatures on and off :repl/toggle-highlight Toggle readline syntax highlighting on and off :repl/toggle-indent Toggle the automatic indenting of Clojure code on and off","title":"Rebel Commands"},{"location":"clojure-cli/repl/help/#key-bindings","text":"Keybinding Description Ctrl-C aborts editing the current line Ctrl-D at the start of a line => sends an end of stream message TAB word completion or code indent when cursor in whitespace at the start of line Ctrl-X_Ctrl-D Show documentation for word at point Ctrl-X_Ctrl-S Show source for word at point Ctrl-X_Ctrl-A Show apropos for word at point Ctrl-X_Ctrl-E Inline eval for SEXP before the point Examine key-bindings with the :repl/key-bindings command.","title":"Key-bindings"},{"location":"clojure-cli/repl/libraries/","text":"Using Clojure libraries in the REPL \u03bb\ufe0e A library should be included as a dependency in order to use it within the REPL. Add library dependencies to the top level :deps key in a project deps.edn configuration file, or add via an alias if the library is use at development time. Aliases from a user configuration can also add optional libraries when running a REPL, e.g. Practicalli Clojure CLI config { :paths [ \"src\" \"resources\" ] :deps { org.clojure/clojure { :mvn/version \"1.10.3\" }} :aliases { :database/h2 { :extra-deps { com.h2database/h2 { :mvn/version \"2.1.210\" } com.github.seancorfield/next.jdbc { :mvn/version \"1.2.772\" }}} # _ ()} Finding libraries Search for community libraries via the Clojars.org website clojure -M:search/libraries pattern where pattern is the name of the library to search for. Copy the relevant results into the project deps.edn file. clojure -M:search/libraries --format:merge pattern will automatically add the library into the deps.edn file. clojure -X:deps find-versions :lib fully.qualified/library-name :n 5 returns the last 5 versions of the given library. Include library \u03bb\ufe0e Open a terminal and change to the root of the Clojure project directory, where the deps.edn file can be found. Start the REPL including the :database/h2 alias to include every library defined in the :deps key and libraries in the :database/h2 alias. This example is using rebel readline rich terminal UI clojure -M:repl/rebel This command will include Add aliases to include optional libraries, such as those used for development. In this example, the H2 database and next.jdbc libraries are included along with those libraries in the :deps key of deps.edn clojure -M:database/h2:repl/rebel Load namespace \u03bb\ufe0e At the REPL prompt, require a namespace from the project to load all the code from that namespace and any namespaces required. If a project was created with the command clojure -T:project/new :template app :name practicalli/status-monitor then the main namespace will be practicalli.status-monitor ( require ' [ practicalli.status-monitor ]) The require function loads all the code from the main namespace. When an ns form is read, required namespaces in the ns form are also loaded. Reloading namespace \u03bb\ufe0e Clojure is a dynamic environment, so changes to function definitions ( defn ) and shared symbol names ( def ) can be updated without restarting the REPL. require loads the code from the specified namespace. Using the :reload option forces the namespace to be loaded again, even if it was already loaded. When changes are made to a namespace in the source code file, :reload ensures those changes become the code running in the REPL ( require ' [ practicalli.status-monitor ] :reload ) If errors occur when loading or reloading the namespace with require, the :verbose option will show all the namespaces that are loaded. This may show issues or help track down conflicting namespaces or functions. ( require ' [ practicalli.status-monitor ] :reload :verbose ) Hotload libraries \u03bb\ufe0e Hotload Libraries in the REPL add-libs function from the clojure.tools.deps.alpha library is an experimental approach to hot-loading library dependencies without having to restart the REPL or add those dependencies to the project deps.edn . This provides a simple way to try out libraries. hotload libraries secion for more details and how to use with Clojure editors. Start a REPL session using Clojure CLI with the :lib/hotload alias , including rebel readline for an enhance REPL terminal UI. clojure -M:lib/hotload:repl/rebel Require the clojure.tools.deps.alpha library and refer the add-libs function. The add-libs function can then be called without having to use an alias or the fully qualified name. ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) Hotload a library into the REPL using the add-lib function in the following form, where domain/library is the fully qualified name of the library and RELEASE is a string of the version number of that library to use. ( add-libs ' { domain/library { :mvn/version \"RELEASE\" }}) Multiple libraries can be hot-loaded in a single add-libs expression ( add-libs ' { hhgttg/meaning { :mvn/version \"4.2.0\" } eternity/room { :mvn/version \"1.0.1\" }}) Hotload hiccup in a terminal REPL \u03bb\ufe0e The hiccup library converts clojure structures into html, where vectors represent the scope of keywords that represent html tags. Load the hiccup library using add-libs ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) Require the hiccup library so its functions are accessible from the current namespace in the REPL. ( require ' [ hiccup.core :as hiccup ]) Enter an expression using the hiccup/html function to convert a clojure data structure to html. ( hiccup/html [ :div { :class \"right-aligned\" }]) The hiccup expression returns a string of the html code.","title":"REPL Libraries"},{"location":"clojure-cli/repl/libraries/#using-clojure-libraries-in-the-repl","text":"A library should be included as a dependency in order to use it within the REPL. Add library dependencies to the top level :deps key in a project deps.edn configuration file, or add via an alias if the library is use at development time. Aliases from a user configuration can also add optional libraries when running a REPL, e.g. Practicalli Clojure CLI config { :paths [ \"src\" \"resources\" ] :deps { org.clojure/clojure { :mvn/version \"1.10.3\" }} :aliases { :database/h2 { :extra-deps { com.h2database/h2 { :mvn/version \"2.1.210\" } com.github.seancorfield/next.jdbc { :mvn/version \"1.2.772\" }}} # _ ()} Finding libraries Search for community libraries via the Clojars.org website clojure -M:search/libraries pattern where pattern is the name of the library to search for. Copy the relevant results into the project deps.edn file. clojure -M:search/libraries --format:merge pattern will automatically add the library into the deps.edn file. clojure -X:deps find-versions :lib fully.qualified/library-name :n 5 returns the last 5 versions of the given library.","title":"Using Clojure libraries in the REPL"},{"location":"clojure-cli/repl/libraries/#include-library","text":"Open a terminal and change to the root of the Clojure project directory, where the deps.edn file can be found. Start the REPL including the :database/h2 alias to include every library defined in the :deps key and libraries in the :database/h2 alias. This example is using rebel readline rich terminal UI clojure -M:repl/rebel This command will include Add aliases to include optional libraries, such as those used for development. In this example, the H2 database and next.jdbc libraries are included along with those libraries in the :deps key of deps.edn clojure -M:database/h2:repl/rebel","title":"Include library"},{"location":"clojure-cli/repl/libraries/#load-namespace","text":"At the REPL prompt, require a namespace from the project to load all the code from that namespace and any namespaces required. If a project was created with the command clojure -T:project/new :template app :name practicalli/status-monitor then the main namespace will be practicalli.status-monitor ( require ' [ practicalli.status-monitor ]) The require function loads all the code from the main namespace. When an ns form is read, required namespaces in the ns form are also loaded.","title":"Load namespace"},{"location":"clojure-cli/repl/libraries/#reloading-namespace","text":"Clojure is a dynamic environment, so changes to function definitions ( defn ) and shared symbol names ( def ) can be updated without restarting the REPL. require loads the code from the specified namespace. Using the :reload option forces the namespace to be loaded again, even if it was already loaded. When changes are made to a namespace in the source code file, :reload ensures those changes become the code running in the REPL ( require ' [ practicalli.status-monitor ] :reload ) If errors occur when loading or reloading the namespace with require, the :verbose option will show all the namespaces that are loaded. This may show issues or help track down conflicting namespaces or functions. ( require ' [ practicalli.status-monitor ] :reload :verbose )","title":"Reloading namespace"},{"location":"clojure-cli/repl/libraries/#hotload-libraries","text":"Hotload Libraries in the REPL add-libs function from the clojure.tools.deps.alpha library is an experimental approach to hot-loading library dependencies without having to restart the REPL or add those dependencies to the project deps.edn . This provides a simple way to try out libraries. hotload libraries secion for more details and how to use with Clojure editors. Start a REPL session using Clojure CLI with the :lib/hotload alias , including rebel readline for an enhance REPL terminal UI. clojure -M:lib/hotload:repl/rebel Require the clojure.tools.deps.alpha library and refer the add-libs function. The add-libs function can then be called without having to use an alias or the fully qualified name. ( require ' [ clojure.tools.deps.alpha.repl :refer [ add-libs ]]) Hotload a library into the REPL using the add-lib function in the following form, where domain/library is the fully qualified name of the library and RELEASE is a string of the version number of that library to use. ( add-libs ' { domain/library { :mvn/version \"RELEASE\" }}) Multiple libraries can be hot-loaded in a single add-libs expression ( add-libs ' { hhgttg/meaning { :mvn/version \"4.2.0\" } eternity/room { :mvn/version \"1.0.1\" }})","title":"Hotload libraries"},{"location":"clojure-cli/repl/libraries/#hotload-hiccup-in-a-terminal-repl","text":"The hiccup library converts clojure structures into html, where vectors represent the scope of keywords that represent html tags. Load the hiccup library using add-libs ( add-libs ' { hiccup/hiccup { :mvn/version \"2.0.0-alpha2\" }}) Require the hiccup library so its functions are accessible from the current namespace in the REPL. ( require ' [ hiccup.core :as hiccup ]) Enter an expression using the hiccup/html function to convert a clojure data structure to html. ( hiccup/html [ :div { :class \"right-aligned\" }]) The hiccup expression returns a string of the html code.","title":"Hotload hiccup in a terminal REPL"},{"location":"clojure-cli/repl/repl-uncovered/","text":"Read, Evaluate Print Loop (REPL) \u03bb\ufe0e The REPL provides a fast, powerful and fun way to develop code and is the hard of the Clojure developers workflow. The REPL allows you to quickly test out designs and your domain knowledge of the system you are building, easily accommodating multiple designs to help you evaluate the best approach. Starting a REPL is the first thing you do after creating or downloading a project. The REPL allows you to run any existing code, write new code and change code. Each time you can see the results of your code instantly. The REPL can run all of your code or simply get the result of an individual expression. You can inspect run-time values and continually develop your code without having to restart each time. Hint If you are not using the REPL for your Clojure development you are missing out on a highly productive workflow. Once you start using a REPL as part of you development cycle you will feel lost without one. How the REPL works (simple version) \u03bb\ufe0e A Clojure REPL has 4 stages: Read - read in the code Evaluate - evaluate the code Print - show the results Loop - on to the next expression Its useful to understand the difference between Read and Evaluate, especially when you get as far as writing macro's for Clojure. The Reader \u03bb\ufe0e The Reader parses the Clojure source code, form by form, producing the Clojure data structures an [Abstract Syntax Tree] (AST). Due to the syntax of Clojure, much of the source code is already in the right structure. Any macros will be expanded into its Clojure structure. These data structures are then evaluated: Clojure traverses the data structures and performs actions like function application or var lookup based on the type of the data structure. For example, when Clojure reads the text (+ 1 2), the result is a list data structure whose first element is a + symbol, followed by the numbers 1 and 2. This data structure is passed to Clojure\u2019s evaluator, which looks up the function corresponding to + and applies that function to 1 and 2. The Reader \u03bb\ufe0e Hint Clojure is a homoiconic language, which is a fancy term describing the fact that Clojure programs are represented by Clojure data structures. This is a very important difference between Clojure and most other programming languages. It means that Clojure is defined in terms of the evaluation of data structures and not in terms of the syntax of character streams/files. It is quite common, and easy, for Clojure programs to manipulate, transform and produce other Clojure programs. The reader has syntax defined in terms of characters, and the Clojure language has syntax defined in terms of symbols, lists, vectors, maps etc. The reader is represented by the function read , which reads the next form (not character) from a stream, and returns the object represented by that form. There are also Reader Macros that define special rules on top of the Clojure syntax. They give the language some additional syntax sugar, making your Clojure code compact. See the reference section on reader macros for more information Evaluator \u03bb\ufe0e The Evaluator takes the data structure as an argument (from the Reader) and processes it using rules corresponding to the data structure\u2019s type, returning the result. To evaluate a symbol, Clojure looks up what the symbol refers to. To evaluate a list, Clojure looks at the first element of the list and calls a function, macro, or special form. Any other values including strings, numbers and keywords simply evaluate to themselves. Hint Read the section on Reading, Evaluation and Macros from BraveClojure to see examples of the REPL process.","title":"Read, Evaluate Print Loop (REPL)"},{"location":"clojure-cli/repl/repl-uncovered/#read-evaluate-print-loop-repl","text":"The REPL provides a fast, powerful and fun way to develop code and is the hard of the Clojure developers workflow. The REPL allows you to quickly test out designs and your domain knowledge of the system you are building, easily accommodating multiple designs to help you evaluate the best approach. Starting a REPL is the first thing you do after creating or downloading a project. The REPL allows you to run any existing code, write new code and change code. Each time you can see the results of your code instantly. The REPL can run all of your code or simply get the result of an individual expression. You can inspect run-time values and continually develop your code without having to restart each time. Hint If you are not using the REPL for your Clojure development you are missing out on a highly productive workflow. Once you start using a REPL as part of you development cycle you will feel lost without one.","title":"Read, Evaluate Print Loop (REPL)"},{"location":"clojure-cli/repl/repl-uncovered/#how-the-repl-works-simple-version","text":"A Clojure REPL has 4 stages: Read - read in the code Evaluate - evaluate the code Print - show the results Loop - on to the next expression Its useful to understand the difference between Read and Evaluate, especially when you get as far as writing macro's for Clojure.","title":"How the REPL works (simple version)"},{"location":"clojure-cli/repl/repl-uncovered/#the-reader","text":"The Reader parses the Clojure source code, form by form, producing the Clojure data structures an [Abstract Syntax Tree] (AST). Due to the syntax of Clojure, much of the source code is already in the right structure. Any macros will be expanded into its Clojure structure. These data structures are then evaluated: Clojure traverses the data structures and performs actions like function application or var lookup based on the type of the data structure. For example, when Clojure reads the text (+ 1 2), the result is a list data structure whose first element is a + symbol, followed by the numbers 1 and 2. This data structure is passed to Clojure\u2019s evaluator, which looks up the function corresponding to + and applies that function to 1 and 2.","title":"The Reader"},{"location":"clojure-cli/repl/repl-uncovered/#the-reader_1","text":"Hint Clojure is a homoiconic language, which is a fancy term describing the fact that Clojure programs are represented by Clojure data structures. This is a very important difference between Clojure and most other programming languages. It means that Clojure is defined in terms of the evaluation of data structures and not in terms of the syntax of character streams/files. It is quite common, and easy, for Clojure programs to manipulate, transform and produce other Clojure programs. The reader has syntax defined in terms of characters, and the Clojure language has syntax defined in terms of symbols, lists, vectors, maps etc. The reader is represented by the function read , which reads the next form (not character) from a stream, and returns the object represented by that form. There are also Reader Macros that define special rules on top of the Clojure syntax. They give the language some additional syntax sugar, making your Clojure code compact. See the reference section on reader macros for more information","title":"The Reader"},{"location":"clojure-cli/repl/repl-uncovered/#evaluator","text":"The Evaluator takes the data structure as an argument (from the Reader) and processes it using rules corresponding to the data structure\u2019s type, returning the result. To evaluate a symbol, Clojure looks up what the symbol refers to. To evaluate a list, Clojure looks at the first element of the list and calls a function, macro, or special form. Any other values including strings, numbers and keywords simply evaluate to themselves. Hint Read the section on Reading, Evaluation and Macros from BraveClojure to see examples of the REPL process.","title":"Evaluator"},{"location":"clojure-cli/repl/troubleshooting/","text":"Troubleshooting the REPL \u03bb\ufe0e The aspects to consider when a REPL process fails to run are: Some code expressions are not correct Dependencies are not available Project (or editor) misconfigured Code expression failing \u03bb\ufe0e All code in the project must compile and be syntactically correct, even if that code is in a rich (comment ,,,) block. A Clojure expression following a Reader comment, #_ does not have to compile, however it must be syntactically correct, i.e. balanced parentheses. Add a line comment, ;; , to any code that is suspected of not compiling or being syntactically incorrect (or delete that code). Editor REPL fails to start \u03bb\ufe0e If using a jack-in approach with the editor to start the repl, run a terminal UI REPL with an nREPL server and try connecting to that REPL from the editor. Clojure CLI repl - rebel terminal UI clojure -M:repl/rebel Then require the main namespace and see if there are issues, optionally using :verbose to see which libraries are being loaded. ( require ' [ practicalli.service ] :verbose ) If the REPL runs correctly, it is likely the editor configuration is missing something or is incorrect. Check the configuration for running a Clojure project with the editor. Terminal UI REPL fails in project \u03bb\ufe0e If the REPL does not run correctly or the namespace fails to load, run a repl without any extra development dependencies (tooling, dev libraries, etc) and load the main namespace clj REPL doesnt start in any project \u03bb\ufe0e Run the clojure command in a directory that is not part of any existing Clojure project. This will run the REPL with only the org.clojure/clojure dependency Run clojure -Sdescribe to check that the Clojure CLI is using the correct configuration files and is the expected version. If a REPL prompt appears, then Clojure CLI is working. If a REPL prompt does not appear, then reinstall the Clojure CLI or upgrade to a newer version. Clojure CLI install - Practicalli Guide REPL starts but requiring code fails \u03bb\ufe0e Creating a new project is a fast way to check development tooling is working correctly. A project can be created with clojure -T:project/create (with Practicalli Clojure CLI Config installed) If a REPL process starts correctly for a new project but not the existing project, then its most likely one or more expressions in the existing project that are causing an error or the project deps.edn configuration. Copy the deps.edn configuration from the existing project to the root of the new project (or just the :deps section of the deps.edn configuration). Run the REPL again using the clojure command. If the REPL fails then it is likely an issue with the exiting projects deps.edn file or one of the dependencies Dependency issues \u03bb\ufe0e Projects typically depend on many other libraries and sometimes those libraries depend on other libraries too. When running the clojure command to run a terminal UI REPL, libraries are retrieved from remote repositories (Maven Central, Clojars.org) and stored in a local cache ~/.m2/repositories If a dependency is not available then a warning should state which library cannot be downloaded and from which repository Check the extent of the dependencies for the existing project: clojure -Stree Use the antq tool to check for a newer version of a dependency clojure -T:project/outdated If libraries are likely to become unavailable (i.e. old versions) then consider creating a local repository service with Artefactory or Nexus, which can share library depenencies between development teams of an organisation.","title":"REPL troubleshoot"},{"location":"clojure-cli/repl/troubleshooting/#troubleshooting-the-repl","text":"The aspects to consider when a REPL process fails to run are: Some code expressions are not correct Dependencies are not available Project (or editor) misconfigured","title":"Troubleshooting the REPL"},{"location":"clojure-cli/repl/troubleshooting/#code-expression-failing","text":"All code in the project must compile and be syntactically correct, even if that code is in a rich (comment ,,,) block. A Clojure expression following a Reader comment, #_ does not have to compile, however it must be syntactically correct, i.e. balanced parentheses. Add a line comment, ;; , to any code that is suspected of not compiling or being syntactically incorrect (or delete that code).","title":"Code expression failing"},{"location":"clojure-cli/repl/troubleshooting/#editor-repl-fails-to-start","text":"If using a jack-in approach with the editor to start the repl, run a terminal UI REPL with an nREPL server and try connecting to that REPL from the editor. Clojure CLI repl - rebel terminal UI clojure -M:repl/rebel Then require the main namespace and see if there are issues, optionally using :verbose to see which libraries are being loaded. ( require ' [ practicalli.service ] :verbose ) If the REPL runs correctly, it is likely the editor configuration is missing something or is incorrect. Check the configuration for running a Clojure project with the editor.","title":"Editor REPL fails to start"},{"location":"clojure-cli/repl/troubleshooting/#terminal-ui-repl-fails-in-project","text":"If the REPL does not run correctly or the namespace fails to load, run a repl without any extra development dependencies (tooling, dev libraries, etc) and load the main namespace clj","title":"Terminal UI REPL fails in project"},{"location":"clojure-cli/repl/troubleshooting/#repl-doesnt-start-in-any-project","text":"Run the clojure command in a directory that is not part of any existing Clojure project. This will run the REPL with only the org.clojure/clojure dependency Run clojure -Sdescribe to check that the Clojure CLI is using the correct configuration files and is the expected version. If a REPL prompt appears, then Clojure CLI is working. If a REPL prompt does not appear, then reinstall the Clojure CLI or upgrade to a newer version. Clojure CLI install - Practicalli Guide","title":"REPL doesnt start in any project"},{"location":"clojure-cli/repl/troubleshooting/#repl-starts-but-requiring-code-fails","text":"Creating a new project is a fast way to check development tooling is working correctly. A project can be created with clojure -T:project/create (with Practicalli Clojure CLI Config installed) If a REPL process starts correctly for a new project but not the existing project, then its most likely one or more expressions in the existing project that are causing an error or the project deps.edn configuration. Copy the deps.edn configuration from the existing project to the root of the new project (or just the :deps section of the deps.edn configuration). Run the REPL again using the clojure command. If the REPL fails then it is likely an issue with the exiting projects deps.edn file or one of the dependencies","title":"REPL starts but requiring code fails"},{"location":"clojure-cli/repl/troubleshooting/#dependency-issues","text":"Projects typically depend on many other libraries and sometimes those libraries depend on other libraries too. When running the clojure command to run a terminal UI REPL, libraries are retrieved from remote repositories (Maven Central, Clojars.org) and stored in a local cache ~/.m2/repositories If a dependency is not available then a warning should state which library cannot be downloaded and from which repository Check the extent of the dependencies for the existing project: clojure -Stree Use the antq tool to check for a newer version of a dependency clojure -T:project/outdated If libraries are likely to become unavailable (i.e. old versions) then consider creating a local repository service with Artefactory or Nexus, which can share library depenencies between development teams of an organisation.","title":"Dependency issues"},{"location":"clojure-editors/","text":"Editors for Clojure development \u03bb\ufe0e The best editor to use for learning Clojure is the editor already familiar with (or want to learn). An ideal Clojure editor includes the these core features running / connecting to a REPL process evaluation results inline or in a repl window (fast feedback on what the code does) syntax highlighting (including highlight of matching parens) structural editing to ensure parens are balanced when writing and refactor code data inspector to visualise large and nested data, or connection to ( external data inpector tools ) Clojure aware editors \u03bb\ufe0e Emacs (Spacemacs, Doom, Prelude), VSCode (Clover or Calva) and Neovim are the most common open source Editors for Clojure and ClojureScript development. SublimeText and IntelliJ are commercial editors (with free editions) that also provide Clojure support Install guides Emacs Neovim VSCode Atom SublineText Intellij Emacs is a very powerful editor with thousands of packages enabling a person to do almost any digital task concievable. Emacs is highly extensible via the ELisp programming language used to write configuration and the numerous Emacs packages. Use one of the popular community configurations for Emacs or visit the CIDER documentation to learn how to add Clojure support to Emacs. Emacs 28 onward uses Native Compilation of Emacs packages, dramatically speeding up many common tasks and keeping Emacs a valuable option for development (and everything else). Emacs uses CIDER and Clojure LSP for a feature rich clojure development experience. Emacs Spacemacs Doom Emacs Prelude Emacs Spacemacs is a community configuration bringing Emacs features and Vim sytle editing together. Spacemacs uses a mnemonic menu system that makes it easy to learn and provides detailed documentation for configuring and using Emacs. Spacemacs, Practicalli guides you through Clojure development, documenting with org-mode, Git version control with Magit, Vim editing modes and dozens of other features. Spacemacs install guide Doom Emacs is a community configuration for Emacs that provides a minimalistic configuration that is readily customisable. Doom Emacs is most suited to those comming from a Vim-style editing background or simply looking for a lightweight setup with options to extend the configuration. Doom Emacs practicalli/doom-emacs-config repository contains a customised configuration for Clojure development and supporting tools. Browse the repository online or fork / clone the repository Free Desktop XDG Config Classic Config git clone https://github.com/practicalli/doom-emacs-config.git $XDG_CONFIG_HOME /doom ` The Practicalli configuration should replace the ~/.config/doom/ directory created by the doom install command. git clone https://github.com/practicalli/doom-emacs-config.git $HOME /.doom.d ` The Practicalli configuration should replace the ~/.doom.d/ directory created by the doom install command. Emacs Prelude is an easy to use Emacs configuration for Emacs newcomers and lots of additional power for Emacs power users, from the author of CIDER - the definitive Clojure IDE for Emacs . Prelude uses the traditional chorded key bindings to drive Emacs, e.g. Ctrl + c Ctrl + c to evaluate the current top-level form. Neovim is a hyper-extensible text editor that evolved from Vim whist still fully compatible with Vim\"s editing model and Vimscript extension language. Neovim uses lua configuration and with the aniseed package configuration and Neovim packages can be written in Fennel (a lisp dialect). Neovim is based on multi-model editing (e.g. normal, insert, visual editing states) providing a highly effective tool for writing code, configuration and documentation. The Neovim community provides a large number of packages to add features. Conjure is predominantly used for Clojure development and supports Clojure CLI, Leiningen and Babashka projects (as well as several other Lisp dialects and interesting languages) Practicalli Neovim SpaceVim vimiced practicalli/neovim-config-redux is written in Fennel as it is very close to Clojure. A Which-key menu can be used to drive Neovim, with a mnemonic set of key bindings to make adoptiong Neovim easier. Conjure provides interactive environment for evaluating Clojure code and providing inline results (or see results in an Heads Up Display or Log buffer). Practicalli Neovim covers installation and basic use of Neovim for Clojure development. Practicalli Neovim Older Neovim guides include: Practicalli install guide for neovim and conjure Practicalli user guide for neovim and conjure Quick try tutorial \u03bb\ufe0e Try the Conjure interactive :ConjureSchool tutorial without the need to install, only a recent version of neovim curl -fL conjure.fun/school | sh :q to quit the tutorial. References \u03bb\ufe0e Getting started with Neovim and Conjure Neovim user guide Conjure install guide Conjuring Clojure in Vim - an introduction to using Conjure SpaceVim is a fully featured vim experience that includes a simple Clojure development environment based around vim-fireplace Practicalli install guide Practicalli user guide SpaceVim quickstart guide SpaceVim documentation Clojure Interactive Development Environment for Vim8/Neovim. vim-iced documentation Calva Clover The Calva extension adds Clojure support to Microsoft VS Code editor. Calva is an active project and the #calva channel on the Clojurians Slack community can be supportive. VSCode & Calva install guide VSCode & Calva user guide VSCode Calva extension Clover is a Socket REPL based development tool for Clojure. Clojure GitLab repository includes useage details. VSpaceCode \u03bb\ufe0e VSpaceCode is a Spacemacs-like community configuration for Microsoft VS Code. Drive VS Code and Calva entirely from the keyboard, using easy to remember mnemonic keys for all commands and full vim-stile editing tools. Also included edamagit, a sophisticated text based Git client (like magit for Emacs). Quick install guide Quick user guide Atom not actively developed Atom will be archived on December 15 2022 and no further updates from GitHub team, although it may continue in open source. Consider using VSCode with Clover or Calva plugins instead Atom.io is flexible and simple to use editor . Chlorine is the recommended plugin for Atom.io. ProtoREPL is not actively maintained at present. The Chlorine plugin for Atom is especially recommended for ClojureScript shadow-cljs projects. Chlorine install guide ProtoREPL \u03bb\ufe0e ProtoREPL Atom & ProtoREPL install guide Proton - alternative menu and configuration approach \u03bb\ufe0e Proton offers a simple mnemonic menu as an alternative to the multiple keys for shortcuts in Atom.io. Proton also gives you a simple text configuration to manage all your packages quickly. Unfortunately Proton is not complete replacement of all actions. Atom & Proton install guide SublimeText 4 is a lightweight and feature rich text editor, especially of interest that like a simple and uncluttered UI. SublimeText is a commercial project although has free trial version available (check conditions of use ). Clojure-Sublimed provides Clojure support for SublimeText 4, with support for Clojure & Edn syntax, code formatting and an nREPL client to connect to a Clojure REPL process. SublimeText install Clojure-Sublimed install SublimeText Documentation Cursive may be an appropriate choice for people from a Java background who are already familiar with IntelliJ. Cursive will run static analysis of Clojure code when opening a Clojure project, as IntelliJ does with other languages. Requires license for commercial development There is a free license when development is not for commercial projects, however, a license must be purchased for each developer working on a commercial project. IntelliJ & Cursive install guide","title":"Editors for Clojure development"},{"location":"clojure-editors/#editors-for-clojure-development","text":"The best editor to use for learning Clojure is the editor already familiar with (or want to learn). An ideal Clojure editor includes the these core features running / connecting to a REPL process evaluation results inline or in a repl window (fast feedback on what the code does) syntax highlighting (including highlight of matching parens) structural editing to ensure parens are balanced when writing and refactor code data inspector to visualise large and nested data, or connection to ( external data inpector tools )","title":"Editors for Clojure development"},{"location":"clojure-editors/#clojure-aware-editors","text":"Emacs (Spacemacs, Doom, Prelude), VSCode (Clover or Calva) and Neovim are the most common open source Editors for Clojure and ClojureScript development. SublimeText and IntelliJ are commercial editors (with free editions) that also provide Clojure support Install guides Emacs Neovim VSCode Atom SublineText Intellij Emacs is a very powerful editor with thousands of packages enabling a person to do almost any digital task concievable. Emacs is highly extensible via the ELisp programming language used to write configuration and the numerous Emacs packages. Use one of the popular community configurations for Emacs or visit the CIDER documentation to learn how to add Clojure support to Emacs. Emacs 28 onward uses Native Compilation of Emacs packages, dramatically speeding up many common tasks and keeping Emacs a valuable option for development (and everything else). Emacs uses CIDER and Clojure LSP for a feature rich clojure development experience. Emacs Spacemacs Doom Emacs Prelude Emacs Spacemacs is a community configuration bringing Emacs features and Vim sytle editing together. Spacemacs uses a mnemonic menu system that makes it easy to learn and provides detailed documentation for configuring and using Emacs. Spacemacs, Practicalli guides you through Clojure development, documenting with org-mode, Git version control with Magit, Vim editing modes and dozens of other features. Spacemacs install guide Doom Emacs is a community configuration for Emacs that provides a minimalistic configuration that is readily customisable. Doom Emacs is most suited to those comming from a Vim-style editing background or simply looking for a lightweight setup with options to extend the configuration. Doom Emacs practicalli/doom-emacs-config repository contains a customised configuration for Clojure development and supporting tools. Browse the repository online or fork / clone the repository Free Desktop XDG Config Classic Config git clone https://github.com/practicalli/doom-emacs-config.git $XDG_CONFIG_HOME /doom ` The Practicalli configuration should replace the ~/.config/doom/ directory created by the doom install command. git clone https://github.com/practicalli/doom-emacs-config.git $HOME /.doom.d ` The Practicalli configuration should replace the ~/.doom.d/ directory created by the doom install command. Emacs Prelude is an easy to use Emacs configuration for Emacs newcomers and lots of additional power for Emacs power users, from the author of CIDER - the definitive Clojure IDE for Emacs . Prelude uses the traditional chorded key bindings to drive Emacs, e.g. Ctrl + c Ctrl + c to evaluate the current top-level form. Neovim is a hyper-extensible text editor that evolved from Vim whist still fully compatible with Vim\"s editing model and Vimscript extension language. Neovim uses lua configuration and with the aniseed package configuration and Neovim packages can be written in Fennel (a lisp dialect). Neovim is based on multi-model editing (e.g. normal, insert, visual editing states) providing a highly effective tool for writing code, configuration and documentation. The Neovim community provides a large number of packages to add features. Conjure is predominantly used for Clojure development and supports Clojure CLI, Leiningen and Babashka projects (as well as several other Lisp dialects and interesting languages) Practicalli Neovim SpaceVim vimiced practicalli/neovim-config-redux is written in Fennel as it is very close to Clojure. A Which-key menu can be used to drive Neovim, with a mnemonic set of key bindings to make adoptiong Neovim easier. Conjure provides interactive environment for evaluating Clojure code and providing inline results (or see results in an Heads Up Display or Log buffer). Practicalli Neovim covers installation and basic use of Neovim for Clojure development. Practicalli Neovim Older Neovim guides include: Practicalli install guide for neovim and conjure Practicalli user guide for neovim and conjure","title":"Clojure aware editors"},{"location":"clojure-editors/#quick-try-tutorial","text":"Try the Conjure interactive :ConjureSchool tutorial without the need to install, only a recent version of neovim curl -fL conjure.fun/school | sh :q to quit the tutorial.","title":"Quick try tutorial"},{"location":"clojure-editors/#references","text":"Getting started with Neovim and Conjure Neovim user guide Conjure install guide Conjuring Clojure in Vim - an introduction to using Conjure SpaceVim is a fully featured vim experience that includes a simple Clojure development environment based around vim-fireplace Practicalli install guide Practicalli user guide SpaceVim quickstart guide SpaceVim documentation Clojure Interactive Development Environment for Vim8/Neovim. vim-iced documentation Calva Clover The Calva extension adds Clojure support to Microsoft VS Code editor. Calva is an active project and the #calva channel on the Clojurians Slack community can be supportive. VSCode & Calva install guide VSCode & Calva user guide VSCode Calva extension Clover is a Socket REPL based development tool for Clojure. Clojure GitLab repository includes useage details.","title":"References"},{"location":"clojure-editors/#vspacecode","text":"VSpaceCode is a Spacemacs-like community configuration for Microsoft VS Code. Drive VS Code and Calva entirely from the keyboard, using easy to remember mnemonic keys for all commands and full vim-stile editing tools. Also included edamagit, a sophisticated text based Git client (like magit for Emacs). Quick install guide Quick user guide Atom not actively developed Atom will be archived on December 15 2022 and no further updates from GitHub team, although it may continue in open source. Consider using VSCode with Clover or Calva plugins instead Atom.io is flexible and simple to use editor . Chlorine is the recommended plugin for Atom.io. ProtoREPL is not actively maintained at present. The Chlorine plugin for Atom is especially recommended for ClojureScript shadow-cljs projects. Chlorine install guide","title":"VSpaceCode"},{"location":"clojure-editors/#protorepl","text":"ProtoREPL Atom & ProtoREPL install guide","title":"ProtoREPL"},{"location":"clojure-editors/#proton-alternative-menu-and-configuration-approach","text":"Proton offers a simple mnemonic menu as an alternative to the multiple keys for shortcuts in Atom.io. Proton also gives you a simple text configuration to manage all your packages quickly. Unfortunately Proton is not complete replacement of all actions. Atom & Proton install guide SublimeText 4 is a lightweight and feature rich text editor, especially of interest that like a simple and uncluttered UI. SublimeText is a commercial project although has free trial version available (check conditions of use ). Clojure-Sublimed provides Clojure support for SublimeText 4, with support for Clojure & Edn syntax, code formatting and an nREPL client to connect to a Clojure REPL process. SublimeText install Clojure-Sublimed install SublimeText Documentation Cursive may be an appropriate choice for people from a Java background who are already familiar with IntelliJ. Cursive will run static analysis of Clojure code when opening a Clojure project, as IntelliJ does with other languages. Requires license for commercial development There is a free license when development is not for commercial projects, however, a license must be purchased for each developer working on a commercial project. IntelliJ & Cursive install guide","title":"Proton - alternative menu and configuration approach"},{"location":"clojure-editors/clojure-lsp/","text":"Clojure LSP \u03bb\ufe0e The Language Server Protocol provides a standard set of tools that are used to developer any programming language. These tools are typically provides with a language specific server. clojure-lsp is an implementation of an LSP server, for Clojure and ClojureScript languages. Install \u03bb\ufe0e Follow your preferred option on the Clojure LSP installation guide Practicalli downloads the clojure-lsp-native-linux-amd64.zip file from GitHub release page and extracts the clojure-lsp binary to ~/.local/bin/clojure-lsp . clojure-lsp -v in a terminal will test if the the install is working. Editors may install Clojure LSP for you Spacemacs LSP layer will prompt to install a language server when first opening a file of a major mode where LSP is enabled. E.g. when a Clojure related file is opened, the Clojure LSP server is downloaded if not installed (or not found on the Emacs path). VSCode Calva plugin includes the clojure-lsp server, although an external server can be configured. References \u03bb\ufe0e LSP mode - A guide on disabling / enabling features - if the Emacs UI is too cluttered or missing visual features Configure Emacs as a Clojure IDE Language Server Protocol support for Emacs","title":"Clojure LSP"},{"location":"clojure-editors/clojure-lsp/#clojure-lsp","text":"The Language Server Protocol provides a standard set of tools that are used to developer any programming language. These tools are typically provides with a language specific server. clojure-lsp is an implementation of an LSP server, for Clojure and ClojureScript languages.","title":"Clojure LSP"},{"location":"clojure-editors/clojure-lsp/#install","text":"Follow your preferred option on the Clojure LSP installation guide Practicalli downloads the clojure-lsp-native-linux-amd64.zip file from GitHub release page and extracts the clojure-lsp binary to ~/.local/bin/clojure-lsp . clojure-lsp -v in a terminal will test if the the install is working. Editors may install Clojure LSP for you Spacemacs LSP layer will prompt to install a language server when first opening a file of a major mode where LSP is enabled. E.g. when a Clojure related file is opened, the Clojure LSP server is downloaded if not installed (or not found on the Emacs path). VSCode Calva plugin includes the clojure-lsp server, although an external server can be configured.","title":"Install"},{"location":"clojure-editors/clojure-lsp/#references","text":"LSP mode - A guide on disabling / enabling features - if the Emacs UI is too cluttered or missing visual features Configure Emacs as a Clojure IDE Language Server Protocol support for Emacs","title":"References"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/","text":"Practicalli Snippets for Clojure LSP \u03bb\ufe0e Custom snippets created by Practicalli and added via the :additional-snippets key in the Clojure LSP configuration ( .lsp/config.edn or user level configuration). Snippets are defined as a vector of hash-maps { :additional-snippets [{} {} {} ,,, ]} Practicalli Snippets available in practicalli/clojure-lsp-config === Via SSH git@github.com:practicalli/clojure-lsp-config.git === Via HTTPS git clone https://github.com/practicalli/clojure-lsp-config Documentation \u03bb\ufe0e A comment heading to describe the purpose and important information about the current namesapce. { :name \"comment-heading\" :detail \"Comment Header\" :snippet \";; --------------------------------------------------------- ;; ${1:Heading summary title} ;; ;; ${2:Brief description}\\n;; ---------------------------------------------------------\\n\\n$0\" } A comment separator for marking logical sections within a namespace, useful for navigating code and identifying opportunities to refactor a namespace into multiple namespaces. { :name \"comment-separator\" :detail \"Comment Separator\" :snippet \";; ---------------------------------------------------------\\n;; ${1:Section title}\\n\\n$0\" } A comment section with start and end titles for marking logical sections within a namespace, again for navigation and identifying opportunities to refactor a namespace. { :name \"comment-section\" :detail \"Comment Section\" :snippet \";; ---------------------------------------------------------\\n;; ${1:Section title}\\n\\n$0\\n\\n ;; End of $1\\n;; ---------------------------------------------------------\\n\\n\" } REPL Driven Development \u03bb\ufe0e A rich comment block typically used to hold function calls to show how to make use of the important aspects of the current namespace. For example, calls to start , restart , stop functions in a namespace that defines the service life-cycle. This provides a live executable guide to using the namespace, without being called if the whole namespace is evaluated. A commented expression is placed before the closing paren to ensure that closing paren is not folded up into the previous line. This makes it easier to add further code to the rich comment block. { :name \"rich-comment\" :detail \"Create rich comment\" :snippet \"(comment $0 #_()) ;; End of rich comment\" } A modified rich comment block with clj-kondo configuration to suppress warnings for duplicate function definition names, supporting alternative function implementations as part of a REPL driven development workflow. { :name \"rich-comment-rdd\" :detail \"Create comment block\" :snippet \"#_{:clj-kondo/ignore [:redefined-var]} (comment $0 #_()) ;; End of rich comment\" } Wrap an existing form in a rich comment { :name \"wrap-rich-comment\" :detail \"Wrap current expression with rich comment form\" :snippet \"(comment $current-form $0 #_()) ;; End of rich comment\" } Comment an existing form with the Clojure Comment macro, _# { :name \"wrap-reader-comment\" :detail \"Wrap current expression with Comment Reader macro\" :snippet \"#_$current-form\" } Hot loading library dependencies \u03bb\ufe0e Clojure CLI projects can hotload library dependencies into a running Clojure REPL using the tools.deps library . This requires starting a REPL with the clojure.tools.deps.alpha library as a dependency which can be done by including the :lib/hotload alias from practicalli/clojure-deps-edn . Note this library is alpha and the API could change in future. Create a rich comment block that requires the clojure.tools.deps.alpha namespace and an add-libs expression to hotload one or more libraries in a hash-map. Tab stops with placeholders are included for adding the first library to hotload. { :name \"rich-comment-hotload\" :detail \"Rich comment library hotload\" :snippet \"#_{:clj-kondo/ignore [:redefined-var]} (comment ;; Add-lib library for hot-loading (require '[clojure.tools.deps.alpha.repl :refer [add-libs]]) (add-libs '{${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$3}) $0 #_()) ;; End of rich comment block\" } Core functions \u03bb\ufe0e Create a public var using a def form with a doc-string, with placeholders for name and value. { :name \"def\" :detail \"def with docstring\" :snippet \"(def ${1:name}\\n \\\"${2:docstring}\\\"\\n $0)\" } Create a private var using a def form with ^:private meta data and a doc-string, with placeholders for name and value. { :name \"def-\" :detail \"def private\" :snippet \"(def ^:private ${1:name}\\n \\\"${2:doc-string}\\\"\\n $0)\" } A defn form with name, doc-string and args tab-stops { :name \"defn\" :detail \"Create public function\" :snippet \"(defn ${1:name}\\n \\\"${2:docstring}\\\"\\n [${3:args}]\\n $0)\" } A defn form with private metatdata. Including name, doc-string and args tab-stops { :name \"defn-\" :detail \"Create public function\" :snippet \"(defn ^:private ${1:name}\\n \\\"${2:docstring}\\\"\\n [${3:args}]\\n $0)\" } A namespace form with name, doc-string and require tab-stop. { :name \"ns\" :detail \"Create ns\" :snippet \"(ns ${1:name}\\n \\\"${2:docstring}\\\"\\n ${3:require})\" } Clojure CLI aliases and library dependencies \u03bb\ufe0e Add Clojure CLI alias to deps.edn , with an :extra-paths and :extra-deps section { :name \"deps-alias\" :detail \"deps.edn alias with extra path & deps\" :snippet \":${1:category/name} {:extra-paths [\\\"${2:path}\\\"] :extra-deps {${3:deps-maven or deps-git}}}$0\" } Add a Maven style dependency to a Clojure CLI deps.edn project. { :name \"deps-maven\" :detail \"deps.edn Maven dependency\" :snippet \"${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$0\" } Add a dependency from a Git repository, where the library is named after the remote Git repository, i.e io.github.user|org/library-name for the GitHub repository https://github.com/user|org/library-name . The :git/sha defines a specific commit to use for the dependency. { :name \"deps-git\" :detail \"deps.edn Git dependency\" :snippet \"${1:domain/library-name} {:git/sha \\\"${2:git-sha-value}\\\"}$0\" } Additionally a Git tag can be specified, enabling the use of the short SHA value for :git/sha (short sha is the first 7 characters of the 40 character SHA-1 value). A Git client can obtain the short form of a SHA from a Git repository git rev-parse --short 1e872b59013425b7c404a91d16119e8452b983f2 { :name \"deps-git-tag\" :detail \"Git dependency\" :snippet \"${1:domain/library-name} {:git/tag \\\"${2:git-tag-value}\\\" :git/sha \\\"${3:git-sha-value}\\\"}$0\" } If a library is not named after the domain of the Git repository, the URL of the Git repository must be specified using the :git/url key. { :name \"deps-git-url\" :detail \"Git URL dependency\" :snippet \"${1:domain/library-name} {:git/url \\\"https://github.com/$1\\\" :git/sha \\\"${2:git-sha-value}\\\"}$0\" } Add a library dependency that is a local Clojure project. { :name \"deps-local\" :detail \"deps.edn Maven dependency\" :snippet \"${1:domain/library-name} {:local/root \\\"${2:/path/to/project/root}\\\"}$0\" } Require Library Dependencies \u03bb\ufe0e Require a library when using REPL driven development in a rich comment block, adding a (require ,,,) form when evaluating the use of a library without forcing it to be loaded when loading the namespace. { :name \"require-rdd\" :detail \"require for rich comment experiments\" :snippet \"(require '[${1:namespace} :as ${2:alias}]$3)$0\" } A basic :require expression for an ns form. { :name \"require\" :detail \"ns require\" :snippet \"(:require [${1:namespace}])$0\" } A :require expression for an ns form, including a :as directive to define an alias for the required namespace. { :name \"require-as\" :detail \"ns require with :as alias\" :snippet \"(:require [${1:namespace} :as ${2:alias}]$3)$0\" } A :require expression for an ns form, including a :refer directive to include specific function definitions and vars by name. { :name \"require-refer\" :detail \"ns require with :refer\" :snippet \"(:require [${1:namespace} :refer [$2]]$3)$0\" } It is idiomatic to use require with refer to pull in specific functions and vars from another namespace. The use function is not recommended as it can easily pull more transitive dependencies into the current namespace, causing unexpected results { :name \"use\" :detail \"require refer preferred over use\" :snippet \"(:require [${1:namespace} :refer [$2]])$0\" } Clojure.test snippets \u03bb\ufe0e When writing a deftest , a new assertion written may be better in a new group. The testing snippet will create a new testing form and pull in the following assertion. { :name \"deftest\" :detail \"deftest clojure.test\" :snippet \"(deftest ${1:name}-test (testing \\\"${2:Context of the test assertions}\\\" (is (= ${3:assertion-values}))$4)) $0\" } Create a new assertion group using the clojure.test/testing form. Using testing before an assertion form pull that assertion into the group { :name \"testing\" :detail \"testing clojure.test\" :snippet \"(testing \\\"${1:description-of-assertion-group}\\\"\\n $0)\" } Define an is assertion for a deftest { :name \"is\" :detail \"assertion for clojure.test\" :snippet \"(is (= ${1:function call} ${2:expected result}))$0\" }","title":"Practicalli Snippets for Clojure LSP"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#practicalli-snippets-for-clojure-lsp","text":"Custom snippets created by Practicalli and added via the :additional-snippets key in the Clojure LSP configuration ( .lsp/config.edn or user level configuration). Snippets are defined as a vector of hash-maps { :additional-snippets [{} {} {} ,,, ]} Practicalli Snippets available in practicalli/clojure-lsp-config === Via SSH git@github.com:practicalli/clojure-lsp-config.git === Via HTTPS git clone https://github.com/practicalli/clojure-lsp-config","title":"Practicalli Snippets for Clojure LSP"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#documentation","text":"A comment heading to describe the purpose and important information about the current namesapce. { :name \"comment-heading\" :detail \"Comment Header\" :snippet \";; --------------------------------------------------------- ;; ${1:Heading summary title} ;; ;; ${2:Brief description}\\n;; ---------------------------------------------------------\\n\\n$0\" } A comment separator for marking logical sections within a namespace, useful for navigating code and identifying opportunities to refactor a namespace into multiple namespaces. { :name \"comment-separator\" :detail \"Comment Separator\" :snippet \";; ---------------------------------------------------------\\n;; ${1:Section title}\\n\\n$0\" } A comment section with start and end titles for marking logical sections within a namespace, again for navigation and identifying opportunities to refactor a namespace. { :name \"comment-section\" :detail \"Comment Section\" :snippet \";; ---------------------------------------------------------\\n;; ${1:Section title}\\n\\n$0\\n\\n ;; End of $1\\n;; ---------------------------------------------------------\\n\\n\" }","title":"Documentation"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#repl-driven-development","text":"A rich comment block typically used to hold function calls to show how to make use of the important aspects of the current namespace. For example, calls to start , restart , stop functions in a namespace that defines the service life-cycle. This provides a live executable guide to using the namespace, without being called if the whole namespace is evaluated. A commented expression is placed before the closing paren to ensure that closing paren is not folded up into the previous line. This makes it easier to add further code to the rich comment block. { :name \"rich-comment\" :detail \"Create rich comment\" :snippet \"(comment $0 #_()) ;; End of rich comment\" } A modified rich comment block with clj-kondo configuration to suppress warnings for duplicate function definition names, supporting alternative function implementations as part of a REPL driven development workflow. { :name \"rich-comment-rdd\" :detail \"Create comment block\" :snippet \"#_{:clj-kondo/ignore [:redefined-var]} (comment $0 #_()) ;; End of rich comment\" } Wrap an existing form in a rich comment { :name \"wrap-rich-comment\" :detail \"Wrap current expression with rich comment form\" :snippet \"(comment $current-form $0 #_()) ;; End of rich comment\" } Comment an existing form with the Clojure Comment macro, _# { :name \"wrap-reader-comment\" :detail \"Wrap current expression with Comment Reader macro\" :snippet \"#_$current-form\" }","title":"REPL Driven Development"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#hot-loading-library-dependencies","text":"Clojure CLI projects can hotload library dependencies into a running Clojure REPL using the tools.deps library . This requires starting a REPL with the clojure.tools.deps.alpha library as a dependency which can be done by including the :lib/hotload alias from practicalli/clojure-deps-edn . Note this library is alpha and the API could change in future. Create a rich comment block that requires the clojure.tools.deps.alpha namespace and an add-libs expression to hotload one or more libraries in a hash-map. Tab stops with placeholders are included for adding the first library to hotload. { :name \"rich-comment-hotload\" :detail \"Rich comment library hotload\" :snippet \"#_{:clj-kondo/ignore [:redefined-var]} (comment ;; Add-lib library for hot-loading (require '[clojure.tools.deps.alpha.repl :refer [add-libs]]) (add-libs '{${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$3}) $0 #_()) ;; End of rich comment block\" }","title":"Hot loading library dependencies"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#core-functions","text":"Create a public var using a def form with a doc-string, with placeholders for name and value. { :name \"def\" :detail \"def with docstring\" :snippet \"(def ${1:name}\\n \\\"${2:docstring}\\\"\\n $0)\" } Create a private var using a def form with ^:private meta data and a doc-string, with placeholders for name and value. { :name \"def-\" :detail \"def private\" :snippet \"(def ^:private ${1:name}\\n \\\"${2:doc-string}\\\"\\n $0)\" } A defn form with name, doc-string and args tab-stops { :name \"defn\" :detail \"Create public function\" :snippet \"(defn ${1:name}\\n \\\"${2:docstring}\\\"\\n [${3:args}]\\n $0)\" } A defn form with private metatdata. Including name, doc-string and args tab-stops { :name \"defn-\" :detail \"Create public function\" :snippet \"(defn ^:private ${1:name}\\n \\\"${2:docstring}\\\"\\n [${3:args}]\\n $0)\" } A namespace form with name, doc-string and require tab-stop. { :name \"ns\" :detail \"Create ns\" :snippet \"(ns ${1:name}\\n \\\"${2:docstring}\\\"\\n ${3:require})\" }","title":"Core functions"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#clojure-cli-aliases-and-library-dependencies","text":"Add Clojure CLI alias to deps.edn , with an :extra-paths and :extra-deps section { :name \"deps-alias\" :detail \"deps.edn alias with extra path & deps\" :snippet \":${1:category/name} {:extra-paths [\\\"${2:path}\\\"] :extra-deps {${3:deps-maven or deps-git}}}$0\" } Add a Maven style dependency to a Clojure CLI deps.edn project. { :name \"deps-maven\" :detail \"deps.edn Maven dependency\" :snippet \"${1:domain/library-name} {:mvn/version \\\"${2:1.0.0}\\\"}$0\" } Add a dependency from a Git repository, where the library is named after the remote Git repository, i.e io.github.user|org/library-name for the GitHub repository https://github.com/user|org/library-name . The :git/sha defines a specific commit to use for the dependency. { :name \"deps-git\" :detail \"deps.edn Git dependency\" :snippet \"${1:domain/library-name} {:git/sha \\\"${2:git-sha-value}\\\"}$0\" } Additionally a Git tag can be specified, enabling the use of the short SHA value for :git/sha (short sha is the first 7 characters of the 40 character SHA-1 value). A Git client can obtain the short form of a SHA from a Git repository git rev-parse --short 1e872b59013425b7c404a91d16119e8452b983f2 { :name \"deps-git-tag\" :detail \"Git dependency\" :snippet \"${1:domain/library-name} {:git/tag \\\"${2:git-tag-value}\\\" :git/sha \\\"${3:git-sha-value}\\\"}$0\" } If a library is not named after the domain of the Git repository, the URL of the Git repository must be specified using the :git/url key. { :name \"deps-git-url\" :detail \"Git URL dependency\" :snippet \"${1:domain/library-name} {:git/url \\\"https://github.com/$1\\\" :git/sha \\\"${2:git-sha-value}\\\"}$0\" } Add a library dependency that is a local Clojure project. { :name \"deps-local\" :detail \"deps.edn Maven dependency\" :snippet \"${1:domain/library-name} {:local/root \\\"${2:/path/to/project/root}\\\"}$0\" }","title":"Clojure CLI aliases and library dependencies"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#require-library-dependencies","text":"Require a library when using REPL driven development in a rich comment block, adding a (require ,,,) form when evaluating the use of a library without forcing it to be loaded when loading the namespace. { :name \"require-rdd\" :detail \"require for rich comment experiments\" :snippet \"(require '[${1:namespace} :as ${2:alias}]$3)$0\" } A basic :require expression for an ns form. { :name \"require\" :detail \"ns require\" :snippet \"(:require [${1:namespace}])$0\" } A :require expression for an ns form, including a :as directive to define an alias for the required namespace. { :name \"require-as\" :detail \"ns require with :as alias\" :snippet \"(:require [${1:namespace} :as ${2:alias}]$3)$0\" } A :require expression for an ns form, including a :refer directive to include specific function definitions and vars by name. { :name \"require-refer\" :detail \"ns require with :refer\" :snippet \"(:require [${1:namespace} :refer [$2]]$3)$0\" } It is idiomatic to use require with refer to pull in specific functions and vars from another namespace. The use function is not recommended as it can easily pull more transitive dependencies into the current namespace, causing unexpected results { :name \"use\" :detail \"require refer preferred over use\" :snippet \"(:require [${1:namespace} :refer [$2]])$0\" }","title":"Require Library Dependencies"},{"location":"clojure-editors/clojure-lsp/practicalli-snippets/#clojuretest-snippets","text":"When writing a deftest , a new assertion written may be better in a new group. The testing snippet will create a new testing form and pull in the following assertion. { :name \"deftest\" :detail \"deftest clojure.test\" :snippet \"(deftest ${1:name}-test (testing \\\"${2:Context of the test assertions}\\\" (is (= ${3:assertion-values}))$4)) $0\" } Create a new assertion group using the clojure.test/testing form. Using testing before an assertion form pull that assertion into the group { :name \"testing\" :detail \"testing clojure.test\" :snippet \"(testing \\\"${1:description-of-assertion-group}\\\"\\n $0)\" } Define an is assertion for a deftest { :name \"is\" :detail \"assertion for clojure.test\" :snippet \"(is (= ${1:function call} ${2:expected result}))$0\" }","title":"Clojure.test snippets"},{"location":"clojure-editors/clojure-lsp/snippets/","text":"Clojure LSP Snippets \u03bb\ufe0e Custom snippets are defined in the Clojure LSP EDN configuration using the :additional-snipets key. The snippet body uses the same tab stop and placeholder syntax as Yasnipets, although the body is contained within a string. Built-in snippets can include Clojure code for generating the text of the snippet when expanded. Custom snippets do not currently support evaluation of code in the snippet. Clojure LSP Configuration locations Project specific configuration resides in .lsp/config.edn User level configuration is either $XDG_CONFIG_HOME/clojure-lsp/config.edn or $HOME/.lsp/config Snippet definition \u03bb\ufe0e The :additional-snippets key is associated with a vector or hash-maps, [{}{},,,] with each hash-map defining a snippet using the keys: :name - name of the snippet, typed into the editor for completion :detail - a meaningful description of the snippet :snippet - the definition of the snippet, with tab stops and current-form syntax The :snippet can be any text, ideally with syntax that is correct for the particular language Snippet Tab Stops \u03bb\ufe0e Include $ with a number, e.g. $1 , $2 , $3 , to include tab stops in the snippet. Once the snippet code has been generated, TAB key jumps through the tab stops in sequence, allowing customisation of a generic snippet. $0 marks the final position of the cursor, after which TAB has no more positions in the snippet to jump to. Snippet current-form \u03bb\ufe0e When a Clojure LSP snipped includes $current-form then typing a snippet name in front of an existing Clojure form includes that form in the generated code. { :additional-snippets [{ :name \"wrap-let-sexpr\" :detail \"Wrap current sexpr in let\" :snippet \"(let [$1 $current-form] $0)\" }]} Limited scope with current-form A Snippet including $current-form is only active when typed in front of an existing expression. A snippet is not recognised when typed at the top level. Placeholders \u03bb\ufe0e Tab Stops can also include default values or text used as hint on what each tab stop value is for. These are referred to as placeholders. ${1:default-value} is the form of a placeholder for tab stop 1. When the cursor tabs to tab stop 1, the default-value text is highlighted and replaces as soon as characters are typed. Placeholder text is not replaced for $0 tab-stop, as the snippet interaction is effectively over at this point. The deftest custom snippet shows examples of placeholders for three tab stops. { :name \"deftest\" :detail \"deftest clojure.test\" :snippet \"(deftest ${1:name}-test (testing \\\"${2:Context of the test assertions}\\\" (is (= ${3:assertion-values}))$4)) $0\" } Escape string quotes in snippet body Use \\ character before the \" character within the snippet body. For example, doc-strings in defn function definitions or the string in testing function. Code driven snippet \u03bb\ufe0e The built-in defn snippet uses Clojure code to help generate the snippet. %s is a substitution point within a snippet, used by the standard Clojure format command, used to included either defn ^:private or defn- , depending on the value returned from the if expression. :use-metadata-for-privacy? is a key from the Clojure LSP configuration { :label \"defn-\" :detail \"Create private function\" :insert-text ( format \"(defn%s ${1:name} [$2]\\n ${0:body})\" ( if ( :use-metadata-for-privacy? settings ) \" ^:private\" \"-\" ))} The syntax for built-in snippets is slightly different that the :additional-syntax form. The internal form uses :label for :name and :insert-text for :snippet . Code supported only in built-in snippets Clojure code only works for built-in snippets and not for :additional-snippets . Clojure LSP is compiled by Graal to a native binary, including the built-in snippets. To include Clojure code in a snippet then consider submitting a pull request to the Clojure LSP project to add a built-in snippet.","title":"Clojure LSP Snippets"},{"location":"clojure-editors/clojure-lsp/snippets/#clojure-lsp-snippets","text":"Custom snippets are defined in the Clojure LSP EDN configuration using the :additional-snipets key. The snippet body uses the same tab stop and placeholder syntax as Yasnipets, although the body is contained within a string. Built-in snippets can include Clojure code for generating the text of the snippet when expanded. Custom snippets do not currently support evaluation of code in the snippet. Clojure LSP Configuration locations Project specific configuration resides in .lsp/config.edn User level configuration is either $XDG_CONFIG_HOME/clojure-lsp/config.edn or $HOME/.lsp/config","title":"Clojure LSP Snippets"},{"location":"clojure-editors/clojure-lsp/snippets/#snippet-definition","text":"The :additional-snippets key is associated with a vector or hash-maps, [{}{},,,] with each hash-map defining a snippet using the keys: :name - name of the snippet, typed into the editor for completion :detail - a meaningful description of the snippet :snippet - the definition of the snippet, with tab stops and current-form syntax The :snippet can be any text, ideally with syntax that is correct for the particular language","title":"Snippet definition"},{"location":"clojure-editors/clojure-lsp/snippets/#snippet-tab-stops","text":"Include $ with a number, e.g. $1 , $2 , $3 , to include tab stops in the snippet. Once the snippet code has been generated, TAB key jumps through the tab stops in sequence, allowing customisation of a generic snippet. $0 marks the final position of the cursor, after which TAB has no more positions in the snippet to jump to.","title":"Snippet Tab Stops"},{"location":"clojure-editors/clojure-lsp/snippets/#snippet-current-form","text":"When a Clojure LSP snipped includes $current-form then typing a snippet name in front of an existing Clojure form includes that form in the generated code. { :additional-snippets [{ :name \"wrap-let-sexpr\" :detail \"Wrap current sexpr in let\" :snippet \"(let [$1 $current-form] $0)\" }]} Limited scope with current-form A Snippet including $current-form is only active when typed in front of an existing expression. A snippet is not recognised when typed at the top level.","title":"Snippet current-form"},{"location":"clojure-editors/clojure-lsp/snippets/#placeholders","text":"Tab Stops can also include default values or text used as hint on what each tab stop value is for. These are referred to as placeholders. ${1:default-value} is the form of a placeholder for tab stop 1. When the cursor tabs to tab stop 1, the default-value text is highlighted and replaces as soon as characters are typed. Placeholder text is not replaced for $0 tab-stop, as the snippet interaction is effectively over at this point. The deftest custom snippet shows examples of placeholders for three tab stops. { :name \"deftest\" :detail \"deftest clojure.test\" :snippet \"(deftest ${1:name}-test (testing \\\"${2:Context of the test assertions}\\\" (is (= ${3:assertion-values}))$4)) $0\" } Escape string quotes in snippet body Use \\ character before the \" character within the snippet body. For example, doc-strings in defn function definitions or the string in testing function.","title":"Placeholders"},{"location":"clojure-editors/clojure-lsp/snippets/#code-driven-snippet","text":"The built-in defn snippet uses Clojure code to help generate the snippet. %s is a substitution point within a snippet, used by the standard Clojure format command, used to included either defn ^:private or defn- , depending on the value returned from the if expression. :use-metadata-for-privacy? is a key from the Clojure LSP configuration { :label \"defn-\" :detail \"Create private function\" :insert-text ( format \"(defn%s ${1:name} [$2]\\n ${0:body})\" ( if ( :use-metadata-for-privacy? settings ) \" ^:private\" \"-\" ))} The syntax for built-in snippets is slightly different that the :additional-syntax form. The internal form uses :label for :name and :insert-text for :snippet . Code supported only in built-in snippets Clojure code only works for built-in snippets and not for :additional-snippets . Clojure LSP is compiled by Graal to a native binary, including the built-in snippets. To include Clojure code in a snippet then consider submitting a pull request to the Clojure LSP project to add a built-in snippet.","title":"Code driven snippet"},{"location":"clojure-editors/editor-install-guides/","text":"Clojure Editors: Quick Install Guides \u03bb\ufe0e Curated installation guides to get started with Clojure as quickly and simply as possible. Editor Install Guides Spacemacs NeoVim & Conjure Spacevim & Fireplace vim-iced Atom & Chlorine Atom & ProtoREPL Atom & Proton IntelliJ & Cursive VSpaceCode & Calva VSCode & Calva Once installed, take a look at the quick user guides for each editor.","title":"Clojure Editors: Quick Install Guides"},{"location":"clojure-editors/editor-install-guides/#clojure-editors-quick-install-guides","text":"Curated installation guides to get started with Clojure as quickly and simply as possible. Editor Install Guides Spacemacs NeoVim & Conjure Spacevim & Fireplace vim-iced Atom & Chlorine Atom & ProtoREPL Atom & Proton IntelliJ & Cursive VSpaceCode & Calva VSCode & Calva Once installed, take a look at the quick user guides for each editor.","title":"Clojure Editors: Quick Install Guides"},{"location":"clojure-editors/editor-install-guides/atom-proton/","text":"Atom Proton \u03bb\ufe0e Proton-mode gives a Spacemacs-like experience to the Atom editor Proton-mode provides a mnemonic menu and set of keybindings that offer an effective alternative to the interesting keybindings with Atom and ProtoREPL. It also provides modal editing features, simplifying keybindings. Install Atom.io \u03bb\ufe0e Follow the instructions for your operating system {% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions. Standalone Install \u03bb\ufe0e Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install. Alternative install via Package Manager \u03bb\ufe0e Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom Running Atom \u03bb\ufe0e To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"mac\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"redhat\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"windows\" %} Danger::Leiningen in GitBash does not work with Atom \u03bb\ufe0e Recommend using VSCode and Calva if you have installed Leiningen via GitBash method. Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %} Install Proton \u03bb\ufe0e Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Proton-mode - Spacemacs style menu and keybindings to make Atom easier to use (included Vim / Emacs keybinding support) Recommended packages lisp-paredit - to manage your () proto-repl-charts - graphs and charts tool-bar - displays a REPL tool bar highlight-selected - highlights selected keywords throughout an editor Example project: Welcome to ClojureBridge \u03bb\ufe0e We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs projectzip=\"Download project as zip file\", projectclone=\"Clone project from Github\" %} {% content \"projectzip\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"projectclone\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %} Test your editor with a clojure project \u03bb\ufe0e Add the project called welcometoclojurebridge . Open the project.clj file and add the dependency [proto-repl \"0.3.1\"] . Open the src/welcometoclojurebridge/core.clj file. , s i to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Atom Proton"},{"location":"clojure-editors/editor-install-guides/atom-proton/#atom-proton","text":"Proton-mode gives a Spacemacs-like experience to the Atom editor Proton-mode provides a mnemonic menu and set of keybindings that offer an effective alternative to the interesting keybindings with Atom and ProtoREPL. It also provides modal editing features, simplifying keybindings.","title":"Atom Proton"},{"location":"clojure-editors/editor-install-guides/atom-proton/#install-atomio","text":"Follow the instructions for your operating system {% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions.","title":"Install Atom.io"},{"location":"clojure-editors/editor-install-guides/atom-proton/#standalone-install","text":"Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install.","title":"Standalone Install"},{"location":"clojure-editors/editor-install-guides/atom-proton/#alternative-install-via-package-manager","text":"Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom","title":"Alternative install via Package Manager"},{"location":"clojure-editors/editor-install-guides/atom-proton/#running-atom","text":"To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"mac\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"redhat\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"windows\" %}","title":"Running Atom"},{"location":"clojure-editors/editor-install-guides/atom-proton/#dangerleiningen-in-gitbash-does-not-work-with-atom","text":"Recommend using VSCode and Calva if you have installed Leiningen via GitBash method. Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %}","title":"Danger::Leiningen in GitBash does not work with Atom"},{"location":"clojure-editors/editor-install-guides/atom-proton/#install-proton","text":"Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Proton-mode - Spacemacs style menu and keybindings to make Atom easier to use (included Vim / Emacs keybinding support) Recommended packages lisp-paredit - to manage your () proto-repl-charts - graphs and charts tool-bar - displays a REPL tool bar highlight-selected - highlights selected keywords throughout an editor","title":"Install Proton"},{"location":"clojure-editors/editor-install-guides/atom-proton/#example-project-welcome-to-clojurebridge","text":"We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs projectzip=\"Download project as zip file\", projectclone=\"Clone project from Github\" %} {% content \"projectzip\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"projectclone\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %}","title":"Example project: Welcome to ClojureBridge"},{"location":"clojure-editors/editor-install-guides/atom-proton/#test-your-editor-with-a-clojure-project","text":"Add the project called welcometoclojurebridge . Open the project.clj file and add the dependency [proto-repl \"0.3.1\"] . Open the src/welcometoclojurebridge/core.clj file. , s i to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Test your editor with a clojure project"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/","text":"Atom.io and ProtoREPL \u03bb\ufe0e Proto REPL is a Clojure development environment and REPL for Atom.io. Install Atom.io \u03bb\ufe0e Follow the instructions for your operating system {% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions. Standalone Install \u03bb\ufe0e Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install. Via Package Manager \u03bb\ufe0e Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom Running Atom \u03bb\ufe0e To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"mac\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"redhat\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"windows\" %} Danger::Leiningen in GitBash does not work with Atom \u03bb\ufe0e Recommend using VSCode and Calva if you have installed Leiningen via GitBash method. Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %} Install Proto REPL package \u03bb\ufe0e Open the Atom Settings. In the install section, search for each of the required packages and install them. If you have time, also install the recommended packages. Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Recommended packages lisp-paredit - to manage your () proto-repl-charts Configure ProtoREPL with Leiningen \u03bb\ufe0e Go to the Proto REPL Settings (Atom Preferences, then packages, then Proto REPL) Modify \"Lein Path\" to the path where Leiningen. Use which lein in a terminal to get the path. Example project: Welcome to ClojureBridge \u03bb\ufe0e We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs projectzip=\"Download project as zip file\", projectclone=\"Clone project from Github\" %} {% content \"projectzip\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"projectclone\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %} Test your editor with a clojure project \u03bb\ufe0e Add the project called welcometoclojurebridge . Open the project.clj file and add the dependency [proto-repl \"0.3.1\"] . Open the src/welcometoclojurebridge/core.clj file. Ctrl-Alt-, s to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Atom.io and ProtoREPL"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#atomio-and-protorepl","text":"Proto REPL is a Clojure development environment and REPL for Atom.io.","title":"Atom.io and ProtoREPL"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#install-atomio","text":"Follow the instructions for your operating system {% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions.","title":"Install Atom.io"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#standalone-install","text":"Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install.","title":"Standalone Install"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#via-package-manager","text":"Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom","title":"Via Package Manager"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#running-atom","text":"To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"mac\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"redhat\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"windows\" %}","title":"Running Atom"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#dangerleiningen-in-gitbash-does-not-work-with-atom","text":"Recommend using VSCode and Calva if you have installed Leiningen via GitBash method. Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %}","title":"Danger::Leiningen in GitBash does not work with Atom"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#install-proto-repl-package","text":"Open the Atom Settings. In the install section, search for each of the required packages and install them. If you have time, also install the recommended packages. Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Recommended packages lisp-paredit - to manage your () proto-repl-charts","title":"Install Proto REPL package"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#configure-protorepl-with-leiningen","text":"Go to the Proto REPL Settings (Atom Preferences, then packages, then Proto REPL) Modify \"Lein Path\" to the path where Leiningen. Use which lein in a terminal to get the path.","title":"Configure ProtoREPL with Leiningen"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#example-project-welcome-to-clojurebridge","text":"We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs projectzip=\"Download project as zip file\", projectclone=\"Clone project from Github\" %} {% content \"projectzip\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"projectclone\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %}","title":"Example project: Welcome to ClojureBridge"},{"location":"clojure-editors/editor-install-guides/atom-protorepl/#test-your-editor-with-a-clojure-project","text":"Add the project called welcometoclojurebridge . Open the project.clj file and add the dependency [proto-repl \"0.3.1\"] . Open the src/welcometoclojurebridge/core.clj file. Ctrl-Alt-, s to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Test your editor with a clojure project"},{"location":"clojure-editors/editor-install-guides/emacs-spacemacs/","text":"Emacs and Spacemacs Install \u03bb\ufe0e Spacemacs is a community configuration bringing Emacs and Vim together. Spacemacs uses a mnemonic menu system that makes it easy to learn. Spacemacs, Practicalli guides you through Clojure development, documenting with org-mode, Git version control with Magit, Vim editing modes and dozens of other features. Install guide covering Java, Clojure, Emacs and Spacemacs {% youtube %} https://youtu.be/rZNYLGw1qFk","title":"Emacs and Spacemacs Install"},{"location":"clojure-editors/editor-install-guides/emacs-spacemacs/#emacs-and-spacemacs-install","text":"Spacemacs is a community configuration bringing Emacs and Vim together. Spacemacs uses a mnemonic menu system that makes it easy to learn. Spacemacs, Practicalli guides you through Clojure development, documenting with org-mode, Git version control with Magit, Vim editing modes and dozens of other features. Install guide covering Java, Clojure, Emacs and Spacemacs {% youtube %} https://youtu.be/rZNYLGw1qFk","title":"Emacs and Spacemacs Install"},{"location":"clojure-editors/editor-install-guides/emacs/","text":"Installing Emacs \u03bb\ufe0e Emacs is available for Linux, MacOSX and Windows. The Spacemacs Readme suggested ways to install Emacs Info::Minimum Emacs Version - 26.3 \u03bb\ufe0e This guide used the develop version of Spacemacs which requires Emacs 26.3 or greater. Here is a summary of the Emacs installation process for several operating system. {% tabs ubuntu=\"Ubuntu\", macosx=\"MacOSX\", windows=\"Windows\", msys2=\"MSYS2\" %} {% content \"ubuntu\" %} Emacs is available via the Ubuntu software manager. Check which version is available using apt-cache show emacs sudo apt-get install emacs Hint::Ubuntu Personal Package Archives \u03bb\ufe0e If the Emacs version you want is not available, add the Personal Package Archive from the Ubuntu Emacs Team . Try the latest nightly builds of Emacs using the emacs-snapshot package, although be aware that some things may break. You can install emacs and emacs-snapshot packages at the same time, calling emacs or emacs-snapshot to run the respective versions of Emacs. {% content \"macosx\" %} For a self-contained install, download Emacs 26.3 or later from the Emacs for OSX website . Alternative, if you use Homebrew, run the following command: brew cask install emacs {% content \"windows\" %} Download Emacs-26.3 from the GNU repository and extract the zip file to %AppData%/local/Programs/emacs . Alternatively, if you are using the Chocolatey package manager then install Emacs version 26 Add the Emacs directory to the PATH variable in your user account environment variables. To start Emacs run the command runemacs.exe . You can also pin this to the start menu or task bar. Hint::Access to common Unix tools \u03bb\ufe0e Command line tools, such as diff , are used by Emacs. To have these command line tools available in Windows, install Emacs as above but then run emacs from a Unix shell such as GitBash . {% content \"msys2\" %} Install Emacs (64bits build) with the following: pacman -S mingw-w64-x86_64-emacs {% endtabs %}","title":"Emacs"},{"location":"clojure-editors/editor-install-guides/emacs/#installing-emacs","text":"Emacs is available for Linux, MacOSX and Windows. The Spacemacs Readme suggested ways to install Emacs","title":"Installing Emacs"},{"location":"clojure-editors/editor-install-guides/emacs/#infominimum-emacs-version-263","text":"This guide used the develop version of Spacemacs which requires Emacs 26.3 or greater. Here is a summary of the Emacs installation process for several operating system. {% tabs ubuntu=\"Ubuntu\", macosx=\"MacOSX\", windows=\"Windows\", msys2=\"MSYS2\" %} {% content \"ubuntu\" %} Emacs is available via the Ubuntu software manager. Check which version is available using apt-cache show emacs sudo apt-get install emacs","title":"Info::Minimum Emacs Version - 26.3"},{"location":"clojure-editors/editor-install-guides/emacs/#hintubuntu-personal-package-archives","text":"If the Emacs version you want is not available, add the Personal Package Archive from the Ubuntu Emacs Team . Try the latest nightly builds of Emacs using the emacs-snapshot package, although be aware that some things may break. You can install emacs and emacs-snapshot packages at the same time, calling emacs or emacs-snapshot to run the respective versions of Emacs. {% content \"macosx\" %} For a self-contained install, download Emacs 26.3 or later from the Emacs for OSX website . Alternative, if you use Homebrew, run the following command: brew cask install emacs {% content \"windows\" %} Download Emacs-26.3 from the GNU repository and extract the zip file to %AppData%/local/Programs/emacs . Alternatively, if you are using the Chocolatey package manager then install Emacs version 26 Add the Emacs directory to the PATH variable in your user account environment variables. To start Emacs run the command runemacs.exe . You can also pin this to the start menu or task bar.","title":"Hint::Ubuntu Personal Package Archives"},{"location":"clojure-editors/editor-install-guides/emacs/#hintaccess-to-common-unix-tools","text":"Command line tools, such as diff , are used by Emacs. To have these command line tools available in Windows, install Emacs as above but then run emacs from a Unix shell such as GitBash . {% content \"msys2\" %} Install Emacs (64bits build) with the following: pacman -S mingw-w64-x86_64-emacs {% endtabs %}","title":"Hint::Access to common Unix tools"},{"location":"clojure-editors/editor-install-guides/intellij-cursive/","text":"IntelliJ / Cursive \u03bb\ufe0e The Cursive user guide has full details of the installation options. Cursive IDE for IntelliJ Install IntelliJ \u03bb\ufe0e Install the community edition of IntelliJ, unless you have the key for a commercial licence. {% tabs linux=\"Debian/Ubuntu\", mac=\"MacOSX\", windows=\"Windows\" %} {% content \"linux\" %} Download the free Community Edition of IntelliJ IDEA Open the ideaC-2018.3.4.tar.gz file, either from your browser download link or from the Downloads directory. {% content \"mac\" %} Download the free Community Edition of IntelliJ IDEA Open the ideaC-2018.3.4.dmg file when downloaded and follow the install instructions. {% content \"windows\" %} Download the free Community Edition of IntelliJ IDEA Open the ideaC-2018.3.4.exe file, either from your browser download link or from the Downloads directory. {% endtabs %} Installing Cursive plugin \u03bb\ufe0e Cursive is a Plugin to IntelliJ. The Installing Cursive section of the Cursive user guide details how to install the plugin Getting a Cursive License \u03bb\ufe0e You can use the free Non-commercial license for this workshop, obtainable from https://cursive-ide.com/buy.html Using Cursive \u03bb\ufe0e Cursive editor guide","title":"IntelliJ / Cursive"},{"location":"clojure-editors/editor-install-guides/intellij-cursive/#intellij-cursive","text":"The Cursive user guide has full details of the installation options. Cursive IDE for IntelliJ","title":"IntelliJ / Cursive"},{"location":"clojure-editors/editor-install-guides/intellij-cursive/#install-intellij","text":"Install the community edition of IntelliJ, unless you have the key for a commercial licence. {% tabs linux=\"Debian/Ubuntu\", mac=\"MacOSX\", windows=\"Windows\" %} {% content \"linux\" %} Download the free Community Edition of IntelliJ IDEA Open the ideaC-2018.3.4.tar.gz file, either from your browser download link or from the Downloads directory. {% content \"mac\" %} Download the free Community Edition of IntelliJ IDEA Open the ideaC-2018.3.4.dmg file when downloaded and follow the install instructions. {% content \"windows\" %} Download the free Community Edition of IntelliJ IDEA Open the ideaC-2018.3.4.exe file, either from your browser download link or from the Downloads directory. {% endtabs %}","title":"Install IntelliJ"},{"location":"clojure-editors/editor-install-guides/intellij-cursive/#installing-cursive-plugin","text":"Cursive is a Plugin to IntelliJ. The Installing Cursive section of the Cursive user guide details how to install the plugin","title":"Installing Cursive plugin"},{"location":"clojure-editors/editor-install-guides/intellij-cursive/#getting-a-cursive-license","text":"You can use the free Non-commercial license for this workshop, obtainable from https://cursive-ide.com/buy.html","title":"Getting a Cursive License"},{"location":"clojure-editors/editor-install-guides/intellij-cursive/#using-cursive","text":"Cursive editor guide","title":"Using Cursive"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/","text":"{% tabs ubuntu=\"Debian/Ubuntu\" %} {% content \"ubuntu\" %} Neovim (plugin) requirements \u03bb\ufe0e Install pip3 package manager for python3 (the default in Ubuntu 20.04) sudo apt install python-pip3 Add msgpack package via pip3, required for the deoplete plugin for neovim) pip3 install --upgrade msgpack Install neovim package \u03bb\ufe0e Use the apt command to install the neovim package sudo apt install neovim Set nvim as the default vim command sudo update-alternatives --config vim {% endtabs %} Install plug.vim package manager \u03bb\ufe0e Plug.vim provides a simple to use packages manager for neovim. {% tabs unix=\"Unix\", powershell=\"Windows Powershell\" %} {% content \"unix\" %} sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' {% content \"powershell\" %} iwr -useb https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim | ` ni \" $env :LOCALAPPDATA/nvim-data/site/autoload/plug.vim\" -Force This created the following tree structure under ~/.local/share/nvim \u251c\u2500\u2500 shada \u2502 \u2514\u2500\u2500 main.shada \u251c\u2500\u2500 site \u2502 \u2514\u2500\u2500 autoload \u2502 \u2514\u2500\u2500 plug.vim \u2514\u2500\u2500 swap Create a neovim init file with essential configuration \u03bb\ufe0e Create a directory for the neovim init file mkdir ~/.config/nvim Create a new init.vim file nvim ~/.config/nvim/init.vim Add plugins for conjure and a few supporting plugins call plug#begin ( stdpath ( 'data' ) . '/plugged' ) \" Conjure Plug 'Olical/conjure', {'tag': 'v4.3.1'} \" Conjure support - jack-in with nrepl dependencies Plug 'tpope/vim-dispatch' Plug 'clojure-vim/vim-jack-in' \" Only in Neovim: Plug 'radenling/vim-dispatch-neovim' call plug#end() The plugins will be saved to the ~/.local/share/nvim/plugged/ directory. A long list of suggested plugins can be found in the Conjure authors neovim configuration Plugins download \u03bb\ufe0e Run neovim and run :PlugInstall to install all the packages defined in the ~/.config/nvim/init.vim file. Use :PlugUpdate to update packages managed by vim-plug. Use :PlugUpgrade to update the vim-plug package itself. Code analysis - ALE and clj-kondo \u03bb\ufe0e Install the clj-kondo lint and static analysis tool to give instant feedback on Clojure syntax and idiomatic code use. Add the dense-analysis/ale plugin to provide Linting with clj-kondo Plug 'dense-analysis/ale' Add the following configuration to specify the binary for Clojure linting with ALE. \" Lint configuration - clj-kondo \" clj-kondo should be installed on operating system path let g:ale_linters = { \\ 'clojure' : [ 'clj-kondo' ] \\} Neovim Themes and Powerline themes \u03bb\ufe0e Gruvbox \u03bb\ufe0e Matches the theme used for Spacemacs https://github.com/morhetz/gruvbox Add following to vim-plug section \" Plug 'morhetz/gruvbox' After vim-plug section, configure the specific Gruvbox theme settings, in this case to use the light theme and use powerline fonts (not sure that makes a difference) let g:airline_solarized_bg = 'light' let g:airline_powerline_fonts = 1 Solarized8 \u03bb\ufe0e https://github.com/lifepillar/vim-solarized8 Plug 'lifepillar/vim-solarized8' set background = light colorscheme solarized8 Practicalli complete configuration \u03bb\ufe0e The ~/.config/nvim/init.vim configuration file used by Practicalli \" Set leader key let maplocalleader = \",\" \" Remap keys \" Use Esc to exit terminal state (used by vim-jack-in) : tnoremap < Esc > < C - \\ >< C - n > \" Use fd as escape, Spacemacs style : inoremap fd < esc > \" Current line number and Relative line numbers set number set relativenumber \" Full color theme support for neovim set termguicolors \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" vim-plug - manage plugins \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Saves plugins to ~/.local/share/nvim/plugged call plug#begin ( stdpath ( 'data' ) . '/plugged' ) \" Starup page Plug 'mhinz/vim-startify' \"\" Version control plugins \" https://github.com/airblade/vim-gitgutter Plug 'airblade/vim-gitgutter' \" File management \" https://github.com/preservim/nerdtree Plug 'preservim/nerdtree' \" Navigation \" https://github.com/easymotion/vim-easymotion Plug 'easymotion/vim-easymotion' \" Searching in projects - ripgrep Plug 'liuchengxu/vim-clap' \" Conjure Plug 'Olical/conjure' , { 'tag' : 'v4.3.1' } \"\"\"\"\"\"\"\"\" \" Conjure support - jack-in with nrepl dependencies \" Start a REPL from within Vim Plug 'tpope/vim-dispatch' Plug 'clojure-vim/vim-jack-in' Plug 'radenling/vim-dispatch-neovim' \" Structural editing for lisp languages Plug 'guns/vim-sexp' Plug 'tpope/vim-sexp-mappings-for-regular-people' \" Auto-close parens Plug 'jiangmiao/auto-pairs' , { 'tag' : 'v2.0.0' } \" Completion support Plug 'Shougo/deoplete.nvim' Plug 'ncm2/float-preview.nvim' \" Linting with clj-kondo Plug 'dense-analysis/ale' \"\"\"\"\"\"\"\"\" \" Themes \" Gruvbox theme \" https://github.com/morhetz/gruvbox/ Plug 'morhetz/gruvbox' \" Spaceline.vim - Status line themes Plug 'hardcoreplayers/spaceline.vim' Plug 'ryanoasis/vim-devicons' call plug# end () \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" The end of plugins for vim-plug \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Plugin configuration \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Enable startify startup screen let g :webdevicons_enable_startify = 1 \" Search in project configuration let g :clap_provider_grep_delay = 50 let g :clap_provider_grep_opts = '-H --no-heading --vimgrep --smart-case --hidden -g \"!.git/\"' nnoremap < leader > * :Clap grep ++ query =< cword >< cr > nnoremap < leader > fg :Clap grep < cr > nnoremap < leader > ff :Clap files -- hidden < cr > nnoremap < leader > fb :Clap buffers < cr > nnoremap < leader > fw :Clap windows < cr > nnoremap < leader > fr :Clap history < cr > nnoremap < leader > fh :Clap command_history < cr > nnoremap < leader > fj :Clap jumps < cr > nnoremap < leader > fl :Clap blines < cr > nnoremap < leader > fL :Clap lines < cr > nnoremap < leader > ft :Clap filetypes < cr > nnoremap < leader > fm :Clap marks < cr > \" Completion configuration let g :deoplete#enable_at_startup = 1 call deoplete#custom# option ( 'keyword_patterns' , { 'clojure' : '[\\w!$%&*+/:<=>?@\\^_~\\-\\.#]*' } ) set completeopt -= preview let g :float_preview#docked = 0 let g :float_preview#max_width = 80 let g :float_preview#max_height = 40 \" Lint configuration - clj-kondo \" clj-kondo should be installed on operating system path let g :ale_linters = { \\ 'clojure' : [ 'clj-kondo' ] \\} \" Set Gruvbox theme set background = light autocmd vimenter * colorscheme gruvbox \" Spaceline.vim configuration let g :spaceline_colorscheme = 'one' TODO::work in progress, sorry \u03bb\ufe0e Additional configuration to try \u03bb\ufe0e Spacemacs like mappings for window interactions using SPC w prefix. Configured with a combination of: * https://github.com/Olical/dotfiles/blob/master/stowed/.config/nvim/fnl/dotfiles/module/mapping.fnl * https://github.com/liuchengxu/vim-better-default Useful keybinding reference: * https://github.com/liuchengxu/vim-better-default/wiki/a-brief-introduction-to-key-bindings","title":"Neovim conjure"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#neovim-plugin-requirements","text":"Install pip3 package manager for python3 (the default in Ubuntu 20.04) sudo apt install python-pip3 Add msgpack package via pip3, required for the deoplete plugin for neovim) pip3 install --upgrade msgpack","title":"Neovim (plugin) requirements"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#install-neovim-package","text":"Use the apt command to install the neovim package sudo apt install neovim Set nvim as the default vim command sudo update-alternatives --config vim {% endtabs %}","title":"Install neovim package"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#install-plugvim-package-manager","text":"Plug.vim provides a simple to use packages manager for neovim. {% tabs unix=\"Unix\", powershell=\"Windows Powershell\" %} {% content \"unix\" %} sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' {% content \"powershell\" %} iwr -useb https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim | ` ni \" $env :LOCALAPPDATA/nvim-data/site/autoload/plug.vim\" -Force This created the following tree structure under ~/.local/share/nvim \u251c\u2500\u2500 shada \u2502 \u2514\u2500\u2500 main.shada \u251c\u2500\u2500 site \u2502 \u2514\u2500\u2500 autoload \u2502 \u2514\u2500\u2500 plug.vim \u2514\u2500\u2500 swap","title":"Install plug.vim package manager"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#create-a-neovim-init-file-with-essential-configuration","text":"Create a directory for the neovim init file mkdir ~/.config/nvim Create a new init.vim file nvim ~/.config/nvim/init.vim Add plugins for conjure and a few supporting plugins call plug#begin ( stdpath ( 'data' ) . '/plugged' ) \" Conjure Plug 'Olical/conjure', {'tag': 'v4.3.1'} \" Conjure support - jack-in with nrepl dependencies Plug 'tpope/vim-dispatch' Plug 'clojure-vim/vim-jack-in' \" Only in Neovim: Plug 'radenling/vim-dispatch-neovim' call plug#end() The plugins will be saved to the ~/.local/share/nvim/plugged/ directory. A long list of suggested plugins can be found in the Conjure authors neovim configuration","title":"Create a neovim init file with essential configuration"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#plugins-download","text":"Run neovim and run :PlugInstall to install all the packages defined in the ~/.config/nvim/init.vim file. Use :PlugUpdate to update packages managed by vim-plug. Use :PlugUpgrade to update the vim-plug package itself.","title":"Plugins download"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#code-analysis-ale-and-clj-kondo","text":"Install the clj-kondo lint and static analysis tool to give instant feedback on Clojure syntax and idiomatic code use. Add the dense-analysis/ale plugin to provide Linting with clj-kondo Plug 'dense-analysis/ale' Add the following configuration to specify the binary for Clojure linting with ALE. \" Lint configuration - clj-kondo \" clj-kondo should be installed on operating system path let g:ale_linters = { \\ 'clojure' : [ 'clj-kondo' ] \\}","title":"Code analysis - ALE and clj-kondo"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#neovim-themes-and-powerline-themes","text":"","title":"Neovim Themes and Powerline themes"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#gruvbox","text":"Matches the theme used for Spacemacs https://github.com/morhetz/gruvbox Add following to vim-plug section \" Plug 'morhetz/gruvbox' After vim-plug section, configure the specific Gruvbox theme settings, in this case to use the light theme and use powerline fonts (not sure that makes a difference) let g:airline_solarized_bg = 'light' let g:airline_powerline_fonts = 1","title":"Gruvbox"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#solarized8","text":"https://github.com/lifepillar/vim-solarized8 Plug 'lifepillar/vim-solarized8' set background = light colorscheme solarized8","title":"Solarized8"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#practicalli-complete-configuration","text":"The ~/.config/nvim/init.vim configuration file used by Practicalli \" Set leader key let maplocalleader = \",\" \" Remap keys \" Use Esc to exit terminal state (used by vim-jack-in) : tnoremap < Esc > < C - \\ >< C - n > \" Use fd as escape, Spacemacs style : inoremap fd < esc > \" Current line number and Relative line numbers set number set relativenumber \" Full color theme support for neovim set termguicolors \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" vim-plug - manage plugins \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Saves plugins to ~/.local/share/nvim/plugged call plug#begin ( stdpath ( 'data' ) . '/plugged' ) \" Starup page Plug 'mhinz/vim-startify' \"\" Version control plugins \" https://github.com/airblade/vim-gitgutter Plug 'airblade/vim-gitgutter' \" File management \" https://github.com/preservim/nerdtree Plug 'preservim/nerdtree' \" Navigation \" https://github.com/easymotion/vim-easymotion Plug 'easymotion/vim-easymotion' \" Searching in projects - ripgrep Plug 'liuchengxu/vim-clap' \" Conjure Plug 'Olical/conjure' , { 'tag' : 'v4.3.1' } \"\"\"\"\"\"\"\"\" \" Conjure support - jack-in with nrepl dependencies \" Start a REPL from within Vim Plug 'tpope/vim-dispatch' Plug 'clojure-vim/vim-jack-in' Plug 'radenling/vim-dispatch-neovim' \" Structural editing for lisp languages Plug 'guns/vim-sexp' Plug 'tpope/vim-sexp-mappings-for-regular-people' \" Auto-close parens Plug 'jiangmiao/auto-pairs' , { 'tag' : 'v2.0.0' } \" Completion support Plug 'Shougo/deoplete.nvim' Plug 'ncm2/float-preview.nvim' \" Linting with clj-kondo Plug 'dense-analysis/ale' \"\"\"\"\"\"\"\"\" \" Themes \" Gruvbox theme \" https://github.com/morhetz/gruvbox/ Plug 'morhetz/gruvbox' \" Spaceline.vim - Status line themes Plug 'hardcoreplayers/spaceline.vim' Plug 'ryanoasis/vim-devicons' call plug# end () \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" The end of plugins for vim-plug \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Plugin configuration \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Enable startify startup screen let g :webdevicons_enable_startify = 1 \" Search in project configuration let g :clap_provider_grep_delay = 50 let g :clap_provider_grep_opts = '-H --no-heading --vimgrep --smart-case --hidden -g \"!.git/\"' nnoremap < leader > * :Clap grep ++ query =< cword >< cr > nnoremap < leader > fg :Clap grep < cr > nnoremap < leader > ff :Clap files -- hidden < cr > nnoremap < leader > fb :Clap buffers < cr > nnoremap < leader > fw :Clap windows < cr > nnoremap < leader > fr :Clap history < cr > nnoremap < leader > fh :Clap command_history < cr > nnoremap < leader > fj :Clap jumps < cr > nnoremap < leader > fl :Clap blines < cr > nnoremap < leader > fL :Clap lines < cr > nnoremap < leader > ft :Clap filetypes < cr > nnoremap < leader > fm :Clap marks < cr > \" Completion configuration let g :deoplete#enable_at_startup = 1 call deoplete#custom# option ( 'keyword_patterns' , { 'clojure' : '[\\w!$%&*+/:<=>?@\\^_~\\-\\.#]*' } ) set completeopt -= preview let g :float_preview#docked = 0 let g :float_preview#max_width = 80 let g :float_preview#max_height = 40 \" Lint configuration - clj-kondo \" clj-kondo should be installed on operating system path let g :ale_linters = { \\ 'clojure' : [ 'clj-kondo' ] \\} \" Set Gruvbox theme set background = light autocmd vimenter * colorscheme gruvbox \" Spaceline.vim configuration let g :spaceline_colorscheme = 'one'","title":"Practicalli complete configuration"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"clojure-editors/editor-install-guides/neovim-conjure/#additional-configuration-to-try","text":"Spacemacs like mappings for window interactions using SPC w prefix. Configured with a combination of: * https://github.com/Olical/dotfiles/blob/master/stowed/.config/nvim/fnl/dotfiles/module/mapping.fnl * https://github.com/liuchengxu/vim-better-default Useful keybinding reference: * https://github.com/liuchengxu/vim-better-default/wiki/a-brief-introduction-to-key-bindings","title":"Additional configuration to try"},{"location":"clojure-editors/editor-install-guides/spacevim-configuration/","text":"Understanding the SpaceVim configuration \u03bb\ufe0e Read the SpaceVim documentation for a complete guide to the configuration. Set the SpaceVim option \u03bb\ufe0e SpaceVim now uses toml language as the configuration. All SpaceVim options are configured in a dictionary and the key is removed from the original option name.g:spacevim_ g:spacevim_enable_guicolors -> enable_guicolors The value of this option can be true or false, so the write configuration is: [options] enable_guicolors = false Options values \u200bcan be numbers or strings. The format of string is similar to vim script, either single quotes or double quotes [options] enable_guicolors = false snippet_engine = \"neosnippet\" statusline_separator = 'arrow' sidebar_width = 30 Managing layers \u03bb\ufe0e SpaceVim adds functionality via layers consisting of plug-ins and configuration to make those plug-ins work. SpaceVim has a range of pre-defined layers . Enable layers by including a [[layers]] section in the .Spacevim.d/init.toml file. To enable the shell layer [[layers]] name = \"shell\" default_position = \"top\" default_height = 30 When the enable layer variable is set to false, that layer is disabled [[layers]] name = \"shell\" enable = false Custom plug-ins \u03bb\ufe0e Custom plug-ins add functionality outside of that provided by SpaceVim layers. The name variable is the name of the vim plug-in. [[custom_plugins]] name = \"lilydjwg/colorizer\" merged = 0 [[custom_plugins]] name = \"tpope/vim-scriptease\" merged = 0 on_cmd = \"Scriptnames\" Define when configuration is called \u03bb\ufe0e In the [options] section of the config bootstrap_before and bootstrap_after are strings that contain a vim method name. [options] enable_guicolors = false snippet_engine = \"neosnippet\" statusline_separator = 'arrow' sidebar_width = 30 bootstrap_before = \"myspacevim#before\" bootstrap_after = \"myspacevim#after\" Create a new ~/.SpaceVim.d/autoload/myspacevim.vim and define a function function! myspacevim#before() abort let g:neomake_enabled_c_makers = ['clang'] nnoremap jk <esc> endf function! myspacevim#after() abort endf Variables, shortcut and other vim scripts, such as customizing some autocmd, can be included. augroup MySpaceVim au! autocmd FileType markdown setlocal nowrap augroup END","title":"Understanding the SpaceVim configuration"},{"location":"clojure-editors/editor-install-guides/spacevim-configuration/#understanding-the-spacevim-configuration","text":"Read the SpaceVim documentation for a complete guide to the configuration.","title":"Understanding the SpaceVim configuration"},{"location":"clojure-editors/editor-install-guides/spacevim-configuration/#set-the-spacevim-option","text":"SpaceVim now uses toml language as the configuration. All SpaceVim options are configured in a dictionary and the key is removed from the original option name.g:spacevim_ g:spacevim_enable_guicolors -> enable_guicolors The value of this option can be true or false, so the write configuration is: [options] enable_guicolors = false Options values \u200bcan be numbers or strings. The format of string is similar to vim script, either single quotes or double quotes [options] enable_guicolors = false snippet_engine = \"neosnippet\" statusline_separator = 'arrow' sidebar_width = 30","title":"Set the SpaceVim option"},{"location":"clojure-editors/editor-install-guides/spacevim-configuration/#managing-layers","text":"SpaceVim adds functionality via layers consisting of plug-ins and configuration to make those plug-ins work. SpaceVim has a range of pre-defined layers . Enable layers by including a [[layers]] section in the .Spacevim.d/init.toml file. To enable the shell layer [[layers]] name = \"shell\" default_position = \"top\" default_height = 30 When the enable layer variable is set to false, that layer is disabled [[layers]] name = \"shell\" enable = false","title":"Managing layers"},{"location":"clojure-editors/editor-install-guides/spacevim-configuration/#custom-plug-ins","text":"Custom plug-ins add functionality outside of that provided by SpaceVim layers. The name variable is the name of the vim plug-in. [[custom_plugins]] name = \"lilydjwg/colorizer\" merged = 0 [[custom_plugins]] name = \"tpope/vim-scriptease\" merged = 0 on_cmd = \"Scriptnames\"","title":"Custom plug-ins"},{"location":"clojure-editors/editor-install-guides/spacevim-configuration/#define-when-configuration-is-called","text":"In the [options] section of the config bootstrap_before and bootstrap_after are strings that contain a vim method name. [options] enable_guicolors = false snippet_engine = \"neosnippet\" statusline_separator = 'arrow' sidebar_width = 30 bootstrap_before = \"myspacevim#before\" bootstrap_after = \"myspacevim#after\" Create a new ~/.SpaceVim.d/autoload/myspacevim.vim and define a function function! myspacevim#before() abort let g:neomake_enabled_c_makers = ['clang'] nnoremap jk <esc> endf function! myspacevim#after() abort endf Variables, shortcut and other vim scripts, such as customizing some autocmd, can be included. augroup MySpaceVim au! autocmd FileType markdown setlocal nowrap augroup END","title":"Define when configuration is called"},{"location":"clojure-editors/editor-install-guides/spacevim-fireplace/","text":"SpaceVim and vim-fireplace: Install guide \u03bb\ufe0e {% tabs automatic=\"Automatic install\", manual=\"Manual install\" %} {% content \"automatic\" %} Run the install script and select dark powered mode. All the default curl -sLf https://spacevim.org/install.sh | bash The SpaceVim install script moves an existing ~/.vimrc to ~/.vimrc_back . {% content \"manual\" %} Try SpaceVim without over-writing an existing Vim or Neovim configuration by installing manually. git clone https://github.com/SpaceVim/SpaceVim.git ~/.SpaceVim Then create an alias to run spacevim on the command line alias svim='vim -u ~/.SpaceVim/vimrc' Run nvim command in a terminal and Spacevim will install the plug-ins from the default layers. See the quick start guide for other install options Make vimproc Library \u03bb\ufe0e SpaceVim uses vimproc library and should build the library file during the installation. If the build failed then the following error is shown when running neovim [vimproc] vimproc's DLL: \"~/.SpaceVim/bundle/vimproc.vim/lib/vimproc_linux64.so\" is not found. To resolve this issue, change into the vimproc.vim bundle director and run the make command cd ~/.SpaceVim/bundle/vimproc.vim/ make Configure Spacevim options \u03bb\ufe0e Edit the .Spacevim.d/init.toml file, or use SPC f v d to open this configuration file. Update the options to your own preferences. Practicalli uses a light theme and rebinds the escape sequence to \"fd\". vim-ale is configured to use clj-kondo, disabling the neomake checker [options] # Set the Spacevim theme, full colour and status line theme colorscheme = \"gruvbox\" colorscheme_bg = \"light\" enable_guicolors = true statusline_separator = \"arrow\" statusline_iseparator = \"arrow\" buffer_index_type = 4 enable_tabline_filetype_icon = true enable_statusline_mode = false # Alternate Escape key binding, default \"jk\" escape_key_binding = \"fd\" # Code analysis - clj-kondo with ale enable_neomake = false enable_ale = true lint_on_the_fly = true ale_linters = ['clojure' ['clj-kondo']] :colorscheme TAB to show a pop-up menu of available themes core#statusline layer describes options in detail Add Spacemacs Layers \u03bb\ufe0e SpaceVim uses several layers by default . Practicalli recommends the following available layers for file management, version control, autocompletion, command line shell and Clojure development. Edit the ~/.Spacevim.d/init.toml file and add the additional layers. SPC q q to quit SpaceVim and then run nvim to start Neovim and install the plug-ins automatically. ######################################### # Layers ######################################### # Each layer requires its own [[layers]] section ######################################### # File management [[layers]] name = 'fzf' ######################################### # version control [[layers]] name = \"VersionControl\" enable-gtm-status = true [[layers]] name = 'git' [[layers]] name = 'github' ######################################### # Enable autocomplete layer [[layers]] name = 'autocomplete' auto_completion_return_key_behavior = \"complete\" auto_completion_tab_key_behavior = \"smart\" ######################################### # Command line [[layers]] name = 'shell' default_position = 'top' default_height = 30 ######################################### # Clojure development [[layers]] name = \"lang#clojure\"","title":"SpaceVim and vim-fireplace: Install guide"},{"location":"clojure-editors/editor-install-guides/spacevim-fireplace/#spacevim-and-vim-fireplace-install-guide","text":"{% tabs automatic=\"Automatic install\", manual=\"Manual install\" %} {% content \"automatic\" %} Run the install script and select dark powered mode. All the default curl -sLf https://spacevim.org/install.sh | bash The SpaceVim install script moves an existing ~/.vimrc to ~/.vimrc_back . {% content \"manual\" %} Try SpaceVim without over-writing an existing Vim or Neovim configuration by installing manually. git clone https://github.com/SpaceVim/SpaceVim.git ~/.SpaceVim Then create an alias to run spacevim on the command line alias svim='vim -u ~/.SpaceVim/vimrc' Run nvim command in a terminal and Spacevim will install the plug-ins from the default layers. See the quick start guide for other install options","title":"SpaceVim and vim-fireplace: Install guide"},{"location":"clojure-editors/editor-install-guides/spacevim-fireplace/#make-vimproc-library","text":"SpaceVim uses vimproc library and should build the library file during the installation. If the build failed then the following error is shown when running neovim [vimproc] vimproc's DLL: \"~/.SpaceVim/bundle/vimproc.vim/lib/vimproc_linux64.so\" is not found. To resolve this issue, change into the vimproc.vim bundle director and run the make command cd ~/.SpaceVim/bundle/vimproc.vim/ make","title":"Make vimproc Library"},{"location":"clojure-editors/editor-install-guides/spacevim-fireplace/#configure-spacevim-options","text":"Edit the .Spacevim.d/init.toml file, or use SPC f v d to open this configuration file. Update the options to your own preferences. Practicalli uses a light theme and rebinds the escape sequence to \"fd\". vim-ale is configured to use clj-kondo, disabling the neomake checker [options] # Set the Spacevim theme, full colour and status line theme colorscheme = \"gruvbox\" colorscheme_bg = \"light\" enable_guicolors = true statusline_separator = \"arrow\" statusline_iseparator = \"arrow\" buffer_index_type = 4 enable_tabline_filetype_icon = true enable_statusline_mode = false # Alternate Escape key binding, default \"jk\" escape_key_binding = \"fd\" # Code analysis - clj-kondo with ale enable_neomake = false enable_ale = true lint_on_the_fly = true ale_linters = ['clojure' ['clj-kondo']] :colorscheme TAB to show a pop-up menu of available themes core#statusline layer describes options in detail","title":"Configure Spacevim options"},{"location":"clojure-editors/editor-install-guides/spacevim-fireplace/#add-spacemacs-layers","text":"SpaceVim uses several layers by default . Practicalli recommends the following available layers for file management, version control, autocompletion, command line shell and Clojure development. Edit the ~/.Spacevim.d/init.toml file and add the additional layers. SPC q q to quit SpaceVim and then run nvim to start Neovim and install the plug-ins automatically. ######################################### # Layers ######################################### # Each layer requires its own [[layers]] section ######################################### # File management [[layers]] name = 'fzf' ######################################### # version control [[layers]] name = \"VersionControl\" enable-gtm-status = true [[layers]] name = 'git' [[layers]] name = 'github' ######################################### # Enable autocomplete layer [[layers]] name = 'autocomplete' auto_completion_return_key_behavior = \"complete\" auto_completion_tab_key_behavior = \"smart\" ######################################### # Command line [[layers]] name = 'shell' default_position = 'top' default_height = 30 ######################################### # Clojure development [[layers]] name = \"lang#clojure\"","title":"Add Spacemacs Layers"},{"location":"clojure-editors/editor-install-guides/vim-plugins/","text":"NeoVim Plugins - a smorgasbord of functionality \u03bb\ufe0e All plugins can be used with VimPlug (unless explicitly expressed otherwise). Hint::Work in progress - suggestions very welcome \u03bb\ufe0e Clojure development tools \u03bb\ufe0e Plugin Dependencies Description Olical/conjure Clojure development tpope/vim-dispatch Asynchronous adapters for Vim plugins radenling/vim-dispatch-neovim vim-dispatch neovim terminal emulator and job control for dispatch.vim clojure-vim/vim-jack-in vim-dispatch Jack in to Boot, Clj & Leiningen guns/vim-sexp vim-repeat Structural editing for lisp languages tpope/vim-sexp-mappings-for-regular-people vim-sexp jiangmiao/auto-pairs Auto-close parens w0rp/ale Linting with clj-kondo kien/rainbow_parentheses.vim tpope/vim-surround svermeulen/vim-yoink Fireplace specific plugins * https://github.com/clojure-vim/vim-cider - depends on cider-nrepl and refactor-nrepl libraries from the orchard * Completion frameworks \u03bb\ufe0e Plugin Dependencies Description Conquer of Completion node.js Fast incremental completion, increment buffer sync and LSP support Shougo/deoplete.nvim Python 3.6.1 asynchronous completion framework ncm2/float-preview.nvim File managers \u03bb\ufe0e Plugin Dependencies Description preservim/nerdtree Visual file browser Navigation \u03bb\ufe0e Plugin Dependencies Description easymotion/vim-easymotion Searching \u03bb\ufe0e Plugin Dependencies Description liuchengxu/vim-clap generic interactive finder and dispatcher, based on the newly feature: floating_win of neovim startup page \u03bb\ufe0e Plugin Dependencies Description vim-startify Fancy startup page with recently used or bookmarked files and persistent sessions Version Control \u03bb\ufe0e Plugin Dependencies Description airblade/vim-gitgutter Show version control changes in the gutter (margin) Themes \u03bb\ufe0e Plugin Dependencies Description nordvim A dark theme with blue focus, includes lightline and airline themes vim-airline/vim-airline vim-airline/vim-airline-themes morhetz/gruvbox Gruvbox theme lifepillar/vim-solarized8 Solarized theme (dark and light) hardcoreplayers/spaceline.vim Spaceline theme ryanoasis/vim-devicons Spaceline theme icons https://github.com/rakr/vim-one Light and dark theme https://github.com/itchyny/lightline.vim Status line theme","title":"NeoVim Plugins - a smorgasbord of functionality"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#neovim-plugins-a-smorgasbord-of-functionality","text":"All plugins can be used with VimPlug (unless explicitly expressed otherwise).","title":"NeoVim Plugins - a smorgasbord of functionality"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#hintwork-in-progress-suggestions-very-welcome","text":"","title":"Hint::Work in progress - suggestions very welcome"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#clojure-development-tools","text":"Plugin Dependencies Description Olical/conjure Clojure development tpope/vim-dispatch Asynchronous adapters for Vim plugins radenling/vim-dispatch-neovim vim-dispatch neovim terminal emulator and job control for dispatch.vim clojure-vim/vim-jack-in vim-dispatch Jack in to Boot, Clj & Leiningen guns/vim-sexp vim-repeat Structural editing for lisp languages tpope/vim-sexp-mappings-for-regular-people vim-sexp jiangmiao/auto-pairs Auto-close parens w0rp/ale Linting with clj-kondo kien/rainbow_parentheses.vim tpope/vim-surround svermeulen/vim-yoink Fireplace specific plugins * https://github.com/clojure-vim/vim-cider - depends on cider-nrepl and refactor-nrepl libraries from the orchard *","title":"Clojure development tools"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#completion-frameworks","text":"Plugin Dependencies Description Conquer of Completion node.js Fast incremental completion, increment buffer sync and LSP support Shougo/deoplete.nvim Python 3.6.1 asynchronous completion framework ncm2/float-preview.nvim","title":"Completion frameworks"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#file-managers","text":"Plugin Dependencies Description preservim/nerdtree Visual file browser","title":"File managers"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#navigation","text":"Plugin Dependencies Description easymotion/vim-easymotion","title":"Navigation"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#searching","text":"Plugin Dependencies Description liuchengxu/vim-clap generic interactive finder and dispatcher, based on the newly feature: floating_win of neovim","title":"Searching"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#startup-page","text":"Plugin Dependencies Description vim-startify Fancy startup page with recently used or bookmarked files and persistent sessions","title":"startup page"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#version-control","text":"Plugin Dependencies Description airblade/vim-gitgutter Show version control changes in the gutter (margin)","title":"Version Control"},{"location":"clojure-editors/editor-install-guides/vim-plugins/#themes","text":"Plugin Dependencies Description nordvim A dark theme with blue focus, includes lightline and airline themes vim-airline/vim-airline vim-airline/vim-airline-themes morhetz/gruvbox Gruvbox theme lifepillar/vim-solarized8 Solarized theme (dark and light) hardcoreplayers/spaceline.vim Spaceline theme ryanoasis/vim-devicons Spaceline theme icons https://github.com/rakr/vim-one Light and dark theme https://github.com/itchyny/lightline.vim Status line theme","title":"Themes"},{"location":"clojure-editors/editor-install-guides/vscode-calva/","text":"Microsoft VSCode and Calva extension \u03bb\ufe0e VS Code supports Clojure and ClojureScript development through an extension called Calva . Warning::Calva with LSP has moments of high memory use \u03bb\ufe0e The current version of Calva runs clojure-lsp when opening a Clojure project. The clojure-lsp process will use a noticeable amount of memory, especially with a large number of dependencies in a project. Use Calva version 2.0.136 if RAM resources are very constrained. A specific version can be selected via Extensions > Calva extension settings > Install Another Version... Install VS Code \u03bb\ufe0e {% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} Download the .deb file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Enter your password when prompted to install the software. Close the Ubuntu Software app once the install has finished. Reference: VSCode on Linux Running VSCode \u03bb\ufe0e To run VSCode, press the Super key and type code , or open a terminal and type the command code . {% content \"mac\" %} Download the .zip file Double-click on the downloaded archive to expand the contents. Drag Visual Studio Code.app to the Applications folder, making it available in the Launchpad. Add VS Code to your Dock by right-clicking on the icon and choosing Options, Keep in Dock . Reference: VSCode on MacOSX Running VSCode \u03bb\ufe0e Launch VSCode from the Dock, or in a command line terminal, type code . {% content \"redhat\" %} Download the .rpm file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Running VSCode \u03bb\ufe0e To run VSCode, press the Super key and type code , or open a terminal and type the command code . Reference: VSCode on Linux {% content \"windows\" %} Download the Windows Installer Run the installer which should have a name similar to VSCodeUserSetup-{version}.exe . VS Code is installed under C:\\users\\{username}\\AppData\\Local\\Programs\\Microsoft VS Code . Reference: VSCode on Windows Running VSCode \u03bb\ufe0e Open the Start menu and type code . Click on the VSCode icon to start. {% endtabs %} Install Calva extension \u03bb\ufe0e Select the Extensions icon in the left hand navigation. Type calva into the search box to list the relevant extensions to install Click the Install button next to the Calva: Clojure & ClojureScript interactive programming extension. After a few moments the extension will show as installed. HINT::No restart required \u03bb\ufe0e VSCode version 1.31.1 does not need to restart after installing the extensions. Calva 2 was released in May 2019, please remove any older extensions","title":"Microsoft VSCode and Calva extension"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#microsoft-vscode-and-calva-extension","text":"VS Code supports Clojure and ClojureScript development through an extension called Calva .","title":"Microsoft VSCode and Calva extension"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#warningcalva-with-lsp-has-moments-of-high-memory-use","text":"The current version of Calva runs clojure-lsp when opening a Clojure project. The clojure-lsp process will use a noticeable amount of memory, especially with a large number of dependencies in a project. Use Calva version 2.0.136 if RAM resources are very constrained. A specific version can be selected via Extensions > Calva extension settings > Install Another Version...","title":"Warning::Calva with LSP has moments of high memory use"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#install-vs-code","text":"{% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} Download the .deb file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Enter your password when prompted to install the software. Close the Ubuntu Software app once the install has finished. Reference: VSCode on Linux","title":"Install VS Code"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#running-vscode","text":"To run VSCode, press the Super key and type code , or open a terminal and type the command code . {% content \"mac\" %} Download the .zip file Double-click on the downloaded archive to expand the contents. Drag Visual Studio Code.app to the Applications folder, making it available in the Launchpad. Add VS Code to your Dock by right-clicking on the icon and choosing Options, Keep in Dock . Reference: VSCode on MacOSX","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#running-vscode_1","text":"Launch VSCode from the Dock, or in a command line terminal, type code . {% content \"redhat\" %} Download the .rpm file Open (double click) the file. The Ubuntu software studio will open. Click the Install button.","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#running-vscode_2","text":"To run VSCode, press the Super key and type code , or open a terminal and type the command code . Reference: VSCode on Linux {% content \"windows\" %} Download the Windows Installer Run the installer which should have a name similar to VSCodeUserSetup-{version}.exe . VS Code is installed under C:\\users\\{username}\\AppData\\Local\\Programs\\Microsoft VS Code . Reference: VSCode on Windows","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#running-vscode_3","text":"Open the Start menu and type code . Click on the VSCode icon to start. {% endtabs %}","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#install-calva-extension","text":"Select the Extensions icon in the left hand navigation. Type calva into the search box to list the relevant extensions to install Click the Install button next to the Calva: Clojure & ClojureScript interactive programming extension. After a few moments the extension will show as installed.","title":"Install Calva extension"},{"location":"clojure-editors/editor-install-guides/vscode-calva/#hintno-restart-required","text":"VSCode version 1.31.1 does not need to restart after installing the extensions. Calva 2 was released in May 2019, please remove any older extensions","title":"HINT::No restart required"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/","text":"VSpaceCode configuration for VSCode and Calva extension \u03bb\ufe0e VS Code supports Clojure and ClojureScript development through an extension called Calva . Note::VSpaceCode releases after 0.8.5 will included Calva key bindings directly \u03bb\ufe0e VSpaceCode bindings for Calva were added via pull request #154 which will be included in the next VSpaceCode release. Currently key bindings can be copied once the VSpaceCode extension is installed. Warning::Calva with LSP has moments of high memory use \u03bb\ufe0e The latest version of Calva runs clojure-lsp when opening a Clojure project. The clojure-lsp process may use a noticeable amount of memory, especially with a large number of dependencies in a project. The maintainers are actively working to resolve this and have already made improvements. Use Calva version 2.0.136 if RAM resources are very constrained. A specific version can be selected via Extensions > Calva extension settings >Install Another Version... Install VSCode \u03bb\ufe0e {% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} Download the .deb file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Enter your password when prompted to install the software. Close the Ubuntu Software app once the install has finished. Reference: VSCode on Linux Running VSCode \u03bb\ufe0e To run VSCode, press the Super key and type code , or open a terminal and type the command code . {% content \"mac\" %} Download the .zip file Double-click on the downloaded archive to expand the contents. Drag Visual Studio Code.app to the Applications folder, making it available in the Launchpad. Add VS Code to your Dock by right-clicking on the icon and choosing Options, Keep in Dock . Reference: VSCode on MacOSX Running VSCode \u03bb\ufe0e Launch VSCode from the Dock, or in a command line terminal, type code . {% content \"redhat\" %} Download the .rpm file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Running VSCode \u03bb\ufe0e To run VSCode, press the Super key and type code , or open a terminal and type the command code . Reference: VSCode on Linux {% content \"windows\" %} Download the Windows Installer Run the installer which should have a name similar to VSCodeUserSetup-{version}.exe . VS Code is installed under C:\\users\\{username}\\AppData\\Local\\Programs\\Microsoft VS Code . Reference: VSCode on Windows Running VSCode \u03bb\ufe0e Open the Start menu and type code . Click on the VSCode icon to start. {% endtabs %} Install Calva extension \u03bb\ufe0e Select the Extensions icon in the left hand navigation. Type calva into the search box to list the relevant extension Click the Install button next to the Calva: Clojure & ClojureScript interactive programming extension. After a few moments the extension will show as installed. Install VS Code extension \u03bb\ufe0e Select the Extensions icon in the left hand navigation. Type vspacecode into the search box to list the relevant extension Click the Install button next to the VSpaceCode extension. After a few momments the extension will show as installed, along with several other extensions that VSpaceCode uses. Settings and Keybinding install \u03bb\ufe0e Ctrl+Shift+p ( SPC SPC when VSpaceCode keys are working) opens the VS Code command menu, type vspacecode to narrow the command list and select VSpaceCode: Configure Default Settings and Keybindings . Save the settings.json and keybindings.json by searching Preference: Open Settings (JSON) and Preference: Open Keyboard Shortcuts (JSON) in the command palette ( Ctl+Shift+P ) Remap the Calva Esc key \u03bb\ufe0e Calva extension adds Esc as a keyboard shortcut for clearing evaluation results. This binding breaks vim-style editing in VSpaceCode, so the Calva keyboard shortcut should be remapped. SPC SPC opens the VSCode command menu, type keyboard to narrow the command list and select Preferences: Open keyboard shortcuts (JSON) . Toward the end of the settings.json file, add the following configuration. This removes Esc from the calva.clearInlineResults and creates a new keyboard shortcut for that command using Shift Esc { \"key\" : \"escape\" , \"command\" : \"-calva.clearInlineResults\" }, { \"key\" : \"shift+escape\" , \"command\" : \"calva.clearInlineResults\" , \"when\" : \"editorTextFocus && !editorHasMultipleSelections && !editorReadOnly && !hasOtherSuggestions && !suggestWidgetVisible && editorLangId == 'clojure'\" }, Add the Calva specific keyboard shortcuts \u03bb\ufe0e Required for VSpaceCode version 0.8.5 or earlier. Later version will include the Clojure keybindings for the Calva extension pull request . SPC f f and select the ~/.vscode/extensions/vspacecode.vspacecode-0.8.5/package.json file. / followed by Major to find the location to add the clojure keyboard shortcuts Open the Clojure keybindings pull request and copy the code from the package.json change to your local package.json file. SPC f s to save the file and the keyboard shortcuts will be available when opening a Clojure file. Configure theme and font \u03bb\ufe0e SPC SPC opens the VSCode command menu, type settings to narrow the command list and select Preferences: Open Settings (JSON) . Change the preferences for theme, font size, font family and window zoom level (size of graphical parts of the VS Code windows - positive numbers for larger, negative for smaller). \"workbench.colorTheme\" : \"Solarized Light\" , \"editor.fontSize\" : 14 , \"editor.fontFamily\" : \"'Fira Code', 'Ubuntu Mono', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'\" , \"window.zoomLevel\" : 0 , SPC f f to save changes and apply them directly. Fira Code and Ubuntu Mono fonts may require installing on your operating system.","title":"VSpaceCode configuration for VSCode and Calva extension"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#vspacecode-configuration-for-vscode-and-calva-extension","text":"VS Code supports Clojure and ClojureScript development through an extension called Calva .","title":"VSpaceCode configuration for VSCode and Calva extension"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#notevspacecode-releases-after-085-will-included-calva-key-bindings-directly","text":"VSpaceCode bindings for Calva were added via pull request #154 which will be included in the next VSpaceCode release. Currently key bindings can be copied once the VSpaceCode extension is installed.","title":"Note::VSpaceCode releases after 0.8.5 will included Calva key bindings directly"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#warningcalva-with-lsp-has-moments-of-high-memory-use","text":"The latest version of Calva runs clojure-lsp when opening a Clojure project. The clojure-lsp process may use a noticeable amount of memory, especially with a large number of dependencies in a project. The maintainers are actively working to resolve this and have already made improvements. Use Calva version 2.0.136 if RAM resources are very constrained. A specific version can be selected via Extensions > Calva extension settings >Install Another Version...","title":"Warning::Calva with LSP has moments of high memory use"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#install-vscode","text":"{% tabs debian=\"Debian/Ubuntu\", mac=\"MacOSX\", redhat=\"RedHat\", windows=\"Windows\" %} {% content \"debian\" %} Download the .deb file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Enter your password when prompted to install the software. Close the Ubuntu Software app once the install has finished. Reference: VSCode on Linux","title":"Install VSCode"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#running-vscode","text":"To run VSCode, press the Super key and type code , or open a terminal and type the command code . {% content \"mac\" %} Download the .zip file Double-click on the downloaded archive to expand the contents. Drag Visual Studio Code.app to the Applications folder, making it available in the Launchpad. Add VS Code to your Dock by right-clicking on the icon and choosing Options, Keep in Dock . Reference: VSCode on MacOSX","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#running-vscode_1","text":"Launch VSCode from the Dock, or in a command line terminal, type code . {% content \"redhat\" %} Download the .rpm file Open (double click) the file. The Ubuntu software studio will open. Click the Install button.","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#running-vscode_2","text":"To run VSCode, press the Super key and type code , or open a terminal and type the command code . Reference: VSCode on Linux {% content \"windows\" %} Download the Windows Installer Run the installer which should have a name similar to VSCodeUserSetup-{version}.exe . VS Code is installed under C:\\users\\{username}\\AppData\\Local\\Programs\\Microsoft VS Code . Reference: VSCode on Windows","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#running-vscode_3","text":"Open the Start menu and type code . Click on the VSCode icon to start. {% endtabs %}","title":"Running VSCode"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#install-calva-extension","text":"Select the Extensions icon in the left hand navigation. Type calva into the search box to list the relevant extension Click the Install button next to the Calva: Clojure & ClojureScript interactive programming extension. After a few moments the extension will show as installed.","title":"Install Calva extension"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#install-vs-code-extension","text":"Select the Extensions icon in the left hand navigation. Type vspacecode into the search box to list the relevant extension Click the Install button next to the VSpaceCode extension. After a few momments the extension will show as installed, along with several other extensions that VSpaceCode uses.","title":"Install VS Code extension"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#settings-and-keybinding-install","text":"Ctrl+Shift+p ( SPC SPC when VSpaceCode keys are working) opens the VS Code command menu, type vspacecode to narrow the command list and select VSpaceCode: Configure Default Settings and Keybindings . Save the settings.json and keybindings.json by searching Preference: Open Settings (JSON) and Preference: Open Keyboard Shortcuts (JSON) in the command palette ( Ctl+Shift+P )","title":"Settings and Keybinding install"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#remap-the-calva-esc-key","text":"Calva extension adds Esc as a keyboard shortcut for clearing evaluation results. This binding breaks vim-style editing in VSpaceCode, so the Calva keyboard shortcut should be remapped. SPC SPC opens the VSCode command menu, type keyboard to narrow the command list and select Preferences: Open keyboard shortcuts (JSON) . Toward the end of the settings.json file, add the following configuration. This removes Esc from the calva.clearInlineResults and creates a new keyboard shortcut for that command using Shift Esc { \"key\" : \"escape\" , \"command\" : \"-calva.clearInlineResults\" }, { \"key\" : \"shift+escape\" , \"command\" : \"calva.clearInlineResults\" , \"when\" : \"editorTextFocus && !editorHasMultipleSelections && !editorReadOnly && !hasOtherSuggestions && !suggestWidgetVisible && editorLangId == 'clojure'\" },","title":"Remap the Calva Esc key"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#add-the-calva-specific-keyboard-shortcuts","text":"Required for VSpaceCode version 0.8.5 or earlier. Later version will include the Clojure keybindings for the Calva extension pull request . SPC f f and select the ~/.vscode/extensions/vspacecode.vspacecode-0.8.5/package.json file. / followed by Major to find the location to add the clojure keyboard shortcuts Open the Clojure keybindings pull request and copy the code from the package.json change to your local package.json file. SPC f s to save the file and the keyboard shortcuts will be available when opening a Clojure file.","title":"Add the Calva specific keyboard shortcuts"},{"location":"clojure-editors/editor-install-guides/vspacecode-calva/#configure-theme-and-font","text":"SPC SPC opens the VSCode command menu, type settings to narrow the command list and select Preferences: Open Settings (JSON) . Change the preferences for theme, font size, font family and window zoom level (size of graphical parts of the VS Code windows - positive numbers for larger, negative for smaller). \"workbench.colorTheme\" : \"Solarized Light\" , \"editor.fontSize\" : 14 , \"editor.fontFamily\" : \"'Fira Code', 'Ubuntu Mono', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'\" , \"window.zoomLevel\" : 0 , SPC f f to save changes and apply them directly. Fira Code and Ubuntu Mono fonts may require installing on your operating system.","title":"Configure theme and font"},{"location":"clojure-editors/editor-user-guides/","text":"Clojure Editors: Quick User Guides \u03bb\ufe0e User guides that cover the essential ways of using Clojure aware editors, to get you up and running with the minimum of reading. See the official websites for more extensive details. Quick start guides Detailed guides Atom and ProtoREPL quick start Atom & Proton quick start Proton Manual VSpaceCode & Calva quick start VSCode & Calva quick start Calva - How to use Spacemacs quick start & Practicalli Spacemacs book Spacemacs documentation NeoVim & Conjure quick start Conjure SpaceVim & Fireplace User Guide SpaceVim Documentation vim-iced Vim-iced quick-start IntelliJ & Cursive Cursive quick start","title":"Clojure Editors: Quick User Guides"},{"location":"clojure-editors/editor-user-guides/#clojure-editors-quick-user-guides","text":"User guides that cover the essential ways of using Clojure aware editors, to get you up and running with the minimum of reading. See the official websites for more extensive details. Quick start guides Detailed guides Atom and ProtoREPL quick start Atom & Proton quick start Proton Manual VSpaceCode & Calva quick start VSCode & Calva quick start Calva - How to use Spacemacs quick start & Practicalli Spacemacs book Spacemacs documentation NeoVim & Conjure quick start Conjure SpaceVim & Fireplace User Guide SpaceVim Documentation vim-iced Vim-iced quick-start IntelliJ & Cursive Cursive quick start","title":"Clojure Editors: Quick User Guides"},{"location":"clojure-editors/editor-user-guides/atom-proton/","text":"Atom.io and Proton user guide \u03bb\ufe0e A simplified user guide to get you started quickly and a list of keyboard shortcuts . Please take a look at the Proton documentation for a detailed guide. Space menu \u03bb\ufe0e SPC means press the Space bar on the keyboard. This displays a text menu to run the most common commands. , means press the comma key. This will open the language specific menu. So when a Clojure window pane is displayed, , will show you commands specific to Clojure. You can also use SPC m to get to the same Clojure menu. Add Clojure Project to Atom \u03bb\ufe0e SPC f f to add a Clojure project to Atom. This should be a project created with Leiningen . Open the project.clj file and add the latest proto-repl library as a dependency Start a Local Clojure REPL \u03bb\ufe0e , s i will start a REPL using the Clojure project A new window pane will open in Atom and the REPL will start in a few seconds. Connecting to a Remote REPL \u03bb\ufe0e , s c will connect to a running REPL, (i.e. that was started in a terminal with the command lein repl ). When prompted, enter the hosts and port number from the already running REPL. These details were shown when the REPL was run. Evaluate code in the REPL \u03bb\ufe0e shift+enter evaluates code that you type in the REPL window. The REPL maintains a history of the code typed in and can be navigated by using the up and down arrow keys. Evaluate code in the source file \u03bb\ufe0e , e b evaluates an expression (a block of code) , e B evaluates the outer-most expression (top block) , e r evaluates a selected region of code Changing the REPL Namespace \u03bb\ufe0e Change the REPL namespace to get access to the functions in that namespace. Place your cursor in the namespace definition, (ns my-namespace ,,,) , e B evaluates the namespace expression and change the REPL to this new namespace. Save changes in the source code file \u03bb\ufe0e SPC f s will save the current file. Commenting / uncommenting code \u03bb\ufe0e SPC ; will comment or uncomment the current line. Use v to select a region of code and SPC ; will comment or uncomment that region. Increase / decrease font size \u03bb\ufe0e Ctrl + and Ctrl - will increase and decrease the size of the font in the editor windows. To increase the size of the font in the UI, you need to edit the theme Settings > Theme > Theme name > settings cog icon Hint::Atom UI styles CSS \u03bb\ufe0e You can set the size of font used for the Atom UI, along with other CSS styles, by editing the ~/.atom/styles.less file. See this styles.less gist for examples of changes to the general styles and for theme specific styles, such as with one-dark-ui","title":"Atom.io and Proton user guide"},{"location":"clojure-editors/editor-user-guides/atom-proton/#atomio-and-proton-user-guide","text":"A simplified user guide to get you started quickly and a list of keyboard shortcuts . Please take a look at the Proton documentation for a detailed guide.","title":"Atom.io and Proton user guide"},{"location":"clojure-editors/editor-user-guides/atom-proton/#space-menu","text":"SPC means press the Space bar on the keyboard. This displays a text menu to run the most common commands. , means press the comma key. This will open the language specific menu. So when a Clojure window pane is displayed, , will show you commands specific to Clojure. You can also use SPC m to get to the same Clojure menu.","title":"Space menu"},{"location":"clojure-editors/editor-user-guides/atom-proton/#add-clojure-project-to-atom","text":"SPC f f to add a Clojure project to Atom. This should be a project created with Leiningen . Open the project.clj file and add the latest proto-repl library as a dependency","title":"Add Clojure Project to Atom"},{"location":"clojure-editors/editor-user-guides/atom-proton/#start-a-local-clojure-repl","text":", s i will start a REPL using the Clojure project A new window pane will open in Atom and the REPL will start in a few seconds.","title":"Start a Local Clojure REPL"},{"location":"clojure-editors/editor-user-guides/atom-proton/#connecting-to-a-remote-repl","text":", s c will connect to a running REPL, (i.e. that was started in a terminal with the command lein repl ). When prompted, enter the hosts and port number from the already running REPL. These details were shown when the REPL was run.","title":"Connecting to a Remote REPL"},{"location":"clojure-editors/editor-user-guides/atom-proton/#evaluate-code-in-the-repl","text":"shift+enter evaluates code that you type in the REPL window. The REPL maintains a history of the code typed in and can be navigated by using the up and down arrow keys.","title":"Evaluate code in the REPL"},{"location":"clojure-editors/editor-user-guides/atom-proton/#evaluate-code-in-the-source-file","text":", e b evaluates an expression (a block of code) , e B evaluates the outer-most expression (top block) , e r evaluates a selected region of code","title":"Evaluate code in the source file"},{"location":"clojure-editors/editor-user-guides/atom-proton/#changing-the-repl-namespace","text":"Change the REPL namespace to get access to the functions in that namespace. Place your cursor in the namespace definition, (ns my-namespace ,,,) , e B evaluates the namespace expression and change the REPL to this new namespace.","title":"Changing the REPL Namespace"},{"location":"clojure-editors/editor-user-guides/atom-proton/#save-changes-in-the-source-code-file","text":"SPC f s will save the current file.","title":"Save changes in the source code file"},{"location":"clojure-editors/editor-user-guides/atom-proton/#commenting-uncommenting-code","text":"SPC ; will comment or uncomment the current line. Use v to select a region of code and SPC ; will comment or uncomment that region.","title":"Commenting / uncommenting code"},{"location":"clojure-editors/editor-user-guides/atom-proton/#increase-decrease-font-size","text":"Ctrl + and Ctrl - will increase and decrease the size of the font in the editor windows. To increase the size of the font in the UI, you need to edit the theme Settings > Theme > Theme name > settings cog icon","title":"Increase / decrease font size"},{"location":"clojure-editors/editor-user-guides/atom-proton/#hintatom-ui-styles-css","text":"You can set the size of font used for the Atom UI, along with other CSS styles, by editing the ~/.atom/styles.less file. See this styles.less gist for examples of changes to the general styles and for theme specific styles, such as with one-dark-ui","title":"Hint::Atom UI styles CSS"},{"location":"clojure-editors/editor-user-guides/atom-protorepl/","text":"Atom and ProtoREPL user guide \u03bb\ufe0e A simplified user guide to get you started quickly and a list of keyboard shortcuts . Please take a look at the ProtoREPL documentation for a detailed guides. {% youtube %} https://youtu.be/_P7urPN2QRQ Start a Local Clojure REPL \u03bb\ufe0e Ctrl-Shift-a to add a Clojure project to Atom. This should be a project created with Leiningen . Open the project.clj file and add the latest proto-repl library as a dependency Ctrl-Shift-p to pop-up the Command Palette (cmd-shift-p) and select Proto REPL: Toggle ctrl-alt-, e will exit the REPL, (i.e. once you have finished the workshop). Connecting to a Remote REPL \u03bb\ufe0e Proto REPL can connect to a Clojure REPL started with Leiningen on the command line. Ctrl-Alt-, y and enter the hosts and port number from the already running REPL. Alternatively, use Ctrl-Shift-p to pop-up the Command Palette (cmd-shift-p) and select Proto REPL: Remote Nrepl Connection . Enter the host and port of the REPL to establish the connection. Evaluating Code \u03bb\ufe0e Code can be evaluated in a Clojure file or the REPL window. shift+enter to evaluate code typed in the REPL window. The REPL maintains a history of the code typed in and can be navigated by using the up and down arrow keys. ctrl-alt-, b evaluates an expression (a block of code) ctrl-alt-, s evaluates a selected area of code ctrl-alt-, f evaluates the whole Clojure file Changing the REPL Namespace \u03bb\ufe0e Change the REPL namespace to get access to the functions in that namespace. Place your cursor in the namespace definition, (ns my-namespace ,,,) ctrl-alt-, b evaluates the namespace expression and change the REPL to this new namespace. Keybindings and Events \u03bb\ufe0e Keyboard shortcuts below refer to using ctrl-alt-, then a letter. This means press the ctrl key and the comma key at the same time, release them, and then press the subsequent letter. Keybinding Action ctrl-alt-, L Starts the REPL ctrl-alt-, shift-L Starts the REPL using the current open project.clj ctrl-alt-, y Connects to a remote nREPL session. ctrl-alt-, j Starts a self hosted REPL. ctrl-alt-, e Exits the REPL ctrl-alt-, k Clears REPL Output ctrl-alt-shift-, s Enables/Disables autoscrolling the REPL ctrl-alt-, b Sends the current block of Clojure code to the REPL for execution. ctrl-alt-, B Sends the current top-level block of Clojure code to the REPL for execution. ctrl-alt-, s Sends the selected text to the REPL for execution. ctrl-alt-, f Loads the current file in the repl. ctrl-alt-, r Runs the user/reset function. See Clojure Workflow, Reloaded ctrl-alt-shift-, r Clears all loaded namespaces using clojure.tools.namespace the runs the user/reset function. ctrl-alt-, p Pretty prints the last value returned at the REPL. ctrl-alt-, x Runs all the tests in the current namespace. ctrl-alt-, t Runs the test that has a name under the cursor. ctrl-alt-, a Runs all the test in the current project. ctrl-alt-, d Prints the documentation of a var under the cursor. ctrl-alt-, c Prints out the code of the var under the cursor. ctrl-alt-, o Opens the code of the var or namespace under the cursor. This works even with vars defined in libraries. ctrl-alt-, n Lists the vars in the namespace under the cursor. ctrl-alt-shift-, n Lists the vars in the namespace under the cursor with documentation. shift-ctrl-c Attempts to interrupt the currently running command in the REPL. ctrl-alt-shift-, i Inserts a call to proto/save with a unique id ctrl-alt-shift-, d Displays values saved using the proto/save function. ctrl-alt-shift-, c Clears previously saved values using the proto/save function.","title":"Atom and ProtoREPL user guide"},{"location":"clojure-editors/editor-user-guides/atom-protorepl/#atom-and-protorepl-user-guide","text":"A simplified user guide to get you started quickly and a list of keyboard shortcuts . Please take a look at the ProtoREPL documentation for a detailed guides. {% youtube %} https://youtu.be/_P7urPN2QRQ","title":"Atom and ProtoREPL user guide"},{"location":"clojure-editors/editor-user-guides/atom-protorepl/#start-a-local-clojure-repl","text":"Ctrl-Shift-a to add a Clojure project to Atom. This should be a project created with Leiningen . Open the project.clj file and add the latest proto-repl library as a dependency Ctrl-Shift-p to pop-up the Command Palette (cmd-shift-p) and select Proto REPL: Toggle ctrl-alt-, e will exit the REPL, (i.e. once you have finished the workshop).","title":"Start a Local Clojure REPL"},{"location":"clojure-editors/editor-user-guides/atom-protorepl/#connecting-to-a-remote-repl","text":"Proto REPL can connect to a Clojure REPL started with Leiningen on the command line. Ctrl-Alt-, y and enter the hosts and port number from the already running REPL. Alternatively, use Ctrl-Shift-p to pop-up the Command Palette (cmd-shift-p) and select Proto REPL: Remote Nrepl Connection . Enter the host and port of the REPL to establish the connection.","title":"Connecting to a Remote REPL"},{"location":"clojure-editors/editor-user-guides/atom-protorepl/#evaluating-code","text":"Code can be evaluated in a Clojure file or the REPL window. shift+enter to evaluate code typed in the REPL window. The REPL maintains a history of the code typed in and can be navigated by using the up and down arrow keys. ctrl-alt-, b evaluates an expression (a block of code) ctrl-alt-, s evaluates a selected area of code ctrl-alt-, f evaluates the whole Clojure file","title":"Evaluating Code"},{"location":"clojure-editors/editor-user-guides/atom-protorepl/#changing-the-repl-namespace","text":"Change the REPL namespace to get access to the functions in that namespace. Place your cursor in the namespace definition, (ns my-namespace ,,,) ctrl-alt-, b evaluates the namespace expression and change the REPL to this new namespace.","title":"Changing the REPL Namespace"},{"location":"clojure-editors/editor-user-guides/atom-protorepl/#keybindings-and-events","text":"Keyboard shortcuts below refer to using ctrl-alt-, then a letter. This means press the ctrl key and the comma key at the same time, release them, and then press the subsequent letter. Keybinding Action ctrl-alt-, L Starts the REPL ctrl-alt-, shift-L Starts the REPL using the current open project.clj ctrl-alt-, y Connects to a remote nREPL session. ctrl-alt-, j Starts a self hosted REPL. ctrl-alt-, e Exits the REPL ctrl-alt-, k Clears REPL Output ctrl-alt-shift-, s Enables/Disables autoscrolling the REPL ctrl-alt-, b Sends the current block of Clojure code to the REPL for execution. ctrl-alt-, B Sends the current top-level block of Clojure code to the REPL for execution. ctrl-alt-, s Sends the selected text to the REPL for execution. ctrl-alt-, f Loads the current file in the repl. ctrl-alt-, r Runs the user/reset function. See Clojure Workflow, Reloaded ctrl-alt-shift-, r Clears all loaded namespaces using clojure.tools.namespace the runs the user/reset function. ctrl-alt-, p Pretty prints the last value returned at the REPL. ctrl-alt-, x Runs all the tests in the current namespace. ctrl-alt-, t Runs the test that has a name under the cursor. ctrl-alt-, a Runs all the test in the current project. ctrl-alt-, d Prints the documentation of a var under the cursor. ctrl-alt-, c Prints out the code of the var under the cursor. ctrl-alt-, o Opens the code of the var or namespace under the cursor. This works even with vars defined in libraries. ctrl-alt-, n Lists the vars in the namespace under the cursor. ctrl-alt-shift-, n Lists the vars in the namespace under the cursor with documentation. shift-ctrl-c Attempts to interrupt the currently running command in the REPL. ctrl-alt-shift-, i Inserts a call to proto/save with a unique id ctrl-alt-shift-, d Displays values saved using the proto/save function. ctrl-alt-shift-, c Clears previously saved values using the proto/save function.","title":"Keybindings and Events"},{"location":"clojure-editors/editor-user-guides/emacs-spacemacs/","text":"Emacs and Spacemacs user guide \u03bb\ufe0e A simplified user guide to get you started quickly. Please take a look at the Spacemacs documentation and Practicalli Spacemacs book for detailed guides. {% youtube %} https://youtu.be/tzj1y4hNwrA Starting a Clojure REPL \u03bb\ufe0e SPC f f to open a Clojure or ClojureScript file. Type the path and filename of the file (possible matches of existing files narrow as you type). Now start either a Clojure or ClojureScript REPL , ' or M-RET ' to start a Clojure repl. , \" or M-RET \" to start a ClojureScript repl. Evaluating code \u03bb\ufe0e In the Clojure or ClojureScript file you opened, you can evaluate specific expressions (any parts of the code in () ) or symbols. , e f will evaluate the outer most expression and show the result inline. , e ; will evaluate the outer most expression and show the result as a comment. , e e will evaluate the last expression before the cursor position (eg. to the left or above). Changing the REPL Namespace \u03bb\ufe0e , s n changes the namespace to that in the current code buffer Hint::Practicalli Spacemacs \u03bb\ufe0e Practicalli Spacemacs is a detailed guide to Clojure development with Spacemacs and is freely available. Practicalli Spacemacs YouTube playlist contains all the videos from the book.","title":"Emacs and Spacemacs user guide"},{"location":"clojure-editors/editor-user-guides/emacs-spacemacs/#emacs-and-spacemacs-user-guide","text":"A simplified user guide to get you started quickly. Please take a look at the Spacemacs documentation and Practicalli Spacemacs book for detailed guides. {% youtube %} https://youtu.be/tzj1y4hNwrA","title":"Emacs and Spacemacs user guide"},{"location":"clojure-editors/editor-user-guides/emacs-spacemacs/#starting-a-clojure-repl","text":"SPC f f to open a Clojure or ClojureScript file. Type the path and filename of the file (possible matches of existing files narrow as you type). Now start either a Clojure or ClojureScript REPL , ' or M-RET ' to start a Clojure repl. , \" or M-RET \" to start a ClojureScript repl.","title":"Starting a Clojure REPL"},{"location":"clojure-editors/editor-user-guides/emacs-spacemacs/#evaluating-code","text":"In the Clojure or ClojureScript file you opened, you can evaluate specific expressions (any parts of the code in () ) or symbols. , e f will evaluate the outer most expression and show the result inline. , e ; will evaluate the outer most expression and show the result as a comment. , e e will evaluate the last expression before the cursor position (eg. to the left or above).","title":"Evaluating code"},{"location":"clojure-editors/editor-user-guides/emacs-spacemacs/#changing-the-repl-namespace","text":", s n changes the namespace to that in the current code buffer","title":"Changing the REPL Namespace"},{"location":"clojure-editors/editor-user-guides/emacs-spacemacs/#hintpracticalli-spacemacs","text":"Practicalli Spacemacs is a detailed guide to Clojure development with Spacemacs and is freely available. Practicalli Spacemacs YouTube playlist contains all the videos from the book.","title":"Hint::Practicalli Spacemacs"},{"location":"clojure-editors/editor-user-guides/intellij-cursive/","text":"IntelliJ and Cursive user guide \u03bb\ufe0e See the different sections of the Cursive user guide GitHub issue #5 TODO::Create a quick start user guide \u03bb\ufe0e Create a quick start user guide for key parts of using Cursive for Clojure development.","title":"IntelliJ and Cursive user guide"},{"location":"clojure-editors/editor-user-guides/intellij-cursive/#intellij-and-cursive-user-guide","text":"See the different sections of the Cursive user guide GitHub issue #5","title":"IntelliJ and Cursive user guide"},{"location":"clojure-editors/editor-user-guides/intellij-cursive/#todocreate-a-quick-start-user-guide","text":"Create a quick start user guide for key parts of using Cursive for Clojure development.","title":"TODO::Create a quick start user guide"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/","text":"OS X Setup \u03bb\ufe0e Start a terminal Install Git Configure Git Make sure Java is installed Install Leiningen Install Light Table Test your setup Troubleshooting OS X 10.6.8 Yosemite Starting a terminal \u03bb\ufe0e For these instructions, and for much of the class, you will need to have a terminal, or command line, open. This is a text-based interface to talk to your computer, and you can open it by running Terminal.app, which is found under /Applications/Utilities . If you have never used the terminal before, you may want to spend some time reading up on command-line basics . Go ahead and open your terminal now. It should look something like this: The prompt (where you will type your commands) may look different: it usually shows the computer name and user name, as well as the folder or directory you are currently in. For the rest of this setup, I will tell you to run commands in your terminal. When I say that, I mean \"type the command into the terminal and press the Return key.\" Install Git \u03bb\ufe0e To see if you have git installed type in: git --version If you have git version 1.9.3 (Apple Git-50) or above you should be fine. If not, visit git-scm.com . Click \"Downloads for Mac\". The Git installer may begin downloading automatically. If it does not, click the manual download link. Once the download has finished, open ~/Downloads in Finder and double-click the downloaded file (named something like git-2.0.1-intel-universal-snow-leopard.dmg ). This will mount the disk image and open a new Finder window. Double-click the installer package (named something like git-2.0.1-intel-universal-snow-leopard.pkg ). You may be told that the installer can't be opened because it is from an unidentified developer. If so, click \"OK\", then right-click (or control-click) the file and select \"Open\" from the contextual menu. You may be warned again that the installer is from an unidentified developer, but this time you'll have the option to click \"Open\". Do so. This will launch the installer. Follow its directions, and enter your password when prompted to do so. Once you have finished this process it's safe to unmount the disk image (by clicking the eject button in the Finder sidebar) and delete the file from the Downloads folder. Configure Git \u03bb\ufe0e If you've used Git before then you should already have user.name and user.email configured. Otherwise, type this in the terminal: git config --global user.name \"Your Actual Name\" git config --global user.email \"Your Actual Email\" TIP: Use the same email address for git, github, and ssh. Verify by typing this in the terminal: git config --get user.name Expected result: your name git config --get user.email Expected result: your email address Making sure Java is installed \u03bb\ufe0e If you have OS X version 10.11 (El Capitan), you don't have Java installed. You need to install Java as well. Download Java from http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html and follow the instruction. Once installation finishes, set JAVA_HOME environment variable on the terminal. export JAVA_HOME=/usr/libexec/java_home -v 1.8 If you have a trouble, the article, http://osxdaily.com/2015/10/17/how-to-install-java-in-os-x-el-capitan/ , may help. Run java -version in your terminal. If you do not have Java installed, OS X will prompt you to install it (if your OS X is 10.10 or older). Follow all of the directions OS X gives you, then return to this part of the tutorial and run java -version again. If Java is installed, you will see something like this in your terminal: The details of Java's version may differ from what you see above; that is perfectly fine. Install Leiningen \u03bb\ufe0e Leiningen is a tool used on the command line to manage Clojure projects. To install lein , execute the following commands in your terminal; you will be prompted to enter your password for at least the first command starting with sudo (The % character is a typical commandline prompt, don't type it): % curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein > lein % sudo mkdir -p /usr/local/bin/ % sudo mv lein /usr/local/bin/lein % sudo chmod a+x /usr/local/bin/lein Check that you can now see the command: % which lein /usr/local/bin/lein If you don't see /usr/local/bin/lein as above, do this next: % export PATH = $PATH :/usr/local/bin Now run which lein and you should see the lein command. After you set up Leiningen as above, run the lein version command. This should take a while to run, as it will download some resources it needs the first time. If it completes successfully, you are golden! If not, ask an instructor for help. Install Light Table \u03bb\ufe0e Go to the Light Table site . On the page there, you should see a set of buttons that have download links for Light Table. Click the \"OS X 10.7+\" button and you will download a .zip file. There should now be a file named LightTableMac.zip in your Downloads folder. Double-click the file to unzip it, then move LightTable.app to your Applications folder. The first time you launch Light Table you will be presented with a confirmation prompt. Click \"Open\". Opening files in Light Table from the command line (optional) \u03bb\ufe0e Run the following commands to create a \"shortcut command\" called light-table : echo \"alias light-table='open -a /Applications/LightTable/LightTable.app'\" >> ~/.bash_profile source ~/.bash_profile You can now open files and folders in Light Table from the command line by entering light-table path/to/the/file/you/want/to/open.clj . Test your setup \u03bb\ufe0e You have set up Java, Leiningen, Light Table, and Git on your computer--all the tools you will need for this workshop. Before starting, we need to test them out. Cloning out github repository \u03bb\ufe0e Go to your terminal and run the following command: git clone https://github.com/ClojureBridge/welcometoclojurebridge This will clone welcometoclojurebridge repository which includes sample Clojure apps. Your terminal should look similar to this picture: Testing lein repl \u03bb\ufe0e Then run the command: cd welcometoclojurebridge This will take you to the directory with the source code. After that completes, run: lein repl This could take a long time, and will download many other pieces of code apps rely on. You should see lines that start with Retrieving ... on your screen. When it finishes, your terminal should look like the following: This is starting a REPL, which we will learn about soon. It's a special terminal for Clojure. At the REPL prompt, type (+ 1 1) and press Return. Did you get the answer 2 back? You will learn more about that in the course. For now, press the Control button and D button on your keyboard together (abbreviated as Ctrl+D). This should take you out of the Clojure REPL and back to your normal terminal prompt. Then, the terminal will show you the following message: user=> Bye for now! Testing Light Table \u03bb\ufe0e Now we will open and run the sample Clojure apps in Light Table. Start LightTable from Applications > LightTable. In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Cmd + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Cmd + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Cmd + Enter You should see this on the Light Table: also, your turtle should move. Success! \u03bb\ufe0e Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed! For convenience \u03bb\ufe0e automatic closing of parentheses \u03bb\ufe0e Enabling auto-closing parens. This has been disabled, because it tends to break with none english keyboard layouts! But if you use the EN layout you should be fine. Quote from the link: What I needed to do was add this form to the User behaviors configuration: To do so, I followed these steps: Ctrl-Space to open Commands Type user behaviors and click the proposed command This open a file that you can edit to add [:app :lt.objs.settings/pair-keymap-diffs] show line numbers \u03bb\ufe0e To show line numbers: * Ctrl-Space to open Commands * Type user behaviors and click the proposed command * This open a file that you can edit to add [:editor :lt.objs.editor/line-numbers] down wrap lines around \u03bb\ufe0e To not have lines wrap around if they are to long for the screen: * Ctrl-Space to open Commands * Type user behaviors and click the proposed command * This open a file that you can edit to add [:editor :lt.objs.editor/no-wrap] Troubleshooting \u03bb\ufe0e OS X 10.6.8 \u03bb\ufe0e Light Table actually does work on OS X 10.6.8. It thinks it does not. To convince it otherwise, do this: Use a text editor to open /Applications/LightTable.app/Contents/Info.plist Search for the key LSMinimumSystemVersion Remove that key from the file. Delete this entire text: LSMinimumSystemVersion 10.7.5 Save the file, and you should be able to start Light Table. Yosemite \u03bb\ufe0e Yosemite was released after Light Table development was stalled. Because of this historical reason, students may encounter troubles to start or use Light Table on Yosemite. In such a case, Nightcode is another option. See the instruction, Getting Started with Clojure using Nightcode .","title":"Lighttable osx"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#os-x-setup","text":"Start a terminal Install Git Configure Git Make sure Java is installed Install Leiningen Install Light Table Test your setup Troubleshooting OS X 10.6.8 Yosemite","title":"OS X Setup"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#starting-a-terminal","text":"For these instructions, and for much of the class, you will need to have a terminal, or command line, open. This is a text-based interface to talk to your computer, and you can open it by running Terminal.app, which is found under /Applications/Utilities . If you have never used the terminal before, you may want to spend some time reading up on command-line basics . Go ahead and open your terminal now. It should look something like this: The prompt (where you will type your commands) may look different: it usually shows the computer name and user name, as well as the folder or directory you are currently in. For the rest of this setup, I will tell you to run commands in your terminal. When I say that, I mean \"type the command into the terminal and press the Return key.\"","title":"Starting a terminal"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#install-git","text":"To see if you have git installed type in: git --version If you have git version 1.9.3 (Apple Git-50) or above you should be fine. If not, visit git-scm.com . Click \"Downloads for Mac\". The Git installer may begin downloading automatically. If it does not, click the manual download link. Once the download has finished, open ~/Downloads in Finder and double-click the downloaded file (named something like git-2.0.1-intel-universal-snow-leopard.dmg ). This will mount the disk image and open a new Finder window. Double-click the installer package (named something like git-2.0.1-intel-universal-snow-leopard.pkg ). You may be told that the installer can't be opened because it is from an unidentified developer. If so, click \"OK\", then right-click (or control-click) the file and select \"Open\" from the contextual menu. You may be warned again that the installer is from an unidentified developer, but this time you'll have the option to click \"Open\". Do so. This will launch the installer. Follow its directions, and enter your password when prompted to do so. Once you have finished this process it's safe to unmount the disk image (by clicking the eject button in the Finder sidebar) and delete the file from the Downloads folder.","title":"Install Git"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#configure-git","text":"If you've used Git before then you should already have user.name and user.email configured. Otherwise, type this in the terminal: git config --global user.name \"Your Actual Name\" git config --global user.email \"Your Actual Email\" TIP: Use the same email address for git, github, and ssh. Verify by typing this in the terminal: git config --get user.name Expected result: your name git config --get user.email Expected result: your email address","title":"Configure Git"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#making-sure-java-is-installed","text":"If you have OS X version 10.11 (El Capitan), you don't have Java installed. You need to install Java as well. Download Java from http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html and follow the instruction. Once installation finishes, set JAVA_HOME environment variable on the terminal. export JAVA_HOME=/usr/libexec/java_home -v 1.8 If you have a trouble, the article, http://osxdaily.com/2015/10/17/how-to-install-java-in-os-x-el-capitan/ , may help. Run java -version in your terminal. If you do not have Java installed, OS X will prompt you to install it (if your OS X is 10.10 or older). Follow all of the directions OS X gives you, then return to this part of the tutorial and run java -version again. If Java is installed, you will see something like this in your terminal: The details of Java's version may differ from what you see above; that is perfectly fine.","title":"Making sure Java is installed"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#install-leiningen","text":"Leiningen is a tool used on the command line to manage Clojure projects. To install lein , execute the following commands in your terminal; you will be prompted to enter your password for at least the first command starting with sudo (The % character is a typical commandline prompt, don't type it): % curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein > lein % sudo mkdir -p /usr/local/bin/ % sudo mv lein /usr/local/bin/lein % sudo chmod a+x /usr/local/bin/lein Check that you can now see the command: % which lein /usr/local/bin/lein If you don't see /usr/local/bin/lein as above, do this next: % export PATH = $PATH :/usr/local/bin Now run which lein and you should see the lein command. After you set up Leiningen as above, run the lein version command. This should take a while to run, as it will download some resources it needs the first time. If it completes successfully, you are golden! If not, ask an instructor for help.","title":"Install Leiningen"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#install-light-table","text":"Go to the Light Table site . On the page there, you should see a set of buttons that have download links for Light Table. Click the \"OS X 10.7+\" button and you will download a .zip file. There should now be a file named LightTableMac.zip in your Downloads folder. Double-click the file to unzip it, then move LightTable.app to your Applications folder. The first time you launch Light Table you will be presented with a confirmation prompt. Click \"Open\".","title":"Install Light Table"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#opening-files-in-light-table-from-the-command-line-optional","text":"Run the following commands to create a \"shortcut command\" called light-table : echo \"alias light-table='open -a /Applications/LightTable/LightTable.app'\" >> ~/.bash_profile source ~/.bash_profile You can now open files and folders in Light Table from the command line by entering light-table path/to/the/file/you/want/to/open.clj .","title":"Opening files in Light Table from the command line (optional)"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#test-your-setup","text":"You have set up Java, Leiningen, Light Table, and Git on your computer--all the tools you will need for this workshop. Before starting, we need to test them out.","title":"Test your setup"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#cloning-out-github-repository","text":"Go to your terminal and run the following command: git clone https://github.com/ClojureBridge/welcometoclojurebridge This will clone welcometoclojurebridge repository which includes sample Clojure apps. Your terminal should look similar to this picture:","title":"Cloning out github repository"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#testing-lein-repl","text":"Then run the command: cd welcometoclojurebridge This will take you to the directory with the source code. After that completes, run: lein repl This could take a long time, and will download many other pieces of code apps rely on. You should see lines that start with Retrieving ... on your screen. When it finishes, your terminal should look like the following: This is starting a REPL, which we will learn about soon. It's a special terminal for Clojure. At the REPL prompt, type (+ 1 1) and press Return. Did you get the answer 2 back? You will learn more about that in the course. For now, press the Control button and D button on your keyboard together (abbreviated as Ctrl+D). This should take you out of the Clojure REPL and back to your normal terminal prompt. Then, the terminal will show you the following message: user=> Bye for now!","title":"Testing lein repl"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#testing-light-table","text":"Now we will open and run the sample Clojure apps in Light Table. Start LightTable from Applications > LightTable. In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Cmd + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Cmd + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Cmd + Enter You should see this on the Light Table: also, your turtle should move.","title":"Testing Light Table"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#success","text":"Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed!","title":"Success!"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#for-convenience","text":"","title":"For convenience"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#automatic-closing-of-parentheses","text":"Enabling auto-closing parens. This has been disabled, because it tends to break with none english keyboard layouts! But if you use the EN layout you should be fine. Quote from the link: What I needed to do was add this form to the User behaviors configuration: To do so, I followed these steps: Ctrl-Space to open Commands Type user behaviors and click the proposed command This open a file that you can edit to add [:app :lt.objs.settings/pair-keymap-diffs]","title":"automatic closing of parentheses"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#show-line-numbers","text":"To show line numbers: * Ctrl-Space to open Commands * Type user behaviors and click the proposed command * This open a file that you can edit to add [:editor :lt.objs.editor/line-numbers]","title":"show line numbers"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#down-wrap-lines-around","text":"To not have lines wrap around if they are to long for the screen: * Ctrl-Space to open Commands * Type user behaviors and click the proposed command * This open a file that you can edit to add [:editor :lt.objs.editor/no-wrap]","title":"down wrap lines around"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#os-x-1068","text":"Light Table actually does work on OS X 10.6.8. It thinks it does not. To convince it otherwise, do this: Use a text editor to open /Applications/LightTable.app/Contents/Info.plist Search for the key LSMinimumSystemVersion Remove that key from the file. Delete this entire text: LSMinimumSystemVersion 10.7.5 Save the file, and you should be able to start Light Table.","title":"OS X 10.6.8"},{"location":"clojure-editors/editor-user-guides/lighttable-osx/#yosemite","text":"Yosemite was released after Light Table development was stalled. Because of this historical reason, students may encounter troubles to start or use Light Table on Yosemite. In such a case, Nightcode is another option. See the instruction, Getting Started with Clojure using Nightcode .","title":"Yosemite"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/","text":"Windows 7 Setup \u03bb\ufe0e Start a command prompt Install Git Configure Git Install Java Install Leiningen Install Light Table Test your setup Troubleshooting Starting a command prompt \u03bb\ufe0e For these instructions, and for much of the class, you will need to have a command prompt open. This is a text-based interface to talk to your computer. Go to the Start Menu and type \"command\" in the search box. Choose the \"Command Prompt\" program, like in this screenshot: When you choose \"Command Prompt,\" your screen should look similar to this: If you have never used the command prompt before, you may want to spend some time reading up on command prompt basics . For the rest of this setup, I will tell you to run commands in your command prompt. When I say that, I mean \"type the command into the command prompt and press the Return key.\" On other operating systems, the command prompt is called the terminal. We will use the terms terminal, command prompt, and command line interchangeably. Install Git \u03bb\ufe0e See if you already have Git installed at the command prompt with the command git --version . If not, download it from the git-scm.com Windows download page and run the executable to install. After installation, try the git --version command in a new command prompt window. If you see a version number, git was installed correctly. If you see a message that says, 'git' is not recognized as an internal or external command , try these steps to update your PATH variable properly: * Right-click \"My Computer\" and select \"Properties\". * Click the \"Advanced Tab\" and then the \"Environment Variables\" button. * Highlight the PATH entry and click \"Edit\". * Scroll to the end of this value and check for a file path at the end that includes \"...\\Git...\". * If that path existed: * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again. * If that path did not exist: * If you did not change the install location of git during installation, add \";C:\\Program Files (x86)\\Git\\cmd\" to the end of the line. Make sure you add the semi-colon between file paths and the line includes no spaces between paths. * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again. Configure Git \u03bb\ufe0e If you've used Git before then you should already have user.name and user.email configured. Otherwise, type this in the command prompt: git config --global user.name \"Your Actual Name\" git config --global user.email \"Your Actual Email\" TIP: Use the same email address for git, github, and ssh. Verify by typing this in the command prompt: git config --get user.name Expected result: your name git config --get user.email Expected result: your email address Install Java \u03bb\ufe0e Go to the Leiningen Windows installer site . You should see two links, one for installing Java and another for \"leiningen-win-installer.\" Click the Java link. Then, you should see a screen like the following: Click the button above \"Java Platform (JDK),\" as you can see in the above picture. Then you will come to a page that will have the following table on it: Click the radio button to accept the license agreement, and then download one of the two Windows choices. If you are running 32-bit Windows, choose \"Windows x86.\" If you are running 64-bit Windows, choose \"Windows x64.\" If you do not know if you are running 32-bit or 64-bit Windows, go to the Control Panel (Start Menu - Control Panel) and choose \"System and Security\" and then \"System.\" You should see a window like the following: You should see if you are running 32- or 64-bit Windows beside \"System Type.\" Once you have downloaded the right Java version, run the executable you downloaded to install Java. Follow the installation wizard. Install Leiningen \u03bb\ufe0e Leiningen is a tool used on the command line to manage Clojure projects. Next, go back to the Leiningen Windows installer site and download the file linked as \"leiningen-win-installer.\" Run this executable and follow the \"Detailed installation\" section at the Leiningen Windows Installer site. At the end of the installation, leave \"Run a Clojure REPL\" checked before you click \"Finish.\" If a terminal window opens that looks like the one on the Leiningen Windows installer site, then you are good to go. Install Light Table \u03bb\ufe0e Go to the Light Table site . On the page there, you should see a set of buttons that have download links for Light Table. Click the \"Win\" button and you will download a .zip file. Unzip this file (either by finding it in your Downloads folder and double-clicking it, or by choosing \"Open\" when downloading.) Inside the .zip file, there is a a directory called \"Light Table\". Drag this to your desktop, or another location of your choosing. Be sure the location you choose does not have spaces anywhere in the file path. Inside the Light Table directory, there is an application called Light Table. Right-click it and choose \"Pin to Start Menu\" so you can start it more quickly. Test your setup \u03bb\ufe0e You have set up Java, Leiningen, Light Table, and Git on your computer--all the tools you will need for this workshop. Before starting, we need to test them out. Cloning out github repository \u03bb\ufe0e Go to your command prompt window and run the following command: git clone https://github.com/ClojureBridge/welcometoclojurebridge This will clone welcometoclojurebridge repository which includes sample Clojure apps. Your command prompt should look similar to this picture: Then run the command: cd welcometoclojurebridge This will take you to the folder with the source code. After that completes, run: lein repl This could take a long time, and will download many other pieces of code it relies on. You should see lines that start with Retrieving ... on your screen. When it finishes, your terminal should look like the following: This is starting a REPL, which we will learn about soon. It's a special command prompt for Clojure. At the REPL prompt, type (+ 1 1) and hit enter. Did you get the answer 2 back? You will learn more about that in the course. For now, press the Control button and D button on your keyboard together (abbreviated as Ctrl+D). This should take you out of the Clojure REPL and back to your normal command prompt. Then, the command prompt will show you the following message: user=> Bye for now! Testing Light Table \u03bb\ufe0e Now we will open and run the sample Clojure apps in Light Table, so start Light Table. In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Ctrl + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Ctrl + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Ctrl + Enter You should see this on the Light Table: also, your turtle should move. press the Control button and Space Bar together (abbreviated Ctrl+Space). This is how you start giving Light Table a command Success! \u03bb\ufe0e Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed! Troubleshooting \u03bb\ufe0e Students with Windows 7 may get the error below when they run lein repl for the first time. Address family not supported by protocol family: connect If the error message is this, look at http://stackoverflow.com/a/21383865 . This error happens because lein command couldn't download necessary stuffs because a program called Relevant Knowledge, some sort of spyware, blocks the traffic. To solve this problem, uninstall Relevant Knowledge. This requires users' (owner's or administrator's) password. Sometimes, attendees haven't heard of such permission stuff. Be ready for that.","title":"Lighttable windows7"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#windows-7-setup","text":"Start a command prompt Install Git Configure Git Install Java Install Leiningen Install Light Table Test your setup Troubleshooting","title":"Windows 7 Setup"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#starting-a-command-prompt","text":"For these instructions, and for much of the class, you will need to have a command prompt open. This is a text-based interface to talk to your computer. Go to the Start Menu and type \"command\" in the search box. Choose the \"Command Prompt\" program, like in this screenshot: When you choose \"Command Prompt,\" your screen should look similar to this: If you have never used the command prompt before, you may want to spend some time reading up on command prompt basics . For the rest of this setup, I will tell you to run commands in your command prompt. When I say that, I mean \"type the command into the command prompt and press the Return key.\" On other operating systems, the command prompt is called the terminal. We will use the terms terminal, command prompt, and command line interchangeably.","title":"Starting a command prompt"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#install-git","text":"See if you already have Git installed at the command prompt with the command git --version . If not, download it from the git-scm.com Windows download page and run the executable to install. After installation, try the git --version command in a new command prompt window. If you see a version number, git was installed correctly. If you see a message that says, 'git' is not recognized as an internal or external command , try these steps to update your PATH variable properly: * Right-click \"My Computer\" and select \"Properties\". * Click the \"Advanced Tab\" and then the \"Environment Variables\" button. * Highlight the PATH entry and click \"Edit\". * Scroll to the end of this value and check for a file path at the end that includes \"...\\Git...\". * If that path existed: * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again. * If that path did not exist: * If you did not change the install location of git during installation, add \";C:\\Program Files (x86)\\Git\\cmd\" to the end of the line. Make sure you add the semi-colon between file paths and the line includes no spaces between paths. * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again.","title":"Install Git"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#configure-git","text":"If you've used Git before then you should already have user.name and user.email configured. Otherwise, type this in the command prompt: git config --global user.name \"Your Actual Name\" git config --global user.email \"Your Actual Email\" TIP: Use the same email address for git, github, and ssh. Verify by typing this in the command prompt: git config --get user.name Expected result: your name git config --get user.email Expected result: your email address","title":"Configure Git"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#install-java","text":"Go to the Leiningen Windows installer site . You should see two links, one for installing Java and another for \"leiningen-win-installer.\" Click the Java link. Then, you should see a screen like the following: Click the button above \"Java Platform (JDK),\" as you can see in the above picture. Then you will come to a page that will have the following table on it: Click the radio button to accept the license agreement, and then download one of the two Windows choices. If you are running 32-bit Windows, choose \"Windows x86.\" If you are running 64-bit Windows, choose \"Windows x64.\" If you do not know if you are running 32-bit or 64-bit Windows, go to the Control Panel (Start Menu - Control Panel) and choose \"System and Security\" and then \"System.\" You should see a window like the following: You should see if you are running 32- or 64-bit Windows beside \"System Type.\" Once you have downloaded the right Java version, run the executable you downloaded to install Java. Follow the installation wizard.","title":"Install Java"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#install-leiningen","text":"Leiningen is a tool used on the command line to manage Clojure projects. Next, go back to the Leiningen Windows installer site and download the file linked as \"leiningen-win-installer.\" Run this executable and follow the \"Detailed installation\" section at the Leiningen Windows Installer site. At the end of the installation, leave \"Run a Clojure REPL\" checked before you click \"Finish.\" If a terminal window opens that looks like the one on the Leiningen Windows installer site, then you are good to go.","title":"Install Leiningen"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#install-light-table","text":"Go to the Light Table site . On the page there, you should see a set of buttons that have download links for Light Table. Click the \"Win\" button and you will download a .zip file. Unzip this file (either by finding it in your Downloads folder and double-clicking it, or by choosing \"Open\" when downloading.) Inside the .zip file, there is a a directory called \"Light Table\". Drag this to your desktop, or another location of your choosing. Be sure the location you choose does not have spaces anywhere in the file path. Inside the Light Table directory, there is an application called Light Table. Right-click it and choose \"Pin to Start Menu\" so you can start it more quickly.","title":"Install Light Table"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#test-your-setup","text":"You have set up Java, Leiningen, Light Table, and Git on your computer--all the tools you will need for this workshop. Before starting, we need to test them out.","title":"Test your setup"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#cloning-out-github-repository","text":"Go to your command prompt window and run the following command: git clone https://github.com/ClojureBridge/welcometoclojurebridge This will clone welcometoclojurebridge repository which includes sample Clojure apps. Your command prompt should look similar to this picture: Then run the command: cd welcometoclojurebridge This will take you to the folder with the source code. After that completes, run: lein repl This could take a long time, and will download many other pieces of code it relies on. You should see lines that start with Retrieving ... on your screen. When it finishes, your terminal should look like the following: This is starting a REPL, which we will learn about soon. It's a special command prompt for Clojure. At the REPL prompt, type (+ 1 1) and hit enter. Did you get the answer 2 back? You will learn more about that in the course. For now, press the Control button and D button on your keyboard together (abbreviated as Ctrl+D). This should take you out of the Clojure REPL and back to your normal command prompt. Then, the command prompt will show you the following message: user=> Bye for now!","title":"Cloning out github repository"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#testing-light-table","text":"Now we will open and run the sample Clojure apps in Light Table, so start Light Table. In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Ctrl + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Ctrl + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Ctrl + Enter You should see this on the Light Table: also, your turtle should move. press the Control button and Space Bar together (abbreviated Ctrl+Space). This is how you start giving Light Table a command","title":"Testing Light Table"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#success","text":"Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed!","title":"Success!"},{"location":"clojure-editors/editor-user-guides/lighttable-windows7/#troubleshooting","text":"Students with Windows 7 may get the error below when they run lein repl for the first time. Address family not supported by protocol family: connect If the error message is this, look at http://stackoverflow.com/a/21383865 . This error happens because lein command couldn't download necessary stuffs because a program called Relevant Knowledge, some sort of spyware, blocks the traffic. To solve this problem, uninstall Relevant Knowledge. This requires users' (owner's or administrator's) password. Sometimes, attendees haven't heard of such permission stuff. Be ready for that.","title":"Troubleshooting"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/","text":"Windows 8 Setup \u03bb\ufe0e Start a command prompt Install Git Configure Git Install Java Install Leiningen Install Light Table Test your setup Troubleshooting Starting a command prompt \u03bb\ufe0e For these instructions, and for much of the class, you will need to have a command prompt open. This is a text-based interface to talk to your computer. Go to the \"Windows\" screen (the \"Start Screen\") and type \"command\". Choose the \"Command Prompt\" program, like in this screenshot: When you choose \"Command Prompt,\" your screen should look similar to this: If you have never used the command prompt before, you may want to spend some time reading up on command prompt basics . For the rest of this setup, I will tell you to run commands in your command prompt. When I say that, I mean \"type the command into the command prompt and press the Return key.\" On other operating systems, the command prompt is called the terminal. We will use the terms terminal, command prompt, and command line interchangeably. Installing Git \u03bb\ufe0e See if you already have Git installed at the command prompt with the command git --version . If not, download it from the git-scm.com Windows download page and run the executable to install. After installation, try the git --version command in a new command prompt window. If you see a version number, git was installed correctly. If you see a message that says, 'git' is not recognized as an internal or external command , try these steps to update your PATH variable properly: * Right-click \"My Computer\" and select \"Properties\". * Click the \"Advanced Tab\" and then the \"Environment Variables\" button. * Highlight the PATH entry and click \"Edit\". * Scroll to the end of this value and check for a file path at the end that includes \"...\\Git...\". * If that path existed: * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again. * If that path did not exist: * If you did not change the install location of git during installation, add \";C:\\Program Files (x86)\\Git\\cmd\" to the end of the line. Make sure you add the semi-colon between file paths and the line includes no spaces between paths. * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again. If you've used Git before then you should already have user.name and user.email configured. Otherwise, type this in the command prompt: Configure Git \u03bb\ufe0e git config --global user.name \"Your Actual Name\" git config --global user.email \"Your Actual Email\" TIP: Use the same email address for git, github, and ssh. Verify by typing this in the command prompt: git config --get user.name Expected result: your name git config --get user.email Expected result: your email address Install Java \u03bb\ufe0e Go to the Leiningen Windows installer site . You should see two links, one for installing Java and another for \"leiningen-win-installer.\" Click the Java link. Then, you should see a screen like the following: Click the button above \"Java Platform (JDK),\" as you can see in the above picture. Then you will come to a page that will have the following table on it: Click the radio button to accept the license agreement, and then download one of the two Windows choices. If you are running 32-bit Windows, choose \"Windows x86.\" If you are running 64-bit Windows, choose \"Windows x64.\" If you do not know if you are running 32-bit or 64-bit Windows, go to the \"Windows\" screen (the \"Start Screen\") and type \"system.\" Choose \"System.\" (If that does not work, type \"Control Panel\" and choose \"System\" from the Control Panel screen.) You should see a window like the following: You should see if you are running 32- or 64-bit Windows beside \"System Type.\" Once you have downloaded the right Java version, run the executable you downloaded to install Java. Follow the installation wizard. Install Leiningen \u03bb\ufe0e Leiningen is a tool used on the command line to manage Clojure projects. see troubleshooting for leiningen installation Next, go back to the Leiningen Windows installer site and download the file linked as \"leiningen-win-installer.\" Run this executable and follow the \"Detailed installation\" section at the Leiningen Windows Installer site. At the end of the installation, leave \"Run a Clojure REPL\" checked before you click \"Finish.\" If a terminal window opens that looks like the one on the Leiningen Windows installer site, then you are good to go. Install Light Table \u03bb\ufe0e Go to the Light Table site . On the page there, you should see a set of buttons that have download links for Light Table. Click the \"Win\" button and you will download a .zip file. Unzip this file (either by finding it in your Downloads folder and double-clicking it, or by choosing \"Open\" when downloading.) Inside the .zip file, there is a a directory called \"Light Table\". Drag this to your desktop. (If you know what you are doing and want this somewhere else, that is fine.) Inside the Light Table directory, there is an application called Light Table. Right-click it and choose \"Pin to Start Menu\" so you can start it more quickly. Test your setup \u03bb\ufe0e You have set up Java, Leiningen, Light Table, and Git on your computer--all the tools you will need for this workshop. Before starting, we need to test them out. Cloning out github repository \u03bb\ufe0e Go to your command prompt and run the following command: git clone https://github.com/ClojureBridge/welcometoclojurebridge This will clone welcometoclojurebridge repository which includes sample Clojure apps. Your command prompt should look similar to this picture: Then run the command: cd welcometoclojurebridge This will take you to the folder with the source code. After that completes, run: lein repl This could take a long time, and will download many other pieces of code it relies on. You should see lines that start with Retrieving ... on your screen. When it finishes, your terminal should look like the following: This is starting a REPL, which we will learn about soon. It's a special command prompt for Clojure. At the REPL prompt, type (+ 1 1) and hit enter. Did you get the answer 2 back? You will learn more about that in the course. For now, press the Control button and D button on your keyboard together (abbreviated as Ctrl+D). This should take you out of the Clojure REPL and back to your normal command prompt. Then, the command prompt will show you the following message: user=> Bye for now! Testing Light Table \u03bb\ufe0e Now we will open and run the sample Clojure apps in Light Table, so start Light Table. In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Ctrl + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Ctrl + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Ctrl + Enter You should see this on the Light Table: also, your turtle should move. press the Control button and Space Bar together (abbreviated Ctrl+Space). This is how you start giving Light Table a command Success! \u03bb\ufe0e Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed! Troubleshooting \u03bb\ufe0e If you receive errors while running Light Table about Java or JDK, these may be resolved by finishing the installation of Leiningen first. If not, see a TA to look at your environment variables. Leiningen Windows Installer has an issue that it doesn't install lein.bat correctly. This causes curl.exe to fail downloading files with th error below. Skip the Leiningen Windows Installer. Download lein.bat from leiningen.org and run self-installer. error:0307A071:bignum routines:BN_rand_range:too many iterations.","title":"Lighttable windows8"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#windows-8-setup","text":"Start a command prompt Install Git Configure Git Install Java Install Leiningen Install Light Table Test your setup Troubleshooting","title":"Windows 8 Setup"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#starting-a-command-prompt","text":"For these instructions, and for much of the class, you will need to have a command prompt open. This is a text-based interface to talk to your computer. Go to the \"Windows\" screen (the \"Start Screen\") and type \"command\". Choose the \"Command Prompt\" program, like in this screenshot: When you choose \"Command Prompt,\" your screen should look similar to this: If you have never used the command prompt before, you may want to spend some time reading up on command prompt basics . For the rest of this setup, I will tell you to run commands in your command prompt. When I say that, I mean \"type the command into the command prompt and press the Return key.\" On other operating systems, the command prompt is called the terminal. We will use the terms terminal, command prompt, and command line interchangeably.","title":"Starting a command prompt"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#installing-git","text":"See if you already have Git installed at the command prompt with the command git --version . If not, download it from the git-scm.com Windows download page and run the executable to install. After installation, try the git --version command in a new command prompt window. If you see a version number, git was installed correctly. If you see a message that says, 'git' is not recognized as an internal or external command , try these steps to update your PATH variable properly: * Right-click \"My Computer\" and select \"Properties\". * Click the \"Advanced Tab\" and then the \"Environment Variables\" button. * Highlight the PATH entry and click \"Edit\". * Scroll to the end of this value and check for a file path at the end that includes \"...\\Git...\". * If that path existed: * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again. * If that path did not exist: * If you did not change the install location of git during installation, add \";C:\\Program Files (x86)\\Git\\cmd\" to the end of the line. Make sure you add the semi-colon between file paths and the line includes no spaces between paths. * Click \"Okay\" until the \"My Computer\" dialog box is closed. * Open a new command prompt window and try git --version again. If that does not succeed, restart your computer and try again. If you've used Git before then you should already have user.name and user.email configured. Otherwise, type this in the command prompt:","title":"Installing Git"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#configure-git","text":"git config --global user.name \"Your Actual Name\" git config --global user.email \"Your Actual Email\" TIP: Use the same email address for git, github, and ssh. Verify by typing this in the command prompt: git config --get user.name Expected result: your name git config --get user.email Expected result: your email address","title":"Configure Git"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#install-java","text":"Go to the Leiningen Windows installer site . You should see two links, one for installing Java and another for \"leiningen-win-installer.\" Click the Java link. Then, you should see a screen like the following: Click the button above \"Java Platform (JDK),\" as you can see in the above picture. Then you will come to a page that will have the following table on it: Click the radio button to accept the license agreement, and then download one of the two Windows choices. If you are running 32-bit Windows, choose \"Windows x86.\" If you are running 64-bit Windows, choose \"Windows x64.\" If you do not know if you are running 32-bit or 64-bit Windows, go to the \"Windows\" screen (the \"Start Screen\") and type \"system.\" Choose \"System.\" (If that does not work, type \"Control Panel\" and choose \"System\" from the Control Panel screen.) You should see a window like the following: You should see if you are running 32- or 64-bit Windows beside \"System Type.\" Once you have downloaded the right Java version, run the executable you downloaded to install Java. Follow the installation wizard.","title":"Install Java"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#install-leiningen","text":"Leiningen is a tool used on the command line to manage Clojure projects. see troubleshooting for leiningen installation Next, go back to the Leiningen Windows installer site and download the file linked as \"leiningen-win-installer.\" Run this executable and follow the \"Detailed installation\" section at the Leiningen Windows Installer site. At the end of the installation, leave \"Run a Clojure REPL\" checked before you click \"Finish.\" If a terminal window opens that looks like the one on the Leiningen Windows installer site, then you are good to go.","title":"Install Leiningen"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#install-light-table","text":"Go to the Light Table site . On the page there, you should see a set of buttons that have download links for Light Table. Click the \"Win\" button and you will download a .zip file. Unzip this file (either by finding it in your Downloads folder and double-clicking it, or by choosing \"Open\" when downloading.) Inside the .zip file, there is a a directory called \"Light Table\". Drag this to your desktop. (If you know what you are doing and want this somewhere else, that is fine.) Inside the Light Table directory, there is an application called Light Table. Right-click it and choose \"Pin to Start Menu\" so you can start it more quickly.","title":"Install Light Table"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#test-your-setup","text":"You have set up Java, Leiningen, Light Table, and Git on your computer--all the tools you will need for this workshop. Before starting, we need to test them out.","title":"Test your setup"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#cloning-out-github-repository","text":"Go to your command prompt and run the following command: git clone https://github.com/ClojureBridge/welcometoclojurebridge This will clone welcometoclojurebridge repository which includes sample Clojure apps. Your command prompt should look similar to this picture: Then run the command: cd welcometoclojurebridge This will take you to the folder with the source code. After that completes, run: lein repl This could take a long time, and will download many other pieces of code it relies on. You should see lines that start with Retrieving ... on your screen. When it finishes, your terminal should look like the following: This is starting a REPL, which we will learn about soon. It's a special command prompt for Clojure. At the REPL prompt, type (+ 1 1) and hit enter. Did you get the answer 2 back? You will learn more about that in the course. For now, press the Control button and D button on your keyboard together (abbreviated as Ctrl+D). This should take you out of the Clojure REPL and back to your normal command prompt. Then, the command prompt will show you the following message: user=> Bye for now!","title":"Cloning out github repository"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#testing-light-table","text":"Now we will open and run the sample Clojure apps in Light Table, so start Light Table. In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Ctrl + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Ctrl + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Ctrl + Enter You should see this on the Light Table: also, your turtle should move. press the Control button and Space Bar together (abbreviated Ctrl+Space). This is how you start giving Light Table a command","title":"Testing Light Table"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#success","text":"Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed!","title":"Success!"},{"location":"clojure-editors/editor-user-guides/lighttable-windows8/#troubleshooting","text":"If you receive errors while running Light Table about Java or JDK, these may be resolved by finishing the installation of Leiningen first. If not, see a TA to look at your environment variables. Leiningen Windows Installer has an issue that it doesn't install lein.bat correctly. This causes curl.exe to fail downloading files with th error below. Skip the Leiningen Windows Installer. Download lein.bat from leiningen.org and run self-installer. error:0307A071:bignum routines:BN_rand_range:too many iterations.","title":"Troubleshooting"},{"location":"clojure-editors/editor-user-guides/lighttable/","text":"Install LightTable \u03bb\ufe0e Go to the Light Table site and click the button for your Operating System (MacOSX, Windows, Linux) and save the file. Ubuntu & MacOSX \u03bb\ufe0e Extract the compressed file tar -xzf LightTableLinux64.tar.gz Move the LightTable directory to \"/usr/local/bin\" sudo mv LightTable /usr/local/bin Set your path so you can launch LightTable from the command line export PATH=$PATH:/usr/local/bin/LightTable Launch LightTable LightTable Windows \u03bb\ufe0e Create a directory called C:\\Users\\your-user-name\\AppData\\Local\\Programs\\LightTable Extract the contents of the downloaded file to the above directory Open \"Environment variables for your account\" and add the directory to your path Open a command window and run the command: LightTable.bat Testing Light Table \u03bb\ufe0e Now we will open and run the sample Clojure apps in Light Table, so start Light Table In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Ctrl + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Ctrl + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Ctrl + Enter You should see this on the Light Table: also, your turtle should move. Pressing the Control button and Space Bar together (abbreviated Ctrl+Space ) is how you start giving Light Table a command. Success! \u03bb\ufe0e Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed!","title":"Install LightTable"},{"location":"clojure-editors/editor-user-guides/lighttable/#install-lighttable","text":"Go to the Light Table site and click the button for your Operating System (MacOSX, Windows, Linux) and save the file.","title":"Install LightTable"},{"location":"clojure-editors/editor-user-guides/lighttable/#ubuntu-macosx","text":"Extract the compressed file tar -xzf LightTableLinux64.tar.gz Move the LightTable directory to \"/usr/local/bin\" sudo mv LightTable /usr/local/bin Set your path so you can launch LightTable from the command line export PATH=$PATH:/usr/local/bin/LightTable Launch LightTable LightTable","title":"Ubuntu &amp; MacOSX"},{"location":"clojure-editors/editor-user-guides/lighttable/#windows","text":"Create a directory called C:\\Users\\your-user-name\\AppData\\Local\\Programs\\LightTable Extract the contents of the downloaded file to the above directory Open \"Environment variables for your account\" and add the directory to your path Open a command window and run the command: LightTable.bat","title":"Windows"},{"location":"clojure-editors/editor-user-guides/lighttable/#testing-light-table","text":"Now we will open and run the sample Clojure apps in Light Table, so start Light Table In Light Table, click on the menu \"File\" then choose \"Open Folder.\" Find the directory, welcometoclojurebridge , which was created when you ran git clone command. Click \"Upload.\" In the workspace menu on the left, click on welcometoclojurebridge - src - welcometoclojurebridge - core.clj . Double-click the core.clj file to open it. This is a Clojure program. Click on the file contents and press the following key combination: Ctrl + Shift + Enter You should see a fun welcome message. Next, in the workspace menu on the left, click on welcometoclojurebridge - src - clojurebridge-turtle - walk.clj . Double-click the core.clj file to open it. press the following key combination: Ctrl + Shift + Enter An initial image of the turtles app will pop up. Type (forward 40) at the end of the walk.clj and press the following combination: Ctrl + Enter You should see this on the Light Table: also, your turtle should move. Pressing the Control button and Space Bar together (abbreviated Ctrl+Space ) is how you start giving Light Table a command.","title":"Testing Light Table"},{"location":"clojure-editors/editor-user-guides/lighttable/#success","text":"Congratulations! You have opened and run your first Clojure apps, and your install and setup are all completed!","title":"Success!"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/","text":"Learning to use Conjure \u03bb\ufe0e :help conjure opens the conjure documentation in neovim. Use j to scroll down, k to scroll up. :ConjureSchool command will start an interactive tutorial and introduce Conjure's workflow and key mappings Start a REPL on the command line \u03bb\ufe0e {% tabs rebel=\"Rebel REPL with nREPL\", basic=\"Basic REPL with nREPL\" %} {% content \"rebel\" %} Using practicalli/clojure-deps-edn aliases, run a command line REPL that starts a nrepl server and starts the rebel readline terminal UI clojure -M:repl/rebel-nrepl {% content \"basic\" %} Using practicalli/clojure-deps-edn aliases, run a command line REPL that starts an nrepl server clojure -M:middleware/nrepl {% endtabs %} Then open a Clojure file and Conjure will (magically) connect to the running REPL and pop-up a connect message in the top right corner. Starting a REPL from Vim \u03bb\ufe0e Start neovim with a Clojure file, e.g. nvim src/practialli/playground.clj or run nvim and open a Clojure file using :NERDTree . A Clojure file has a name ending in *.clj , *.cljc or .edn . :Clj command to start a REPL using Clojure CLI Tools :Lein command to start a REPL using Leiningen Neovim switches to a terminal state, use C-\\ C-n to leave the terminal state. Use :N or :previous to switch back to the source code buffer , c f to connect to the REPL from Conjure, or simply open a Clojure file. Automated connection will be added in a future version on Conjure. The vim-jack-in plugin enables Neovim to call out to Clojure tools or Leiningen to start a REPL and connect to it once its started. A full screen REPL log is displayed. , l q to close the log window and return to the Clojure file. , l v to create a vertical split between code and REPL log, , l h for a horizontal split. Evaluating code \u03bb\ufe0e With the maplocalleader key set to , , e b evaluates the current buffer , e f evaluate the code in the file (from the file system) , e e evaluate the current expression , e r evaluate top level form (root) , e ! evaluate current form and replace with result NOTE: Conjure results appear in a pop-up panel which displays until the cursor is moved. Whilst the pop-up is displaying, it is not possible to quit a file with :q . Move the cursor or use g t to change tabs to remove the popup. Neovim commands and history \u03bb\ufe0e : in Vim normal mode to start entering a command, type the start of a command and press TAB to use command completion. TAB and Shift-TAB navigate the completion menu. q: to popup a list of recent commands File management \u03bb\ufe0e Multiple files can be opened in Neovim, either as split windows or tabs. nvim src.clj deps.edn readme.org will open three files in separate tabs :n or :next to switch to the next tab, :2next to jump 2 tabs, :last for the last tab. :N or :previous to switch to the previous tab C-^ to toggle to last shown tab :NERDTree or :NERDTreeToggle to show a graphical file manager in a left side split. NERDTree opens files as splits. C-w followed by either jkhl will move the cursor to the split in that direction. Neovim reference: editing more than one file Navigation within projects \u03bb\ufe0e g d go to definition of current symbol General vim commands \u03bb\ufe0e :cd changes the current working directory, use by :e :lcd ^ but local to the current window :windo lcd ^ for all windows in the current tab :pwd prints the current working directory :e! reloads the current buffer, discarding unsaved changes :find to search for file names relative to the path option (set path?) and open them. Completion \u03bb\ufe0e Install the Deoplete plugin (from Olical configuration) https://github.com/Shougo/deoplete.nvim \" Completion support Plug 'Shougo/deoplete.nvim' | Plug 'ncm2/float-preview.nvim' \" :wq to quit neovim. Run neovim and :PlugInstall to install all plugins defined in the ~/.config/nvim/init.vim configuration Alternative completion plugin: Conquer of Completion - required node.js install Running tests \u03bb\ufe0e , t n to test the current namespace Structural editing \u03bb\ufe0e >) , <) , >( , and <( to slurp and barf, where the angle bracket indicates the direction, and the parenthesis indicates which end to operate on. See vim-sexp mappings for regular people for more structural editing Searching through projects \u03bb\ufe0e TODO: Refactor code \u03bb\ufe0e TODO: find equivalents for narrowing, iedit and helm search results editing for vim Code analysis and idiom checking \u03bb\ufe0e clj-kondo automatically checks Clojure code at it is typed, providing instant feedback on Clojure syntax and idioms Linting works continually once the dense/ale plugin and clj-kondo is installed via the 'w0rp/ale' plugin","title":"Neovim conjure"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#learning-to-use-conjure","text":":help conjure opens the conjure documentation in neovim. Use j to scroll down, k to scroll up. :ConjureSchool command will start an interactive tutorial and introduce Conjure's workflow and key mappings","title":"Learning to use Conjure"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#start-a-repl-on-the-command-line","text":"{% tabs rebel=\"Rebel REPL with nREPL\", basic=\"Basic REPL with nREPL\" %} {% content \"rebel\" %} Using practicalli/clojure-deps-edn aliases, run a command line REPL that starts a nrepl server and starts the rebel readline terminal UI clojure -M:repl/rebel-nrepl {% content \"basic\" %} Using practicalli/clojure-deps-edn aliases, run a command line REPL that starts an nrepl server clojure -M:middleware/nrepl {% endtabs %} Then open a Clojure file and Conjure will (magically) connect to the running REPL and pop-up a connect message in the top right corner.","title":"Start a REPL on the command line"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#starting-a-repl-from-vim","text":"Start neovim with a Clojure file, e.g. nvim src/practialli/playground.clj or run nvim and open a Clojure file using :NERDTree . A Clojure file has a name ending in *.clj , *.cljc or .edn . :Clj command to start a REPL using Clojure CLI Tools :Lein command to start a REPL using Leiningen Neovim switches to a terminal state, use C-\\ C-n to leave the terminal state. Use :N or :previous to switch back to the source code buffer , c f to connect to the REPL from Conjure, or simply open a Clojure file. Automated connection will be added in a future version on Conjure. The vim-jack-in plugin enables Neovim to call out to Clojure tools or Leiningen to start a REPL and connect to it once its started. A full screen REPL log is displayed. , l q to close the log window and return to the Clojure file. , l v to create a vertical split between code and REPL log, , l h for a horizontal split.","title":"Starting a REPL from Vim"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#evaluating-code","text":"With the maplocalleader key set to , , e b evaluates the current buffer , e f evaluate the code in the file (from the file system) , e e evaluate the current expression , e r evaluate top level form (root) , e ! evaluate current form and replace with result NOTE: Conjure results appear in a pop-up panel which displays until the cursor is moved. Whilst the pop-up is displaying, it is not possible to quit a file with :q . Move the cursor or use g t to change tabs to remove the popup.","title":"Evaluating code"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#neovim-commands-and-history","text":": in Vim normal mode to start entering a command, type the start of a command and press TAB to use command completion. TAB and Shift-TAB navigate the completion menu. q: to popup a list of recent commands","title":"Neovim commands and history"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#file-management","text":"Multiple files can be opened in Neovim, either as split windows or tabs. nvim src.clj deps.edn readme.org will open three files in separate tabs :n or :next to switch to the next tab, :2next to jump 2 tabs, :last for the last tab. :N or :previous to switch to the previous tab C-^ to toggle to last shown tab :NERDTree or :NERDTreeToggle to show a graphical file manager in a left side split. NERDTree opens files as splits. C-w followed by either jkhl will move the cursor to the split in that direction. Neovim reference: editing more than one file","title":"File management"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#navigation-within-projects","text":"g d go to definition of current symbol","title":"Navigation within projects"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#general-vim-commands","text":":cd changes the current working directory, use by :e :lcd ^ but local to the current window :windo lcd ^ for all windows in the current tab :pwd prints the current working directory :e! reloads the current buffer, discarding unsaved changes :find to search for file names relative to the path option (set path?) and open them.","title":"General vim commands"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#completion","text":"Install the Deoplete plugin (from Olical configuration) https://github.com/Shougo/deoplete.nvim \" Completion support Plug 'Shougo/deoplete.nvim' | Plug 'ncm2/float-preview.nvim' \" :wq to quit neovim. Run neovim and :PlugInstall to install all plugins defined in the ~/.config/nvim/init.vim configuration Alternative completion plugin: Conquer of Completion - required node.js install","title":"Completion"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#running-tests","text":", t n to test the current namespace","title":"Running tests"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#structural-editing","text":">) , <) , >( , and <( to slurp and barf, where the angle bracket indicates the direction, and the parenthesis indicates which end to operate on. See vim-sexp mappings for regular people for more structural editing","title":"Structural editing"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#searching-through-projects","text":"TODO:","title":"Searching through projects"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#refactor-code","text":"TODO: find equivalents for narrowing, iedit and helm search results editing for vim","title":"Refactor code"},{"location":"clojure-editors/editor-user-guides/neovim-conjure/#code-analysis-and-idiom-checking","text":"clj-kondo automatically checks Clojure code at it is typed, providing instant feedback on Clojure syntax and idioms Linting works continually once the dense/ale plugin and clj-kondo is installed via the 'w0rp/ale' plugin","title":"Code analysis and idiom checking"},{"location":"clojure-editors/editor-user-guides/optional-git/","text":"Installing Git \u03bb\ufe0e To check if you already have Git installed open a terminal and use the command git version . Install Git on Ubuntu \u03bb\ufe0e Install Git with this command in the terminal: sudo apt-get install git ` Install Git on Mac or Windows \u03bb\ufe0e Download Git Open the downloaded file to run the installer and accept all the default options. Configure Git \u03bb\ufe0e To show who makes changes in a Git project you should set your user.name and user.email configured. If this is the first time using Git, then use the following commands in a terminal: git config --global user.name \"Your Name\" git config --global user.email \"Your Email address\"","title":"Installing Git"},{"location":"clojure-editors/editor-user-guides/optional-git/#installing-git","text":"To check if you already have Git installed open a terminal and use the command git version .","title":"Installing Git"},{"location":"clojure-editors/editor-user-guides/optional-git/#install-git-on-ubuntu","text":"Install Git with this command in the terminal: sudo apt-get install git `","title":"Install Git on Ubuntu"},{"location":"clojure-editors/editor-user-guides/optional-git/#install-git-on-mac-or-windows","text":"Download Git Open the downloaded file to run the installer and accept all the default options.","title":"Install Git on Mac or Windows"},{"location":"clojure-editors/editor-user-guides/optional-git/#configure-git","text":"To show who makes changes in a Git project you should set your user.name and user.email configured. If this is the first time using Git, then use the following commands in a terminal: git config --global user.name \"Your Name\" git config --global user.email \"Your Email address\"","title":"Configure Git"},{"location":"clojure-editors/editor-user-guides/setup/","text":"Getting Set Up \u03bb\ufe0e Requirements \u03bb\ufe0e Everyone in the workshop should have a laptop. If it is running Windows, it should be running Windows 7 or above. If it is running OS X, it should be running 10.7 \"Lion\" or above. If it is running Linux, you are probably fine. If anyone attending does not have access to a laptop running one of the above choices, let the instructors know. You can either pair with someone else, or we can provide a virtual machine that you can run if you have a laptop. What we are installing \u03bb\ufe0e By the end of these instructions, you will have the following installed: Java standard edition (SE) - Clojure runs on top of Java. The Java Runtime Environment (JRE) is needed to run Clojure . Leiningen - a tool for running Clojure programs, also creating & managing Clojure projects LightTable - an easy to use development tool for Clojure and other programming languages Git - versioning your Clojure code (so you can go back to earlier versions if you make a mistake) Java version 1.8 (Java 8) is the latest version. Java 1.7 (Java 7) & 1.6 (Java 6) will also work. Instructions by operating system \u03bb\ufe0e Choose your operating system to get setup instructions: OS X Windows 7 Windows 8 Ubuntu Linux Once this is done, please also install the Instarepl plugin and create a Clojure project, as described in the next two sections Add the LightTable Instarepl plugin \u03bb\ufe0e In LightTable, open the menu: view > Commands or use Ctrl-Space or Cmd-Space keyboard shortcut In the command window, type plugin and select Plugins: Show plugin manager In the plugins manager, select the Available button and type Instarepl . Press the Enter key to search for the plugin On the ClojureInstarepl plugin, click Install . Run the Instarepl via the menu: View > Commands and type Instarepl . Select _Instarepl: Open a clojure Instarepl Create a Clojure project \u03bb\ufe0e Create a new project to practice what you are learning about Clojure: Open a command line terminal and run the following command: lein new playground This command creates a new folder called playground that contains your new Clojure project. Open the file playground/src/playground/core.clj in LightTable. Light Table convenience settings \u03bb\ufe0e The following setting are optional, but can make LightTable easier to use for Clojure. To add a setting, edit the User Behaviour file as follows: Ctrl-Space to open Commands Type user behaviors and click the proposed command This opens the User Behaviours file for editing. When you save the file, Ctrl-s , changes are applied immediately. Add any of the following options you wish: Open Workspace on startup Show the workspace browser when you run LightTable, so you can see all the projects you have added and open files easily. [:app :lt.objs.sidebar.workspace/workspace.open-on-start] automatic closing of characters Auto-close characters, so when you type an opening { , [ or ( you automatically get a closing ) , ] or } . [:editor :lt.objs.editor/autoclose-brackets] show line numbers Show line numbers on the left hand side of the editor [:editor :lt.objs.editor/line-numbers] don't wrap lines Don't wrap a line of text around if they are to long for the screen: [:editor :lt.objs.editor/no-wrap] For more on configuring behaviors see behaviour & keymap configuration . Sample User Behaviours file If you want all the settings, simply copy the example User Behaviour file at the end of this section. [ ;; The app tag is kind of like global scope. You assign behaviors that affect ;; all of Light Table to it. [:app :lt.objs.style/set-skin \"dark\"] [:app :lt.objs.plugins/load-js \"user_compiled.js\"] [:app :lt.objs.sidebar.workspace/workspace.open-on-start] ;; The editor tag is applied to all editors [:editor :lt.objs.editor/no-wrap] [:editor :lt.objs.style/set-theme \"default\"] [:editor :lt.objs.style/font-settings \"Sans\" 12] [:editor :lt.objs.editor/autoclose-brackets] [:editor :lt.objs.editor/line-numbers] ;; Here we can add behaviors to just clojure editors [:editor.clojure :lt.plugins.clojure/print-length 1000] ;; Behaviors specific to a user-defined object [:user.hello :lt.plugins.user/on-close-destroy] ;; To subtract a behavior, prefix the name with '-' e.g. ;; [:app :-lt.objs.intro/show-intro] ]","title":"Setup"},{"location":"clojure-editors/editor-user-guides/setup/#getting-set-up","text":"","title":"Getting Set Up"},{"location":"clojure-editors/editor-user-guides/setup/#requirements","text":"Everyone in the workshop should have a laptop. If it is running Windows, it should be running Windows 7 or above. If it is running OS X, it should be running 10.7 \"Lion\" or above. If it is running Linux, you are probably fine. If anyone attending does not have access to a laptop running one of the above choices, let the instructors know. You can either pair with someone else, or we can provide a virtual machine that you can run if you have a laptop.","title":"Requirements"},{"location":"clojure-editors/editor-user-guides/setup/#what-we-are-installing","text":"By the end of these instructions, you will have the following installed: Java standard edition (SE) - Clojure runs on top of Java. The Java Runtime Environment (JRE) is needed to run Clojure . Leiningen - a tool for running Clojure programs, also creating & managing Clojure projects LightTable - an easy to use development tool for Clojure and other programming languages Git - versioning your Clojure code (so you can go back to earlier versions if you make a mistake) Java version 1.8 (Java 8) is the latest version. Java 1.7 (Java 7) & 1.6 (Java 6) will also work.","title":"What we are installing"},{"location":"clojure-editors/editor-user-guides/setup/#instructions-by-operating-system","text":"Choose your operating system to get setup instructions: OS X Windows 7 Windows 8 Ubuntu Linux Once this is done, please also install the Instarepl plugin and create a Clojure project, as described in the next two sections","title":"Instructions by operating system"},{"location":"clojure-editors/editor-user-guides/setup/#add-the-lighttable-instarepl-plugin","text":"In LightTable, open the menu: view > Commands or use Ctrl-Space or Cmd-Space keyboard shortcut In the command window, type plugin and select Plugins: Show plugin manager In the plugins manager, select the Available button and type Instarepl . Press the Enter key to search for the plugin On the ClojureInstarepl plugin, click Install . Run the Instarepl via the menu: View > Commands and type Instarepl . Select _Instarepl: Open a clojure Instarepl","title":"Add the LightTable Instarepl plugin"},{"location":"clojure-editors/editor-user-guides/setup/#create-a-clojure-project","text":"Create a new project to practice what you are learning about Clojure: Open a command line terminal and run the following command: lein new playground This command creates a new folder called playground that contains your new Clojure project. Open the file playground/src/playground/core.clj in LightTable.","title":"Create a Clojure project"},{"location":"clojure-editors/editor-user-guides/setup/#light-table-convenience-settings","text":"The following setting are optional, but can make LightTable easier to use for Clojure. To add a setting, edit the User Behaviour file as follows: Ctrl-Space to open Commands Type user behaviors and click the proposed command This opens the User Behaviours file for editing. When you save the file, Ctrl-s , changes are applied immediately. Add any of the following options you wish: Open Workspace on startup Show the workspace browser when you run LightTable, so you can see all the projects you have added and open files easily. [:app :lt.objs.sidebar.workspace/workspace.open-on-start] automatic closing of characters Auto-close characters, so when you type an opening { , [ or ( you automatically get a closing ) , ] or } . [:editor :lt.objs.editor/autoclose-brackets] show line numbers Show line numbers on the left hand side of the editor [:editor :lt.objs.editor/line-numbers] don't wrap lines Don't wrap a line of text around if they are to long for the screen: [:editor :lt.objs.editor/no-wrap] For more on configuring behaviors see behaviour & keymap configuration . Sample User Behaviours file If you want all the settings, simply copy the example User Behaviour file at the end of this section. [ ;; The app tag is kind of like global scope. You assign behaviors that affect ;; all of Light Table to it. [:app :lt.objs.style/set-skin \"dark\"] [:app :lt.objs.plugins/load-js \"user_compiled.js\"] [:app :lt.objs.sidebar.workspace/workspace.open-on-start] ;; The editor tag is applied to all editors [:editor :lt.objs.editor/no-wrap] [:editor :lt.objs.style/set-theme \"default\"] [:editor :lt.objs.style/font-settings \"Sans\" 12] [:editor :lt.objs.editor/autoclose-brackets] [:editor :lt.objs.editor/line-numbers] ;; Here we can add behaviors to just clojure editors [:editor.clojure :lt.plugins.clojure/print-length 1000] ;; Behaviors specific to a user-defined object [:user.hello :lt.plugins.user/on-close-destroy] ;; To subtract a behavior, prefix the name with '-' e.g. ;; [:app :-lt.objs.intro/show-intro] ]","title":"Light Table convenience settings"},{"location":"clojure-editors/editor-user-guides/spacevim-fireplace/","text":"SpaceVim and vim-fireplace \u03bb\ufe0e SpaceVim uses vim-fireplace to provide a simple Clojure development experience that runs very quickly. Starting a REPL \u03bb\ufe0e Open a Clojure file, either deps.edn , project.clj , or a source code file ( .clj , .cljs , .cljc ) , s i to start the Clojure REPL f , s b to evaluate the code in a source code buffer , s l to evaluate the top-level expression under the cursor TODO: restart a REPL ? Stop/Start SpaceVim Making changes \u03bb\ufe0e Parens matching happens automatically, so adding a ( will also add the closing ) . The same for [ and { . Typing Clojure function names will show a pop-up menu with auto-completion options. Live linting is configured in the Practicalli configuration example and continually runs clj-kondo on the code as you type. Structured Editing \u03bb\ufe0e Buffer management \u03bb\ufe0e SPC b menu provides commands to manage buffers. A buffer is open as a vim tab and all tabs are displayed along the top. Version control \u03bb\ufe0e General commands for version control SPC ' opens a shell in the directory of the current buffer. Run git init to create a local repository. SPC g . is the transient menu w to stage, u to unstage c with popup, C to commit directly l shows the git log D to see diff of unstaged hunks F pull from remote repository with popup P push to remote repository with popup See VersionControl layer keybindings for more commands","title":"SpaceVim and vim-fireplace"},{"location":"clojure-editors/editor-user-guides/spacevim-fireplace/#spacevim-and-vim-fireplace","text":"SpaceVim uses vim-fireplace to provide a simple Clojure development experience that runs very quickly.","title":"SpaceVim and vim-fireplace"},{"location":"clojure-editors/editor-user-guides/spacevim-fireplace/#starting-a-repl","text":"Open a Clojure file, either deps.edn , project.clj , or a source code file ( .clj , .cljs , .cljc ) , s i to start the Clojure REPL f , s b to evaluate the code in a source code buffer , s l to evaluate the top-level expression under the cursor TODO: restart a REPL ? Stop/Start SpaceVim","title":"Starting a REPL"},{"location":"clojure-editors/editor-user-guides/spacevim-fireplace/#making-changes","text":"Parens matching happens automatically, so adding a ( will also add the closing ) . The same for [ and { . Typing Clojure function names will show a pop-up menu with auto-completion options. Live linting is configured in the Practicalli configuration example and continually runs clj-kondo on the code as you type.","title":"Making changes"},{"location":"clojure-editors/editor-user-guides/spacevim-fireplace/#structured-editing","text":"","title":"Structured Editing"},{"location":"clojure-editors/editor-user-guides/spacevim-fireplace/#buffer-management","text":"SPC b menu provides commands to manage buffers. A buffer is open as a vim tab and all tabs are displayed along the top.","title":"Buffer management"},{"location":"clojure-editors/editor-user-guides/spacevim-fireplace/#version-control","text":"General commands for version control SPC ' opens a shell in the directory of the current buffer. Run git init to create a local repository. SPC g . is the transient menu w to stage, u to unstage c with popup, C to commit directly l shows the git log D to see diff of unstaged hunks F pull from remote repository with popup P push to remote repository with popup See VersionControl layer keybindings for more commands","title":"Version control"},{"location":"clojure-editors/editor-user-guides/vscode-calva/","text":"VSCode and Calva quick start \u03bb\ufe0e Run the command code . from the root of a Clojure project. Alternatively, run VS Code and use Ctrl+k Ctrl+o or the File > Open Folder menu to open the Folder that contains your Clojure project. Select the top level of the folder, e.g. playground and click OK HINT::MacOSX Keys - Option or Alt \u03bb\ufe0e Depending on the version of Mac computer you use, your Alt key may be called Option So Ctrl+Alt+c e would be Ctrl+Option+c e Start a REPL for basic projects \u03bb\ufe0e ctrl+alt+c ctrl+alt+j to start a REPL click on the nrepl name in the bottom left of VSCode UI. Select either Clojure CLI or Leiningen when prompted for the project type Wait a few moments for the REPL to start. A new CLJ REPL tab will open when the Clojure REPL is ready Troubleshooting \u03bb\ufe0e If the REPL did not start, the nREPL link in the bottom blue bar will show the word \"Disconnected\". Open the Output tab to see the progress of the REPL starting. Ask your coach for help if you see output other than that below. Try running a REPL in the command line and connecting to it (details at bottom of this page). Start a REPL on the command line \u03bb\ufe0e Ctrl+` toggles open the VSCode Integrated terminal . Or open your operating system terminal. INFO::Windows GitBash users \u03bb\ufe0e Configure the VS Code internal terminal to use the GitBash shell . In the terminal, change to the folder than contains your project, e.g. cd projects/clojure/playground To use Leiningen, type the command lein repl in the terminal. To use Clojure CLI tools, us the practicalli/clojure-deps-edn aliases and run a REPL that also starts an nREPL server clojure -M:middleware/cider-clj If you also wish to have an interactive terminal REPL, include rebel readline when starting the REPL clojure -M:repl/rebel-nrepl Connecting to an external REPL from Calva \u03bb\ufe0e Ctrl+Alt+c Ctrl+Alt+c will open a command pop-up asking you to enter host and port . These details were shown when the REPL was run in the terminal. In the bottom left of the VS Code window, check the status of the nrepl connection. If you are connected, then the disconnected status should disappear Developing your project \u03bb\ufe0e Once you have a running REPL, use these commands to help you develop your code. HINT::MacOSX Keys - Option or Alt \u03bb\ufe0e Depending on the version of Mac computer you use, your Alt key may be called Option So Ctrl+Alt+c e would be Ctrl+Option+c e Evaluate code Keybinding Description Namespace/file Ctrl+Alt+c ENTER Load current file/namespace and all required namespaces Top level expression Ctrl+Alt+c SPACE Show the result of the top level expression Expression Ctrl+Alt+c e Show the result of the current expression Expression (send to REPL) Ctrl+Alt+c alt+e Evaluate current expression in the REPL Window Expression to comment Ctrl+Alt+c c Evaluate current expression and paste as comment Replace expression Ctrl+Alt+c r Replace the expression with its result In the REPL ALt+Enter Evaluates the current line REPL window You can run tests from Calva too... Tests to run Keybinding Description All tests Ctrl+Alt+c Shift+t Run all tests in the project Current Namespace tests Ctrl+Alt+c t Run all tests for the current namespace Re-run failing tests Ctrl+Alt+c Ctrl+t Run all tests for the current namespace HINT::REPL history \u03bb\ufe0e The REPL window maintains a history of the code typed in and can be navigated by pressing Alt+Up and Alt+Down . Commenting / uncommenting code \u03bb\ufe0e Use ;; at the start of a line, which comments it out. WARNING::Line comments keybindings ? \u03bb\ufe0e The Add Line Comment command to place line comment command is broken in Calva, it only produces a single semi-colon Increase / decrease font size \u03bb\ufe0e Ctrl + and Ctrl - will increase and decrease the size of the whole editor. Ctrl Shift P and type the command Preference: Open Settings (JSON) to open the settings.json configuration file. Update the value for editor.fontSize and save the file. The font should update immediately in the VS Code UI. Other useful options that can be added to the settings.json configuration \"workbench.colorTheme\": \"Solarized Light\", \"editor.fontSize\": 14, \"editor.fontFamily\": \"'Fira Code', 'Ubuntu Mono', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'\", \"window.zoomLevel\": 1, \"calva.paredit.defaultKeyMap\": \"strict\" Structured editing - Paredit \u03bb\ufe0e Once you get the basics of Clojure development, you can try structural editing which is a way to edit your code without breaking the structure of Clojure. Structural editing ensures you dont have uneven parentheses, () , [] , {} , etc. The Calva visual Guide to Paredit includes lots of examples of using Structural editing.","title":"VSCode and Calva quick start"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#vscode-and-calva-quick-start","text":"Run the command code . from the root of a Clojure project. Alternatively, run VS Code and use Ctrl+k Ctrl+o or the File > Open Folder menu to open the Folder that contains your Clojure project. Select the top level of the folder, e.g. playground and click OK","title":"VSCode and Calva quick start"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#hintmacosx-keys-option-or-alt","text":"Depending on the version of Mac computer you use, your Alt key may be called Option So Ctrl+Alt+c e would be Ctrl+Option+c e","title":"HINT::MacOSX Keys - Option or Alt"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#start-a-repl-for-basic-projects","text":"ctrl+alt+c ctrl+alt+j to start a REPL click on the nrepl name in the bottom left of VSCode UI. Select either Clojure CLI or Leiningen when prompted for the project type Wait a few moments for the REPL to start. A new CLJ REPL tab will open when the Clojure REPL is ready","title":"Start a REPL for basic projects"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#troubleshooting","text":"If the REPL did not start, the nREPL link in the bottom blue bar will show the word \"Disconnected\". Open the Output tab to see the progress of the REPL starting. Ask your coach for help if you see output other than that below. Try running a REPL in the command line and connecting to it (details at bottom of this page).","title":"Troubleshooting"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#start-a-repl-on-the-command-line","text":"Ctrl+` toggles open the VSCode Integrated terminal . Or open your operating system terminal.","title":"Start a REPL on the command line"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#infowindows-gitbash-users","text":"Configure the VS Code internal terminal to use the GitBash shell . In the terminal, change to the folder than contains your project, e.g. cd projects/clojure/playground To use Leiningen, type the command lein repl in the terminal. To use Clojure CLI tools, us the practicalli/clojure-deps-edn aliases and run a REPL that also starts an nREPL server clojure -M:middleware/cider-clj If you also wish to have an interactive terminal REPL, include rebel readline when starting the REPL clojure -M:repl/rebel-nrepl","title":"INFO::Windows GitBash users"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#connecting-to-an-external-repl-from-calva","text":"Ctrl+Alt+c Ctrl+Alt+c will open a command pop-up asking you to enter host and port . These details were shown when the REPL was run in the terminal. In the bottom left of the VS Code window, check the status of the nrepl connection. If you are connected, then the disconnected status should disappear","title":"Connecting to an external REPL from Calva"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#developing-your-project","text":"Once you have a running REPL, use these commands to help you develop your code.","title":"Developing your project"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#hintmacosx-keys-option-or-alt_1","text":"Depending on the version of Mac computer you use, your Alt key may be called Option So Ctrl+Alt+c e would be Ctrl+Option+c e Evaluate code Keybinding Description Namespace/file Ctrl+Alt+c ENTER Load current file/namespace and all required namespaces Top level expression Ctrl+Alt+c SPACE Show the result of the top level expression Expression Ctrl+Alt+c e Show the result of the current expression Expression (send to REPL) Ctrl+Alt+c alt+e Evaluate current expression in the REPL Window Expression to comment Ctrl+Alt+c c Evaluate current expression and paste as comment Replace expression Ctrl+Alt+c r Replace the expression with its result In the REPL ALt+Enter Evaluates the current line REPL window You can run tests from Calva too... Tests to run Keybinding Description All tests Ctrl+Alt+c Shift+t Run all tests in the project Current Namespace tests Ctrl+Alt+c t Run all tests for the current namespace Re-run failing tests Ctrl+Alt+c Ctrl+t Run all tests for the current namespace","title":"HINT::MacOSX Keys - Option or Alt"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#hintrepl-history","text":"The REPL window maintains a history of the code typed in and can be navigated by pressing Alt+Up and Alt+Down .","title":"HINT::REPL history"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#commenting-uncommenting-code","text":"Use ;; at the start of a line, which comments it out.","title":"Commenting / uncommenting code"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#warningline-comments-keybindings","text":"The Add Line Comment command to place line comment command is broken in Calva, it only produces a single semi-colon","title":"WARNING::Line comments keybindings ?"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#increase-decrease-font-size","text":"Ctrl + and Ctrl - will increase and decrease the size of the whole editor. Ctrl Shift P and type the command Preference: Open Settings (JSON) to open the settings.json configuration file. Update the value for editor.fontSize and save the file. The font should update immediately in the VS Code UI. Other useful options that can be added to the settings.json configuration \"workbench.colorTheme\": \"Solarized Light\", \"editor.fontSize\": 14, \"editor.fontFamily\": \"'Fira Code', 'Ubuntu Mono', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'\", \"window.zoomLevel\": 1, \"calva.paredit.defaultKeyMap\": \"strict\"","title":"Increase / decrease font size"},{"location":"clojure-editors/editor-user-guides/vscode-calva/#structured-editing-paredit","text":"Once you get the basics of Clojure development, you can try structural editing which is a way to edit your code without breaking the structure of Clojure. Structural editing ensures you dont have uneven parentheses, () , [] , {} , etc. The Calva visual Guide to Paredit includes lots of examples of using Structural editing.","title":"Structured editing - Paredit"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/","text":"VS Code with VSpaceCode and Calva \u03bb\ufe0e The Calva User Guide provides a detailed guide to the features of Calva, although the key bindings for VSpaceCode are not included in that guide. Open the VSCode editor and open the root folder of your project. Then add use let Calva start your project REPL and connect. Open Project Folder in VSCode \u03bb\ufe0e SPC SPC to open the command menu and type file open folder and select the folder that contains the Clojure project. Select the top level of the folder, e.g. playground and type Ctrl-l Start a REPL for the project \u03bb\ufe0e , \" to jack-in to a Clojure REPL for the project. This starts an external REPL process and connects to it. Alternative, use , ' to connect to an external REPL process that has already started. Select either deps.edn for Clojure CLI or Leiningen when prompted for the project type Wait a few moments for the REPL to start. A new REPL window will open when the Clojure REPL is ready Troubleshooting \u03bb\ufe0e If the REPL did not start, the nREPL link in the bottom blue bar will show the word \"Disconnected\". Open the Output tab to see the progress of the REPL starting. Try running a REPL in the command line and connecting to it (details at bottom of this page). Evaluating Clojure code \u03bb\ufe0e , e f to evaluate a top-level expression and see the results inline. Or , e s to select a specific expression and , e e to evaluate it. , e l to clear all the evaluated results. Keybinding Description , e ; Evaluate the current expression and paste as comment , e : Evaluate the current expression and paste as comment , e e Show the result of the current expression , e f Show the result of the top level expression , e l Clear all the evaluated results , e n Evaluate all code in the current file/namespace , e w Replace the expression with its result Running tests \u03bb\ufe0e , e n to evaluate all the unit test code in the current window , t a to run all the unit tests in the project , t f to run just the failing tests Keybinding Description , t a Run all tests in the project , t f Run all tests for the current namespace , t n Run all tests for the current namespace , t t Run all tests for the current namespace HINT::Test results shown in REPL \u03bb\ufe0e The REPL window is used to display the results of running unit tests Commenting / uncommenting code \u03bb\ufe0e SPC c l toggles a comment on the current line. Use the Add Line Comment command to place ;; at the start of a line, which comments it out. Linting \u03bb\ufe0e , c n and , c N cycle through clj-kondo linting warnings Increase / decrease font size \u03bb\ufe0e Ctrl + and Ctrl - will increase and decrease the size of the whole editor. SPC SPC and type the command Preference: Open Settings (JSON) to open the settings.json configuration file. Update the value for editor.fontSize and save the file. The font should update immediately in the VS Code UI. Other useful options that can be added to the settings.json configuration \"workbench.colorTheme\": \"Solarized Light\", \"editor.fontSize\": 14, \"editor.fontFamily\": \"'Fira Code', 'Ubuntu Mono', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'\", \"window.zoomLevel\": 1, \"calva.paredit.defaultKeyMap\": \"strict\" Structural editing - Paredit \u03bb\ufe0e , k is the structural editing menu. Structural editing ensures code can be written and edited without breaking the structure of Clojure. Structural editing ensures you dont have uneven parentheses, () , [] , {} , etc. The Calva visual Guide to Paredit includes lots of examples of using Structural editing. Keybinding Description , k . Toggle paredit strict mode , k b Barf forwards , k c Convolute expression , k h Jump backwards , k j Jump forward down an expression , k k Jump backwards down an expression , k l Jump forward an expression , k r Raise an expression (over-write parent expression) , k s Slurp forward , k t Transpose expression , k w ( Wrap with () , k w [ Wrap with [] , k w { Wrap with {} , k w \" Wrap with \"\" , k w p rewrap with () , k w s rewWrap with [] , k w c rewWrap with {} , k w q rewWrap with \"\" Start a REPL on the command line \u03bb\ufe0e Ctrl+` toggles open the VSCode Integrated terminal . Or open your operating system terminal. INFO::Windows GitBash users \u03bb\ufe0e Configure the VS Code internal terminal to use the GitBash shell . In the terminal, change to the folder than contains your project, e.g. cd projects/clojure/playground For a Clojure CLI project, use the command clojure -M:env/test:middleware/cider-clj to run a REPL process for Calva to connect to via nREPL, using the practicalli/clojure-deps-edn configuration . For a Leiningen project, use the command lein repl Connecting to an external REPL from Calva \u03bb\ufe0e , ' to connect to an external REPL process. Select either Clojure CLI or Leiningen when prompted for the project type Confirm the host and port of the REPL, this should be automatically detected. These details were shown when the REPL was run in the terminal. Wait a few moments for the REPL to start. A new REPL window will open when the Clojure REPL is ready In the bottom left of the VS Code window, check the status of the nrepl connection. If you are connected, then the disconnected status should disappear","title":"Vspacecode calva"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#vs-code-with-vspacecode-and-calva","text":"The Calva User Guide provides a detailed guide to the features of Calva, although the key bindings for VSpaceCode are not included in that guide. Open the VSCode editor and open the root folder of your project. Then add use let Calva start your project REPL and connect.","title":"VS Code with VSpaceCode and Calva"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#open-project-folder-in-vscode","text":"SPC SPC to open the command menu and type file open folder and select the folder that contains the Clojure project. Select the top level of the folder, e.g. playground and type Ctrl-l","title":"Open Project Folder in VSCode"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#start-a-repl-for-the-project","text":", \" to jack-in to a Clojure REPL for the project. This starts an external REPL process and connects to it. Alternative, use , ' to connect to an external REPL process that has already started. Select either deps.edn for Clojure CLI or Leiningen when prompted for the project type Wait a few moments for the REPL to start. A new REPL window will open when the Clojure REPL is ready","title":"Start a REPL for the project"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#troubleshooting","text":"If the REPL did not start, the nREPL link in the bottom blue bar will show the word \"Disconnected\". Open the Output tab to see the progress of the REPL starting. Try running a REPL in the command line and connecting to it (details at bottom of this page).","title":"Troubleshooting"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#evaluating-clojure-code","text":", e f to evaluate a top-level expression and see the results inline. Or , e s to select a specific expression and , e e to evaluate it. , e l to clear all the evaluated results. Keybinding Description , e ; Evaluate the current expression and paste as comment , e : Evaluate the current expression and paste as comment , e e Show the result of the current expression , e f Show the result of the top level expression , e l Clear all the evaluated results , e n Evaluate all code in the current file/namespace , e w Replace the expression with its result","title":"Evaluating Clojure code"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#running-tests","text":", e n to evaluate all the unit test code in the current window , t a to run all the unit tests in the project , t f to run just the failing tests Keybinding Description , t a Run all tests in the project , t f Run all tests for the current namespace , t n Run all tests for the current namespace , t t Run all tests for the current namespace","title":"Running tests"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#hinttest-results-shown-in-repl","text":"The REPL window is used to display the results of running unit tests","title":"HINT::Test results shown in REPL"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#commenting-uncommenting-code","text":"SPC c l toggles a comment on the current line. Use the Add Line Comment command to place ;; at the start of a line, which comments it out.","title":"Commenting / uncommenting code"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#linting","text":", c n and , c N cycle through clj-kondo linting warnings","title":"Linting"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#increase-decrease-font-size","text":"Ctrl + and Ctrl - will increase and decrease the size of the whole editor. SPC SPC and type the command Preference: Open Settings (JSON) to open the settings.json configuration file. Update the value for editor.fontSize and save the file. The font should update immediately in the VS Code UI. Other useful options that can be added to the settings.json configuration \"workbench.colorTheme\": \"Solarized Light\", \"editor.fontSize\": 14, \"editor.fontFamily\": \"'Fira Code', 'Ubuntu Mono', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Fallback'\", \"window.zoomLevel\": 1, \"calva.paredit.defaultKeyMap\": \"strict\"","title":"Increase / decrease font size"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#structural-editing-paredit","text":", k is the structural editing menu. Structural editing ensures code can be written and edited without breaking the structure of Clojure. Structural editing ensures you dont have uneven parentheses, () , [] , {} , etc. The Calva visual Guide to Paredit includes lots of examples of using Structural editing. Keybinding Description , k . Toggle paredit strict mode , k b Barf forwards , k c Convolute expression , k h Jump backwards , k j Jump forward down an expression , k k Jump backwards down an expression , k l Jump forward an expression , k r Raise an expression (over-write parent expression) , k s Slurp forward , k t Transpose expression , k w ( Wrap with () , k w [ Wrap with [] , k w { Wrap with {} , k w \" Wrap with \"\" , k w p rewrap with () , k w s rewWrap with [] , k w c rewWrap with {} , k w q rewWrap with \"\"","title":"Structural editing - Paredit"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#start-a-repl-on-the-command-line","text":"Ctrl+` toggles open the VSCode Integrated terminal . Or open your operating system terminal.","title":"Start a REPL on the command line"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#infowindows-gitbash-users","text":"Configure the VS Code internal terminal to use the GitBash shell . In the terminal, change to the folder than contains your project, e.g. cd projects/clojure/playground For a Clojure CLI project, use the command clojure -M:env/test:middleware/cider-clj to run a REPL process for Calva to connect to via nREPL, using the practicalli/clojure-deps-edn configuration . For a Leiningen project, use the command lein repl","title":"INFO::Windows GitBash users"},{"location":"clojure-editors/editor-user-guides/vspacecode-calva/#connecting-to-an-external-repl-from-calva","text":", ' to connect to an external REPL process. Select either Clojure CLI or Leiningen when prompted for the project type Confirm the host and port of the REPL, this should be automatically detected. These details were shown when the REPL was run in the terminal. Wait a few moments for the REPL to start. A new REPL window will open when the Clojure REPL is ready In the bottom left of the VS Code window, check the status of the nrepl connection. If you are connected, then the disconnected status should disappear","title":"Connecting to an external REPL from Calva"},{"location":"clojure-editors/install-guides/","text":"Editor Install Guides \u03bb\ufe0e Short guides to using clojure aware editors to quickly start with the basics. References are included to the full documentation for using each editor for further study. === \"Atom.io\" %} Atom.io is flexible and simple to use editor. The ProtoREPL plugin adds support for Clojure and ClojureScript. Simplified menu and configuration approach \u03bb\ufe0e Proton offers a simple mnemonic menu as an alternative to the somewhat cumbersome keybindings in Atom.io. Proton also gives you a simple text configuration to manage all your packages quickly. === \"VS Code\" %} VSCode Calva extension === \"Spacemacs\" %} Spacemacs is a community configuration bring Emacs and Vim together. Spacemacs uses a mnemonic menu system that makes it easy to learn. Spacemacs, Practicalli guides you through Clojure development, documenting with org-mode, Git version control with Magit, Vim editing modes and dozens of other features. === \"IntelliJ\" %} Cursive IDE for IntelliJ","title":"Editor Install Guides"},{"location":"clojure-editors/install-guides/#editor-install-guides","text":"Short guides to using clojure aware editors to quickly start with the basics. References are included to the full documentation for using each editor for further study. === \"Atom.io\" %} Atom.io is flexible and simple to use editor. The ProtoREPL plugin adds support for Clojure and ClojureScript.","title":"Editor Install Guides"},{"location":"clojure-editors/install-guides/#simplified-menu-and-configuration-approach","text":"Proton offers a simple mnemonic menu as an alternative to the somewhat cumbersome keybindings in Atom.io. Proton also gives you a simple text configuration to manage all your packages quickly. === \"VS Code\" %} VSCode Calva extension === \"Spacemacs\" %} Spacemacs is a community configuration bring Emacs and Vim together. Spacemacs uses a mnemonic menu system that makes it easy to learn. Spacemacs, Practicalli guides you through Clojure development, documenting with org-mode, Git version control with Magit, Vim editing modes and dozens of other features. === \"IntelliJ\" %} Cursive IDE for IntelliJ","title":"Simplified menu and configuration approach"},{"location":"clojure-editors/install-guides/atom-proton/","text":"Atom Proton \u03bb\ufe0e Proton-mode gives a Spacemacs-like experience to the Atom editor Proton-mode provides a mnemonic menu and set of keybindings that offer an effective alternative to the interesting keybindings with Atom and ProtoREPL. It also provides modal editing features, simplifying keybindings. Install Atom.io \u03bb\ufe0e Follow the instructions for your operating system {% tabs first=\"Debian/Ubuntu\", second=\"MacOSX\", third=\"RedHat\", forth=\"Windows\" %} {% content \"first\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions. Standalone Install \u03bb\ufe0e Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install. Via Package Manager \u03bb\ufe0e Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom Running Atom \u03bb\ufe0e To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"second\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"third\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"forth\" %} Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %} Install Proton \u03bb\ufe0e Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Proton-mode - Spacemacs style menu and keybindings to make Atom easier to use (included Vim / Emacs keybinding support) Recommended packages lisp-paredit - to manage your () proto-repl-charts - graphs and charts tool-bar - displays a REPL tool bar highlight-selected - highlights selected keywords throughout an editor Download the sample project \u03bb\ufe0e We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs fifth=\"Download project as zip file\", sixth=\"Clone project from Github\" %} {% content \"fifth\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"sixth\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %} Test your editor with a clojure project \u03bb\ufe0e Add the project called welcometoclojurebridge . Open the src/welcometoclojurebridge/core.clj file. Ctrl-Alt-, s to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Atom Proton"},{"location":"clojure-editors/install-guides/atom-proton/#atom-proton","text":"Proton-mode gives a Spacemacs-like experience to the Atom editor Proton-mode provides a mnemonic menu and set of keybindings that offer an effective alternative to the interesting keybindings with Atom and ProtoREPL. It also provides modal editing features, simplifying keybindings.","title":"Atom Proton"},{"location":"clojure-editors/install-guides/atom-proton/#install-atomio","text":"Follow the instructions for your operating system {% tabs first=\"Debian/Ubuntu\", second=\"MacOSX\", third=\"RedHat\", forth=\"Windows\" %} {% content \"first\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions.","title":"Install Atom.io"},{"location":"clojure-editors/install-guides/atom-proton/#standalone-install","text":"Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install.","title":"Standalone Install"},{"location":"clojure-editors/install-guides/atom-proton/#via-package-manager","text":"Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom","title":"Via Package Manager"},{"location":"clojure-editors/install-guides/atom-proton/#running-atom","text":"To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"second\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"third\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"forth\" %} Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %}","title":"Running Atom"},{"location":"clojure-editors/install-guides/atom-proton/#install-proton","text":"Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Proton-mode - Spacemacs style menu and keybindings to make Atom easier to use (included Vim / Emacs keybinding support) Recommended packages lisp-paredit - to manage your () proto-repl-charts - graphs and charts tool-bar - displays a REPL tool bar highlight-selected - highlights selected keywords throughout an editor","title":"Install Proton"},{"location":"clojure-editors/install-guides/atom-proton/#download-the-sample-project","text":"We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs fifth=\"Download project as zip file\", sixth=\"Clone project from Github\" %} {% content \"fifth\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"sixth\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %}","title":"Download the sample project"},{"location":"clojure-editors/install-guides/atom-proton/#test-your-editor-with-a-clojure-project","text":"Add the project called welcometoclojurebridge . Open the src/welcometoclojurebridge/core.clj file. Ctrl-Alt-, s to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Test your editor with a clojure project"},{"location":"clojure-editors/install-guides/atom-protorepl/","text":"Atom.io and ProtoREPL \u03bb\ufe0e Proto REPL is a Clojure development environment and REPL for Atom.io. Install Atom.io \u03bb\ufe0e Follow the instructions for your operating system {% tabs first=\"Debian/Ubuntu\", second=\"MacOSX\", third=\"RedHat\", forth=\"Windows\" %} {% content \"first\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions. Standalone Install \u03bb\ufe0e Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install. Via Package Manager \u03bb\ufe0e Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom Running Atom \u03bb\ufe0e To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"second\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"third\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"forth\" %} Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %} Install Proto REPL package \u03bb\ufe0e Open the Atom Settings. In the install section, search for each of the required packages and install them. If you have time, also install the recommended packages. Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Recommended packages lisp-paredit - to manage your () proto-repl-charts Configure ProtoREPL with Leiningen \u03bb\ufe0e Go to the Proto REPL Settings (Atom Preferences, then packages, then Proto REPL) Modify \"Lein Path\" to the path where Leiningen. Use which lein in a terminal to get the path. Download the sample project \u03bb\ufe0e We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs fifth=\"Download project as zip file\", sixth=\"Clone project from Github\" %} {% content \"fifth\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"sixth\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %} Test your editor with a clojure project \u03bb\ufe0e Add the project called welcometoclojurebridge . Open the src/welcometoclojurebridge/core.clj file. Ctrl-Alt-, s to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Atom.io and ProtoREPL"},{"location":"clojure-editors/install-guides/atom-protorepl/#atomio-and-protorepl","text":"Proto REPL is a Clojure development environment and REPL for Atom.io.","title":"Atom.io and ProtoREPL"},{"location":"clojure-editors/install-guides/atom-protorepl/#install-atomio","text":"Follow the instructions for your operating system {% tabs first=\"Debian/Ubuntu\", second=\"MacOSX\", third=\"RedHat\", forth=\"Windows\" %} {% content \"first\" %} The standalone install is the simplest option. However, using the package manager approach will simplify updating Atom.io to new versions.","title":"Install Atom.io"},{"location":"clojure-editors/install-guides/atom-protorepl/#standalone-install","text":"Download the latest .deb file from Atom.io Once downloaded, double-click the .deb file to install.","title":"Standalone Install"},{"location":"clojure-editors/install-guides/atom-protorepl/#via-package-manager","text":"Add the official Atom package repository to your system by running the following commands in a terminal window: curl -sL https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" > /etc/apt/sources.list.d/atom.list' sudo apt-get update sudo apt-get install atom","title":"Via Package Manager"},{"location":"clojure-editors/install-guides/atom-protorepl/#running-atom","text":"To run atom, press the Super key and type atom , or open a terminal and type the command atom . {% content \"second\" %} Download the atom-mac.zip file. Open the atom-mac.zip file (double click) and drag the Atom application into your \"Applications\" folder. See Installing Atom for troubleshooting and further details. {% content \"third\" %} Download the latest .rpm file from Atom.io Once downloaded, double-click the .rpm file to install. To run atom, press the Super key and type atom , or open a terminal and type the command atom . See the Atom guide for Fedora if you wish to use the package manager instead. {% content \"forth\" %} Downloaded AtomSetup.exe Windows Installer. Open the AtomSetup.exe installer and follow the instructions. This will install Atom, add the atom and apm commands to your PATH and create a shortcut in the start menu. {% endtabs %}","title":"Running Atom"},{"location":"clojure-editors/install-guides/atom-protorepl/#install-proto-repl-package","text":"Open the Atom Settings. In the install section, search for each of the required packages and install them. If you have time, also install the recommended packages. Required packages ink - Proto REPL dependency used for inline display and the REPL output. proto-repl - Clojure REPL, autocompletion, etc. Recommended packages lisp-paredit - to manage your () proto-repl-charts","title":"Install Proto REPL package"},{"location":"clojure-editors/install-guides/atom-protorepl/#configure-protorepl-with-leiningen","text":"Go to the Proto REPL Settings (Atom Preferences, then packages, then Proto REPL) Modify \"Lein Path\" to the path where Leiningen. Use which lein in a terminal to get the path.","title":"Configure ProtoREPL with Leiningen"},{"location":"clojure-editors/install-guides/atom-protorepl/#download-the-sample-project","text":"We have created an example Clojure project called \"Welcome To ClojureBridge\" to test your development tools. {% tabs fifth=\"Download project as zip file\", sixth=\"Clone project from Github\" %} {% content \"fifth\" %} Download the \"Welcome To ClojureBridge\" zip file and extract all the files. {% content \"sixth\" %} If you are comfortable using the git version control tool and the command line, then you can clone the project using git git clone https://github.com/ClojureBridge/welcometoclojurebridge {% endtabs %}","title":"Download the sample project"},{"location":"clojure-editors/install-guides/atom-protorepl/#test-your-editor-with-a-clojure-project","text":"Add the project called welcometoclojurebridge . Open the src/welcometoclojurebridge/core.clj file. Ctrl-Alt-, s to start a Clojure REPL and display the REPL in a new window. You should see a friendly message from the ClojureBridge team.","title":"Test your editor with a clojure project"},{"location":"clojure-editors/install-guides/vscode-calva/","text":"Microsoft VSCode and Calva extension \u03bb\ufe0e VS Code supports Clojure and ClojureScript development through an extension called Calva . A Clojure REPL is run via Leiningen first, then connected to from VSCode. Install VS Code \u03bb\ufe0e {% tabs first=\"Debian/Ubuntu\", second=\"MacOSX\", third=\"RedHat\", forth=\"Windows\" %} {% content \"first\" %} Download the .deb file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Enter your password when prompted to install the software. Close the Ubuntu Software app once the install has finished. Reference: VSCode on Linux Running VSCode \u03bb\ufe0e To run VSCode, press the Super key and type code , or open a terminal and type the command code . {% content \"second\" %} Download the .zip file Double-click on the downloaded archive to expand the contents. Drag Visual Studio Code.app to the Applications folder, making it available in the Launchpad. Add VS Code to your Dock by right-clicking on the icon and choosing Options, Keep in Dock . Reference: VSCode on MacOSX Running VSCode \u03bb\ufe0e Launch VSCode from the Dock, or in a command line terminal, type code . {% content \"third\" %} Download the .rpm file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Running VSCode \u03bb\ufe0e To run VSCode, press the Super key and type code , or open a terminal and type the command code . Reference: VSCode on Linux {% content \"forth\" %} Download the Windows Installer Run the installer which should have a name similar to VSCodeUserSetup-{version}.exe . VS Code is installed under C:\\users\\{username}\\AppData\\Local\\Programs\\Microsoft VS Code . Reference: VSCode on Windows Running VSCode \u03bb\ufe0e Open the Start menu and type code . Click on the VSCode icon to start. {% endtabs %} Install Calva extension \u03bb\ufe0e Launch VS Code Quick Open, Ctrl+P , paste the following command, and press enter. ext install cospaia.clojure4vscode Reference: VSCode Extension Marketplace","title":"Microsoft VSCode and Calva extension"},{"location":"clojure-editors/install-guides/vscode-calva/#microsoft-vscode-and-calva-extension","text":"VS Code supports Clojure and ClojureScript development through an extension called Calva . A Clojure REPL is run via Leiningen first, then connected to from VSCode.","title":"Microsoft VSCode and Calva extension"},{"location":"clojure-editors/install-guides/vscode-calva/#install-vs-code","text":"{% tabs first=\"Debian/Ubuntu\", second=\"MacOSX\", third=\"RedHat\", forth=\"Windows\" %} {% content \"first\" %} Download the .deb file Open (double click) the file. The Ubuntu software studio will open. Click the Install button. Enter your password when prompted to install the software. Close the Ubuntu Software app once the install has finished. Reference: VSCode on Linux","title":"Install VS Code"},{"location":"clojure-editors/install-guides/vscode-calva/#running-vscode","text":"To run VSCode, press the Super key and type code , or open a terminal and type the command code . {% content \"second\" %} Download the .zip file Double-click on the downloaded archive to expand the contents. Drag Visual Studio Code.app to the Applications folder, making it available in the Launchpad. Add VS Code to your Dock by right-clicking on the icon and choosing Options, Keep in Dock . Reference: VSCode on MacOSX","title":"Running VSCode"},{"location":"clojure-editors/install-guides/vscode-calva/#running-vscode_1","text":"Launch VSCode from the Dock, or in a command line terminal, type code . {% content \"third\" %} Download the .rpm file Open (double click) the file. The Ubuntu software studio will open. Click the Install button.","title":"Running VSCode"},{"location":"clojure-editors/install-guides/vscode-calva/#running-vscode_2","text":"To run VSCode, press the Super key and type code , or open a terminal and type the command code . Reference: VSCode on Linux {% content \"forth\" %} Download the Windows Installer Run the installer which should have a name similar to VSCodeUserSetup-{version}.exe . VS Code is installed under C:\\users\\{username}\\AppData\\Local\\Programs\\Microsoft VS Code . Reference: VSCode on Windows","title":"Running VSCode"},{"location":"clojure-editors/install-guides/vscode-calva/#running-vscode_3","text":"Open the Start menu and type code . Click on the VSCode icon to start. {% endtabs %}","title":"Running VSCode"},{"location":"clojure-editors/install-guides/vscode-calva/#install-calva-extension","text":"Launch VS Code Quick Open, Ctrl+P , paste the following command, and press enter. ext install cospaia.clojure4vscode Reference: VSCode Extension Marketplace","title":"Install Calva extension"},{"location":"clojure-spec/","text":"Clojure Specifications \u03bb\ufe0e Clojure Spec is a library for defining specifications around data and functions to test for correctness. A spec defines the expected shape of specific values in Clojure and specs are intended to be used across multiple projects. Specifications for more complex values are composed of specific value specifications, providing a flexible way to define what key parts of the system should look like. Clojure specs are used to generate comprehensive test data, identifying more scenarios and edge cases with less code. Spec is included in Clojure version 1.9 onward and can be used by requiring the clojure.spec.alpha in the REPL or in namespaces of a Clojure project. Recommended Reading \u03bb\ufe0e What is Clojure spec - an illustrated guide Purpose of Clojure spec \u03bb\ufe0e A summary highlighting the common purposes that Clojure Spec is used for Purpose Description Living documentation Use spec to include specifications in Function documentation ( fdef ) Data Validation Ensure the data entering and leaving the system or its key functions are of the correct form. Test Data Generation Provide extensive test data coverage with minimal code maintenance Generative testing of functions Test functions using their spec defined contract ( fdef ) Generative scenario testing Specific correct usage paths for known states Development time checking Instrument functions to ensure correctness Derive code from specifications Specify a system of record for data structures, internal and external to the system. How do you use clojure.spec - Sean Corfield Example use cases \u03bb\ufe0e API requests (schema is often used here, but so can spec) Checking data pulled from / pushed to message systems (e.g. Kafka, TIBCO) Data specifications (eg. Vega-lite) Example code \u03bb\ufe0e practicalli/leveraging-spec - basic examples of using spec, following the Practicalli Spec broadcasts Understanding the basics of Clojure Spec \u03bb\ufe0e Trying clojure.spec \u03bb\ufe0e Follow the examples in these two excellent videos Why is the spec library called alpha? \u03bb\ufe0e The library is called clojure.spec.alpha as the design of spec is still evolving and there may be some changes to the design in later versions. Clojure aims for backwards compatibility, so new versions typically do not break existing use of libraries. There are some important changes being developed for spec version 2 and a few things may change, however, the large majority of Spec will remain the same and is safe to use. References \u03bb\ufe0e spec.alpha API reference Introducing clojure.spec clojure.spec - rational and overview Clojure Spec: Expressing Data Constraints without Types spec guide - clojure.org Specifications for clojure.core Leveraging clojure.spec - Stuart Halloway - YouTube spec.test - Stuart Halloway - YouTube","title":"Clojure Specifications"},{"location":"clojure-spec/#clojure-specifications","text":"Clojure Spec is a library for defining specifications around data and functions to test for correctness. A spec defines the expected shape of specific values in Clojure and specs are intended to be used across multiple projects. Specifications for more complex values are composed of specific value specifications, providing a flexible way to define what key parts of the system should look like. Clojure specs are used to generate comprehensive test data, identifying more scenarios and edge cases with less code. Spec is included in Clojure version 1.9 onward and can be used by requiring the clojure.spec.alpha in the REPL or in namespaces of a Clojure project.","title":"Clojure Specifications"},{"location":"clojure-spec/#recommended-reading","text":"What is Clojure spec - an illustrated guide","title":"Recommended Reading"},{"location":"clojure-spec/#purpose-of-clojure-spec","text":"A summary highlighting the common purposes that Clojure Spec is used for Purpose Description Living documentation Use spec to include specifications in Function documentation ( fdef ) Data Validation Ensure the data entering and leaving the system or its key functions are of the correct form. Test Data Generation Provide extensive test data coverage with minimal code maintenance Generative testing of functions Test functions using their spec defined contract ( fdef ) Generative scenario testing Specific correct usage paths for known states Development time checking Instrument functions to ensure correctness Derive code from specifications Specify a system of record for data structures, internal and external to the system. How do you use clojure.spec - Sean Corfield","title":"Purpose of Clojure spec"},{"location":"clojure-spec/#example-use-cases","text":"API requests (schema is often used here, but so can spec) Checking data pulled from / pushed to message systems (e.g. Kafka, TIBCO) Data specifications (eg. Vega-lite)","title":"Example use cases"},{"location":"clojure-spec/#example-code","text":"practicalli/leveraging-spec - basic examples of using spec, following the Practicalli Spec broadcasts","title":"Example code"},{"location":"clojure-spec/#understanding-the-basics-of-clojure-spec","text":"","title":"Understanding the basics of Clojure Spec"},{"location":"clojure-spec/#trying-clojurespec","text":"Follow the examples in these two excellent videos","title":"Trying clojure.spec"},{"location":"clojure-spec/#why-is-the-spec-library-called-alpha","text":"The library is called clojure.spec.alpha as the design of spec is still evolving and there may be some changes to the design in later versions. Clojure aims for backwards compatibility, so new versions typically do not break existing use of libraries. There are some important changes being developed for spec version 2 and a few things may change, however, the large majority of Spec will remain the same and is safe to use.","title":"Why is the spec library called alpha?"},{"location":"clojure-spec/#references","text":"spec.alpha API reference Introducing clojure.spec clojure.spec - rational and overview Clojure Spec: Expressing Data Constraints without Types spec guide - clojure.org Specifications for clojure.core Leveraging clojure.spec - Stuart Halloway - YouTube spec.test - Stuart Halloway - YouTube","title":"References"},{"location":"clojure-spec/add-spec-to-projects/","text":"Add Spec to Clojure Projects \u03bb\ufe0e Add the clojure.spec.alpha to namespaces in the project that should directly use functions from that library. It is recommended to use the spec alias to clearly indicate where those functions are defined. ( ns practicalli.leveraging-spec ( :require [ clojure.spec.alpha :as spec ])) Evaluate the namespace definition to start using the functions from the namespace. Using Spec functions \u03bb\ufe0e All functions from clojure.spec.alpha are accessible using the spec alias, e.g. spec/conform , spec/valid? , spec/def . Testing specifications \u03bb\ufe0e Add the clojure.spec.test.alpha to any namespaces in the project that will directly use the functions from that library. It is recommended to use the spec-test alias to clearly indicate where those functions are defined. ( ns practicalli.leveraging-spec ( :require [ clojure.spec.alpha :as spec ] [ clojure.spec.test.alpha :as spec-test ])) Using Spec functions \u03bb\ufe0e All functions from clojure.spec.alpha are accessible using the spec alias, e.g. spec/conform , spec/valid? , spec/def . Creating new projects \u03bb\ufe0e Create a new Clojure project using the clj-new tool or open an existing deps.edn based project. clojure -T:project/new :template lib :name practicalli/leveraging-spec The project is created with Clojure as a dependency, which in turn includes the clojure.spec.alpha library. Clojure 1.9.0 or higher versions include Clojure Spec. Clojure 1.11.1 is recommended. The practicalli/leveraging-spec project is a working example that includes clojure.spec.alpha . Hint:: :project/new is an alias from practicalli/clojure-deps-edn \u03bb\ufe0e practicalli/clojure-deps-edn repository includes the :project/new alias for creating new Clojure projects from a template using clj-new .","title":"Add Spec to Clojure Projects"},{"location":"clojure-spec/add-spec-to-projects/#add-spec-to-clojure-projects","text":"Add the clojure.spec.alpha to namespaces in the project that should directly use functions from that library. It is recommended to use the spec alias to clearly indicate where those functions are defined. ( ns practicalli.leveraging-spec ( :require [ clojure.spec.alpha :as spec ])) Evaluate the namespace definition to start using the functions from the namespace.","title":"Add Spec to Clojure Projects"},{"location":"clojure-spec/add-spec-to-projects/#using-spec-functions","text":"All functions from clojure.spec.alpha are accessible using the spec alias, e.g. spec/conform , spec/valid? , spec/def .","title":"Using Spec functions"},{"location":"clojure-spec/add-spec-to-projects/#testing-specifications","text":"Add the clojure.spec.test.alpha to any namespaces in the project that will directly use the functions from that library. It is recommended to use the spec-test alias to clearly indicate where those functions are defined. ( ns practicalli.leveraging-spec ( :require [ clojure.spec.alpha :as spec ] [ clojure.spec.test.alpha :as spec-test ]))","title":"Testing specifications"},{"location":"clojure-spec/add-spec-to-projects/#using-spec-functions_1","text":"All functions from clojure.spec.alpha are accessible using the spec alias, e.g. spec/conform , spec/valid? , spec/def .","title":"Using Spec functions"},{"location":"clojure-spec/add-spec-to-projects/#creating-new-projects","text":"Create a new Clojure project using the clj-new tool or open an existing deps.edn based project. clojure -T:project/new :template lib :name practicalli/leveraging-spec The project is created with Clojure as a dependency, which in turn includes the clojure.spec.alpha library. Clojure 1.9.0 or higher versions include Clojure Spec. Clojure 1.11.1 is recommended. The practicalli/leveraging-spec project is a working example that includes clojure.spec.alpha .","title":"Creating new projects"},{"location":"clojure-spec/add-spec-to-projects/#hint-projectnew-is-an-alias-from-practicalliclojure-deps-edn","text":"practicalli/clojure-deps-edn repository includes the :project/new alias for creating new Clojure projects from a template using clj-new .","title":"Hint:: :project/new is an alias from practicalli/clojure-deps-edn"},{"location":"clojure-spec/organising-specs/","text":"Organizing Specifications \u03bb\ufe0e Data and function definition specifications are typically placed in a specifications namespace under the relevant src directory for a project. Add the data specifications ( spec/def ), custom predicate functions and function specifications ( spec/fdef ) to the specifications namespace. Instrumenting functions \u03bb\ufe0e Add spec-test/instrument expressions to the specifications file, after the spec/fdef expressions. Rather than create individual expressions, create a clojure.core/def to contain a collection of all the spec/fdef expressions. This list can then be used to instrument and unstrument all the spec/fdef specifications. ( def ^ :private function-specifications [ ` card-game/deal-cards ` card-game/winning-player ]) Write simple helper functions to wrap the instrumenting of function specifications ( defn instrument-all-functions [] ( spec-test/instrument function-specifications )) ( defn unstrument-all-functions [] ( spec-test/unstrument function-specifications )) Unit testing \u03bb\ufe0e Specifications can be incorporated into the existing unit tests, so it is sensible to keep them under the corresponding test directory files. Generative testing \u03bb\ufe0e Using spec-test/check will generate 1000 data values for each expression, so by default these tests will take far longer that other tests. Configuring generative tests to only generate a small number of values will make spec-test/check expressions return almost instantaneously. In this example, only 10 data values are generated ( spec-test/check ` deal-cards { :clojure.spec.test.check/opts { :num-tests 10 }}) Generative testing with small generators can be run regularly during development without impacting fast feedback. It is recommended to separate full generative testing from unit tests, to maintain the fast feedback of those unit tests. These tests can be included in a separate namespace or marked with meta data as integration tests, e.g ^:integration","title":"Organizing Specifications"},{"location":"clojure-spec/organising-specs/#organizing-specifications","text":"Data and function definition specifications are typically placed in a specifications namespace under the relevant src directory for a project. Add the data specifications ( spec/def ), custom predicate functions and function specifications ( spec/fdef ) to the specifications namespace.","title":"Organizing Specifications"},{"location":"clojure-spec/organising-specs/#instrumenting-functions","text":"Add spec-test/instrument expressions to the specifications file, after the spec/fdef expressions. Rather than create individual expressions, create a clojure.core/def to contain a collection of all the spec/fdef expressions. This list can then be used to instrument and unstrument all the spec/fdef specifications. ( def ^ :private function-specifications [ ` card-game/deal-cards ` card-game/winning-player ]) Write simple helper functions to wrap the instrumenting of function specifications ( defn instrument-all-functions [] ( spec-test/instrument function-specifications )) ( defn unstrument-all-functions [] ( spec-test/unstrument function-specifications ))","title":"Instrumenting functions"},{"location":"clojure-spec/organising-specs/#unit-testing","text":"Specifications can be incorporated into the existing unit tests, so it is sensible to keep them under the corresponding test directory files.","title":"Unit testing"},{"location":"clojure-spec/organising-specs/#generative-testing","text":"Using spec-test/check will generate 1000 data values for each expression, so by default these tests will take far longer that other tests. Configuring generative tests to only generate a small number of values will make spec-test/check expressions return almost instantaneously. In this example, only 10 data values are generated ( spec-test/check ` deal-cards { :clojure.spec.test.check/opts { :num-tests 10 }}) Generative testing with small generators can be run regularly during development without impacting fast feedback. It is recommended to separate full generative testing from unit tests, to maintain the fast feedback of those unit tests. These tests can be included in a separate namespace or marked with meta data as integration tests, e.g ^:integration","title":"Generative testing"},{"location":"clojure-spec/using-spec-in-the-repl/","text":"Using Clojure Spec in the REPL \u03bb\ufe0e Clojure 1.10.x or greater includes the clojure.spec.alpha library. clojure -Sdescribe in a terminal will show the version of Clojure. Run a Clojure REPL in a terminal window from your operating system using rebel readline . clojure -M:repl/rebel Hint::Rebel Alias in practicalli/clojure-deps \u03bb\ufe0e The practicalli/clojure-deps repository includes the :repl/rebel alias to run a rebel readline powered Clojure REPL. Alternative use clj if you have rlwrap installed or clojure to run a basic Clojure REPL UI. Require the clojure.spec.alpha using an alias called spec to use functions from that namespace. ( require ' [ clojure.spec.alpha :as spec ]) Use (in-ns 'namespace.name) if you need to change into a specific namespace. Spec auto-completion \u03bb\ufe0e Using rebel-readline for the Clojure REPL will show autocompletion for all spec functions once the spec namespace has been required. Type (spec / and press TAB to list all the functions in the namespace. Typing a space character after the full name of a function shows the function signature with arguments that should be passed to that function. Check data conforms to the specification \u03bb\ufe0e Use the spec/conform and spec/valid? functions to test if data matches a specification. In these examples, predicate functions are used as a specification. Try examples in the REPL \u03bb\ufe0e spec/conform will return the value if it conforms to the specification, or :clojure.spec.alpha/invalid if the data does not conform. ( spec/conform odd? 101 ) ( spec/conform integer? 1 ) ( spec/conform seq? [ 1 2 3 ]) ( spec/conform seq? ( range 10 )) ( spec/conform map? {}) ( spec/conform map? ( hash-map :a 1 :b 2 )) spec/valid? returns true or false ( spec/valid? even? 180 ) ( spec/valid? string? \"Am I a valid string\" ) ( spec/valid? ( fn [ value ] ( > value 10000 )) 30076 ) ( spec/valid? # ( > % 10000 ) 30076 ) ( spec/conform # ( > % 10000 ) 30076 )","title":"Using Clojure Spec in the REPL"},{"location":"clojure-spec/using-spec-in-the-repl/#using-clojure-spec-in-the-repl","text":"Clojure 1.10.x or greater includes the clojure.spec.alpha library. clojure -Sdescribe in a terminal will show the version of Clojure. Run a Clojure REPL in a terminal window from your operating system using rebel readline . clojure -M:repl/rebel","title":"Using Clojure Spec in the REPL"},{"location":"clojure-spec/using-spec-in-the-repl/#hintrebel-alias-in-practicalliclojure-deps","text":"The practicalli/clojure-deps repository includes the :repl/rebel alias to run a rebel readline powered Clojure REPL. Alternative use clj if you have rlwrap installed or clojure to run a basic Clojure REPL UI. Require the clojure.spec.alpha using an alias called spec to use functions from that namespace. ( require ' [ clojure.spec.alpha :as spec ]) Use (in-ns 'namespace.name) if you need to change into a specific namespace.","title":"Hint::Rebel Alias in practicalli/clojure-deps"},{"location":"clojure-spec/using-spec-in-the-repl/#spec-auto-completion","text":"Using rebel-readline for the Clojure REPL will show autocompletion for all spec functions once the spec namespace has been required. Type (spec / and press TAB to list all the functions in the namespace. Typing a space character after the full name of a function shows the function signature with arguments that should be passed to that function.","title":"Spec auto-completion"},{"location":"clojure-spec/using-spec-in-the-repl/#check-data-conforms-to-the-specification","text":"Use the spec/conform and spec/valid? functions to test if data matches a specification. In these examples, predicate functions are used as a specification.","title":"Check data conforms to the specification"},{"location":"clojure-spec/using-spec-in-the-repl/#try-examples-in-the-repl","text":"spec/conform will return the value if it conforms to the specification, or :clojure.spec.alpha/invalid if the data does not conform. ( spec/conform odd? 101 ) ( spec/conform integer? 1 ) ( spec/conform seq? [ 1 2 3 ]) ( spec/conform seq? ( range 10 )) ( spec/conform map? {}) ( spec/conform map? ( hash-map :a 1 :b 2 )) spec/valid? returns true or false ( spec/valid? even? 180 ) ( spec/valid? string? \"Am I a valid string\" ) ( spec/valid? ( fn [ value ] ( > value 10000 )) 30076 ) ( spec/valid? # ( > % 10000 ) 30076 ) ( spec/conform # ( > % 10000 ) 30076 )","title":"Try examples in the REPL"},{"location":"clojure-spec/data/","text":"Clojure Spec for data \u03bb\ufe0e Specifications can be defined for any data in Clojure, be that simple values or complex data structures. More complex specifications are composed of individual specifications, providing a flexible way to define specifications without building a brittle hierarchy. What is a specification \u03bb\ufe0e Specifications can be predicates (return true or false), literal values in sets and entity maps . There are many predicate functions that come with Clojure which help speed the creation of specifications. Clojure function definitions ( fn , defn ) can be used to define custom predicate functions too. Do values meet a specification \u03bb\ufe0e The functions use to compare data with a specification are: conform - test if data conforms to a specification, returning the conformed value valid? - predicate to test if data conforms to a specification, returning true of false explain - explain why a value is not conforming to a specification There are variations on explain, that present the results in different formats. Workflow for data specifications \u03bb\ufe0e Using Clojure Specification is very flexible, they can be used as much or as little as required. Typically Specifications are created when data structures are being modeled, which can be done via experimenting in the REPL or taking a test first approach. Either way is viable. The generative tests section shows how specifications are used to generate mock data, so creating specifications earlier on in the development process will provide a wider range of data for unit tests and repl experimentation.","title":"Clojure Spec for data"},{"location":"clojure-spec/data/#clojure-spec-for-data","text":"Specifications can be defined for any data in Clojure, be that simple values or complex data structures. More complex specifications are composed of individual specifications, providing a flexible way to define specifications without building a brittle hierarchy.","title":"Clojure Spec for data"},{"location":"clojure-spec/data/#what-is-a-specification","text":"Specifications can be predicates (return true or false), literal values in sets and entity maps . There are many predicate functions that come with Clojure which help speed the creation of specifications. Clojure function definitions ( fn , defn ) can be used to define custom predicate functions too.","title":"What is a specification"},{"location":"clojure-spec/data/#do-values-meet-a-specification","text":"The functions use to compare data with a specification are: conform - test if data conforms to a specification, returning the conformed value valid? - predicate to test if data conforms to a specification, returning true of false explain - explain why a value is not conforming to a specification There are variations on explain, that present the results in different formats.","title":"Do values meet a specification"},{"location":"clojure-spec/data/#workflow-for-data-specifications","text":"Using Clojure Specification is very flexible, they can be used as much or as little as required. Typically Specifications are created when data structures are being modeled, which can be done via experimenting in the REPL or taking a test first approach. Either way is viable. The generative tests section shows how specifications are used to generate mock data, so creating specifications earlier on in the development process will provide a wider range of data for unit tests and repl experimentation.","title":"Workflow for data specifications"},{"location":"clojure-spec/data/and-or-specifications/","text":"Combining specifications with and and or \u03bb\ufe0e clojure.core/and function and clojure.core/or function can be used to define a specification with multiple parts. Conform to One or more specifications \u03bb\ufe0e A specification for residential address included either a house number or name. The clojure.core/or function allows either type of value to be used and conform to the specification. ( spec/def ::house-name-number ( or string? int? )) Using spec/or then unique keys are required for each possible type of value. Keys are used to explain where a failure occurred if values do not conform to the specification. ( spec/def ::house-name-number ( spec/or :string string? :number int? )) If specifications are uses as the options in the clojure.spec.alpha/or then those specification names are used as the keys to explain where failure to conform to the specification happened. ( spec/def ::social-security-id ( spec/or ::social-security-id-uk ::social-security-id-usa )) Conform to all specifications \u03bb\ufe0e Create a composite specification using clojure.spec.alpha/and when all specifications should be conformed by the values For an arranged banking overdraft limit, the value should be a positive number, that is an integer type and is less than 1000. ( spec/def ::arranged-overdraft-limit ( spec/and pos? int? # ( > 1000 % ))) If a value does not conform to any of the three specifications then the value fails the ::arranged-overdraft-limit specification.","title":"Combining specifications with and and or"},{"location":"clojure-spec/data/and-or-specifications/#combining-specifications-with-and-and-or","text":"clojure.core/and function and clojure.core/or function can be used to define a specification with multiple parts.","title":"Combining specifications with and and or"},{"location":"clojure-spec/data/and-or-specifications/#conform-to-one-or-more-specifications","text":"A specification for residential address included either a house number or name. The clojure.core/or function allows either type of value to be used and conform to the specification. ( spec/def ::house-name-number ( or string? int? )) Using spec/or then unique keys are required for each possible type of value. Keys are used to explain where a failure occurred if values do not conform to the specification. ( spec/def ::house-name-number ( spec/or :string string? :number int? )) If specifications are uses as the options in the clojure.spec.alpha/or then those specification names are used as the keys to explain where failure to conform to the specification happened. ( spec/def ::social-security-id ( spec/or ::social-security-id-uk ::social-security-id-usa ))","title":"Conform to One or more specifications"},{"location":"clojure-spec/data/and-or-specifications/#conform-to-all-specifications","text":"Create a composite specification using clojure.spec.alpha/and when all specifications should be conformed by the values For an arranged banking overdraft limit, the value should be a positive number, that is an integer type and is less than 1000. ( spec/def ::arranged-overdraft-limit ( spec/and pos? int? # ( > 1000 % ))) If a value does not conform to any of the three specifications then the value fails the ::arranged-overdraft-limit specification.","title":"Conform to all specifications"},{"location":"clojure-spec/data/composite-specifications/","text":"Composing Specifications \u03bb\ufe0e No spec is an island Composing individual specifications is an effective way to build larger abstractions in specifications without creating fixed hierarchical structures that are harder to refactor. Require specification namespace to the page (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) spec/and is used when all specifications should be true. (spec/def ::meaning-of-life (spec/and int? even? #(= 42 %))) spec/or is use when one or more specifications should be true (spec/def ::meaning-of-life-int-or-string (spec/or :integer #(= 42 %) :string #(= \"forty two\" %))) Each condition in the spec is annotated with a label for each conditional branches. Labels are included in the return result from spec/explain when values do not conform to a specification, providing context as to why a value failed the specification. When an or is conformed, it returns a vector with the condition name and conformed value. (spec/conform ::meaning-of-life-int-or-string 42) (spec/conform ::meaning-of-life-int-or-string \"forty two\") (spec/conform ::meaning-of-life-int-or-string :entropy) (spec/explain ::meaning-of-life-int-or-string :entropy) Individual specifications \u03bb\ufe0e Before composing a more abstract specification, first define individual specifications (spec/def ::first-name string?) (spec/def ::last-name string?) (spec/def ::residential-address string?) Composing hash-map specification \u03bb\ufe0e The individual specifications can now be composed into a single specification. keys function combines specifications to form a composite specification in the form of a Clojure hash-map. (spec/def ::customer-details (spec/keys :req [::first-name ::last-name ::residential-address])) Use the composite specification with a value (spec/conform ::customer-details {::first-name \"Jenny\" ::last-name \"Jetpack\" ::residential-address \"42 meaning of life street, Earth\"})","title":"Composing Specifications"},{"location":"clojure-spec/data/composite-specifications/#composing-specifications","text":"No spec is an island Composing individual specifications is an effective way to build larger abstractions in specifications without creating fixed hierarchical structures that are harder to refactor. Require specification namespace to the page (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) spec/and is used when all specifications should be true. (spec/def ::meaning-of-life (spec/and int? even? #(= 42 %))) spec/or is use when one or more specifications should be true (spec/def ::meaning-of-life-int-or-string (spec/or :integer #(= 42 %) :string #(= \"forty two\" %))) Each condition in the spec is annotated with a label for each conditional branches. Labels are included in the return result from spec/explain when values do not conform to a specification, providing context as to why a value failed the specification. When an or is conformed, it returns a vector with the condition name and conformed value. (spec/conform ::meaning-of-life-int-or-string 42) (spec/conform ::meaning-of-life-int-or-string \"forty two\") (spec/conform ::meaning-of-life-int-or-string :entropy) (spec/explain ::meaning-of-life-int-or-string :entropy)","title":"Composing Specifications"},{"location":"clojure-spec/data/composite-specifications/#individual-specifications","text":"Before composing a more abstract specification, first define individual specifications (spec/def ::first-name string?) (spec/def ::last-name string?) (spec/def ::residential-address string?)","title":"Individual specifications"},{"location":"clojure-spec/data/composite-specifications/#composing-hash-map-specification","text":"The individual specifications can now be composed into a single specification. keys function combines specifications to form a composite specification in the form of a Clojure hash-map. (spec/def ::customer-details (spec/keys :req [::first-name ::last-name ::residential-address])) Use the composite specification with a value (spec/conform ::customer-details {::first-name \"Jenny\" ::last-name \"Jetpack\" ::residential-address \"42 meaning of life street, Earth\"})","title":"Composing hash-map specification"},{"location":"clojure-spec/data/conform/","text":"Does a value conform to a specification? \u03bb\ufe0e clojure.spec.alpha/conform takes two arguments - a specification - a value to test against the specification :clojure.spec.alpha/invalid is returned when a value does not conform to a specification. If the value does conform to the specification, then the value is returned. This value is referred to as a conformed value. Require the Clojure spec library \u03bb\ufe0e Set the namespace for the page and require clojure.spec.alpha library, setting the alias to spec (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec])) Using conform \u03bb\ufe0e If the value conforms to the spec, a conformed value is returned (spec/conform odd? 101) When a value does not conform to a spec, the value :clojure.spec.alpha/invalid is returned (spec/conform even? 101) (spec/conform integer? 1) (spec/conform seq? [1 2 3]) (spec/conform seq? (range 10)) (spec/conform map? {}) (spec/conform map? (hash-map :a 1 :b 2))","title":"Conform"},{"location":"clojure-spec/data/conform/#does-a-value-conform-to-a-specification","text":"clojure.spec.alpha/conform takes two arguments - a specification - a value to test against the specification :clojure.spec.alpha/invalid is returned when a value does not conform to a specification. If the value does conform to the specification, then the value is returned. This value is referred to as a conformed value.","title":"Does a value conform to a specification?"},{"location":"clojure-spec/data/conform/#require-the-clojure-spec-library","text":"Set the namespace for the page and require clojure.spec.alpha library, setting the alias to spec (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec]))","title":"Require the Clojure spec library"},{"location":"clojure-spec/data/conform/#using-conform","text":"If the value conforms to the spec, a conformed value is returned (spec/conform odd? 101) When a value does not conform to a spec, the value :clojure.spec.alpha/invalid is returned (spec/conform even? 101) (spec/conform integer? 1) (spec/conform seq? [1 2 3]) (spec/conform seq? (range 10)) (spec/conform map? {}) (spec/conform map? (hash-map :a 1 :b 2))","title":"Using conform"},{"location":"clojure-spec/data/defining-specifications/","text":"Defining specifications \u03bb\ufe0e clojure.spec.alpha/def binds a name to a specification, just like clojure.core/def binds a name to a value. Binding a name means specifications are available throughout the code and in other projects if the project is included as a library. Naming - fully qualified keywords \u03bb\ufe0e Specification names should use fully qualified keywords, typically using the namespace in which the specification is defined in. Define a namespace for the page and require Clojure Spec (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec])) (spec/def :practicalli.clojure.specifications/number number?) auto-resolve macro \u03bb\ufe0e :: double colon is the auto-resolve macro, which will pre-pend the current namespace to the specification keyword. The :: notation removes the need to edit fully qualified names should a specification be moved to a different namespace. (spec/def ::number number?) Hint::Fully Qualified keywords \u03bb\ufe0e Using fully qualified keywords ensures they are unique and therefore can be used across all projects. Namespaces are usually unique as they include the name of the company or organization behind the code and any project or component names used to organize the code.","title":"Defining specifications"},{"location":"clojure-spec/data/defining-specifications/#defining-specifications","text":"clojure.spec.alpha/def binds a name to a specification, just like clojure.core/def binds a name to a value. Binding a name means specifications are available throughout the code and in other projects if the project is included as a library.","title":"Defining specifications"},{"location":"clojure-spec/data/defining-specifications/#naming-fully-qualified-keywords","text":"Specification names should use fully qualified keywords, typically using the namespace in which the specification is defined in. Define a namespace for the page and require Clojure Spec (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec])) (spec/def :practicalli.clojure.specifications/number number?)","title":"Naming - fully qualified keywords"},{"location":"clojure-spec/data/defining-specifications/#auto-resolve-macro","text":":: double colon is the auto-resolve macro, which will pre-pend the current namespace to the specification keyword. The :: notation removes the need to edit fully qualified names should a specification be moved to a different namespace. (spec/def ::number number?)","title":"auto-resolve macro"},{"location":"clojure-spec/data/defining-specifications/#hintfully-qualified-keywords","text":"Using fully qualified keywords ensures they are unique and therefore can be used across all projects. Namespaces are usually unique as they include the name of the company or organization behind the code and any project or component names used to organize the code.","title":"Hint::Fully Qualified keywords"},{"location":"clojure-spec/data/entity-maps/","text":"Entity maps \u03bb\ufe0e An entity map is a Specification for a Clojure hash-map of key-value pairs. A hash-map is a very effective way to express information in Clojure. The key should be a descriptive label to express meaning of the value it is associated with. Without the keys describing the meaning, it is harder for a developer to understand the data. {:account-id 12345 :user-name \"jenny1999\" :name \"Jenny Jetpack\" :address \"42 Meaning place, Earth\" :social-security \"ABC-123-45-6789\"} A hash-map contains any number of key-value pairs, keys are used for efficient lookup so there is no concern over ordering. Passing a hash-map as an argument to a function reduces refactoring required as the signature of the function remains the same and functions can be selective as to which key-value pairs they use. For these reasons, hash-maps are a very common data structure to pass data between functions. Defining entity maps \u03bb\ufe0e The Clojure Spec keys function is used to create a specification for a hash-map of key-value pairs. keys creates a specification from required keys, :req , and optional keys :opt . To define the specification for a player in an online game, first the individual specifications that make up the player hash-map are created. ( spec/def ::account-id uuid? ) ( spec/def ::name string? ) ( spec/def ::score int? ) ( spec/def ::profile string? ) ( spec/def ::games-played # { :vectron :utrazap :avakato }) Those specifications are composed together to create a specification for the player ( spec/def ::player-account ( spec/keys :req [ ::account-id ::name ::score ] :opt [ ::profile ::games-played ])) For a hash-map to meet the ::player-account specification it must contain the :req keys with values that conform to the individual specifications. The hash-map can also include any key-value pairs that conform to the :opt specifications. If any keys are in the map that do not appear in either :req or :opt then that hash-map does not conform to the ::player-account specification. Example: covid19-dashboard \u03bb\ufe0e The coronavirus-cases-data function takes a hash-map of values to make that function easier to extend without breaking existing calls Default values can be used if no value is passed as an argument. Extra values can be ignored without breaking the code. ( defn fun-name [ csv location date ]) ( defn coronavirus-cases-data \"Extract and transform cases data for specific locations and date\" [{ :keys [ csv-file locations date ]}] # _ ( -> ( extract-data-from-csv csv-file ) ( data-set-remove-locations locations ) ( data-set-specific-date date ))) ( coronavirus-cases-data { :csv-file \"data-sets/uk-coronavirus-cases.csv\" :locations # { \"Nation\" \"Country\" \"Region\" } :date \"2020-04-30\" }) Define the individual keys for the hash-map ( spec/def ::csv-file string? ) ( spec/def ::locations set? ) ( spec/def ::date string? ) ( spec/def ::cases-data ( spec/keys :req [ ::csv-file ::locations ::date ]))","title":"Entity maps"},{"location":"clojure-spec/data/entity-maps/#entity-maps","text":"An entity map is a Specification for a Clojure hash-map of key-value pairs. A hash-map is a very effective way to express information in Clojure. The key should be a descriptive label to express meaning of the value it is associated with. Without the keys describing the meaning, it is harder for a developer to understand the data. {:account-id 12345 :user-name \"jenny1999\" :name \"Jenny Jetpack\" :address \"42 Meaning place, Earth\" :social-security \"ABC-123-45-6789\"} A hash-map contains any number of key-value pairs, keys are used for efficient lookup so there is no concern over ordering. Passing a hash-map as an argument to a function reduces refactoring required as the signature of the function remains the same and functions can be selective as to which key-value pairs they use. For these reasons, hash-maps are a very common data structure to pass data between functions.","title":"Entity maps"},{"location":"clojure-spec/data/entity-maps/#defining-entity-maps","text":"The Clojure Spec keys function is used to create a specification for a hash-map of key-value pairs. keys creates a specification from required keys, :req , and optional keys :opt . To define the specification for a player in an online game, first the individual specifications that make up the player hash-map are created. ( spec/def ::account-id uuid? ) ( spec/def ::name string? ) ( spec/def ::score int? ) ( spec/def ::profile string? ) ( spec/def ::games-played # { :vectron :utrazap :avakato }) Those specifications are composed together to create a specification for the player ( spec/def ::player-account ( spec/keys :req [ ::account-id ::name ::score ] :opt [ ::profile ::games-played ])) For a hash-map to meet the ::player-account specification it must contain the :req keys with values that conform to the individual specifications. The hash-map can also include any key-value pairs that conform to the :opt specifications. If any keys are in the map that do not appear in either :req or :opt then that hash-map does not conform to the ::player-account specification.","title":"Defining entity maps"},{"location":"clojure-spec/data/entity-maps/#example-covid19-dashboard","text":"The coronavirus-cases-data function takes a hash-map of values to make that function easier to extend without breaking existing calls Default values can be used if no value is passed as an argument. Extra values can be ignored without breaking the code. ( defn fun-name [ csv location date ]) ( defn coronavirus-cases-data \"Extract and transform cases data for specific locations and date\" [{ :keys [ csv-file locations date ]}] # _ ( -> ( extract-data-from-csv csv-file ) ( data-set-remove-locations locations ) ( data-set-specific-date date ))) ( coronavirus-cases-data { :csv-file \"data-sets/uk-coronavirus-cases.csv\" :locations # { \"Nation\" \"Country\" \"Region\" } :date \"2020-04-30\" }) Define the individual keys for the hash-map ( spec/def ::csv-file string? ) ( spec/def ::locations set? ) ( spec/def ::date string? ) ( spec/def ::cases-data ( spec/keys :req [ ::csv-file ::locations ::date ]))","title":"Example: covid19-dashboard"},{"location":"clojure-spec/data/explain/","text":"Explaining non-conforming values \u03bb\ufe0e clojure.spec.alpha/explain describes why a value does not satisfy a specification. clojure.spec.alpha/explain takes two arguments - a specification - a value to test against the specification Success string is sent to standard out if the value meets the specification A string explaining where the value deviates from the specification is sent to standard out if the value does not meet the specification. There are several variations on the explain function for different situations * explain - sends the return value to the standard out / REPL * explain-str - returns a human readable result. * explain-data - returns a data structure of the error to be processed by other code Example of a failing value \u03bb\ufe0e First define a namespace and require the Clojure Spec namespace (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec])) (spec/def ::meaning-of-life #(= 42 %)) Given the following specification (spec/explain ::meaning-of-life 24) Using the value 24 with that specification will fail. Using explain we can see why (spec/def ::meaning-of-life-int-or-string (spec/or :integer #(= 42 %) :string #(= \"forty two\" %))) In this case explain returned the * value being checked against the spec * result of that check (failed) * predicate used to check the value * spec name used to check the value Notice that the value failed on the first condition, :integer , then stopped without checking the second, :string . The spec/and macro works the same as clojure.core/and in that is stops as soon as something fails. (spec/explain ::meaning-of-life-int-or-string 24) In this case we still have the value checked, the result and the predicate More information is provided as to where in the spec the value failed :at shows the path in the spec where the failure occurred, very useful for nested structures This shows the value of naming your specs descriptively Explain with a string \u03bb\ufe0e rather than send information to the system out (spec/explain-str ::meaning-of-life 24) (spec/explain-data ::meaning-of-life 24)","title":"Explaining non-conforming values"},{"location":"clojure-spec/data/explain/#explaining-non-conforming-values","text":"clojure.spec.alpha/explain describes why a value does not satisfy a specification. clojure.spec.alpha/explain takes two arguments - a specification - a value to test against the specification Success string is sent to standard out if the value meets the specification A string explaining where the value deviates from the specification is sent to standard out if the value does not meet the specification. There are several variations on the explain function for different situations * explain - sends the return value to the standard out / REPL * explain-str - returns a human readable result. * explain-data - returns a data structure of the error to be processed by other code","title":"Explaining non-conforming values"},{"location":"clojure-spec/data/explain/#example-of-a-failing-value","text":"First define a namespace and require the Clojure Spec namespace (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec])) (spec/def ::meaning-of-life #(= 42 %)) Given the following specification (spec/explain ::meaning-of-life 24) Using the value 24 with that specification will fail. Using explain we can see why (spec/def ::meaning-of-life-int-or-string (spec/or :integer #(= 42 %) :string #(= \"forty two\" %))) In this case explain returned the * value being checked against the spec * result of that check (failed) * predicate used to check the value * spec name used to check the value Notice that the value failed on the first condition, :integer , then stopped without checking the second, :string . The spec/and macro works the same as clojure.core/and in that is stops as soon as something fails. (spec/explain ::meaning-of-life-int-or-string 24) In this case we still have the value checked, the result and the predicate More information is provided as to where in the spec the value failed :at shows the path in the spec where the failure occurred, very useful for nested structures This shows the value of naming your specs descriptively","title":"Example of a failing value"},{"location":"clojure-spec/data/explain/#explain-with-a-string","text":"rather than send information to the system out (spec/explain-str ::meaning-of-life 24) (spec/explain-data ::meaning-of-life 24)","title":"Explain with a string"},{"location":"clojure-spec/data/hierarchical-specifications/","text":"Hierarchical Specifications \u03bb\ufe0e Defining specifications for data that is hierarchical or nested in nature. (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) Example hierarchical data \u03bb\ufe0e { :top-level-key { :nested-key \"value\" }} Individual specifications \u03bb\ufe0e (spec/def ::first-name string?) (spec/def ::last-name string?) (spec/def ::residential-address string?) Composite Specification \u03bb\ufe0e keys function combines specifications to form a composite specification in the form of a Clojure hash-map. (spec/def ::customer-details (spec/keys :req [::first-name ::last-name ::residential-address])) Hierarchical Specification \u03bb\ufe0e A user account is composed of a user-id and customer details. Rather than include the individual customer details, the composite customer-details specification. The ::user-id specification is as follows (spec/def ::user-id uuid?) The ::user-account specification (spec/def ::user-account (spec/keys :req [::user-id ::customer-details])) The following data structure will conform to the specification { ::user-id # uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\" ::customer-details { ::first-name \"Jenny\" ::last-name \"Jetpack\" ::residential-address \"Earth\" }}","title":"Hierarchical Specifications"},{"location":"clojure-spec/data/hierarchical-specifications/#hierarchical-specifications","text":"Defining specifications for data that is hierarchical or nested in nature. (ns practicalli.clojure (:require [clojure.spec.alpha :as spec]))","title":"Hierarchical Specifications"},{"location":"clojure-spec/data/hierarchical-specifications/#example-hierarchical-data","text":"{ :top-level-key { :nested-key \"value\" }}","title":"Example hierarchical data"},{"location":"clojure-spec/data/hierarchical-specifications/#individual-specifications","text":"(spec/def ::first-name string?) (spec/def ::last-name string?) (spec/def ::residential-address string?)","title":"Individual specifications"},{"location":"clojure-spec/data/hierarchical-specifications/#composite-specification","text":"keys function combines specifications to form a composite specification in the form of a Clojure hash-map. (spec/def ::customer-details (spec/keys :req [::first-name ::last-name ::residential-address]))","title":"Composite Specification"},{"location":"clojure-spec/data/hierarchical-specifications/#hierarchical-specification","text":"A user account is composed of a user-id and customer details. Rather than include the individual customer details, the composite customer-details specification. The ::user-id specification is as follows (spec/def ::user-id uuid?) The ::user-account specification (spec/def ::user-account (spec/keys :req [::user-id ::customer-details])) The following data structure will conform to the specification { ::user-id # uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\" ::customer-details { ::first-name \"Jenny\" ::last-name \"Jetpack\" ::residential-address \"Earth\" }}","title":"Hierarchical Specification"},{"location":"clojure-spec/data/literal-values/","text":"Literal values \u03bb\ufe0e Sets can be used as predicate functions returning true if the value is within the set Checking valid playing cards Define a namespace for the page and require Clojure Spec (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) (spec/valid? #{:club :diamond :heart :spade} :club) (spec/valid? #{:club :diamond :heart :spade} 42) Answer to the ultimate question? (spec/valid? #{42} 42) Using sets for literal values is similar to using the clojure.core/contains? function with a set collection type. (contains? #{:clubs :diamonds :hearts :spades} :hearts )","title":"Literal values"},{"location":"clojure-spec/data/literal-values/#literal-values","text":"Sets can be used as predicate functions returning true if the value is within the set Checking valid playing cards Define a namespace for the page and require Clojure Spec (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) (spec/valid? #{:club :diamond :heart :spade} :club) (spec/valid? #{:club :diamond :heart :spade} 42) Answer to the ultimate question? (spec/valid? #{42} 42) Using sets for literal values is similar to using the clojure.core/contains? function with a set collection type. (contains? #{:clubs :diamonds :hearts :spades} :hearts )","title":"Literal values"},{"location":"clojure-spec/data/map-literals/","text":"Map literal syntax - #: and #:: \u03bb\ufe0e #: map literal macro for Clojure hash-maps adds a given namespace to all the keywords contained in the hash-map. #:: map literal macro for keyword auto-resolve adds the current fully qualified namespace to all the keywords in the hash-map Require clojure spec in the namespace definition \u03bb\ufe0e (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) In this example the keys in the map are unqualified. {:simplifying [] :keyword-names [] :with-autoresolve [] :map-literal []} Qualifying keys with auto-resolve \u03bb\ufe0e Using the map literal macro for auto-resolve instructs Clojure to treat all keys in the map as qualified to the current namespace The following hash-map has the map literal macro. #::{:simplifying [] :keyword-names [] :with-autoresolve [] :map-literal []} This is the same as explicitly writing out the fully qualified domain for each key in the map. However, if we move the map to another namespace, then the explicit namespaces would need to be updated. {:practicalli.clojure/simplifying [] :practicalli.clojure/keyword-names [] :practicalli.clojure/with-autoresolve [] :practicalli.clojure/map-literal []} Qualifying keywords with a specific name \u03bb\ufe0e Rather than take the name from the current namespace, an explicit name can be added to all the keys in the map #:practicalli.naming {:simplifying [] :keyword-names [] :with-autoresolve [] :map-literal []} This is the same as explicitly writing that name in front of each of the keywords in the map. # {:practicalli.naming/simplifying [] :practicalli.naming/keyword-names [] :practicalli.naming/with-autoresolve [] :practicalli.naming/map-literal []} Map literals are relevant to Entity maps with spec.","title":"Map literal syntax - `#:` and `#::`"},{"location":"clojure-spec/data/map-literals/#map-literal-syntax-and","text":"#: map literal macro for Clojure hash-maps adds a given namespace to all the keywords contained in the hash-map. #:: map literal macro for keyword auto-resolve adds the current fully qualified namespace to all the keywords in the hash-map","title":"Map literal syntax - #: and #::"},{"location":"clojure-spec/data/map-literals/#require-clojure-spec-in-the-namespace-definition","text":"(ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) In this example the keys in the map are unqualified. {:simplifying [] :keyword-names [] :with-autoresolve [] :map-literal []}","title":"Require clojure spec in the namespace definition"},{"location":"clojure-spec/data/map-literals/#qualifying-keys-with-auto-resolve","text":"Using the map literal macro for auto-resolve instructs Clojure to treat all keys in the map as qualified to the current namespace The following hash-map has the map literal macro. #::{:simplifying [] :keyword-names [] :with-autoresolve [] :map-literal []} This is the same as explicitly writing out the fully qualified domain for each key in the map. However, if we move the map to another namespace, then the explicit namespaces would need to be updated. {:practicalli.clojure/simplifying [] :practicalli.clojure/keyword-names [] :practicalli.clojure/with-autoresolve [] :practicalli.clojure/map-literal []}","title":"Qualifying keys with auto-resolve"},{"location":"clojure-spec/data/map-literals/#qualifying-keywords-with-a-specific-name","text":"Rather than take the name from the current namespace, an explicit name can be added to all the keys in the map #:practicalli.naming {:simplifying [] :keyword-names [] :with-autoresolve [] :map-literal []} This is the same as explicitly writing that name in front of each of the keywords in the map. # {:practicalli.naming/simplifying [] :practicalli.naming/keyword-names [] :practicalli.naming/with-autoresolve [] :practicalli.naming/map-literal []} Map literals are relevant to Entity maps with spec.","title":"Qualifying keywords with a specific name"},{"location":"clojure-spec/data/predicate-specifications/","text":"Predicate functions \u03bb\ufe0e A predicate is a function that returns a true or false value and their names end with ? by convention. (odd? 1) (string? \"am i a string\") (int? 2.3) (int? 2.3) Hint:: clojure.core predicate functions \u03bb\ufe0e There are 80+ predicate functions in clojure.core Using predicate functions as specifications \u03bb\ufe0e Predicate functions can be used as un-named specifications to test values conform. Include the clojure.spec.alpha namespace to access the spec functions. (require '[clojure.spec.alpha :as spec]) (spec/conform int? 42) (spec/conform seq? (range 4)) Custom predicate functions \u03bb\ufe0e Define custom predicate functions with defn or fn or the short form #() Using an anonymous function (spec/conform (fn [value] (= value 42)) 42) When the expression is quite terse, then the short form of an anonymous function is typically used. The % represents the value passed as an argument. (spec/conform #(= % 42) 42)","title":"Predicate functions"},{"location":"clojure-spec/data/predicate-specifications/#predicate-functions","text":"A predicate is a function that returns a true or false value and their names end with ? by convention. (odd? 1) (string? \"am i a string\") (int? 2.3) (int? 2.3)","title":"Predicate functions"},{"location":"clojure-spec/data/predicate-specifications/#hintclojurecore-predicate-functions","text":"There are 80+ predicate functions in clojure.core","title":"Hint::clojure.core predicate functions"},{"location":"clojure-spec/data/predicate-specifications/#using-predicate-functions-as-specifications","text":"Predicate functions can be used as un-named specifications to test values conform. Include the clojure.spec.alpha namespace to access the spec functions. (require '[clojure.spec.alpha :as spec]) (spec/conform int? 42) (spec/conform seq? (range 4))","title":"Using predicate functions as specifications"},{"location":"clojure-spec/data/predicate-specifications/#custom-predicate-functions","text":"Define custom predicate functions with defn or fn or the short form #() Using an anonymous function (spec/conform (fn [value] (= value 42)) 42) When the expression is quite terse, then the short form of an anonymous function is typically used. The % represents the value passed as an argument. (spec/conform #(= % 42) 42)","title":"Custom predicate functions"},{"location":"clojure-spec/data/registry/","text":"Registry for unique and re-usable specifications \u03bb\ufe0e So far we have just use predicate functions directly in the code examples. Using a registry, specs can be uniquely defined across the whole project Defining a spec gives that spec a name that has a fully qualified namespace Use the spec specific def function to bind a new spec name and fully qualified namespace and place it in the registry (spec/def :playing-card/suit #{:club :diamond :heart :spade} ) (spec/conform :playing-card/suit :diamond) (spec/def :show-cats/cat-bread #{:abyssinian :birman :chartreau :devon-rex :domestic-short-hair :domestic-long-hair}) Removing specs from the registry \u03bb\ufe0e Named specifications can be removed from the registry by binding the name to nil . If specification names are to be refactored, then the original name should be set to nil and evaluated, before changing the name. This will ensure stale specifications are not residing in the REPL. Here is a named specification as an example (spec/def ::unwanted #{:abandoned}) The specification is evaluated in the REPL (above) and currently works. (spec/conform ::unwanted :abandoned) Remove this specification from the registry by binding it to nil (spec/def ::unwanted nil) Now the specification is unavailable (spec/conform ::unwanted :abandoned) Hint::Registry not persistent \u03bb\ufe0e Restarting the REPL will loose all specification names in the registry as it is not persistent across REPL sessions.","title":"Registry for unique and re-usable specifications"},{"location":"clojure-spec/data/registry/#registry-for-unique-and-re-usable-specifications","text":"So far we have just use predicate functions directly in the code examples. Using a registry, specs can be uniquely defined across the whole project Defining a spec gives that spec a name that has a fully qualified namespace Use the spec specific def function to bind a new spec name and fully qualified namespace and place it in the registry (spec/def :playing-card/suit #{:club :diamond :heart :spade} ) (spec/conform :playing-card/suit :diamond) (spec/def :show-cats/cat-bread #{:abyssinian :birman :chartreau :devon-rex :domestic-short-hair :domestic-long-hair})","title":"Registry for unique and re-usable specifications"},{"location":"clojure-spec/data/registry/#removing-specs-from-the-registry","text":"Named specifications can be removed from the registry by binding the name to nil . If specification names are to be refactored, then the original name should be set to nil and evaluated, before changing the name. This will ensure stale specifications are not residing in the REPL. Here is a named specification as an example (spec/def ::unwanted #{:abandoned}) The specification is evaluated in the REPL (above) and currently works. (spec/conform ::unwanted :abandoned) Remove this specification from the registry by binding it to nil (spec/def ::unwanted nil) Now the specification is unavailable (spec/conform ::unwanted :abandoned)","title":"Removing specs from the registry"},{"location":"clojure-spec/data/registry/#hintregistry-not-persistent","text":"Restarting the REPL will loose all specification names in the registry as it is not persistent across REPL sessions.","title":"Hint::Registry not persistent"},{"location":"clojure-spec/data/valid-q/","text":"Is the value valid? \u03bb\ufe0e clojure.spec.alpha/valid? takes two arguments - a specification - a value to test against the specification clojure.spec.alpha/valid? is a predicate function. true is returned if the value meets the specification, otherwise false is returned. Require the Clojure spec library \u03bb\ufe0e Set the namespace for the page and require clojure.spec.alpha library, setting the alias to spec (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec])) Using valid? \u03bb\ufe0e If the value is valid then a boolean true is returned. Experiment with different values and predicate functions . (spec/valid? even? 180) (spec/valid? string? \"Am I a valid string\") using custom predicate functions \u03bb\ufe0e Create fn definitions to use as predicate functions. Any function that returns true or false can be used. (spec/valid? (fn [value] (> value 1024)) 8080) The custom predicate function may also be written in the shorter form of a fn definition (spec/valid? #(> % 1024) 8080) Use def to bind names to custom predicate functions if they are used more than once in the code base. In this example a name is bound to a function that checks if a port is within the range of IANA registered networking ports . (def registered-port-range? \"Network port number within IANA registered port range\" #(and (> % 1024) #(< % 49151) ) (spec/valid? registered-port-range? 8080)","title":"Is the value valid?"},{"location":"clojure-spec/data/valid-q/#is-the-value-valid","text":"clojure.spec.alpha/valid? takes two arguments - a specification - a value to test against the specification clojure.spec.alpha/valid? is a predicate function. true is returned if the value meets the specification, otherwise false is returned.","title":"Is the value valid?"},{"location":"clojure-spec/data/valid-q/#require-the-clojure-spec-library","text":"Set the namespace for the page and require clojure.spec.alpha library, setting the alias to spec (ns practicalli.clojure.specifications (:require [clojure.spec.alpha :as spec]))","title":"Require the Clojure spec library"},{"location":"clojure-spec/data/valid-q/#using-valid","text":"If the value is valid then a boolean true is returned. Experiment with different values and predicate functions . (spec/valid? even? 180) (spec/valid? string? \"Am I a valid string\")","title":"Using valid?"},{"location":"clojure-spec/data/valid-q/#using-custom-predicate-functions","text":"Create fn definitions to use as predicate functions. Any function that returns true or false can be used. (spec/valid? (fn [value] (> value 1024)) 8080) The custom predicate function may also be written in the shorter form of a fn definition (spec/valid? #(> % 1024) 8080) Use def to bind names to custom predicate functions if they are used more than once in the code base. In this example a name is bound to a function that checks if a port is within the range of IANA registered networking ports . (def registered-port-range? \"Network port number within IANA registered port range\" #(and (> % 1024) #(< % 49151) ) (spec/valid? registered-port-range? 8080)","title":"using custom predicate functions"},{"location":"clojure-spec/functions/","text":"Specification for function definitions \u03bb\ufe0e Define specifications for your custom functions Additional documentation - argument and return values and the relationship between them. Instrumenting functions - checking for correct argument values Generative testing - using argument specifications to generate comprehensive test data. Many of the functions in clojure.core have specifications in the latest version of Clojure. The specifications for clojure.core functions can be found in the clojure/core.specs.alpha repository on GitHub. Examples of specifications from core.specs.alpha \u03bb\ufe0e Specifications used for the defn , defn- , fn functions in clojure.core ( s/def ::param-list ( s/and vector? ( s/cat :params ( s/* ::binding-form ) :var-params ( s/? ( s/cat :ampersand # { '& } :var-form ::binding-form ))))) ( s/def ::params+body ( s/cat :params ::param-list :body ( s/alt :prepost+body ( s/cat :prepost map? :body ( s/+ any? )) :body ( s/* any? )))) ( s/def ::defn-args ( s/cat :fn-name simple-symbol? :docstring ( s/? string? ) :meta ( s/? map? ) :fn-tail ( s/alt :arity-1 ::params+body :arity-n ( s/cat :bodies ( s/+ ( s/spec ::params+body )) :attr-map ( s/? map? )))))","title":"Specification for function definitions"},{"location":"clojure-spec/functions/#specification-for-function-definitions","text":"Define specifications for your custom functions Additional documentation - argument and return values and the relationship between them. Instrumenting functions - checking for correct argument values Generative testing - using argument specifications to generate comprehensive test data. Many of the functions in clojure.core have specifications in the latest version of Clojure. The specifications for clojure.core functions can be found in the clojure/core.specs.alpha repository on GitHub.","title":"Specification for function definitions"},{"location":"clojure-spec/functions/#examples-of-specifications-from-corespecsalpha","text":"Specifications used for the defn , defn- , fn functions in clojure.core ( s/def ::param-list ( s/and vector? ( s/cat :params ( s/* ::binding-form ) :var-params ( s/? ( s/cat :ampersand # { '& } :var-form ::binding-form ))))) ( s/def ::params+body ( s/cat :params ::param-list :body ( s/alt :prepost+body ( s/cat :prepost map? :body ( s/+ any? )) :body ( s/* any? )))) ( s/def ::defn-args ( s/cat :fn-name simple-symbol? :docstring ( s/? string? ) :meta ( s/? map? ) :fn-tail ( s/alt :arity-1 ::params+body :arity-n ( s/cat :bodies ( s/+ ( s/spec ::params+body )) :attr-map ( s/? map? )))))","title":"Examples of specifications from core.specs.alpha"},{"location":"clojure-spec/functions/documentation/","text":"clojure.spec adds documentation to function definitions \u03bb\ufe0e The Clojure doc function shows the doc string included in a function definition, eg. defn expressions. When a specification is defined for a function using fdef the specification is included in the output of the Clojure doc function. Including specification details clarifies the precise way to use the function and the information it expects. When a function has a specification the doc string for that function can focus on the purpose of the function rather than the specific types of data used, as that is covered by the function specification. Example \u03bb\ufe0e ( clojure.repl/doc ::rank ) ;; :practicalli.card-game-specifications/rank ;; Spec ;; (into #{:king :queen :ace :jack} (range 2 11)) When adding a specification to a function definition, doc will also show the specification details along with the function doc-string. Live example \u03bb\ufe0e Define the namespace and include clojure spec and clojure.repl (which contains the doc function) (ns practicalli.clojure (:require [cljs.repl :as repl] [clojure.spec.alpha :as spec])) (repl/doc map) (clojure.repl/doc :playing-card/suit) #{:spade :heart :diamond :club} (repl/doc :cat-show:cat-bread)","title":"clojure.spec adds documentation to function definitions"},{"location":"clojure-spec/functions/documentation/#clojurespec-adds-documentation-to-function-definitions","text":"The Clojure doc function shows the doc string included in a function definition, eg. defn expressions. When a specification is defined for a function using fdef the specification is included in the output of the Clojure doc function. Including specification details clarifies the precise way to use the function and the information it expects. When a function has a specification the doc string for that function can focus on the purpose of the function rather than the specific types of data used, as that is covered by the function specification.","title":"clojure.spec adds documentation to function definitions"},{"location":"clojure-spec/functions/documentation/#example","text":"( clojure.repl/doc ::rank ) ;; :practicalli.card-game-specifications/rank ;; Spec ;; (into #{:king :queen :ace :jack} (range 2 11)) When adding a specification to a function definition, doc will also show the specification details along with the function doc-string.","title":"Example"},{"location":"clojure-spec/functions/documentation/#live-example","text":"Define the namespace and include clojure spec and clojure.repl (which contains the doc function) (ns practicalli.clojure (:require [cljs.repl :as repl] [clojure.spec.alpha :as spec])) (repl/doc map) (clojure.repl/doc :playing-card/suit) #{:spade :heart :diamond :club} (repl/doc :cat-show:cat-bread)","title":"Live example"},{"location":"clojure-spec/functions/function-definition-specifications/","text":"Function definition specifications \u03bb\ufe0e clojure.spec.alpha/fdef defines a specification for a function definition, providing specific specification for arguments passed when calling a function return value expected relationships between arguments and return value Examples \u03bb\ufe0e The practicalli.database-access/new-account-holder function takes a customer details specification and returns an account-holder-id specification. (spec/fdef practicalli.database-access/new-account-holder :args (spec/cat :customer ::customer-details) :ret ::account-holder-id)","title":"Function definition specifications"},{"location":"clojure-spec/functions/function-definition-specifications/#function-definition-specifications","text":"clojure.spec.alpha/fdef defines a specification for a function definition, providing specific specification for arguments passed when calling a function return value expected relationships between arguments and return value","title":"Function definition specifications"},{"location":"clojure-spec/functions/function-definition-specifications/#examples","text":"The practicalli.database-access/new-account-holder function takes a customer details specification and returns an account-holder-id specification. (spec/fdef practicalli.database-access/new-account-holder :args (spec/cat :customer ::customer-details) :ret ::account-holder-id)","title":"Examples"},{"location":"clojure-spec/functions/higher-order-functions/","text":"Higher order functions \u03bb\ufe0e Higher order functions are common in Clojure and spec provides fspec to support spec\u2019ing them. (defn value-added-tax [tax-rate] #(+ (* tax-rate %) %)) The value-added-tax function returns an anonymous function that adds the value of tax to the given value. Define a namespace for the page and require Clojure Spec (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) Declare a function spec for value-added-tax using clojure.spec.alpha/fspec for the return value: (s/fdef value-added-tax :args (spec/cat :tax-rate number?) :ret (spec/fspec :args (s/cat :value number?) :ret number?)) The :ret specification uses fspec to declare that the returning function takes and returns a number.","title":"Higher order functions"},{"location":"clojure-spec/functions/higher-order-functions/#higher-order-functions","text":"Higher order functions are common in Clojure and spec provides fspec to support spec\u2019ing them. (defn value-added-tax [tax-rate] #(+ (* tax-rate %) %)) The value-added-tax function returns an anonymous function that adds the value of tax to the given value. Define a namespace for the page and require Clojure Spec (ns practicalli.clojure (:require [clojure.spec.alpha :as spec])) Declare a function spec for value-added-tax using clojure.spec.alpha/fspec for the return value: (s/fdef value-added-tax :args (spec/cat :tax-rate number?) :ret (spec/fspec :args (s/cat :value number?) :ret number?)) The :ret specification uses fspec to declare that the returning function takes and returns a number.","title":"Higher order functions"},{"location":"clojure-spec/generative-testing/","text":"Generative testing with Spec and Spec Test \u03bb\ufe0e Clojure spec has been used so far to create specifications for both data and functions. Now spec and spec test libraries are used not just validity checking, but also to generate random samples of the data that can be used for extensive testing. Generative testing provides a far more effective alternative to unit testing. clojure.spec.test/check/instrument verifies that calls to a function satisfy the function's specification, the :arg in fdef . clojure.spec.test/check function generates 1000 data values to be used as the inputs to a function, checks that the invocation of the function satisfies its specification, the :ret and :fn in fdef . The argument specification, :arg in fdef is used to generate a wide range of results, which are more capable of finding edge cases that fail. {% youtube %} https://youtu.be/W6crrbF7s2s Example: card game \u03bb\ufe0e practicalli/spec-generative-testing is a simple card game with specifications that are used for basic generative testing. {% youtube %} https://youtu.be/xZQ7p-YBHtE References \u03bb\ufe0e Clojure.org guides: Spec - Generators API reference: clojure.spec.gen.alpha API reference: clojure.spec.test.alpha Video: How to do Stateful Property Testing in Clojure? (->> (spec-test/check `function-with-a-spec) ,,, ;; test more functions ?? (spec-test/summarize-results)) (spec/exercise-fn ..","title":"Generative testing with Spec and Spec Test"},{"location":"clojure-spec/generative-testing/#generative-testing-with-spec-and-spec-test","text":"Clojure spec has been used so far to create specifications for both data and functions. Now spec and spec test libraries are used not just validity checking, but also to generate random samples of the data that can be used for extensive testing. Generative testing provides a far more effective alternative to unit testing. clojure.spec.test/check/instrument verifies that calls to a function satisfy the function's specification, the :arg in fdef . clojure.spec.test/check function generates 1000 data values to be used as the inputs to a function, checks that the invocation of the function satisfies its specification, the :ret and :fn in fdef . The argument specification, :arg in fdef is used to generate a wide range of results, which are more capable of finding edge cases that fail. {% youtube %} https://youtu.be/W6crrbF7s2s","title":"Generative testing with Spec and Spec Test"},{"location":"clojure-spec/generative-testing/#example-card-game","text":"practicalli/spec-generative-testing is a simple card game with specifications that are used for basic generative testing. {% youtube %} https://youtu.be/xZQ7p-YBHtE","title":"Example: card game"},{"location":"clojure-spec/generative-testing/#references","text":"Clojure.org guides: Spec - Generators API reference: clojure.spec.gen.alpha API reference: clojure.spec.test.alpha Video: How to do Stateful Property Testing in Clojure? (->> (spec-test/check `function-with-a-spec) ,,, ;; test more functions ?? (spec-test/summarize-results)) (spec/exercise-fn ..","title":"References"},{"location":"clojure-spec/generative-testing/predicate-generators/","text":"Generators for predicate specifications \u03bb\ufe0e Specifications are used to generate a wide range of random data. A generator for the specification is obtained and then data is generated. Predicate generators \u03bb\ufe0e (spec-gen/generate (spec/gen int?)) (spec-gen/generate (spec/gen nil?)) (spec-gen/sample (spec/gen string?)) (spec-gen/generate (spec/gen #{:club :diamond :heart :spade})) (spec-gen/sample (spec/gen #{:club :diamond :heart :spade}))","title":"Generators for predicate specifications"},{"location":"clojure-spec/generative-testing/predicate-generators/#generators-for-predicate-specifications","text":"Specifications are used to generate a wide range of random data. A generator for the specification is obtained and then data is generated.","title":"Generators for predicate specifications"},{"location":"clojure-spec/generative-testing/predicate-generators/#predicate-generators","text":"(spec-gen/generate (spec/gen int?)) (spec-gen/generate (spec/gen nil?)) (spec-gen/sample (spec/gen string?)) (spec-gen/generate (spec/gen #{:club :diamond :heart :spade})) (spec-gen/sample (spec/gen #{:club :diamond :heart :spade}))","title":"Predicate generators"},{"location":"clojure-spec/generative-testing/example-projects/","text":"Example projects using Clojure Spec \u03bb\ufe0e Project How the project uses Spec seancorfield/next-jdbc Data specifications using predicates, function definition argument specifications More examples welcome Other example projects that use interesting features of Spec are most welcome. Raise an issue on the project issue tracker with details.","title":"Example projects using Clojure Spec"},{"location":"clojure-spec/generative-testing/example-projects/#example-projects-using-clojure-spec","text":"Project How the project uses Spec seancorfield/next-jdbc Data specifications using predicates, function definition argument specifications More examples welcome Other example projects that use interesting features of Spec are most welcome. Raise an issue on the project issue tracker with details.","title":"Example projects using Clojure Spec"},{"location":"clojure-spec/generative-testing/example-projects/next-jdbc/","text":"Projects using Clojure spec - next-jdbc \u03bb\ufe0e The next-jdbc project is a modern low-level Clojure wrapper for JDBC-based access to databases. The project defines data specifications using predicates and Defining specifications \u03bb\ufe0e Specifications are defined within a single file src/next/jdbc/specs.clj . Specifications start with clojure.spec.alpha/def expressions, using predicate functions as specifications. There is also a custom predicate function called Function definition specifications follow, using the clojure.spec.alpha/fdef function. The fdef functions define the specification for the arguments of each function. The fdef function name is the same as the function definition it is defining a specification for. Instrumenting specifications \u03bb\ufe0e Instrumenting functions provides automatic checking that argument in a function call conforms to the specification. Rather than write individual expressions to instrument each function, a var called fns-with-specs contains a collection of names for all the fdef function definition specifications. ( def ^ :private fns-with-specs [ ` jdbc/get-datasource ` jdbc/get-connection ` jdbc/prepare ` jdbc/plan ` jdbc/execute! ` jdbc/execute-one! ` jdbc/transact ` jdbc/with-transaction ` connection/->pool ` prepare/execute-batch! ` prepare/set-parameters ` prepare/statement ` sql/insert! ` sql/insert-multi! ` sql/query ` sql/find-by-keys ` sql/get-by-id ` sql/update! ` sql/delete! ]) Instrument all the functions by passing fns-with-specs as an argument to the clojure.spec.test.alpha/instrument function. This call is wrapped in a simple handler function for convenience. ( defn instrument [] ( clojure.spec.test.alpha/instrument fns-with-specs )) To remove the checking of argument specifications, clojure.spec.test.alpha/unstrument is passed fns-with-specs , again wrapped in a convinced function. ( defn unstrument [] ( clojure.spec.test.alpha/unstrument fns-with-specs ))","title":"Projects using Clojure spec - next-jdbc"},{"location":"clojure-spec/generative-testing/example-projects/next-jdbc/#projects-using-clojure-spec-next-jdbc","text":"The next-jdbc project is a modern low-level Clojure wrapper for JDBC-based access to databases. The project defines data specifications using predicates and","title":"Projects using Clojure spec - next-jdbc"},{"location":"clojure-spec/generative-testing/example-projects/next-jdbc/#defining-specifications","text":"Specifications are defined within a single file src/next/jdbc/specs.clj . Specifications start with clojure.spec.alpha/def expressions, using predicate functions as specifications. There is also a custom predicate function called Function definition specifications follow, using the clojure.spec.alpha/fdef function. The fdef functions define the specification for the arguments of each function. The fdef function name is the same as the function definition it is defining a specification for.","title":"Defining specifications"},{"location":"clojure-spec/generative-testing/example-projects/next-jdbc/#instrumenting-specifications","text":"Instrumenting functions provides automatic checking that argument in a function call conforms to the specification. Rather than write individual expressions to instrument each function, a var called fns-with-specs contains a collection of names for all the fdef function definition specifications. ( def ^ :private fns-with-specs [ ` jdbc/get-datasource ` jdbc/get-connection ` jdbc/prepare ` jdbc/plan ` jdbc/execute! ` jdbc/execute-one! ` jdbc/transact ` jdbc/with-transaction ` connection/->pool ` prepare/execute-batch! ` prepare/set-parameters ` prepare/statement ` sql/insert! ` sql/insert-multi! ` sql/query ` sql/find-by-keys ` sql/get-by-id ` sql/update! ` sql/delete! ]) Instrument all the functions by passing fns-with-specs as an argument to the clojure.spec.test.alpha/instrument function. This call is wrapped in a simple handler function for convenience. ( defn instrument [] ( clojure.spec.test.alpha/instrument fns-with-specs )) To remove the checking of argument specifications, clojure.spec.test.alpha/unstrument is passed fns-with-specs , again wrapped in a convinced function. ( defn unstrument [] ( clojure.spec.test.alpha/unstrument fns-with-specs ))","title":"Instrumenting specifications"},{"location":"clojure-spec/projects/","text":"Clojure Spec Projects \u03bb\ufe0e A series of projects showing approaches to using specifications and generating data for testing. Project Description card game writing specifications and generating data from those specifications banking-on-clojure simplified online bank account using TDD, data and functional specifications and generative testing Bonbon card game A flavorful card game with clojure spec Genetic Programming With clojure.spec https://www.youtube.com/watch?v=xvk-Gnydn54 ClojureScript game with spec References \u03bb\ufe0e Practicalli - Clojure Spec playlist - live coding to define specifications and generative testing","title":"Clojure Spec Projects"},{"location":"clojure-spec/projects/#clojure-spec-projects","text":"A series of projects showing approaches to using specifications and generating data for testing. Project Description card game writing specifications and generating data from those specifications banking-on-clojure simplified online bank account using TDD, data and functional specifications and generative testing Bonbon card game A flavorful card game with clojure spec Genetic Programming With clojure.spec https://www.youtube.com/watch?v=xvk-Gnydn54 ClojureScript game with spec","title":"Clojure Spec Projects"},{"location":"clojure-spec/projects/#references","text":"Practicalli - Clojure Spec playlist - live coding to define specifications and generative testing","title":"References"},{"location":"clojure-spec/projects/bank-account/","text":"Spec project: Bank Account \u03bb\ufe0e A relatively simple bank account application with data and function specifications, including generative testing data and function instrumentation. Hint::Under active development \u03bb\ufe0e Developed as part of the Practicalli study guide live broadcasts Create deps.edn project \u03bb\ufe0e Use Clojure CLI and clj-new clojure -M:new app practicalli/banking-on-clojure Hint::practicalli/banking-on-clojure repository \u03bb\ufe0e practicalli/banking-on-clojure repository contains the latest code to date for this project. Outline design of project \u03bb\ufe0e Data Specifications are created for * Customer Details \u2714 * Account holder \u2714 * Bank account * Multiple Bank accounts * Credit Card * Mortgage Functions and specifications are created for * register-account-holder \u2714 * open-credit-account * open-savings-account * open-credit-card-account * open-mortgage-account * Make a payment * Send account notification * Check for overdraft Development Workflow \u03bb\ufe0e Write a failing test \u2714 write mock data \u2714 write an function definition that returns the argument \u2714 run tests - tests should fail \u2714 write a spec for the functions argument - customer \u2714 write a spec for the return value \u2714 write a spec for relationship between args and return value replace the mock data with generated values from specification \u2714 update functions and make tests pass \u2714 instrument functions run specification checks \u2714 Images to add Running tests that fail on a spec in CIDER spacemacs-cider-test-spec-fail-banking-on-clojure-project.png Running tests that fail on a spec on CircleCI circle-ci-banking-on-clojure-spec-test-runner-fail-register-account-holder-did-not-conform-to-spec.png","title":"Spec project: Bank Account"},{"location":"clojure-spec/projects/bank-account/#spec-project-bank-account","text":"A relatively simple bank account application with data and function specifications, including generative testing data and function instrumentation.","title":"Spec project: Bank Account"},{"location":"clojure-spec/projects/bank-account/#hintunder-active-development","text":"Developed as part of the Practicalli study guide live broadcasts","title":"Hint::Under active development"},{"location":"clojure-spec/projects/bank-account/#create-depsedn-project","text":"Use Clojure CLI and clj-new clojure -M:new app practicalli/banking-on-clojure","title":"Create deps.edn project"},{"location":"clojure-spec/projects/bank-account/#hintpracticallibanking-on-clojure-repository","text":"practicalli/banking-on-clojure repository contains the latest code to date for this project.","title":"Hint::practicalli/banking-on-clojure repository"},{"location":"clojure-spec/projects/bank-account/#outline-design-of-project","text":"Data Specifications are created for * Customer Details \u2714 * Account holder \u2714 * Bank account * Multiple Bank accounts * Credit Card * Mortgage Functions and specifications are created for * register-account-holder \u2714 * open-credit-account * open-savings-account * open-credit-card-account * open-mortgage-account * Make a payment * Send account notification * Check for overdraft","title":"Outline design of project"},{"location":"clojure-spec/projects/bank-account/#development-workflow","text":"Write a failing test \u2714 write mock data \u2714 write an function definition that returns the argument \u2714 run tests - tests should fail \u2714 write a spec for the functions argument - customer \u2714 write a spec for the return value \u2714 write a spec for relationship between args and return value replace the mock data with generated values from specification \u2714 update functions and make tests pass \u2714 instrument functions run specification checks \u2714 Images to add Running tests that fail on a spec in CIDER spacemacs-cider-test-spec-fail-banking-on-clojure-project.png Running tests that fail on a spec on CircleCI circle-ci-banking-on-clojure-spec-test-runner-fail-register-account-holder-did-not-conform-to-spec.png","title":"Development Workflow"},{"location":"clojure-spec/projects/bank-account/account-holder-specification/","text":"Account holder specification \u03bb\ufe0e The account holder has the same information as custom details with the addition of an account-id In the register-account-holder a uuid is generated for the account id, So a spec can be defined for this type ( spec/def ::account-id uuid? ) Design decision: hierarchical or composite \u03bb\ufe0e There are several approaches to combining, depending on the shape of the data used The account holder is a hash-map, so spec/keys will create the map from specification keys Including the customer-details specification in spec/keys would include the customer details as a nested hash-map ( spec/def ::account-holder-hierarchy ( spec/keys :req [ ::account-id ::customer-details ])) A valid data structure for this specification is a map with two keys, account-id and customer-details . account-id is a uuid value, customer-details is a hash-map of values that conform to the customer-details specification ( spec/valid? ::account-holder-hierarchy # :: { :account-id ( java.util.UUID/randomUUID ) :customer-details # :: { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }}) ;; => true Flat data structures are usually preferred in Clojure over a nested hierarchy. Rather than use the ::customer-details specification as a key in the spec/keys expression. The individual specifications that make up ::customer-details can be used. ( spec/def ::account-holder-composition ( spec/keys :req [ ::account-id ::first-name ::last-name ::email-address ::residential-address ::social-security-id ])) ( spec/valid? ::account-holder-composition # :: { :account-id ( java.util.UUID/randomUUID ) :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" })","title":"Account holder specification"},{"location":"clojure-spec/projects/bank-account/account-holder-specification/#account-holder-specification","text":"The account holder has the same information as custom details with the addition of an account-id In the register-account-holder a uuid is generated for the account id, So a spec can be defined for this type ( spec/def ::account-id uuid? )","title":"Account holder specification"},{"location":"clojure-spec/projects/bank-account/account-holder-specification/#design-decision-hierarchical-or-composite","text":"There are several approaches to combining, depending on the shape of the data used The account holder is a hash-map, so spec/keys will create the map from specification keys Including the customer-details specification in spec/keys would include the customer details as a nested hash-map ( spec/def ::account-holder-hierarchy ( spec/keys :req [ ::account-id ::customer-details ])) A valid data structure for this specification is a map with two keys, account-id and customer-details . account-id is a uuid value, customer-details is a hash-map of values that conform to the customer-details specification ( spec/valid? ::account-holder-hierarchy # :: { :account-id ( java.util.UUID/randomUUID ) :customer-details # :: { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }}) ;; => true Flat data structures are usually preferred in Clojure over a nested hierarchy. Rather than use the ::customer-details specification as a key in the spec/keys expression. The individual specifications that make up ::customer-details can be used. ( spec/def ::account-holder-composition ( spec/keys :req [ ::account-id ::first-name ::last-name ::email-address ::residential-address ::social-security-id ])) ( spec/valid? ::account-holder-composition # :: { :account-id ( java.util.UUID/randomUUID ) :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" })","title":"Design decision: hierarchical or composite"},{"location":"clojure-spec/projects/bank-account/customer-details-specification/","text":"Customer details specification \u03bb\ufe0e Create a new file for the specifications, src/practicalli/banking_specifications.cljc , with the namespace practicalli.banking-specifications . Require the clojure.spec.alpha library with an alias of spec . ( ns practicalli.banking-specifications ( :require [ clojure.spec.alpha :as spec ])) Define basic customer details \u03bb\ufe0e Define a specification for the customer-details map, composed of all the required keys that define a customer. The bank legally requires specific information about a customer in order to add them as an account holder ( spec/def ::first-name string? ) ( spec/def ::last-name string? ) ( spec/def ::email-address string? ) INFO::A more detailed email specification \u03bb\ufe0e Use a regular expression to define the syntax of an email address, eg. jenny@jetpack.org ( spec/def ::email-address ( spec/and string? # ( re-matches # \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}$\" % ))) This specification will require a custom generator A residential address is made from several pieces of information and is defined as a composite specification, from several specifications. ( spec/def ::house-name-number ( spec/or :string string? :number int? )) ( spec/def ::street-name string? ) ( spec/def ::post-code string? ) ( spec/def ::county string? ) ( spec/def ::country string? ) ( spec/def ::residential-address ( spec/keys :req [ ::house-name-number ::street-name ::post-code ] :opt [ ::county ::country ])) A social security number specification is also a candidate for a composite specification. Social security numbers may take different forms and even have different names in different countries, eg. the USA SSN is a nine-digit number in the format \"AAA-GG-SSSS\" In the UK the social security number is called the National Insurance number and is of the form QQ123456C ( spec/def ::social-security-id-uk string? ) ( spec/def ::social-security-id-usa string? ) INFO::Detailed social security numbers would check the different forms \u03bb\ufe0e Predicate functions can be defined to check for the size of the different social security forms. ( defn social-security-number-usa? [ value ] ( = 9 ( count value ))) ( defn social-security-number-uk? [ value ] ( = 11 ( count value ))) ( spec/def ::social-security-id-usa ( spec/and string? social-security-number-usa? )) ( spec/def ::social-security-id-uk ( spec/and string? social-security-number-uk? )) These specifications required a custom generator in order to produce correct data each time. A general social security specification can now be defined, with one of any of the country specific specifications ( spec/def ::social-security-id ( spec/or ::social-security-id-uk ::social-security-id-usa )) Composing the customer details specification \u03bb\ufe0e A customer details specification is a hash-map of key value pairs. The keys are the specifications that have just been defined. spec/keys creates a specification for a hash-map with required and optional keys. spec/keys also includes a check for a map, so no explicit check for a map is required. ( spec/def ::customer-details ( spec/keys :req [ ::first-name ::last-name ::email-address ::residential-address ::social-security-id ]))","title":"Customer details specification"},{"location":"clojure-spec/projects/bank-account/customer-details-specification/#customer-details-specification","text":"Create a new file for the specifications, src/practicalli/banking_specifications.cljc , with the namespace practicalli.banking-specifications . Require the clojure.spec.alpha library with an alias of spec . ( ns practicalli.banking-specifications ( :require [ clojure.spec.alpha :as spec ]))","title":"Customer details specification"},{"location":"clojure-spec/projects/bank-account/customer-details-specification/#define-basic-customer-details","text":"Define a specification for the customer-details map, composed of all the required keys that define a customer. The bank legally requires specific information about a customer in order to add them as an account holder ( spec/def ::first-name string? ) ( spec/def ::last-name string? ) ( spec/def ::email-address string? )","title":"Define basic customer details"},{"location":"clojure-spec/projects/bank-account/customer-details-specification/#infoa-more-detailed-email-specification","text":"Use a regular expression to define the syntax of an email address, eg. jenny@jetpack.org ( spec/def ::email-address ( spec/and string? # ( re-matches # \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}$\" % ))) This specification will require a custom generator A residential address is made from several pieces of information and is defined as a composite specification, from several specifications. ( spec/def ::house-name-number ( spec/or :string string? :number int? )) ( spec/def ::street-name string? ) ( spec/def ::post-code string? ) ( spec/def ::county string? ) ( spec/def ::country string? ) ( spec/def ::residential-address ( spec/keys :req [ ::house-name-number ::street-name ::post-code ] :opt [ ::county ::country ])) A social security number specification is also a candidate for a composite specification. Social security numbers may take different forms and even have different names in different countries, eg. the USA SSN is a nine-digit number in the format \"AAA-GG-SSSS\" In the UK the social security number is called the National Insurance number and is of the form QQ123456C ( spec/def ::social-security-id-uk string? ) ( spec/def ::social-security-id-usa string? )","title":"INFO::A more detailed email specification"},{"location":"clojure-spec/projects/bank-account/customer-details-specification/#infodetailed-social-security-numbers-would-check-the-different-forms","text":"Predicate functions can be defined to check for the size of the different social security forms. ( defn social-security-number-usa? [ value ] ( = 9 ( count value ))) ( defn social-security-number-uk? [ value ] ( = 11 ( count value ))) ( spec/def ::social-security-id-usa ( spec/and string? social-security-number-usa? )) ( spec/def ::social-security-id-uk ( spec/and string? social-security-number-uk? )) These specifications required a custom generator in order to produce correct data each time. A general social security specification can now be defined, with one of any of the country specific specifications ( spec/def ::social-security-id ( spec/or ::social-security-id-uk ::social-security-id-usa ))","title":"INFO::Detailed social security numbers would check the different forms"},{"location":"clojure-spec/projects/bank-account/customer-details-specification/#composing-the-customer-details-specification","text":"A customer details specification is a hash-map of key value pairs. The keys are the specifications that have just been defined. spec/keys creates a specification for a hash-map with required and optional keys. spec/keys also includes a check for a map, so no explicit check for a map is required. ( spec/def ::customer-details ( spec/keys :req [ ::first-name ::last-name ::email-address ::residential-address ::social-security-id ]))","title":"Composing the customer details specification"},{"location":"clojure-spec/projects/bank-account/function-specifications/","text":"Specifications for function definitions - fdef \u03bb\ufe0e Create a spec/fdef for the register-account-holder function clojure.spec.alpha/fdef defines a specification for a function definition, defn . Specifications can attached to the arguments using :args , the return value using :ret and the relationship between the two using fn . :args , :ret and fn are optional, although args and ret are required if you want to use :fn Add a spec to cover the function arguments. \u03bb\ufe0e :args is a compound specification that covers all the function arguments. The :args spec is invoked with the arguments in a list, so working with them is like using apply. Using regular expressions we can find the right arguments to give to the specification. Regular expression spec functions include * spec/cat * spec/alt * spec/* The register-account-holder only takes one argument, so spec/cat is used to bind a local key to the specification. The function is defined in the practicalli.banking-on-clojure namespace. Require that namespace in the current ns form. ( ns practicalli.banking-specifications ( :require [ clojure.spec.alpha :as spec ] [ clojure.spec.gen.alpha :as spec-gen ] [ clojure.spec.test.alpha :as spec-test ] [ practicalli.banking-on-clojure :as SUT ])) The SUT alias is used for the banking-on-clojure namespace, as is done with clojure.test unit test namespaces. ( spec/fdef SUT/register-account-holder :args ( spec/cat :customer :practicalli.bank-account-spec/customer-details )) Checking function calls against the spec - instrument \u03bb\ufe0e spec/fdef by itself does not run checks against the specs ( register-account-holder {}) ;; => {:account-id #uuid \"3a6dddb7-dd87-485e-90f8-8c8975302845\"} Require the Clojure spec test library ( require ' [ clojure.spec.test.alpha :as spec-test ]) spec/instrument will add a run time check for the specification ( spec-test/instrument ` SUT/register-account-holder ) No the function is instrumented, data used as arguments of a function call will be checked against the specification. ( register-account-holder { ::bad \"data\" }) This function call throws an exception because of the specification attached to the :args section of the fdef specification. The error report provides detailed and quite clear information to help diagnose the issue 1 . Unhandled clojure.lang.ExceptionInfo Spec assertion failed. Spec : # object [ clojure.spec.alpha$regex_spec_impl$reify__2509 0 x12b66a86 \"clojure.spec.alpha$regex_spec_impl$reify__2509@12b66a86\" ] Value : ( # :practicalli.bank-account-design-journal { :bad \"data\" }) Problems : val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/first-name ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/last-name ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/email-address ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/residential-address ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/social-security-id ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] Calling the register-account-holder with a value that conforms to the bank-account-spec for customer details returns the new value for account-holder ( register-account-holder # :practicalli.bank-account-spec { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; => {:practicalli.bank-account-spec/first-name \"Jenny\", :practicalli.bank-account-spec/last-name \"Jetpack\", :practicalli.bank-account-spec/email-address \"jenny@jetpack.org\", :practicalli.bank-account-spec/residential-address \"42 meaning of life street, Earth\", :practicalli.bank-account-spec/postal-code \"AB3 0EF\", :practicalli.bank-account-spec/social-security-id \"123456789\", :account-id #uuid \"e0f327de-4e92-479e-a9de-468e2c7c0e6d\"} Add a specification to the return value, \u03bb\ufe0e Attach the account-holder details specification to :ret ( spec/fdef register-account-holder :args ( spec/cat :customer :practicalli.bank-account-spec/customer-details ) :ret :practicalli.bank-account-spec/account-holder ) If the register-account-holder logic changes to return a different value that the return spec, then an exception is raised Returns an integer rather than a uuid ( defn register-account-holder \"Register a new customer with the bank Arguments: - hash-map of customer-details Return: - hash-map of an account-holder (adds account id)\" [ customer-details ] ( assoc customer-details :practicalli.bank-account-spec/account-id ( rand-int 100000 ) # _ ( java.util.UUID/randomUUID ))) So this should fail ( register-account-holder # :practicalli.bank-account-spec { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) It still works as spec-test/instrument only checks the args value. spec-test/check will test the return value with generated tests ( require ' [ clojure.spec.gen.alpha :as spec-gen ]) ( spec-test/check ` SUT/register-account-holder ) The result is 100 generated tests that all fail, because the function was changed to return integers, not uuids 1 . Caused by clojure.lang.ExceptionInfo Couldn 't satisfy such-that predicate after 100 tries. { :pred # function [ clojure.spec.alpha/gensub/fn--1876 ] , :gen { :gen # function [ clojure.test.check.generators/such-that/fn--8322 ]} , :max-tries 100 } Change the function back again. \u03bb\ufe0e ( defn register-account-holder \"Register a new customer with the bank Arguments: - hash-map of customer-details Return: - hash-map of an account-holder (adds account id)\" [ customer-details ] ( assoc customer-details :practicalli.bank-account-spec/account-id ( java.util.UUID/randomUUID ))) Instrument the function \u03bb\ufe0e Testing function calls against the specification Requires the spec test namespace ( require ' [ clojure.spec.test.alpha :as spec-test ]) Instrument the spec to add checking, this only checks the arguments are correct. ( spec-test/instrument ` practicalli.bank-account/register-account-holder ) ( register-account-holder { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" })","title":"Specifications for function definitions - `fdef`"},{"location":"clojure-spec/projects/bank-account/function-specifications/#specifications-for-function-definitions-fdef","text":"Create a spec/fdef for the register-account-holder function clojure.spec.alpha/fdef defines a specification for a function definition, defn . Specifications can attached to the arguments using :args , the return value using :ret and the relationship between the two using fn . :args , :ret and fn are optional, although args and ret are required if you want to use :fn","title":"Specifications for function definitions - fdef"},{"location":"clojure-spec/projects/bank-account/function-specifications/#add-a-spec-to-cover-the-function-arguments","text":":args is a compound specification that covers all the function arguments. The :args spec is invoked with the arguments in a list, so working with them is like using apply. Using regular expressions we can find the right arguments to give to the specification. Regular expression spec functions include * spec/cat * spec/alt * spec/* The register-account-holder only takes one argument, so spec/cat is used to bind a local key to the specification. The function is defined in the practicalli.banking-on-clojure namespace. Require that namespace in the current ns form. ( ns practicalli.banking-specifications ( :require [ clojure.spec.alpha :as spec ] [ clojure.spec.gen.alpha :as spec-gen ] [ clojure.spec.test.alpha :as spec-test ] [ practicalli.banking-on-clojure :as SUT ])) The SUT alias is used for the banking-on-clojure namespace, as is done with clojure.test unit test namespaces. ( spec/fdef SUT/register-account-holder :args ( spec/cat :customer :practicalli.bank-account-spec/customer-details ))","title":"Add a spec to cover the function arguments."},{"location":"clojure-spec/projects/bank-account/function-specifications/#checking-function-calls-against-the-spec-instrument","text":"spec/fdef by itself does not run checks against the specs ( register-account-holder {}) ;; => {:account-id #uuid \"3a6dddb7-dd87-485e-90f8-8c8975302845\"} Require the Clojure spec test library ( require ' [ clojure.spec.test.alpha :as spec-test ]) spec/instrument will add a run time check for the specification ( spec-test/instrument ` SUT/register-account-holder ) No the function is instrumented, data used as arguments of a function call will be checked against the specification. ( register-account-holder { ::bad \"data\" }) This function call throws an exception because of the specification attached to the :args section of the fdef specification. The error report provides detailed and quite clear information to help diagnose the issue 1 . Unhandled clojure.lang.ExceptionInfo Spec assertion failed. Spec : # object [ clojure.spec.alpha$regex_spec_impl$reify__2509 0 x12b66a86 \"clojure.spec.alpha$regex_spec_impl$reify__2509@12b66a86\" ] Value : ( # :practicalli.bank-account-design-journal { :bad \"data\" }) Problems : val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/first-name ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/last-name ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/email-address ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/residential-address ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] val : # :practicalli.bank-account-design-journal { :bad \"data\" } in : [ 0 ] failed : ( contains? % :practicalli.bank-account-spec/social-security-id ) spec : :practicalli.bank-account-spec/customer-details at : [ :customer ] Calling the register-account-holder with a value that conforms to the bank-account-spec for customer details returns the new value for account-holder ( register-account-holder # :practicalli.bank-account-spec { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; => {:practicalli.bank-account-spec/first-name \"Jenny\", :practicalli.bank-account-spec/last-name \"Jetpack\", :practicalli.bank-account-spec/email-address \"jenny@jetpack.org\", :practicalli.bank-account-spec/residential-address \"42 meaning of life street, Earth\", :practicalli.bank-account-spec/postal-code \"AB3 0EF\", :practicalli.bank-account-spec/social-security-id \"123456789\", :account-id #uuid \"e0f327de-4e92-479e-a9de-468e2c7c0e6d\"}","title":"Checking function calls against the spec - instrument"},{"location":"clojure-spec/projects/bank-account/function-specifications/#add-a-specification-to-the-return-value","text":"Attach the account-holder details specification to :ret ( spec/fdef register-account-holder :args ( spec/cat :customer :practicalli.bank-account-spec/customer-details ) :ret :practicalli.bank-account-spec/account-holder ) If the register-account-holder logic changes to return a different value that the return spec, then an exception is raised Returns an integer rather than a uuid ( defn register-account-holder \"Register a new customer with the bank Arguments: - hash-map of customer-details Return: - hash-map of an account-holder (adds account id)\" [ customer-details ] ( assoc customer-details :practicalli.bank-account-spec/account-id ( rand-int 100000 ) # _ ( java.util.UUID/randomUUID ))) So this should fail ( register-account-holder # :practicalli.bank-account-spec { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) It still works as spec-test/instrument only checks the args value. spec-test/check will test the return value with generated tests ( require ' [ clojure.spec.gen.alpha :as spec-gen ]) ( spec-test/check ` SUT/register-account-holder ) The result is 100 generated tests that all fail, because the function was changed to return integers, not uuids 1 . Caused by clojure.lang.ExceptionInfo Couldn 't satisfy such-that predicate after 100 tries. { :pred # function [ clojure.spec.alpha/gensub/fn--1876 ] , :gen { :gen # function [ clojure.test.check.generators/such-that/fn--8322 ]} , :max-tries 100 }","title":"Add a specification to the return value,"},{"location":"clojure-spec/projects/bank-account/function-specifications/#change-the-function-back-again","text":"( defn register-account-holder \"Register a new customer with the bank Arguments: - hash-map of customer-details Return: - hash-map of an account-holder (adds account id)\" [ customer-details ] ( assoc customer-details :practicalli.bank-account-spec/account-id ( java.util.UUID/randomUUID )))","title":"Change the function back again."},{"location":"clojure-spec/projects/bank-account/function-specifications/#instrument-the-function","text":"Testing function calls against the specification Requires the spec test namespace ( require ' [ clojure.spec.test.alpha :as spec-test ]) Instrument the spec to add checking, this only checks the arguments are correct. ( spec-test/instrument ` practicalli.bank-account/register-account-holder ) ( register-account-holder { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" })","title":"Instrument the function"},{"location":"clojure-spec/projects/bank-account/generate-test-data/","text":"Generate test data from Specifications \u03bb\ufe0e Now there are specifications for the customer-details and account-details, spec can generate random data for use with tests. Add requires to the test namespace \u03bb\ufe0e Edit the src/test/practicalli/banking_on_clojure.clj and add requires for the banking-specifications , clojure.spec.alpha and clojure.spec.test.alpha . ( ns practicalli.banking-on-clojure-test ( :require [ clojure.test :refer [ deftest is testing ]] [ clojure.spec.alpha :as spec ] [ clojure.spec.test.alpha :as spec-test ] [ clojure.spec.gen.alpha :as spec-gen ] [ practicalli.banking-on-clojure :as SUT ] [ practicalli.banking-specifications ])) Using Generators to generate data \u03bb\ufe0e Test data can now be generated from this specification, creating values for each key in the hash-map. The ::email-address specification has been simplified, as the regular expression version requires a custom generator (no built in generator to support this specification). The simplified email specification is: (spec/def ::email-address string?) Hint::Libraries for custom generators \u03bb\ufe0e gfredericks/test.chuck is a utility library for test.check and will work with clojure spec as its a wrapper around test.check. lambdaisland/regal also has test.check generators that can be used for regular expressions defined with the regal (hiccup style) syntax. With the simplified email specification, the customer-details specification can be used to generate all the data using the built in clojure.spec.alpha generators. ( spec-gen/generate ( spec/gen :practicalli.banking-specifications/customer-details )) ;; => #:practicalli.banking-specifications { :first-name \"r7q9RFB202v7a69z\" , :last-name \"6N5\" , :email-address \"L6dd946p680P0pIYZ33CGZd0\" , :residential-address # :practicalli.banking-specifications { :house-name-number \"gCuRMe0C8\" , :street-name \"5\" , :post-code \"VN\" } , :social-security-id \"a7P0xfBNPv6\" } Bind the result of this function to a name and it can be used as mock data throughout the unit tests defined. ( defn customer-details-mock-data ( spec-gen/generate ( spec/gen :practicalli.banking-specifications/customer-details ))) The generated data can also be used with function definitions and clojure.spec.test.alpha/check function. Generating more than one value for a specification \u03bb\ufe0e clojure.spec.gen.alpha/sample will generate 10 random values from the specification ( spec-gen/sample ( spec/gen :practicalli.banking-specifications/customer-details )) ;; => (#:practicalli.banking-specifications{:first-name \"\", :last-name \"\", :email-address \"\", :residential-address #:practicalli.banking-specifications{:country \"\", :county \"\", :house-name-number \"\", :street-name \"\", :post-code \"\"}, :social-security-id \"2P902qTJCP6\"} # :practicalli.banking-specifications { :first-name \"\" , :last-name \"z\" , :email-address \"\" , :residential-address # :practicalli.banking-specifications { :house-name-number 0 , :street-name \"\" , :post-code \"R\" } , :social-security-id \"3dDBA7pa98r\" } # :practicalli.banking-specifications { :first-name \"nQ\" , :last-name \"w\" , :email-address \"h6\" , :residential-address # :practicalli.banking-specifications { :country \"\" , :county \"7u\" , :house-name-number \"\" , :street-name \"87\" , :post-code \"\" } , :social-security-id \"x57pf2H2i16\" } # :practicalli.banking-specifications { :first-name \"ac\" , :last-name \"L0x\" , :email-address \"S\" , :residential-address # :practicalli.banking-specifications { :country \"Xd\" , :county \"\" , :house-name-number \"P\" , :street-name \"\" , :post-code \"\" } , :social-security-id \"j5iTA70j9FW\" } # :practicalli.banking-specifications { :first-name \"e\" , :last-name \"ic\" , :email-address \"15G\" , :residential-address # :practicalli.banking-specifications { :house-name-number \"\" , :street-name \"Nj\" , :post-code \"f\" } , :social-security-id \"I83rx1wUj07\" } # :practicalli.banking-specifications { :first-name \"zPr\" , :last-name \"r\" , :email-address \"hsVz\" , :residential-address # :practicalli.banking-specifications { :country \"W\" , :house-name-number \"S\" , :street-name \"64\" , :post-code \"85s25\" } , :social-security-id \"8EEDiy28SX7\" } # :practicalli.banking-specifications { :first-name \"QzoV\" , :last-name \"\" , :email-address \"iS\" , :residential-address # :practicalli.banking-specifications { :county \"OaMj9\" , :house-name-number 1 , :street-name \"pzc0ji\" , :post-code \"tv1\" } , :social-security-id \"9z88KM5TLKK\" } # :practicalli.banking-specifications { :first-name \"w73AA\" , :last-name \"\" , :email-address \"\" , :residential-address # :practicalli.banking-specifications { :county \"sUj\" , :house-name-number 4 , :street-name \"jw\" , :post-code \"652Z\" } , :social-security-id \"rZMUTPK72N6\" } # :practicalli.banking-specifications { :first-name \"j09f\" , :last-name \"EoU\" , :email-address \"sA82q\" , :residential-address # :practicalli.banking-specifications { :country \"28nyq3\" , :county \"5PURE\" , :house-name-number \"1NzKwe\" , :street-name \"28Y\" , :post-code \"t\" } , :social-security-id \"yNBdc7M29Io\" } # :practicalli.banking-specifications { :first-name \"Xa38iX8FP\" , :last-name \"u4G\" , :email-address \"Ne1w25nJ\" , :residential-address # :practicalli.banking-specifications { :country \"H07\" , :house-name-number -17 , :street-name \"jWRhfrrz9\" , :post-code \"sF9\" } , :social-security-id \"IX2w8Xx8u0n\" }) Generating multiple result is useful if a collection of customer details is required for testing purposes. Exercising a specification \u03bb\ufe0e clojure.spec.test.alpha/exercise returns pairs of generated and conformed values for a spec. exercise by default produces 10 samples (like sample) but you can pass both functions a number indicating the number of samples to produce. ( spec/exercise ( spec/cat :practicalli.banking-specifications/first-name :practicalli.banking-specifications/last-name )) ;; => ([(\"\") #:practicalli.banking-specifications{:first-name \"\"}] [( \"6\" ) # :practicalli.banking-specifications { :first-name \"6\" }] [( \"\" ) # :practicalli.banking-specifications { :first-name \"\" }] [( \"6\" ) # :practicalli.banking-specifications { :first-name \"6\" }] [( \"W\" ) # :practicalli.banking-specifications { :first-name \"W\" }] [( \"ljooD\" ) # :practicalli.banking-specifications { :first-name \"ljooD\" }] [( \"704d5x\" ) # :practicalli.banking-specifications { :first-name \"704d5x\" }] [( \"EZyBT\" ) # :practicalli.banking-specifications { :first-name \"EZyBT\" }] [( \"1e6\" ) # :practicalli.banking-specifications { :first-name \"1e6\" }] [( \"v\" ) # :practicalli.banking-specifications { :first-name \"v\" }]) clojure.spec.test.alpha/exercise-fn provides the same service but for function specifications ( fdef ).","title":"Generate test data"},{"location":"clojure-spec/projects/bank-account/generate-test-data/#generate-test-data-from-specifications","text":"Now there are specifications for the customer-details and account-details, spec can generate random data for use with tests.","title":"Generate test data from Specifications"},{"location":"clojure-spec/projects/bank-account/generate-test-data/#add-requires-to-the-test-namespace","text":"Edit the src/test/practicalli/banking_on_clojure.clj and add requires for the banking-specifications , clojure.spec.alpha and clojure.spec.test.alpha . ( ns practicalli.banking-on-clojure-test ( :require [ clojure.test :refer [ deftest is testing ]] [ clojure.spec.alpha :as spec ] [ clojure.spec.test.alpha :as spec-test ] [ clojure.spec.gen.alpha :as spec-gen ] [ practicalli.banking-on-clojure :as SUT ] [ practicalli.banking-specifications ]))","title":"Add requires to the test namespace"},{"location":"clojure-spec/projects/bank-account/generate-test-data/#using-generators-to-generate-data","text":"Test data can now be generated from this specification, creating values for each key in the hash-map. The ::email-address specification has been simplified, as the regular expression version requires a custom generator (no built in generator to support this specification). The simplified email specification is: (spec/def ::email-address string?)","title":"Using Generators to generate data"},{"location":"clojure-spec/projects/bank-account/generate-test-data/#hintlibraries-for-custom-generators","text":"gfredericks/test.chuck is a utility library for test.check and will work with clojure spec as its a wrapper around test.check. lambdaisland/regal also has test.check generators that can be used for regular expressions defined with the regal (hiccup style) syntax. With the simplified email specification, the customer-details specification can be used to generate all the data using the built in clojure.spec.alpha generators. ( spec-gen/generate ( spec/gen :practicalli.banking-specifications/customer-details )) ;; => #:practicalli.banking-specifications { :first-name \"r7q9RFB202v7a69z\" , :last-name \"6N5\" , :email-address \"L6dd946p680P0pIYZ33CGZd0\" , :residential-address # :practicalli.banking-specifications { :house-name-number \"gCuRMe0C8\" , :street-name \"5\" , :post-code \"VN\" } , :social-security-id \"a7P0xfBNPv6\" } Bind the result of this function to a name and it can be used as mock data throughout the unit tests defined. ( defn customer-details-mock-data ( spec-gen/generate ( spec/gen :practicalli.banking-specifications/customer-details ))) The generated data can also be used with function definitions and clojure.spec.test.alpha/check function.","title":"Hint::Libraries for custom generators"},{"location":"clojure-spec/projects/bank-account/generate-test-data/#generating-more-than-one-value-for-a-specification","text":"clojure.spec.gen.alpha/sample will generate 10 random values from the specification ( spec-gen/sample ( spec/gen :practicalli.banking-specifications/customer-details )) ;; => (#:practicalli.banking-specifications{:first-name \"\", :last-name \"\", :email-address \"\", :residential-address #:practicalli.banking-specifications{:country \"\", :county \"\", :house-name-number \"\", :street-name \"\", :post-code \"\"}, :social-security-id \"2P902qTJCP6\"} # :practicalli.banking-specifications { :first-name \"\" , :last-name \"z\" , :email-address \"\" , :residential-address # :practicalli.banking-specifications { :house-name-number 0 , :street-name \"\" , :post-code \"R\" } , :social-security-id \"3dDBA7pa98r\" } # :practicalli.banking-specifications { :first-name \"nQ\" , :last-name \"w\" , :email-address \"h6\" , :residential-address # :practicalli.banking-specifications { :country \"\" , :county \"7u\" , :house-name-number \"\" , :street-name \"87\" , :post-code \"\" } , :social-security-id \"x57pf2H2i16\" } # :practicalli.banking-specifications { :first-name \"ac\" , :last-name \"L0x\" , :email-address \"S\" , :residential-address # :practicalli.banking-specifications { :country \"Xd\" , :county \"\" , :house-name-number \"P\" , :street-name \"\" , :post-code \"\" } , :social-security-id \"j5iTA70j9FW\" } # :practicalli.banking-specifications { :first-name \"e\" , :last-name \"ic\" , :email-address \"15G\" , :residential-address # :practicalli.banking-specifications { :house-name-number \"\" , :street-name \"Nj\" , :post-code \"f\" } , :social-security-id \"I83rx1wUj07\" } # :practicalli.banking-specifications { :first-name \"zPr\" , :last-name \"r\" , :email-address \"hsVz\" , :residential-address # :practicalli.banking-specifications { :country \"W\" , :house-name-number \"S\" , :street-name \"64\" , :post-code \"85s25\" } , :social-security-id \"8EEDiy28SX7\" } # :practicalli.banking-specifications { :first-name \"QzoV\" , :last-name \"\" , :email-address \"iS\" , :residential-address # :practicalli.banking-specifications { :county \"OaMj9\" , :house-name-number 1 , :street-name \"pzc0ji\" , :post-code \"tv1\" } , :social-security-id \"9z88KM5TLKK\" } # :practicalli.banking-specifications { :first-name \"w73AA\" , :last-name \"\" , :email-address \"\" , :residential-address # :practicalli.banking-specifications { :county \"sUj\" , :house-name-number 4 , :street-name \"jw\" , :post-code \"652Z\" } , :social-security-id \"rZMUTPK72N6\" } # :practicalli.banking-specifications { :first-name \"j09f\" , :last-name \"EoU\" , :email-address \"sA82q\" , :residential-address # :practicalli.banking-specifications { :country \"28nyq3\" , :county \"5PURE\" , :house-name-number \"1NzKwe\" , :street-name \"28Y\" , :post-code \"t\" } , :social-security-id \"yNBdc7M29Io\" } # :practicalli.banking-specifications { :first-name \"Xa38iX8FP\" , :last-name \"u4G\" , :email-address \"Ne1w25nJ\" , :residential-address # :practicalli.banking-specifications { :country \"H07\" , :house-name-number -17 , :street-name \"jWRhfrrz9\" , :post-code \"sF9\" } , :social-security-id \"IX2w8Xx8u0n\" }) Generating multiple result is useful if a collection of customer details is required for testing purposes.","title":"Generating more than one value for a specification"},{"location":"clojure-spec/projects/bank-account/generate-test-data/#exercising-a-specification","text":"clojure.spec.test.alpha/exercise returns pairs of generated and conformed values for a spec. exercise by default produces 10 samples (like sample) but you can pass both functions a number indicating the number of samples to produce. ( spec/exercise ( spec/cat :practicalli.banking-specifications/first-name :practicalli.banking-specifications/last-name )) ;; => ([(\"\") #:practicalli.banking-specifications{:first-name \"\"}] [( \"6\" ) # :practicalli.banking-specifications { :first-name \"6\" }] [( \"\" ) # :practicalli.banking-specifications { :first-name \"\" }] [( \"6\" ) # :practicalli.banking-specifications { :first-name \"6\" }] [( \"W\" ) # :practicalli.banking-specifications { :first-name \"W\" }] [( \"ljooD\" ) # :practicalli.banking-specifications { :first-name \"ljooD\" }] [( \"704d5x\" ) # :practicalli.banking-specifications { :first-name \"704d5x\" }] [( \"EZyBT\" ) # :practicalli.banking-specifications { :first-name \"EZyBT\" }] [( \"1e6\" ) # :practicalli.banking-specifications { :first-name \"1e6\" }] [( \"v\" ) # :practicalli.banking-specifications { :first-name \"v\" }]) clojure.spec.test.alpha/exercise-fn provides the same service but for function specifications ( fdef ).","title":"Exercising a specification"},{"location":"clojure-spec/projects/bank-account/rebel-readline/","text":"Using the project in rebel readline \u03bb\ufe0e Hint::TODO: add screenshots using Rebel readline REPL \u03bb\ufe0e Start the rebel REPL clojure -M:repl/rebel Once rebel has started a prompt will be displayed. First required the main namespace, containing the functions of the application. This loads the code in that namespace into the REPL. ( require 'practicalli.banking-on-clojure ) Now add the specifications for the project ( require 'practicalli.banking-on-clojure ) ? When does the TAB completion start to work ? Testing the specifications First change into the specifications namespace so the fully qualified names of the specs are not required. ( in-ns 'practicalli.banking-specifications ) Generate sample data from the specifications (spec-gen/sample (spec/gen ::account-id)) The function specifications and the instrument functions are loaded from the requires, so test by calling the instrumented functions, first with bad data and then with correct data. ( register-account-holder {}) Use the specifications to generate good data ( register-account-holder ::customer-details ) Run generative tests on functions to check the return and fn values ( spec-test/check ` register-account-holder )","title":"Using the project in rebel readline"},{"location":"clojure-spec/projects/bank-account/rebel-readline/#using-the-project-in-rebel-readline","text":"","title":"Using the project in rebel readline"},{"location":"clojure-spec/projects/bank-account/rebel-readline/#hinttodo-add-screenshots-using-rebel-readline-repl","text":"Start the rebel REPL clojure -M:repl/rebel Once rebel has started a prompt will be displayed. First required the main namespace, containing the functions of the application. This loads the code in that namespace into the REPL. ( require 'practicalli.banking-on-clojure ) Now add the specifications for the project ( require 'practicalli.banking-on-clojure ) ? When does the TAB completion start to work ? Testing the specifications First change into the specifications namespace so the fully qualified names of the specs are not required. ( in-ns 'practicalli.banking-specifications ) Generate sample data from the specifications (spec-gen/sample (spec/gen ::account-id)) The function specifications and the instrument functions are loaded from the requires, so test by calling the instrumented functions, first with bad data and then with correct data. ( register-account-holder {}) Use the specifications to generate good data ( register-account-holder ::customer-details ) Run generative tests on functions to check the return and fn values ( spec-test/check ` register-account-holder )","title":"Hint::TODO: add screenshots using Rebel readline REPL"},{"location":"clojure-spec/projects/bank-account/test-functions-against-spec/","text":"Generative testing with check \u03bb\ufe0e clojure.spec.test.alpha/check generates 1000 values from the argument section of a function definition specification. Pass the name of the function definition that has a specification to the check function. ( spec-test/check `` register-account-holder ` ) Limiting the generated data \u03bb\ufe0e 1000 tests can take a noticeable time to run, so check is not as often used during active development, as it would slow down the normal fast feedback cycle with Clojure. check takes an optional second argument which configures how the function operates. Passing a hash-map as a second argument will set the number of data values generated {:clojure.spec.test.check/opts {:num-tests 100}} ( spec-test/check ` register-account-holder { :clojure.spec.test.check/opts { :num-tests 100 }}) Configuring check to run fewer tests provides a simple way to test multiple values without slowing down the development workflow. Reporting on Generative testing \u03bb\ufe0e clojure.spec.test.alpha/summarize-results will return a brief summary including the total number of results and a count for how many results passed and failed. ( spec-test/summarize-results ( spec-test/check ` register-customer { :clojure.spec.test.check/opts { :num-tests 10 }})) Use the threading macro to summarize the results of multiple check operations ( ->> ( spec-test/check ` register-account-holder ) ( spec-test/check ` open-current-bank-account ) ( spec-test/summarize-results )) If this expression is bound to a name then it can be called when ever the full suite of check generative testing is required.","title":"Test functions against spec"},{"location":"clojure-spec/projects/bank-account/test-functions-against-spec/#generative-testing-with-check","text":"clojure.spec.test.alpha/check generates 1000 values from the argument section of a function definition specification. Pass the name of the function definition that has a specification to the check function. ( spec-test/check `` register-account-holder ` )","title":"Generative testing with check"},{"location":"clojure-spec/projects/bank-account/test-functions-against-spec/#limiting-the-generated-data","text":"1000 tests can take a noticeable time to run, so check is not as often used during active development, as it would slow down the normal fast feedback cycle with Clojure. check takes an optional second argument which configures how the function operates. Passing a hash-map as a second argument will set the number of data values generated {:clojure.spec.test.check/opts {:num-tests 100}} ( spec-test/check ` register-account-holder { :clojure.spec.test.check/opts { :num-tests 100 }}) Configuring check to run fewer tests provides a simple way to test multiple values without slowing down the development workflow.","title":"Limiting the generated data"},{"location":"clojure-spec/projects/bank-account/test-functions-against-spec/#reporting-on-generative-testing","text":"clojure.spec.test.alpha/summarize-results will return a brief summary including the total number of results and a count for how many results passed and failed. ( spec-test/summarize-results ( spec-test/check ` register-customer { :clojure.spec.test.check/opts { :num-tests 10 }})) Use the threading macro to summarize the results of multiple check operations ( ->> ( spec-test/check ` register-account-holder ) ( spec-test/check ` open-current-bank-account ) ( spec-test/summarize-results )) If this expression is bound to a name then it can be called when ever the full suite of check generative testing is required.","title":"Reporting on Generative testing"},{"location":"clojure-spec/projects/bank-account/unit-tests-with-spec/","text":"Unit tests with specs \u03bb\ufe0e Now that customer data and account-holder data has a specification, we can use the clojure.spec.alpha/valid? in the unity test code, as that function returns true or false. In this example the result of a call to register-account-holder is checked to see if it is valid against the ::account-holder specification. This simplifies the code needed in unit test assertions, as Clojure spec is doing the work. ( deftest register-account-holder-test ( testing \"Basic registration - happy path\" ( is ( = ( set ( keys ( SUT/register-account-holder customer-mock ))) ( set ( keys account-holder )))) ( is ( spec/valid? :practicalli.bank-account-spec/account-holder ( SUT/register-account-holder customer-mock ) ) ) ))","title":"Unit tests with specs"},{"location":"clojure-spec/projects/bank-account/unit-tests-with-spec/#unit-tests-with-specs","text":"Now that customer data and account-holder data has a specification, we can use the clojure.spec.alpha/valid? in the unity test code, as that function returns true or false. In this example the result of a call to register-account-holder is checked to see if it is valid against the ::account-holder specification. This simplifies the code needed in unit test assertions, as Clojure spec is doing the work. ( deftest register-account-holder-test ( testing \"Basic registration - happy path\" ( is ( = ( set ( keys ( SUT/register-account-holder customer-mock ))) ( set ( keys account-holder )))) ( is ( spec/valid? :practicalli.bank-account-spec/account-holder ( SUT/register-account-holder customer-mock ) ) ) ))","title":"Unit tests with specs"},{"location":"clojure-spec/projects/bank-account/validate-customer-details-specification/","text":"Testing data Specifications \u03bb\ufe0e The specifications defined so far can be tested with specific data, using the conform or valid? functions. Generating sample data from the specifications also provides useful feedback on how well the specifications are defined. Generating data from specifications \u03bb\ufe0e Test data specifications by generating sample data from those specifications. Evaluating these functions several times is a quick way to identifies specifications that may require custom generators. If individual specifications do not generate consistent data, then incorrect results may occur during composite data specifications or function specifications. ( spec-gen/sample ( spec/gen ::first-name )) ( spec-gen/sample ( spec/gen ::last-name )) ( spec-gen/sample ( spec/gen ::email-address )) ( spec-gen/sample ( spec/gen ::house-name-number )) ( spec-gen/sample ( spec/gen ::street-name )) ( spec-gen/sample ( spec/gen ::post-code )) ( spec-gen/sample ( spec/gen ::county )) ( spec-gen/sample ( spec/gen ::country )) ( spec-gen/sample ( spec/gen ::residential-address )) ( spec-gen/sample ( spec/gen ::social-security-id-uk )) ( spec-gen/sample ( spec/gen ::social-security-id-usa )) ( spec-gen/sample ( spec/gen ::social-security-id )) ( spec-gen/sample ( spec/gen ::customer-details )) ( spec-gen/sample ( spec/gen ::account-holder )) Validating the customer details specifications \u03bb\ufe0e The specifications can be checked using the conform or valid? functions with example data. Check an example hash-map from our test conforms to the specification ( spec/conform ::customer-details { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; => :clojure.spec.alpha/invalid The mock test data does not confirm to the specification, even though it has all the same keys as the map in the specification ( spec/valid? ::customer-details { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; => false spec/explain will provide more information to help diagnose the issue ( spec/explain ::customer-details { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/first-name) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/last-name) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/email-address) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/residential-address) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/social-security-id) spec: :practicalli.bank-account-design-journal/customer-details The ::customer-details spec is given a map with unqualified keys and is failing the :req part of the spec/keys part of the specification Qualifying keys with auto-resolve macro \u03bb\ufe0e The auto-resolve macro, #:: will add the current namespace to all the keys in a hash-map Change the test data to use qualified keys by adding the ( spec/conform ::customer-details # :: { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" } ) ;; => #:practicalli.bank-account-design-journal{:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"}","title":"Testing data Specifications"},{"location":"clojure-spec/projects/bank-account/validate-customer-details-specification/#testing-data-specifications","text":"The specifications defined so far can be tested with specific data, using the conform or valid? functions. Generating sample data from the specifications also provides useful feedback on how well the specifications are defined.","title":"Testing data Specifications"},{"location":"clojure-spec/projects/bank-account/validate-customer-details-specification/#generating-data-from-specifications","text":"Test data specifications by generating sample data from those specifications. Evaluating these functions several times is a quick way to identifies specifications that may require custom generators. If individual specifications do not generate consistent data, then incorrect results may occur during composite data specifications or function specifications. ( spec-gen/sample ( spec/gen ::first-name )) ( spec-gen/sample ( spec/gen ::last-name )) ( spec-gen/sample ( spec/gen ::email-address )) ( spec-gen/sample ( spec/gen ::house-name-number )) ( spec-gen/sample ( spec/gen ::street-name )) ( spec-gen/sample ( spec/gen ::post-code )) ( spec-gen/sample ( spec/gen ::county )) ( spec-gen/sample ( spec/gen ::country )) ( spec-gen/sample ( spec/gen ::residential-address )) ( spec-gen/sample ( spec/gen ::social-security-id-uk )) ( spec-gen/sample ( spec/gen ::social-security-id-usa )) ( spec-gen/sample ( spec/gen ::social-security-id )) ( spec-gen/sample ( spec/gen ::customer-details )) ( spec-gen/sample ( spec/gen ::account-holder ))","title":"Generating data from specifications"},{"location":"clojure-spec/projects/bank-account/validate-customer-details-specification/#validating-the-customer-details-specifications","text":"The specifications can be checked using the conform or valid? functions with example data. Check an example hash-map from our test conforms to the specification ( spec/conform ::customer-details { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; => :clojure.spec.alpha/invalid The mock test data does not confirm to the specification, even though it has all the same keys as the map in the specification ( spec/valid? ::customer-details { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; => false spec/explain will provide more information to help diagnose the issue ( spec/explain ::customer-details { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/first-name) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/last-name) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/email-address) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/residential-address) spec: :practicalli.bank-account-design-journal/customer-details ;; {:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"} ;; - failed: (contains? % :practicalli.bank-account-design-journal/social-security-id) spec: :practicalli.bank-account-design-journal/customer-details The ::customer-details spec is given a map with unqualified keys and is failing the :req part of the spec/keys part of the specification","title":"Validating the customer details specifications"},{"location":"clojure-spec/projects/bank-account/validate-customer-details-specification/#qualifying-keys-with-auto-resolve-macro","text":"The auto-resolve macro, #:: will add the current namespace to all the keys in a hash-map Change the test data to use qualified keys by adding the ( spec/conform ::customer-details # :: { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" } ) ;; => #:practicalli.bank-account-design-journal{:first-name \"Jenny\", :last-name \"Jetpack\", :email-address \"jenny@jetpack.org\", :residential-address \"42 meaning of life street\", :postal-code \"AB3 0EF\", :social-security-id \"123456789\"}","title":"Qualifying keys with auto-resolve macro"},{"location":"clojure-spec/projects/bank-account/write-failing-tests/","text":"Write failing tests \u03bb\ufe0e In Test Driven Development style, first write unit tests for the banking functions. Edit the src/practicalli/banking_on_clojure_test.clj and add deftest tests ( deftest register-account-holder-test ( testing \"Basic registration - happy path\" ( is ( = ( set ( keys ( register-account-holder {}))) ( set ( keys { :account-id \"123\" :customer-name \"Jenny Jetpack\" })))))) Write a function stub to run the tests \u03bb\ufe0e The tests cannot run unless they call the function to be tested. A common approach it to write a function that returns the argument. ( defn register-account-holder \"Register a new customer with the bank Arguments: - hash-map of customer-details Return: - hash-map of an account-holder (adds account id)\" [ customer-details ] customer-details ) Add mock data \u03bb\ufe0e Define some initial mock data to use with the unit tests ( def customer-mock { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) account is a customer with a bank account id added ( def account-holder-mock { :account-id # uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\" :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) Update the test to use the mock data. ( deftest register-account-holder-test ( testing \"Basic registration - happy path\" ( is ( = ( set ( keys ( register-account-holder customer-mock ))) ( set ( keys account-holder-mock ))))))","title":"Write failing tests"},{"location":"clojure-spec/projects/bank-account/write-failing-tests/#write-failing-tests","text":"In Test Driven Development style, first write unit tests for the banking functions. Edit the src/practicalli/banking_on_clojure_test.clj and add deftest tests ( deftest register-account-holder-test ( testing \"Basic registration - happy path\" ( is ( = ( set ( keys ( register-account-holder {}))) ( set ( keys { :account-id \"123\" :customer-name \"Jenny Jetpack\" }))))))","title":"Write failing tests"},{"location":"clojure-spec/projects/bank-account/write-failing-tests/#write-a-function-stub-to-run-the-tests","text":"The tests cannot run unless they call the function to be tested. A common approach it to write a function that returns the argument. ( defn register-account-holder \"Register a new customer with the bank Arguments: - hash-map of customer-details Return: - hash-map of an account-holder (adds account id)\" [ customer-details ] customer-details )","title":"Write a function stub to run the tests"},{"location":"clojure-spec/projects/bank-account/write-failing-tests/#add-mock-data","text":"Define some initial mock data to use with the unit tests ( def customer-mock { :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) account is a customer with a bank account id added ( def account-holder-mock { :account-id # uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\" :first-name \"Jenny\" :last-name \"Jetpack\" :email-address \"jenny@jetpack.org\" :residential-address \"42 meaning of life street, Earth\" :postal-code \"AB3 0EF\" :social-security-id \"123456789\" }) Update the test to use the mock data. ( deftest register-account-holder-test ( testing \"Basic registration - happy path\" ( is ( = ( set ( keys ( register-account-holder customer-mock ))) ( set ( keys account-holder-mock ))))))","title":"Add mock data"},{"location":"clojure-spec/projects/card-game/","text":"Card game: spec and generative testing \u03bb\ufe0e Specifications to represent the data that composes to create a deck of playing cards and functions that define a simple card game. spec generators are used to return varied sample data from those specifications. Function definitions are instrumented and check for correct arguments when those functions are called. Create a project \u03bb\ufe0e Create a new Clojure project using clj-new tool for Clojure Tools. clojure -M:new app practicalli/card-game Hint::Use practicalli/clojure-deps-edn to add common tools \u03bb\ufe0e fork and clone the practicalli/clojure-deps-edn GitHub repository to ~/.clojure/ and instantly have access to dozens of tools for Clojure software development Add the Clojure spec namespace \u03bb\ufe0e Open the src/practicalli/card_game.clj file and require the clojure.spec.alpha namespace (ns practicalli.card-game.clj (:require [clojure.spec.alpha :as spec])) Hint::Hiding code \u03bb\ufe0e Each page in this guide runs a self contained REPL, so the practicalli.card-game namespace, require expressions and specifications needed for each page are included as a hidden section at the top of each page. This approach removes the need to duplicate code from previous sections.","title":"Card game: spec and generative testing"},{"location":"clojure-spec/projects/card-game/#card-game-spec-and-generative-testing","text":"Specifications to represent the data that composes to create a deck of playing cards and functions that define a simple card game. spec generators are used to return varied sample data from those specifications. Function definitions are instrumented and check for correct arguments when those functions are called.","title":"Card game: spec and generative testing"},{"location":"clojure-spec/projects/card-game/#create-a-project","text":"Create a new Clojure project using clj-new tool for Clojure Tools. clojure -M:new app practicalli/card-game","title":"Create a project"},{"location":"clojure-spec/projects/card-game/#hintuse-practicalliclojure-deps-edn-to-add-common-tools","text":"fork and clone the practicalli/clojure-deps-edn GitHub repository to ~/.clojure/ and instantly have access to dozens of tools for Clojure software development","title":"Hint::Use practicalli/clojure-deps-edn to add common tools"},{"location":"clojure-spec/projects/card-game/#add-the-clojure-spec-namespace","text":"Open the src/practicalli/card_game.clj file and require the clojure.spec.alpha namespace (ns practicalli.card-game.clj (:require [clojure.spec.alpha :as spec]))","title":"Add the Clojure spec namespace"},{"location":"clojure-spec/projects/card-game/#hinthiding-code","text":"Each page in this guide runs a self contained REPL, so the practicalli.card-game namespace, require expressions and specifications needed for each page are included as a hidden section at the top of each page. This approach removes the need to duplicate code from previous sections.","title":"Hint::Hiding code"},{"location":"clojure-spec/projects/card-game/function-specifications/","text":"Specifications for function definitions \u03bb\ufe0e A function specification can contain a specification for the arguments, the return values and the relationship between the two. The specifications for the function may be composed from previously defined data specifications. Function definitions \u03bb\ufe0e The card game application has three functions to start with. (defn regulation-card-deck \"Generate a complete deck of playing cards\" [{:keys [::deck ::players] :as game}] (apply + (count deck) (map #(-> % ::delt-hand count) players))) At the start of function design, the algorithm may still be undefined. Using the specifications and generators mock data can be returned as a placeholder. (defn deal-cards \"Deal cards to each of the players Returns updated game hash-map\" [game] (spec-gen/generate (spec/gen ::game))) (defn winning-player \"Calculate winning hand by comparing each players hand Return winning player\" [players] (spec-gen/generate (spec/gen ::player))) Function specification \u03bb\ufe0e (spec/fdef deal-cards :args (spec/cat :game ::game) :ret ::game :fn #(= (regulation-card-deck (-> % :args :game)) (regulation-card-deck (-> % :ret)))) (spec/fdef winning-player :args (spec/cat :players ::players) :ret ::player) Instrument functions \u03bb\ufe0e Instrumenting functions will wrap a function definition and check the arguments of any call to the instrumented function. (spec-test/instrument `deal-cards) Ignore the Warning message in the result, this is an issue with the REPL implementation used in this page. Calling the deal-cards function with an incorrect argument returns an error that describes where in the specification the error occurred. (deal-cards \"fake game data\") Error in an easier to read format ERROR : # error { :message \"Call to #'practicalli.card-game/deal-cards did not conform to spec:\\n\\ \" fake game data \\\" - failed : map? in : [ 0 ] at : [ :args :game ] spec : :practicalli.card-game/game \\n \", :data {:cljs.spec.alpha/problems [{:path [:args :game], :pred cljs.core/map?, :val \" fake game data \", :via [:practicalli.card-game/game :practicalli.card-game/game], :in [0]}], :cljs.spec.alpha/spec #object[cljs.spec.alpha.t_cljs$spec$alpha17968], :cljs.spec.alpha/value (\" fake game data \"), :cljs.spec.alpha/args (\" fake game data \" ) , :cljs.spec.alpha/failure :instrument }}","title":"Specifications for function definitions"},{"location":"clojure-spec/projects/card-game/function-specifications/#specifications-for-function-definitions","text":"A function specification can contain a specification for the arguments, the return values and the relationship between the two. The specifications for the function may be composed from previously defined data specifications.","title":"Specifications for function definitions"},{"location":"clojure-spec/projects/card-game/function-specifications/#function-definitions","text":"The card game application has three functions to start with. (defn regulation-card-deck \"Generate a complete deck of playing cards\" [{:keys [::deck ::players] :as game}] (apply + (count deck) (map #(-> % ::delt-hand count) players))) At the start of function design, the algorithm may still be undefined. Using the specifications and generators mock data can be returned as a placeholder. (defn deal-cards \"Deal cards to each of the players Returns updated game hash-map\" [game] (spec-gen/generate (spec/gen ::game))) (defn winning-player \"Calculate winning hand by comparing each players hand Return winning player\" [players] (spec-gen/generate (spec/gen ::player)))","title":"Function definitions"},{"location":"clojure-spec/projects/card-game/function-specifications/#function-specification","text":"(spec/fdef deal-cards :args (spec/cat :game ::game) :ret ::game :fn #(= (regulation-card-deck (-> % :args :game)) (regulation-card-deck (-> % :ret)))) (spec/fdef winning-player :args (spec/cat :players ::players) :ret ::player)","title":"Function specification"},{"location":"clojure-spec/projects/card-game/function-specifications/#instrument-functions","text":"Instrumenting functions will wrap a function definition and check the arguments of any call to the instrumented function. (spec-test/instrument `deal-cards) Ignore the Warning message in the result, this is an issue with the REPL implementation used in this page. Calling the deal-cards function with an incorrect argument returns an error that describes where in the specification the error occurred. (deal-cards \"fake game data\") Error in an easier to read format ERROR : # error { :message \"Call to #'practicalli.card-game/deal-cards did not conform to spec:\\n\\ \" fake game data \\\" - failed : map? in : [ 0 ] at : [ :args :game ] spec : :practicalli.card-game/game \\n \", :data {:cljs.spec.alpha/problems [{:path [:args :game], :pred cljs.core/map?, :val \" fake game data \", :via [:practicalli.card-game/game :practicalli.card-game/game], :in [0]}], :cljs.spec.alpha/spec #object[cljs.spec.alpha.t_cljs$spec$alpha17968], :cljs.spec.alpha/value (\" fake game data \"), :cljs.spec.alpha/args (\" fake game data \" ) , :cljs.spec.alpha/failure :instrument }}","title":"Instrument functions"},{"location":"clojure-spec/projects/card-game/game-specifications/","text":"Game specifications \u03bb\ufe0e Specifications for data used to represent players and the overall card game. Specification definition so far \u03bb\ufe0e (ns practicalli.card-game (:require [clojure.spec.alpha :as spec] [clojure.spec.gen.alpha :as spec-gen] [clojure.spec.test.alpha :as spec-test])) (spec/def ::suit #{:clubs :diamonds :hearts :spades}) (spec/def ::rank (into #{:jack :queen :king :ace} (range 2 11))) (spec/def ::playing-card (spec/tuple ::rank ::suit)) (spec/def ::dealt-hand (spec/* ::playing-card)) Player specifications \u03bb\ufe0e The player name is a very simple spec. (spec/def ::name string?) Score will keep a running total of a player score across games, again a simple integer value. (spec/def ::score int?) A player is represented by a hash-map that contains their name, score and the hand they are currently dealt. The hand is a collection of tuples representing a playing card. (spec/def ::player (spec/keys :req [::name ::score ::dealt-hand])) Card game deck specifications \u03bb\ufe0e A card game has a deck of 52 cards, one card for each combination of suit and rank. The size of the card deck changes over the course of a game, so the deck can contain any number of cards. The deck must contain only cards to be valid. (spec/def ::card-deck (spec/* ::playing-card)) At this stage in the design, a card game can have any number of players (spec/def ::players (spec/* ::player)) A game is represented by a hash-map with a collection of players and a card deck (spec/def ::game (spec/keys :req [::players ::card-deck])) Generating random player data \u03bb\ufe0e (spec-gen/generate (spec/gen ::player)) Generating random game data \u03bb\ufe0e clojure.spec.alpha/gen returns a generator for the given specification. clojure.spec.gen.alpha/generate takes that generator and creates a random value that conforms to the specification. (spec-gen/generate (spec/gen ::game)) clojure.spec.gen.alpha/sample will generate a collection of random values that each conform to the specification. (spec-gen/sample (spec/gen ::game))","title":"Game specifications"},{"location":"clojure-spec/projects/card-game/game-specifications/#game-specifications","text":"Specifications for data used to represent players and the overall card game.","title":"Game specifications"},{"location":"clojure-spec/projects/card-game/game-specifications/#specification-definition-so-far","text":"(ns practicalli.card-game (:require [clojure.spec.alpha :as spec] [clojure.spec.gen.alpha :as spec-gen] [clojure.spec.test.alpha :as spec-test])) (spec/def ::suit #{:clubs :diamonds :hearts :spades}) (spec/def ::rank (into #{:jack :queen :king :ace} (range 2 11))) (spec/def ::playing-card (spec/tuple ::rank ::suit)) (spec/def ::dealt-hand (spec/* ::playing-card))","title":"Specification definition so far"},{"location":"clojure-spec/projects/card-game/game-specifications/#player-specifications","text":"The player name is a very simple spec. (spec/def ::name string?) Score will keep a running total of a player score across games, again a simple integer value. (spec/def ::score int?) A player is represented by a hash-map that contains their name, score and the hand they are currently dealt. The hand is a collection of tuples representing a playing card. (spec/def ::player (spec/keys :req [::name ::score ::dealt-hand]))","title":"Player specifications"},{"location":"clojure-spec/projects/card-game/game-specifications/#card-game-deck-specifications","text":"A card game has a deck of 52 cards, one card for each combination of suit and rank. The size of the card deck changes over the course of a game, so the deck can contain any number of cards. The deck must contain only cards to be valid. (spec/def ::card-deck (spec/* ::playing-card)) At this stage in the design, a card game can have any number of players (spec/def ::players (spec/* ::player)) A game is represented by a hash-map with a collection of players and a card deck (spec/def ::game (spec/keys :req [::players ::card-deck]))","title":"Card game deck specifications"},{"location":"clojure-spec/projects/card-game/game-specifications/#generating-random-player-data","text":"(spec-gen/generate (spec/gen ::player))","title":"Generating random player data"},{"location":"clojure-spec/projects/card-game/game-specifications/#generating-random-game-data","text":"clojure.spec.alpha/gen returns a generator for the given specification. clojure.spec.gen.alpha/generate takes that generator and creates a random value that conforms to the specification. (spec-gen/generate (spec/gen ::game)) clojure.spec.gen.alpha/sample will generate a collection of random values that each conform to the specification. (spec-gen/sample (spec/gen ::game))","title":"Generating random game data"},{"location":"clojure-spec/projects/card-game/generative-data-from-specifications/","text":"Generative data from Specifications \u03bb\ufe0e Mock and test data values can be generated from the specifications defined. Require the clojure.spec.gen.alpha namespace to access the data generators. The clojure.spec.test.alpha namespace is required to support getting a generator for a given specification. (ns practicalli.card-game.clj (:require [clojure.spec.alpha :as spec] [clojure.spec.gen.alpha :as spec-gen] [clojure.spec.test.alpha :as spec-test])) (spec/def ::suits #{:clubs :diamonds :hearts :spades}) (spec/def ::rank #{:ace 2 3 4 5 6 7 8 9 10 :jack :queen :king}) To generated data based on a specification, first get a generator for a given spec, (spec/gen ::suits) generate will return a value using the specific generator for the specification. (spec-gen/generate (spec/gen ::suits)) sample will generate a number of values from the given specification (spec-gen/sample (spec/gen ::rank))","title":"Generative data from Specifications"},{"location":"clojure-spec/projects/card-game/generative-data-from-specifications/#generative-data-from-specifications","text":"Mock and test data values can be generated from the specifications defined. Require the clojure.spec.gen.alpha namespace to access the data generators. The clojure.spec.test.alpha namespace is required to support getting a generator for a given specification. (ns practicalli.card-game.clj (:require [clojure.spec.alpha :as spec] [clojure.spec.gen.alpha :as spec-gen] [clojure.spec.test.alpha :as spec-test])) (spec/def ::suits #{:clubs :diamonds :hearts :spades}) (spec/def ::rank #{:ace 2 3 4 5 6 7 8 9 10 :jack :queen :king}) To generated data based on a specification, first get a generator for a given spec, (spec/gen ::suits) generate will return a value using the specific generator for the specification. (spec-gen/generate (spec/gen ::suits)) sample will generate a number of values from the given specification (spec-gen/sample (spec/gen ::rank))","title":"Generative data from Specifications"},{"location":"clojure-spec/projects/card-game/organising-instrumentation/","text":"Organizing the instrumentation of functions \u03bb\ufe0e Instrumenting functions creates a wrapper around the original function definition. When you change the function definition and evaluate the new code, it replaces the instrumentation of the function. Therefore each time a function is redefined it should be instrumented. There is no specific way to manage instrumenting a function, however, a common approach is to define a collection of functions to instrument, then use a helper function to instrument all the functions at once. Bind a name to the collection of function specifications. ( def ^ :private function-specifications [ ` card-game/deal-cards ` card-game/winning-player ]) Define a simple helper function to instrument all the functions in the collection. ( defn instrument-all-functions [] ( spec-test/instrument function-specifications )) Refactoring the code may involve a number of changes benefit from instrumentation being switched off until its complete. The unstrument function will remove instrumentation from all the functions in the collection. ( defn unstrument-all-functions [] ( spec-test/unstrument function-specifications )) Hint::Koacha Test Runner \u03bb\ufe0e Koacha test runner can manage the testing of function specifications and is especially useful for managing unit level testing with specifications.","title":"Organizing the instrumentation of functions"},{"location":"clojure-spec/projects/card-game/organising-instrumentation/#organizing-the-instrumentation-of-functions","text":"Instrumenting functions creates a wrapper around the original function definition. When you change the function definition and evaluate the new code, it replaces the instrumentation of the function. Therefore each time a function is redefined it should be instrumented. There is no specific way to manage instrumenting a function, however, a common approach is to define a collection of functions to instrument, then use a helper function to instrument all the functions at once. Bind a name to the collection of function specifications. ( def ^ :private function-specifications [ ` card-game/deal-cards ` card-game/winning-player ]) Define a simple helper function to instrument all the functions in the collection. ( defn instrument-all-functions [] ( spec-test/instrument function-specifications )) Refactoring the code may involve a number of changes benefit from instrumentation being switched off until its complete. The unstrument function will remove instrumentation from all the functions in the collection. ( defn unstrument-all-functions [] ( spec-test/unstrument function-specifications ))","title":"Organizing the instrumentation of functions"},{"location":"clojure-spec/projects/card-game/organising-instrumentation/#hintkoacha-test-runner","text":"Koacha test runner can manage the testing of function specifications and is especially useful for managing unit level testing with specifications.","title":"Hint::Koacha Test Runner"},{"location":"clojure-spec/projects/card-game/playing-card-specifications/","text":"Representing playing cards as specifications \u03bb\ufe0e A playing card has a face value and a suit. There are 4 suits in a card deck. A specification for the possible suits can be defined using literal values (spec/def ::suits #{:clubs :diamonds :hearts :spades}) As the set is a predicate then it could just be bound to a name, i.e. (def suits? #{:clubs :diamonds :hearts :spades}) Representing different aspects of card game decks \u03bb\ufe0e Suits from different regions are called by different names. Each of these suits can be their own spec. (spec/def ::suits-french #{:hearts :tiles :clovers :pikes}) (spec/def ::suits-german #{:hearts :bells :acorns :leaves}) (spec/def ::suits-spanish #{:cups :coins :clubs :swords}) (spec/def ::suits-italian #{:cups :coins :clubs :swords}) (spec/def ::suits-swiss-german #{:roses :bells :acorns :shields}) A composite specification called ::card-suits provides a simple abstraction over all the variations of suits. Using ::card-suits will be satisfied with any region specific suits. (spec/def ::card-suits (spec/or :french ::suits-french :german ::suits-german :spanish ::suits-spanish :italian ::suits-italian :swiss-german ::suits-swiss-german :international ::suits-international)) Define an alias for a specification \u03bb\ufe0e Jack queen king are called face cards in the USA and occasionally referred to as court cards in the UK. Define a spec for ::face-cards and then make ::court-cards and alias for ::face-cards (spec/def ::face-cards #{:jack :queen :king :ace}) (spec/def ::court-cards ::face-cards) Any value that conforms to the ::face-card specification also conforms to the ::court-cards specification. (spec/conform ::court-cards :ace) Playing card rank \u03bb\ufe0e Each suit in the deck has the same rank of cards explicitly defining a rank (spec/def ::rank #{:ace 2 3 4 5 6 7 8 9 10 :jack :queen :king}) rank can be defined more succinctly with the clojure.core/range function. The expression (range 2 11) will generates a sequence of integer numbers from 2 to 10 (the end number is exclusive, so 11 is not in the sequence). Using clojure.core/into this range of numbers can be added to the face card values. (into #{:ace :jack :queen :king} (range 2 11)) The ::rank specification now generates all the possible values for playing cards. (spec/def ::rank (into #{:ace :jack :queen :king} (range 2 11))) The specification only checks to see if a value is in the set, the order of the values in the set is irrelevant. Playing Cards \u03bb\ufe0e A playing card is a combination of suit and face value, a pair of values, referred to as a tuple. Clojure spec has a tuple function, however, we need to define some predicates first (spec/def ::playing-card (spec/tuple ::rank ::suits )) Use the spec with values to see if they conform. Try you own values for a playing card. (spec/conform ::playing-card [:ace :spades])","title":"Representing playing cards as specifications"},{"location":"clojure-spec/projects/card-game/playing-card-specifications/#representing-playing-cards-as-specifications","text":"A playing card has a face value and a suit. There are 4 suits in a card deck. A specification for the possible suits can be defined using literal values (spec/def ::suits #{:clubs :diamonds :hearts :spades}) As the set is a predicate then it could just be bound to a name, i.e. (def suits? #{:clubs :diamonds :hearts :spades})","title":"Representing playing cards as specifications"},{"location":"clojure-spec/projects/card-game/playing-card-specifications/#representing-different-aspects-of-card-game-decks","text":"Suits from different regions are called by different names. Each of these suits can be their own spec. (spec/def ::suits-french #{:hearts :tiles :clovers :pikes}) (spec/def ::suits-german #{:hearts :bells :acorns :leaves}) (spec/def ::suits-spanish #{:cups :coins :clubs :swords}) (spec/def ::suits-italian #{:cups :coins :clubs :swords}) (spec/def ::suits-swiss-german #{:roses :bells :acorns :shields}) A composite specification called ::card-suits provides a simple abstraction over all the variations of suits. Using ::card-suits will be satisfied with any region specific suits. (spec/def ::card-suits (spec/or :french ::suits-french :german ::suits-german :spanish ::suits-spanish :italian ::suits-italian :swiss-german ::suits-swiss-german :international ::suits-international))","title":"Representing different aspects of card game decks"},{"location":"clojure-spec/projects/card-game/playing-card-specifications/#define-an-alias-for-a-specification","text":"Jack queen king are called face cards in the USA and occasionally referred to as court cards in the UK. Define a spec for ::face-cards and then make ::court-cards and alias for ::face-cards (spec/def ::face-cards #{:jack :queen :king :ace}) (spec/def ::court-cards ::face-cards) Any value that conforms to the ::face-card specification also conforms to the ::court-cards specification. (spec/conform ::court-cards :ace)","title":"Define an alias for a specification"},{"location":"clojure-spec/projects/card-game/playing-card-specifications/#playing-card-rank","text":"Each suit in the deck has the same rank of cards explicitly defining a rank (spec/def ::rank #{:ace 2 3 4 5 6 7 8 9 10 :jack :queen :king}) rank can be defined more succinctly with the clojure.core/range function. The expression (range 2 11) will generates a sequence of integer numbers from 2 to 10 (the end number is exclusive, so 11 is not in the sequence). Using clojure.core/into this range of numbers can be added to the face card values. (into #{:ace :jack :queen :king} (range 2 11)) The ::rank specification now generates all the possible values for playing cards. (spec/def ::rank (into #{:ace :jack :queen :king} (range 2 11))) The specification only checks to see if a value is in the set, the order of the values in the set is irrelevant.","title":"Playing card rank"},{"location":"clojure-spec/projects/card-game/playing-card-specifications/#playing-cards","text":"A playing card is a combination of suit and face value, a pair of values, referred to as a tuple. Clojure spec has a tuple function, however, we need to define some predicates first (spec/def ::playing-card (spec/tuple ::rank ::suits )) Use the spec with values to see if they conform. Try you own values for a playing card. (spec/conform ::playing-card [:ace :spades])","title":"Playing Cards"},{"location":"clojure-spec/testing/","text":"Testing with Specifications \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e During development \u03bb\ufe0e Create specifications for data and functions Selectively instrument function definitions to check function call arguments against the function specification. clojure.spec.test.alpha/instrument - check fdef :args Unit and integration testing \u03bb\ufe0e Add specification checks along with unit testing and integration testing to provide a very wide range of data values to be tested (with a minimal amount of code). clojure.spec.test.alpha/check - use :args to generate tests to check fdef :ret and :fn run a suite of spec-generative tests on an entire ns with check . Just one namespace per check expression? control the number of values check creates for each check expression. As the default is 1000 the checks can take a noticeable time to run (see practicalli/spec-generative-testing ) Many built-in generators for clojure.core data predicates composite specifications can build generators upon predicate generators. Pass generator-returning functions to spec, supplying generators for things spec does not know about. Pass an override map to gen in order to supply alternative generators for one or more sub-paths of a spec. Define your own generators At run time \u03bb\ufe0e Use specifications for run time checking, typically using conform and valid? functions. Specification are typically the minimal checks required for the system, compared to more extensive checks during test and system integration. Create lightweight private specifications for tests that run in the production environment.","title":"Testing with Specifications"},{"location":"clojure-spec/testing/#testing-with-specifications","text":"","title":"Testing with Specifications"},{"location":"clojure-spec/testing/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"clojure-spec/testing/#during-development","text":"Create specifications for data and functions Selectively instrument function definitions to check function call arguments against the function specification. clojure.spec.test.alpha/instrument - check fdef :args","title":"During development"},{"location":"clojure-spec/testing/#unit-and-integration-testing","text":"Add specification checks along with unit testing and integration testing to provide a very wide range of data values to be tested (with a minimal amount of code). clojure.spec.test.alpha/check - use :args to generate tests to check fdef :ret and :fn run a suite of spec-generative tests on an entire ns with check . Just one namespace per check expression? control the number of values check creates for each check expression. As the default is 1000 the checks can take a noticeable time to run (see practicalli/spec-generative-testing ) Many built-in generators for clojure.core data predicates composite specifications can build generators upon predicate generators. Pass generator-returning functions to spec, supplying generators for things spec does not know about. Pass an override map to gen in order to supply alternative generators for one or more sub-paths of a spec. Define your own generators","title":"Unit and integration testing"},{"location":"clojure-spec/testing/#at-run-time","text":"Use specifications for run time checking, typically using conform and valid? functions. Specification are typically the minimal checks required for the system, compared to more extensive checks during test and system integration. Create lightweight private specifications for tests that run in the production environment.","title":"At run time"},{"location":"clojure-spec/testing/checking%20arguments/","text":"Checking arguments in function calls with specifications \u03bb\ufe0e Instrument functions during development \u03bb\ufe0e Instrumenting a function enables the checking of arguments in a function call against the specification defined in an fdef definition of the same name. ( clojure.spec.test.alpha/instrument ` function-name ) Instrumenting a function swaps the function definition var with a wrapped version of the function definition which includes tests the :args spec from the fdef expression. unstrument returns the function definition to the original form and tests for that function are no longer run. Unit (Specification) testing \u03bb\ufe0e You can generate data for interactive testing with gen/sample.","title":"Checking arguments in function calls with specifications"},{"location":"clojure-spec/testing/checking%20arguments/#checking-arguments-in-function-calls-with-specifications","text":"","title":"Checking arguments in function calls with specifications"},{"location":"clojure-spec/testing/checking%20arguments/#instrument-functions-during-development","text":"Instrumenting a function enables the checking of arguments in a function call against the specification defined in an fdef definition of the same name. ( clojure.spec.test.alpha/instrument ` function-name ) Instrumenting a function swaps the function definition var with a wrapped version of the function definition which includes tests the :args spec from the fdef expression. unstrument returns the function definition to the original form and tests for that function are no longer run.","title":"Instrument functions during development"},{"location":"clojure-spec/testing/checking%20arguments/#unit-specification-testing","text":"You can generate data for interactive testing with gen/sample.","title":"Unit (Specification) testing"},{"location":"coding-challenges/","text":"Coding Challenges for Clojure \u03bb\ufe0e Coding challenges are an excellent way to start learning a new language. The challenges allow you to focus on the language and not be concerned about the more general engineering aspects of software development. Challenges are there to explore a language and practice your understanding of how to assemble working code. It is recommended to try different approaches to solving a challenges and even repeat the same challenges at a later date and see what additional approaches you have learned. 4Ever-Clojure is a highly recommended starting point for learning Clojure and does not require any installation or setup. 4Ever-Clojure is a new implementation of 4Clojure.com. Challenge website Description Requirements 4Ever-Clojure Highly recommended for learning the core functions of the Clojure language Web Browser Exercism.io Coding exercises with mentor support, optionhally using Clojure CLI Web Browser (local: Exercism CLI, Clojure CLI & Clojure aware editor ClojureScript Koans Interactive exercises in a web browser Web Browser Advent of Code General coding challenge with a seasonal theme Clojure aware editor CodeWars General coding challenges with Clojure variants. Many math-base challenges Web Browser","title":"Coding Challenges for Clojure"},{"location":"coding-challenges/#coding-challenges-for-clojure","text":"Coding challenges are an excellent way to start learning a new language. The challenges allow you to focus on the language and not be concerned about the more general engineering aspects of software development. Challenges are there to explore a language and practice your understanding of how to assemble working code. It is recommended to try different approaches to solving a challenges and even repeat the same challenges at a later date and see what additional approaches you have learned. 4Ever-Clojure is a highly recommended starting point for learning Clojure and does not require any installation or setup. 4Ever-Clojure is a new implementation of 4Clojure.com. Challenge website Description Requirements 4Ever-Clojure Highly recommended for learning the core functions of the Clojure language Web Browser Exercism.io Coding exercises with mentor support, optionhally using Clojure CLI Web Browser (local: Exercism CLI, Clojure CLI & Clojure aware editor ClojureScript Koans Interactive exercises in a web browser Web Browser Advent of Code General coding challenge with a seasonal theme Clojure aware editor CodeWars General coding challenges with Clojure variants. Many math-base challenges Web Browser","title":"Coding Challenges for Clojure"},{"location":"coding-challenges/advent-of-code/","text":"Advent of Code is the annual coding challenge with a festive theme. Each day there is a new challenge in two parts, the first fairly easy the second a little more involved. The challenges are an investment of your time to complete them all, although even trying just a few is enough to help you think in different ways. Every programming language requires regular practice to maintain your skills. A full time developer role gives you lots of opportunities to practice every day, however, its often focused in around solving problems within a specific business domain, with little time to explore others. The Advent of Code puts you in a different domain, so its great for extending your coding experiences. Solving challenges in a different language is another great way to extend your experiences, so here are some tips and examples for solving the advent of code in Clojure. Tips to solving the challenges \u03bb\ufe0e Keep the solution as simple as possible. Its very easy to over-complicate the solution and end up simply confusing yourself. Don't try and make the perfect solution. Write something that works, this will give you a nice ego boost. Then you can experiment with the code and see if you can improve your approach. Break down the problem into the simplest thing you can solve first. Trying to solve a problem all at once will quickly have you going around in circles. Keep all the code and make notes. I use a a design journal in my projects to document my thinking process, capture decisions that worked and those that didn't work for this project. The journal is a great way to cement learning from solving the challenge. Challenges are only accessible from their day of the month onwards. There is a count-down clock displayed on the next challenge to open, so you know when it will be available. Don't feel pressured to keep up with the challenges though, enjoy the experience and have fun, you will learn more that way. A previous example \u03bb\ufe0e A video guide to solving the first challenge of Advent of Code from 2018, trying out different solutions at increasing levels of abstraction. With each level of abstraction it helps to think in a more functional way. {% youtube %} https://youtu.be/opM7fU7IAV8 Creating a project for the challenge \u03bb\ufe0e I created practicalli/advent-of-clojure-code-2019 , a deps.edn project created with clj-new . I will be sharing any challenges I complete. clojure -M:new lib practicalli/advent-of-clojure-code-2019 Create a new Clojure file for each of the daily challenges. It makes sense to keep both parts of each day in the same file. Useful Resources And Examples \u03bb\ufe0e Videos and code solutions to many challenges from 2019 and past years. fdlk/advent-2019 - example Clojure solutions to the advent of code Awesome Advent Of Code - a collection of solutions in various languages Advent of Code 2018 video walk-through of Clojure solutions by Tim Pote and GitHub repository Also take a look at the #adventofcode channel in the Clojurians slack channel .","title":"Advent Of Code"},{"location":"coding-challenges/advent-of-code/#tips-to-solving-the-challenges","text":"Keep the solution as simple as possible. Its very easy to over-complicate the solution and end up simply confusing yourself. Don't try and make the perfect solution. Write something that works, this will give you a nice ego boost. Then you can experiment with the code and see if you can improve your approach. Break down the problem into the simplest thing you can solve first. Trying to solve a problem all at once will quickly have you going around in circles. Keep all the code and make notes. I use a a design journal in my projects to document my thinking process, capture decisions that worked and those that didn't work for this project. The journal is a great way to cement learning from solving the challenge. Challenges are only accessible from their day of the month onwards. There is a count-down clock displayed on the next challenge to open, so you know when it will be available. Don't feel pressured to keep up with the challenges though, enjoy the experience and have fun, you will learn more that way.","title":"Tips to solving the challenges"},{"location":"coding-challenges/advent-of-code/#a-previous-example","text":"A video guide to solving the first challenge of Advent of Code from 2018, trying out different solutions at increasing levels of abstraction. With each level of abstraction it helps to think in a more functional way. {% youtube %} https://youtu.be/opM7fU7IAV8","title":"A previous example"},{"location":"coding-challenges/advent-of-code/#creating-a-project-for-the-challenge","text":"I created practicalli/advent-of-clojure-code-2019 , a deps.edn project created with clj-new . I will be sharing any challenges I complete. clojure -M:new lib practicalli/advent-of-clojure-code-2019 Create a new Clojure file for each of the daily challenges. It makes sense to keep both parts of each day in the same file.","title":"Creating a project for the challenge"},{"location":"coding-challenges/advent-of-code/#useful-resources-and-examples","text":"Videos and code solutions to many challenges from 2019 and past years. fdlk/advent-2019 - example Clojure solutions to the advent of code Awesome Advent Of Code - a collection of solutions in various languages Advent of Code 2018 video walk-through of Clojure solutions by Tim Pote and GitHub repository Also take a look at the #adventofcode channel in the Clojurians slack channel .","title":"Useful Resources And Examples"},{"location":"coding-challenges/koans/","text":"ClojureScript Koans \u03bb\ufe0e Koans are a collection of small challenges that slowly increase in complexity. They are similar to the 4Clojure challenges in scope. TODO::work in progress, sorry \u03bb\ufe0e","title":"ClojureScript Koans"},{"location":"coding-challenges/koans/#clojurescript-koans","text":"Koans are a collection of small challenges that slowly increase in complexity. They are similar to the 4Clojure challenges in scope.","title":"ClojureScript Koans"},{"location":"coding-challenges/koans/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"coding-challenges/4clojure/","text":"Coding Challenges: 4Clojure \u03bb\ufe0e 4Ever-Clojure Challenges Website 4Ever-Clojure is a simple website with 150 challenges to help discover the functions built-in to the Clojure language, the Clojure API . The website is self-contained with nothing to install, simply paste in the missing code and run the tests. One piece of code should solve all the tests for that challenge. The Problem List shows the challenges categorized by experience level required, (Elementary, Easy, Medium, Hard) to solve them. Start with the easiest problem or work your way through the challenges in any order you wish. The Status column tracks your progress thorugh the challenges. Select the name of a challenge to see the description and one or more code tests that must pass. Enter the code that should be inserted where the __ double underscore characters are. Press the Run button to see if the code satisfies the tests A dialog box is displayed showing how many tests have passed and failed Start learning the Clojure API There are over 550 functions in the clojure.core namespace alone, with additional functions in many other namespaces that make up the https://clojure.github.io/clojure/ . It is not required to learn all these functions to be productive in Clojure. 4ever-clojure replaces 4Clojure 4Ever-Clojure is a new implementation of 4Clojure.com which has now been decommissioned Help completing the challenges \u03bb\ufe0e Look at the Clojure Cheatsheet and Clojure API for an understanding of what functions are available in the core of the Clojure language. Search directly in ClojureDocs for functions. Each function has a page that describes the function, shows the arguments it takes and provides many examples of its use. At the end of the page are related functions too. Practicalli Code walk-through and solution journal practicalli/four-clojure code journals for the first 60 challenges contains a design journal showing how each challenge was solved and addional refactor or alternative approaches to the solution. Practicalli 4Clojure guides playlist provides video walk-through of the first 64 challenges, again with alternative solutions where relevant. An Internet search of clojure topic , where topic is a name of the thing you want to do, should return many examples of functions that could be useful to solving the challenge. Or Clojure community - getting help included several other sources of help. Using let and anonymous functions \u03bb\ufe0e The solution submitted should be a single form, which is inserted in the test code where the __ underscore placeholder is. It is therefore not possible to define data with def or a separate function with defn to support the submitted solution. Use the anonymous function, fn , to define behavior. ( fn [ value1 value2 ] ( * value1 value2 )) Use let to bind a name to a value, so that value can be re-used throughout the expression. let is also useful for breaking the algorithm into smaller pieces, making it easier to solve the challenge. ( let [ name value ] ( * 2 value ( / value 4 ) ( + value 3 ))) It is common to combine fn and let to solve the challenges as they grow in complexity ( fn fibonacci [ length-of-series ] ( let [ fib [ 1 1 ]] ( if ( < ( count fib ) length-of-series ) \"iterate... to implement\" fib ))) fn - ClojureDocs let - ClojureDocs Fibonacci sequence guide - practicalli My function is not working \u03bb\ufe0e 4Ever Clojure uses babashka/sci project to evaluate code on a JavaScript host. Whist this should cover 99.9% of the Clojure API there may be some code that works in a Clojure (JVM) REPL that is not supported. Try the code in a Clojure REPL or create a Clojure project using the latest version of Clojure (1.11.x). References \u03bb\ufe0e 4Ever-Clojure Clojure Cheatsheet - Clojure.org Clojure API - Clojure.org practicalli/four-clojure code journals for the first 60 challenges 4Clojure video guides by Practicalli Clojure Core Library - ClojureDocs Clojure, The Essential Reference - Renzo Bogatti - Manning book published in 2020","title":"Coding Challenges: 4Clojure"},{"location":"coding-challenges/4clojure/#coding-challenges-4clojure","text":"4Ever-Clojure Challenges Website 4Ever-Clojure is a simple website with 150 challenges to help discover the functions built-in to the Clojure language, the Clojure API . The website is self-contained with nothing to install, simply paste in the missing code and run the tests. One piece of code should solve all the tests for that challenge. The Problem List shows the challenges categorized by experience level required, (Elementary, Easy, Medium, Hard) to solve them. Start with the easiest problem or work your way through the challenges in any order you wish. The Status column tracks your progress thorugh the challenges. Select the name of a challenge to see the description and one or more code tests that must pass. Enter the code that should be inserted where the __ double underscore characters are. Press the Run button to see if the code satisfies the tests A dialog box is displayed showing how many tests have passed and failed Start learning the Clojure API There are over 550 functions in the clojure.core namespace alone, with additional functions in many other namespaces that make up the https://clojure.github.io/clojure/ . It is not required to learn all these functions to be productive in Clojure. 4ever-clojure replaces 4Clojure 4Ever-Clojure is a new implementation of 4Clojure.com which has now been decommissioned","title":"Coding Challenges: 4Clojure"},{"location":"coding-challenges/4clojure/#help-completing-the-challenges","text":"Look at the Clojure Cheatsheet and Clojure API for an understanding of what functions are available in the core of the Clojure language. Search directly in ClojureDocs for functions. Each function has a page that describes the function, shows the arguments it takes and provides many examples of its use. At the end of the page are related functions too. Practicalli Code walk-through and solution journal practicalli/four-clojure code journals for the first 60 challenges contains a design journal showing how each challenge was solved and addional refactor or alternative approaches to the solution. Practicalli 4Clojure guides playlist provides video walk-through of the first 64 challenges, again with alternative solutions where relevant. An Internet search of clojure topic , where topic is a name of the thing you want to do, should return many examples of functions that could be useful to solving the challenge. Or Clojure community - getting help included several other sources of help.","title":"Help completing the challenges"},{"location":"coding-challenges/4clojure/#using-let-and-anonymous-functions","text":"The solution submitted should be a single form, which is inserted in the test code where the __ underscore placeholder is. It is therefore not possible to define data with def or a separate function with defn to support the submitted solution. Use the anonymous function, fn , to define behavior. ( fn [ value1 value2 ] ( * value1 value2 )) Use let to bind a name to a value, so that value can be re-used throughout the expression. let is also useful for breaking the algorithm into smaller pieces, making it easier to solve the challenge. ( let [ name value ] ( * 2 value ( / value 4 ) ( + value 3 ))) It is common to combine fn and let to solve the challenges as they grow in complexity ( fn fibonacci [ length-of-series ] ( let [ fib [ 1 1 ]] ( if ( < ( count fib ) length-of-series ) \"iterate... to implement\" fib ))) fn - ClojureDocs let - ClojureDocs Fibonacci sequence guide - practicalli","title":"Using let and anonymous functions"},{"location":"coding-challenges/4clojure/#my-function-is-not-working","text":"4Ever Clojure uses babashka/sci project to evaluate code on a JavaScript host. Whist this should cover 99.9% of the Clojure API there may be some code that works in a Clojure (JVM) REPL that is not supported. Try the code in a Clojure REPL or create a Clojure project using the latest version of Clojure (1.11.x).","title":"My function is not working"},{"location":"coding-challenges/4clojure/#references","text":"4Ever-Clojure Clojure Cheatsheet - Clojure.org Clojure API - Clojure.org practicalli/four-clojure code journals for the first 60 challenges 4Clojure video guides by Practicalli Clojure Core Library - ClojureDocs Clojure, The Essential Reference - Renzo Bogatti - Manning book published in 2020","title":"References"},{"location":"coding-challenges/codewars/","text":"CodeWars \u03bb\ufe0e Coding challenges in various languages with ranking scoreboard, experience levels and voting on solutions. Many of the challenges tend toward mathematics, so may require some background research before solving them. Requirements \u03bb\ufe0e Codewars is a web browser based system in which you can write code and run tests. Sample unit tests are provided with each challenge, so its all self-contained. Create a free account and select the language you wish to attempt challenges in. Two simple coding tests will need to be completed in order to access that specific language. Challenges Dashboard \u03bb\ufe0e After logging in, the dashboard suggests a challenge for you at a suitable level. 8 kyu is the easiest level, the smaller the number the harder the challenge. Tackling a challenge \u03bb\ufe0e Read the instructions and take a look at the sample tests. Many of the challenges have only a very basic explanation, so always review the sample unit tests to help with the understanding. The sample tests are not necessarily the full suite of tests run when testing your solution, so there may be undocumented edge cases to solve The source and test code can be copied into a new project, as has been done with the practicalli/codewars-guides solutions clojure -M:new lib practicalli/readability-is-king Update the solution window with your solution and use the TEST button to run the sample unit tests. The ATTEMPT button will run all the unit tests for the challenge, which may be more than the sample tests. If the attempt passes all the tests then the solution can be submitted an other solutions reviewed. Tracking progress \u03bb\ufe0e View your profile page to track your progress and revisit kata challenges already completed. References \u03bb\ufe0e practicalli/codewars-guide - a repository of code solutions to CodeWars challenges, each challenge is its own Clojure CLI (deps.edn) project. YouTube: CodeWars video guides Unofficial Free Code Camp Clojure Challenges","title":"CodeWars"},{"location":"coding-challenges/codewars/#codewars","text":"Coding challenges in various languages with ranking scoreboard, experience levels and voting on solutions. Many of the challenges tend toward mathematics, so may require some background research before solving them.","title":"CodeWars"},{"location":"coding-challenges/codewars/#requirements","text":"Codewars is a web browser based system in which you can write code and run tests. Sample unit tests are provided with each challenge, so its all self-contained. Create a free account and select the language you wish to attempt challenges in. Two simple coding tests will need to be completed in order to access that specific language.","title":"Requirements"},{"location":"coding-challenges/codewars/#challenges-dashboard","text":"After logging in, the dashboard suggests a challenge for you at a suitable level. 8 kyu is the easiest level, the smaller the number the harder the challenge.","title":"Challenges Dashboard"},{"location":"coding-challenges/codewars/#tackling-a-challenge","text":"Read the instructions and take a look at the sample tests. Many of the challenges have only a very basic explanation, so always review the sample unit tests to help with the understanding. The sample tests are not necessarily the full suite of tests run when testing your solution, so there may be undocumented edge cases to solve The source and test code can be copied into a new project, as has been done with the practicalli/codewars-guides solutions clojure -M:new lib practicalli/readability-is-king Update the solution window with your solution and use the TEST button to run the sample unit tests. The ATTEMPT button will run all the unit tests for the challenge, which may be more than the sample tests. If the attempt passes all the tests then the solution can be submitted an other solutions reviewed.","title":"Tackling a challenge"},{"location":"coding-challenges/codewars/#tracking-progress","text":"View your profile page to track your progress and revisit kata challenges already completed.","title":"Tracking progress"},{"location":"coding-challenges/codewars/#references","text":"practicalli/codewars-guide - a repository of code solutions to CodeWars challenges, each challenge is its own Clojure CLI (deps.edn) project. YouTube: CodeWars video guides Unofficial Free Code Camp Clojure Challenges","title":"References"},{"location":"coding-challenges/exercism/","text":"Exercism.io Challenges \u03bb\ufe0e Exercism.io Clojure Track Exercism.io is a learning platform for 12 programming languates which combines carefully crafted coding challenges and mentors who review and advise on solutions. Solve challenges via the built-in Exercism editor, so no install is reqiured. Or download each exercise locally using the Exercism CLI , providing a Clojure CLI configured project with a test runner. Use the Exercism CLI to submit a solution for metor feedback. Exercism embdedded Clojure editor The Exercisim Clojure editor is powered by babashka/sci Clojure Track \u03bb\ufe0e All the challenges are groups into specific language tracks , including the Clojure track Join the language track and select either mentored mode or practice mode. In mentored mode your solutions are added to the mentors dashboard for review from any of the available mentors. In practice mode you can complete as many solutions as you wish without waiting for a mentor. Working Locally \u03bb\ufe0e Exercism Guide to working locally Follow the Practicalli Clojure CLI Install steps (Exercism includes a similar Clojure CLI install guide ) The Exercism CLI can download a Clojure project containing the code for a specific challeng and submit the code back to exercism to confirm if the tests have passed and complete the challenge (or get feedback from a mentor). Each challenge shows the download and submit commands Each Exercise page shows the command to download the code for that specific exercise, which is of the form exercism download --exercise = exercise-name --track = clojure Open the project in your preferred Clojure editor and write a solution to solve the exercise. clojure -X:test command in the root of the downloaded project will run the tests supplied by the exercise or use any Clojure test runner , e.g. clojure -X:test/run or clojure -X:test/watch Once the tests pass and you are happy with the solution, submit it to the Exercism website exercism submit /path/to/src-file Support \u03bb\ufe0e Mentors on the Exercism website will provide a review of your submissions and you can switch between mentor and practice modes as you prefer. practicalli/exercism-clojure-guides contains a design journal of solutions to several Clojure exercises. Ask for advice in the #exercism or #beginners channels of the Clojurians Slack community.","title":"Exercism.io Challenges"},{"location":"coding-challenges/exercism/#exercismio-challenges","text":"Exercism.io Clojure Track Exercism.io is a learning platform for 12 programming languates which combines carefully crafted coding challenges and mentors who review and advise on solutions. Solve challenges via the built-in Exercism editor, so no install is reqiured. Or download each exercise locally using the Exercism CLI , providing a Clojure CLI configured project with a test runner. Use the Exercism CLI to submit a solution for metor feedback. Exercism embdedded Clojure editor The Exercisim Clojure editor is powered by babashka/sci","title":"Exercism.io Challenges"},{"location":"coding-challenges/exercism/#clojure-track","text":"All the challenges are groups into specific language tracks , including the Clojure track Join the language track and select either mentored mode or practice mode. In mentored mode your solutions are added to the mentors dashboard for review from any of the available mentors. In practice mode you can complete as many solutions as you wish without waiting for a mentor.","title":"Clojure Track"},{"location":"coding-challenges/exercism/#working-locally","text":"Exercism Guide to working locally Follow the Practicalli Clojure CLI Install steps (Exercism includes a similar Clojure CLI install guide ) The Exercism CLI can download a Clojure project containing the code for a specific challeng and submit the code back to exercism to confirm if the tests have passed and complete the challenge (or get feedback from a mentor). Each challenge shows the download and submit commands Each Exercise page shows the command to download the code for that specific exercise, which is of the form exercism download --exercise = exercise-name --track = clojure Open the project in your preferred Clojure editor and write a solution to solve the exercise. clojure -X:test command in the root of the downloaded project will run the tests supplied by the exercise or use any Clojure test runner , e.g. clojure -X:test/run or clojure -X:test/watch Once the tests pass and you are happy with the solution, submit it to the Exercism website exercism submit /path/to/src-file","title":"Working Locally"},{"location":"coding-challenges/exercism/#support","text":"Mentors on the Exercism website will provide a review of your submissions and you can switch between mentor and practice modes as you prefer. practicalli/exercism-clojure-guides contains a design journal of solutions to several Clojure exercises. Ask for advice in the #exercism or #beginners channels of the Clojurians Slack community.","title":"Support"},{"location":"coding-challenges/exercism/bob-regular-expression-approach/","text":"Solution to Bob challenge using regular expressions and the re-matches function. Using re-matchers , if the string matches the pattern, then the string is returned. Otherwise nil is returned The regular expressions cheatsheet from Mozilla Developer Network was very helpful in understanding regular expressions Asking Bob a question? \u03bb\ufe0e The phrase passed to Bob is a question if the last alphanumeric character is a question mark. Using a simple regular expression we can check if the last character in the string a ? #\"\\?\" is a literal regular expression pattern that will match a single ? character So the regular expression pattern will match a single ? character (re-matches #\"\\?\" \"?\") With other characters present though the pattern doesn't match. (re-matches #\"\\?\" \"Ready?\") To match ? with other characters, . matches any single character except line terminators (new line, carriage return) (re-matches #\".\\?\" \"R?\") .* matches any number of single characters one or more times, (re-matches #\".*\\?\" \"?Ready\") \\s matches a single whitespace character and \\s* matches multiple whitespace characters (re-matches #\".*\\?$\" \"Okay if like my spacebar quite a bit?\") ;; => \"Okay if like my spacebar quite a bit?\" $ is a boundary assertion so the pattern only matches the ? at the end of a string and not in the middle. However, this is not required as the re-matches uses groups and that manages the boundary assertion. re-matches does not require the $ as there is an implicit boundary (re-matches #\".*\\?\" \"Okay if like my ? spacebar quite a bit\") Match if there is a single space or space type character after the ? (re-matches #\".*\\?\\s\" \"Okay if like my spacebar quite a bit? \") ;; => \"Okay if like my spacebar quite a bit? \" Match if there are multiple space type characters after the ? (re-matches #\".*\\?\\s*\" \"Okay if like my spacebar quite a bit? \") ;; => \"Okay if like my spacebar quite a bit? \" Don't match if a question mark character is not at the end of the string (re-matches #\".*\\?\" \"Okay if like my ? spacebar quite a bit\") Shouting a question at Bob \u03bb\ufe0e [^a-z] matches if there are no lower case alphabetic characters. The ^ at the start of the pattern negated the pattern. * any number of the proceeding pattern [A-Z]+ any number of upper case alphabetic characters When a phrase has all uppercase characters then we have a match (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"HELLO\") If there are lower case characters, even if there are uppercase characters, the pattern does not match. (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"Hello\") If the characters are all uppercase then the pattern matches, even if there are other non-alphabetic characters (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"ABC 1 2 3\") Silence of the Bob \u03bb\ufe0e \\s matches any single whitespace character, including space, tab, form feed, line feed, and other Unicode spaces. (re-matches #\"\\s*\" \" \\t\\t\\t\") Solution using regular expressions \u03bb\ufe0e The re-matches expressions with regular expressions patterns can be put into a let expression. The names are bound to the re-matches expressions which evaluated to either true or false The names from the let are used with a cond function as conditions, returning the relevant reply from Bob. For the shouting question, the and is used to check if two names are both true. ( defn response-for [ phrase ] ( let [ ;; A ? at the end of the phrase, not counting whitespace question ( re-matches # \".*\\?\\s*\" phrase ) ;; No lower case characters, at least one upper case character yelling ( re-matches # \"[^a-z]*[A-Z]+[^a-z]*\" phrase ) ;; The entire string is whitespace silence ( re-matches # \"\\s*\" phrase )] ( cond silence \"Fine. Be that way!\" ( and question yelling ) \"Calm down, I know what I'm doing!\" question \"Sure.\" yelling \"Whoa, chill out!\" :whatever \"Whatever.\" )))","title":"Bob regular expression approach"},{"location":"coding-challenges/exercism/bob-regular-expression-approach/#asking-bob-a-question","text":"The phrase passed to Bob is a question if the last alphanumeric character is a question mark. Using a simple regular expression we can check if the last character in the string a ? #\"\\?\" is a literal regular expression pattern that will match a single ? character So the regular expression pattern will match a single ? character (re-matches #\"\\?\" \"?\") With other characters present though the pattern doesn't match. (re-matches #\"\\?\" \"Ready?\") To match ? with other characters, . matches any single character except line terminators (new line, carriage return) (re-matches #\".\\?\" \"R?\") .* matches any number of single characters one or more times, (re-matches #\".*\\?\" \"?Ready\") \\s matches a single whitespace character and \\s* matches multiple whitespace characters (re-matches #\".*\\?$\" \"Okay if like my spacebar quite a bit?\") ;; => \"Okay if like my spacebar quite a bit?\" $ is a boundary assertion so the pattern only matches the ? at the end of a string and not in the middle. However, this is not required as the re-matches uses groups and that manages the boundary assertion. re-matches does not require the $ as there is an implicit boundary (re-matches #\".*\\?\" \"Okay if like my ? spacebar quite a bit\") Match if there is a single space or space type character after the ? (re-matches #\".*\\?\\s\" \"Okay if like my spacebar quite a bit? \") ;; => \"Okay if like my spacebar quite a bit? \" Match if there are multiple space type characters after the ? (re-matches #\".*\\?\\s*\" \"Okay if like my spacebar quite a bit? \") ;; => \"Okay if like my spacebar quite a bit? \" Don't match if a question mark character is not at the end of the string (re-matches #\".*\\?\" \"Okay if like my ? spacebar quite a bit\")","title":"Asking Bob a question?"},{"location":"coding-challenges/exercism/bob-regular-expression-approach/#shouting-a-question-at-bob","text":"[^a-z] matches if there are no lower case alphabetic characters. The ^ at the start of the pattern negated the pattern. * any number of the proceeding pattern [A-Z]+ any number of upper case alphabetic characters When a phrase has all uppercase characters then we have a match (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"HELLO\") If there are lower case characters, even if there are uppercase characters, the pattern does not match. (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"Hello\") If the characters are all uppercase then the pattern matches, even if there are other non-alphabetic characters (re-matches #\"[^a-z]*[A-Z]+[^a-z]*\" \"ABC 1 2 3\")","title":"Shouting a question at Bob"},{"location":"coding-challenges/exercism/bob-regular-expression-approach/#silence-of-the-bob","text":"\\s matches any single whitespace character, including space, tab, form feed, line feed, and other Unicode spaces. (re-matches #\"\\s*\" \" \\t\\t\\t\")","title":"Silence of the Bob"},{"location":"coding-challenges/exercism/bob-regular-expression-approach/#solution-using-regular-expressions","text":"The re-matches expressions with regular expressions patterns can be put into a let expression. The names are bound to the re-matches expressions which evaluated to either true or false The names from the let are used with a cond function as conditions, returning the relevant reply from Bob. For the shouting question, the and is used to check if two names are both true. ( defn response-for [ phrase ] ( let [ ;; A ? at the end of the phrase, not counting whitespace question ( re-matches # \".*\\?\\s*\" phrase ) ;; No lower case characters, at least one upper case character yelling ( re-matches # \"[^a-z]*[A-Z]+[^a-z]*\" phrase ) ;; The entire string is whitespace silence ( re-matches # \"\\s*\" phrase )] ( cond silence \"Fine. Be that way!\" ( and question yelling ) \"Calm down, I know what I'm doing!\" question \"Sure.\" yelling \"Whoa, chill out!\" :whatever \"Whatever.\" )))","title":"Solution using regular expressions"},{"location":"coding-challenges/exercism/bob-string-approach/","text":"Solution to Bob challenge using clojure.string functions and Character class from Java. Asking Bob a question? \u03bb\ufe0e The phrase passed to Bob is a question if the last alphanumeric character is a question mark. Using a simple comparison we can check if the last character in the string a ? (= \\? (last \"this is a question?\")) However if there is whitespace after the question mark then the last character is a whitespace and so the expression returns false (= \\? (last \"this is still a question? \")) clojure.string/trimr will remove all the trailing whitespace from the right side of a string. Once trimmed, then our initial comparison code will work again. (= \\? (last (clojure.string/trimr \"this is still a question? \"))) Shouting at Bob \u03bb\ufe0e Unfortunately the clojure.string API does not have a function to check if a string is in capital letters. There is an upper-case function, so a comparison can be made with the original string and the string returned from clojure.string/upper-case . Convert the string to uppercase (clojure.string/upper-case \"watch out!\") compare the uppercase version of the string with the original, if they are equal, then the original string must have been in upper case (= \"WATCH OUT!\" (clojure.string/upper-case \"WATCH OUT!\")) (= \"watch out!\" (clojure.string/upper-case \"watch out!\")) There is a flaw in this approach thought, as it will give false positives for strings that should return the 'Whatever' response (= \"1, 2, 3\" (clojure.string/upper-case \"1, 2, 3\")) Refined rule to check that the phrase contains alphabetic characters, otherwise it is not shouting. The java.lang.Character class has a method called isLetter that determines if a character is a letter. The Classes and methods in java.lang are always available within a Clojure project, without the need for specifically importing the library. Character/isLetter can be called as a function in Clojure, passing in a character type. (Character/isLetter \\a) To support all Unicode characters there is an isLetter method that takes an integer type. As there could be any kind of characters in the phrase, we will use the int version. This required conversing the character to an int first before calling Character/isLetter (Character/isLetter (int \\a)) the some function is used to iterate over all the characters in the phrase. As soon as a letter is found it returns true, so does not need to process the whole phrase unless no letter is found. (some #(Character/isLetter (int %)) phrase) Silence of the Bob \u03bb\ufe0e clojure.string/blank? is a predicate function that returns true if a string is empty or contains only whitespace. It also returns true for a nil value. Final solution \u03bb\ufe0e Each of the rules is bound to a name that represents either a true or false value returned from each expression. The cond expression then evaluates the local names to see if they are true or false. The first true value found returns the string associated with the name. For the shouting question, the and is used to check if two names are both true. ( defn response-for [ phrase ] ( let [ phrase ( string/trimr phrase ) silence? ( string/blank? phrase ) question? ( = \\? ( last phrase )) letters? ( some # ( Character/isLetter ( int % )) phrase ) shouting? ( and ( = phrase ( string/upper-case phrase )) letters? )] ( cond ( and shouting? question? ) \"Calm down, I know what I'm doing!\" silence? \"Fine. Be that way!\" shouting? \"Whoa, chill out!\" question? \"Sure.\" :else \"Whatever.\" ))) The first let binding, phrase over-rides the name of the argument to the function. This is not that common an approach as over-riding can lead to confusion. However, in this relatively simple example it feels okay to do. The over-ride is the first let binding and it is preparing the string for all the other let bindings to use. Over-riding names of functions from the Clojure standard library is not recommended as this does lead to much confusion.","title":"Bob string approach"},{"location":"coding-challenges/exercism/bob-string-approach/#asking-bob-a-question","text":"The phrase passed to Bob is a question if the last alphanumeric character is a question mark. Using a simple comparison we can check if the last character in the string a ? (= \\? (last \"this is a question?\")) However if there is whitespace after the question mark then the last character is a whitespace and so the expression returns false (= \\? (last \"this is still a question? \")) clojure.string/trimr will remove all the trailing whitespace from the right side of a string. Once trimmed, then our initial comparison code will work again. (= \\? (last (clojure.string/trimr \"this is still a question? \")))","title":"Asking Bob a question?"},{"location":"coding-challenges/exercism/bob-string-approach/#shouting-at-bob","text":"Unfortunately the clojure.string API does not have a function to check if a string is in capital letters. There is an upper-case function, so a comparison can be made with the original string and the string returned from clojure.string/upper-case . Convert the string to uppercase (clojure.string/upper-case \"watch out!\") compare the uppercase version of the string with the original, if they are equal, then the original string must have been in upper case (= \"WATCH OUT!\" (clojure.string/upper-case \"WATCH OUT!\")) (= \"watch out!\" (clojure.string/upper-case \"watch out!\")) There is a flaw in this approach thought, as it will give false positives for strings that should return the 'Whatever' response (= \"1, 2, 3\" (clojure.string/upper-case \"1, 2, 3\")) Refined rule to check that the phrase contains alphabetic characters, otherwise it is not shouting. The java.lang.Character class has a method called isLetter that determines if a character is a letter. The Classes and methods in java.lang are always available within a Clojure project, without the need for specifically importing the library. Character/isLetter can be called as a function in Clojure, passing in a character type. (Character/isLetter \\a) To support all Unicode characters there is an isLetter method that takes an integer type. As there could be any kind of characters in the phrase, we will use the int version. This required conversing the character to an int first before calling Character/isLetter (Character/isLetter (int \\a)) the some function is used to iterate over all the characters in the phrase. As soon as a letter is found it returns true, so does not need to process the whole phrase unless no letter is found. (some #(Character/isLetter (int %)) phrase)","title":"Shouting at Bob"},{"location":"coding-challenges/exercism/bob-string-approach/#silence-of-the-bob","text":"clojure.string/blank? is a predicate function that returns true if a string is empty or contains only whitespace. It also returns true for a nil value.","title":"Silence of the Bob"},{"location":"coding-challenges/exercism/bob-string-approach/#final-solution","text":"Each of the rules is bound to a name that represents either a true or false value returned from each expression. The cond expression then evaluates the local names to see if they are true or false. The first true value found returns the string associated with the name. For the shouting question, the and is used to check if two names are both true. ( defn response-for [ phrase ] ( let [ phrase ( string/trimr phrase ) silence? ( string/blank? phrase ) question? ( = \\? ( last phrase )) letters? ( some # ( Character/isLetter ( int % )) phrase ) shouting? ( and ( = phrase ( string/upper-case phrase )) letters? )] ( cond ( and shouting? question? ) \"Calm down, I know what I'm doing!\" silence? \"Fine. Be that way!\" shouting? \"Whoa, chill out!\" question? \"Sure.\" :else \"Whatever.\" ))) The first let binding, phrase over-rides the name of the argument to the function. This is not that common an approach as over-riding can lead to confusion. However, in this relatively simple example it feels okay to do. The over-ride is the first let binding and it is preparing the string for all the other let bindings to use. Over-riding names of functions from the Clojure standard library is not recommended as this does lead to much confusion.","title":"Final solution"},{"location":"coding-challenges/exercism/bob/","text":"The Bob challenge involves writing a very basics example of a text parser, something that would be used for a text based adventure game . Bob is described as a lackadaisical teenager, so responses are very limited. To create the Bob text parser we need to identify the rules that determine Bob's response. The instructions provide some basic rules: Bob answers 'Sure.' if you ask him a question. He answers 'Whoa, chill out!' if you yell at him. He answers 'Calm down, I know what I'm doing!' if you yell a question at him. He says 'Fine. Be that way!' if you address him without actually saying anything. He answers 'Whatever.' to anything else. It is important to also read through the supplied unit tests to elaborate on these rules. Create the project \u03bb\ufe0e Download the Bob transcription exercise using the exercism CLI tool exercism download --exercise = bob --track = clojure To use the Clojure CLI tool instead of Leiningen, create a deps.edn file containing an empty hash-map, {} and clone practicalli/clojure-deps-edn to ~/.clojure/ . Rules derived from the Unit tests \u03bb\ufe0e Reviewing all the examples from the unit tests, there are 5 rules for the Bob parser These rules were discovered by searching through the unit test code for each reply that Bob should return, showing the tests for each reply. Each rule also had to ensure it did not create any false positives by being true for any other reply that Bob could make, especially the whatever reply. Name Rule description question The phrase has a ? as the last alphanumeric character, not including whitespace shouting The phrase has uppercase alphabetic characters, but no lower case alphabetic characters shouting question A combination of question and shouting silence The phrase is empty or contains characters that are not alphanumeric whatever Any phrase that does not match any of the other rules Design approach \u03bb\ufe0e There are two main approaches to solving this challenge. The first is to use the clojure.string functions to check or transform the phrase given to Bob. The second approach is to use regular expressions with functions such as re-seq , re-find and re-matches . Start by defining the rules as an expression that returns either true or false, using some of the example strings from the unit tests. Use a let expression to bind a name to each rule, e.g. shouting? , question? , silence? . Then these names can be used in a simple cond expression to return the appropriate phrase. Regardless of if using clojure.string or regular expressions, the cond code should be similar Once you have tried this challenge for yourself, take a look at the design journal for the clojure.string approach and the regular expression approach .","title":"Bob"},{"location":"coding-challenges/exercism/bob/#create-the-project","text":"Download the Bob transcription exercise using the exercism CLI tool exercism download --exercise = bob --track = clojure To use the Clojure CLI tool instead of Leiningen, create a deps.edn file containing an empty hash-map, {} and clone practicalli/clojure-deps-edn to ~/.clojure/ .","title":"Create the project"},{"location":"coding-challenges/exercism/bob/#rules-derived-from-the-unit-tests","text":"Reviewing all the examples from the unit tests, there are 5 rules for the Bob parser These rules were discovered by searching through the unit test code for each reply that Bob should return, showing the tests for each reply. Each rule also had to ensure it did not create any false positives by being true for any other reply that Bob could make, especially the whatever reply. Name Rule description question The phrase has a ? as the last alphanumeric character, not including whitespace shouting The phrase has uppercase alphabetic characters, but no lower case alphabetic characters shouting question A combination of question and shouting silence The phrase is empty or contains characters that are not alphanumeric whatever Any phrase that does not match any of the other rules","title":"Rules derived from the Unit tests"},{"location":"coding-challenges/exercism/bob/#design-approach","text":"There are two main approaches to solving this challenge. The first is to use the clojure.string functions to check or transform the phrase given to Bob. The second approach is to use regular expressions with functions such as re-seq , re-find and re-matches . Start by defining the rules as an expression that returns either true or false, using some of the example strings from the unit tests. Use a let expression to bind a name to each rule, e.g. shouting? , question? , silence? . Then these names can be used in a simple cond expression to return the appropriate phrase. Regardless of if using clojure.string or regular expressions, the cond code should be similar Once you have tried this challenge for yourself, take a look at the design journal for the clojure.string approach and the regular expression approach .","title":"Design approach"},{"location":"coding-challenges/exercism/rna-transcription/","text":"Exercise: RNA Transcription \u03bb\ufe0e Given a DNA strand, return its RNA complement (per RNA transcription). Both DNA and RNA strands are a sequence of nucleotides. The four nucleotides found in DNA are adenine (A), cytosine (C), guanine (G) and thymine (T). The four nucleotides found in RNA are adenine (A), cytosine (C), guanine (G) and uracil (U). Given a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement: G -> C C -> G T -> A A -> U Hint::Code for this solution on GitHub \u03bb\ufe0e practicalli/exercism-clojure-guides contains the design journal and solution to this exercise Create the project \u03bb\ufe0e Download the RNA transcription exercise using the exercism CLI tool exercism download --exercise = rna-transcription --track = clojure To use the Clojure CLI tool instead of Leiningen, create a deps.edn file containing an empty hash-map, {} and clone practicalli/clojure-deps-edn to ~/.clojure/ . Designing the solution \u03bb\ufe0e To convert a collection of values, define a hash-map where the keys are the initial DNA values and the hash-map values are the transformed RNA values. Using a hash-map in this way is often termed as a dictionary. A string is used as a collection of character values by many of the functions in clojure.core . The dictionary uses characters for its keys and values. { \\G \\C \\C \\G \\T \\A \\A \\U } Use the map function to pass the dictionary over the dna string (collection of characters) to create the RNA transcription. Use an anonymous function to wrap the dictionary and pass each a character (nucleotide) from the DNA string in turn. ( defn to-rna [ dna ] ( map ( fn [ nucleotide ] ( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide )) dna )) ( to-rna \"GCTA\" ) The result is returned as a sequence of characters. Refactor the to-rna function and add clojure.string/join to return the RNA value as a string ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ] ( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide )) dna ))) Now the function returns a string rather than a collection of characters. ( to-rna \"GCTA\" ) Throwing an assertion error for incorrect nucleotide \u03bb\ufe0e In the Exercism test suite, one test checks for an AssertionError when an incorrect nucleotide is passed as part of the DNA string. ( deftest it-validates-dna-strands ( is ( thrown? AssertionError ( rna-transcription/to-rna \"XCGFGGTDTTAA\" )))) The throw function can be use to return any of the Java errors. An assertion error would be thrown using the following code ( throw ( AssertionError. \"Unknown nucleotide\" )) Refactor the to-rna function to throw an assertion error if a nucleotide if found that is not part of the dictionary. An if function could be used with a conditional to check if each nucleotide is one of the keys in the dictionary and throw an AssertionError if not found. This would mean consulting the dictionary twice, once for the conditional check and once for the conversion. Is there a way to consult the dictionary once for each nucleotide? The get function can return a specific not-found value when a key is not found in a map. What if the throw function is used as the not-found value in the get function? ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ]( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide ( throw ( AssertionError. \"Unknown nucleotide\" )) )) dna ))) Unfortunately this approach will evaluate the throw expression regardless of if the nucleotide is found in the dictionary, so calling this version of the function always fails. The or function evaluate the first expression and if a true value is returned then any additional expressions are skipped over. If the first expression returns false or a falsey value, i.e. nil , then the next expression is evaluated. ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ]( or ( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide ) ( throw ( AssertionError. \"Unknown nucleotide\" )))) dna ))) ( to-rna \"GCTA\" ) Call the to-rna function with a DNA string that contains an invalid nucleotide. ( to-rna \"GCXA\" ) An AssertionError is thrown as the X character does not exist in the dictionary hash-map, so the get expression returns nil . Refactor and streamline \u03bb\ufe0e Now the function is working, some minor adjustments could be made to streamline the code. A hash-map can be called as a function and takes a key as an argument. This acts the same as the get function, returning the value associated to a matching key, otherwise returning nil or the not-found value if specified. ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ]( or ({ \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide ) ( throw ( AssertionError. \"Unknown nucleotide\" )))) dna ))) The anonymous function has a terser form. #(* %1 %2) is the same as (fn [value1 value2] (+ value1 value2)) This syntax sugar is often use with map , reduce , apply functions as the function definition tends to be compact and of single use. If the function definition is more complex or used elsewhere in the namespace, then the defn function should be used to define shared behavior. ( defn to-rna [ dna ] ( clojure.string/join ( map # ( or ({ \\G \\C \\C \\G \\T \\A \\A \\U } % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna ))) Replace the hard-coded hash-map by defining a name for the dictionary. ( def dictionary-dna-rna { \\G \\C \\C \\G \\T \\A \\A \\U }) Refactor the to-rna function to use the dictionary by name. ( defn to-rna [ dna ] ( clojure.string/join ( map # ( or ( dictionary-dna-rna % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna ))) Making the function pure \u03bb\ufe0e Its beyond the scope of the Exercism challenge, however, its recommended to use pure functions where possible. A pure function only uses data from its arguments. Adding a dictionary as an argument to the to-rna function would be simple. ( defn to-rna [ dictionary dna ] ( clojure.string/join ( map # ( or ( dictionary % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna ))) With a dictionary as an argument the function is also more usable, as other dictionaries could be used with the function. The function would now be called as follows ( to-rna dictionary-dna-rna \"GTGAC\" )","title":"Rna transcription"},{"location":"coding-challenges/exercism/rna-transcription/#exercise-rna-transcription","text":"Given a DNA strand, return its RNA complement (per RNA transcription). Both DNA and RNA strands are a sequence of nucleotides. The four nucleotides found in DNA are adenine (A), cytosine (C), guanine (G) and thymine (T). The four nucleotides found in RNA are adenine (A), cytosine (C), guanine (G) and uracil (U). Given a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement: G -> C C -> G T -> A A -> U","title":"Exercise: RNA Transcription"},{"location":"coding-challenges/exercism/rna-transcription/#hintcode-for-this-solution-on-github","text":"practicalli/exercism-clojure-guides contains the design journal and solution to this exercise","title":"Hint::Code for this solution on GitHub"},{"location":"coding-challenges/exercism/rna-transcription/#create-the-project","text":"Download the RNA transcription exercise using the exercism CLI tool exercism download --exercise = rna-transcription --track = clojure To use the Clojure CLI tool instead of Leiningen, create a deps.edn file containing an empty hash-map, {} and clone practicalli/clojure-deps-edn to ~/.clojure/ .","title":"Create the project"},{"location":"coding-challenges/exercism/rna-transcription/#designing-the-solution","text":"To convert a collection of values, define a hash-map where the keys are the initial DNA values and the hash-map values are the transformed RNA values. Using a hash-map in this way is often termed as a dictionary. A string is used as a collection of character values by many of the functions in clojure.core . The dictionary uses characters for its keys and values. { \\G \\C \\C \\G \\T \\A \\A \\U } Use the map function to pass the dictionary over the dna string (collection of characters) to create the RNA transcription. Use an anonymous function to wrap the dictionary and pass each a character (nucleotide) from the DNA string in turn. ( defn to-rna [ dna ] ( map ( fn [ nucleotide ] ( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide )) dna )) ( to-rna \"GCTA\" ) The result is returned as a sequence of characters. Refactor the to-rna function and add clojure.string/join to return the RNA value as a string ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ] ( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide )) dna ))) Now the function returns a string rather than a collection of characters. ( to-rna \"GCTA\" )","title":"Designing the solution"},{"location":"coding-challenges/exercism/rna-transcription/#throwing-an-assertion-error-for-incorrect-nucleotide","text":"In the Exercism test suite, one test checks for an AssertionError when an incorrect nucleotide is passed as part of the DNA string. ( deftest it-validates-dna-strands ( is ( thrown? AssertionError ( rna-transcription/to-rna \"XCGFGGTDTTAA\" )))) The throw function can be use to return any of the Java errors. An assertion error would be thrown using the following code ( throw ( AssertionError. \"Unknown nucleotide\" )) Refactor the to-rna function to throw an assertion error if a nucleotide if found that is not part of the dictionary. An if function could be used with a conditional to check if each nucleotide is one of the keys in the dictionary and throw an AssertionError if not found. This would mean consulting the dictionary twice, once for the conditional check and once for the conversion. Is there a way to consult the dictionary once for each nucleotide? The get function can return a specific not-found value when a key is not found in a map. What if the throw function is used as the not-found value in the get function? ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ]( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide ( throw ( AssertionError. \"Unknown nucleotide\" )) )) dna ))) Unfortunately this approach will evaluate the throw expression regardless of if the nucleotide is found in the dictionary, so calling this version of the function always fails. The or function evaluate the first expression and if a true value is returned then any additional expressions are skipped over. If the first expression returns false or a falsey value, i.e. nil , then the next expression is evaluated. ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ]( or ( get { \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide ) ( throw ( AssertionError. \"Unknown nucleotide\" )))) dna ))) ( to-rna \"GCTA\" ) Call the to-rna function with a DNA string that contains an invalid nucleotide. ( to-rna \"GCXA\" ) An AssertionError is thrown as the X character does not exist in the dictionary hash-map, so the get expression returns nil .","title":"Throwing an assertion error for incorrect nucleotide"},{"location":"coding-challenges/exercism/rna-transcription/#refactor-and-streamline","text":"Now the function is working, some minor adjustments could be made to streamline the code. A hash-map can be called as a function and takes a key as an argument. This acts the same as the get function, returning the value associated to a matching key, otherwise returning nil or the not-found value if specified. ( defn to-rna [ dna ] ( clojure.string/join ( map ( fn [ nucleotide ]( or ({ \\G \\C \\C \\G \\T \\A \\A \\U } nucleotide ) ( throw ( AssertionError. \"Unknown nucleotide\" )))) dna ))) The anonymous function has a terser form. #(* %1 %2) is the same as (fn [value1 value2] (+ value1 value2)) This syntax sugar is often use with map , reduce , apply functions as the function definition tends to be compact and of single use. If the function definition is more complex or used elsewhere in the namespace, then the defn function should be used to define shared behavior. ( defn to-rna [ dna ] ( clojure.string/join ( map # ( or ({ \\G \\C \\C \\G \\T \\A \\A \\U } % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna ))) Replace the hard-coded hash-map by defining a name for the dictionary. ( def dictionary-dna-rna { \\G \\C \\C \\G \\T \\A \\A \\U }) Refactor the to-rna function to use the dictionary by name. ( defn to-rna [ dna ] ( clojure.string/join ( map # ( or ( dictionary-dna-rna % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna )))","title":"Refactor and streamline"},{"location":"coding-challenges/exercism/rna-transcription/#making-the-function-pure","text":"Its beyond the scope of the Exercism challenge, however, its recommended to use pure functions where possible. A pure function only uses data from its arguments. Adding a dictionary as an argument to the to-rna function would be simple. ( defn to-rna [ dictionary dna ] ( clojure.string/join ( map # ( or ( dictionary % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna ))) With a dictionary as an argument the function is also more usable, as other dictionaries could be used with the function. The function would now be called as follows ( to-rna dictionary-dna-rna \"GTGAC\" )","title":"Making the function pure"},{"location":"coding-challenges/exercism/space-age/","text":"Topics covered \u03bb\ufe0e Challenge introduction \u03bb\ufe0e Given an age in seconds, calculate how old someone would be on: Earth: orbital period 365.25 Earth days, or 31557600 seconds Mercury: orbital period 0.2408467 Earth years Venus: orbital period 0.61519726 Earth years Mars: orbital period 1.8808158 Earth years Jupiter: orbital period 11.862615 Earth years Saturn: orbital period 29.447498 Earth years Uranus: orbital period 84.016846 Earth years Neptune: orbital period 164.79132 Earth years So if you were told someone were 1,000,000,000 seconds old, you should be able to say that they're 31.69 Earth-years old.","title":"Space age"},{"location":"coding-challenges/exercism/space-age/#topics-covered","text":"","title":"Topics covered"},{"location":"coding-challenges/exercism/space-age/#challenge-introduction","text":"Given an age in seconds, calculate how old someone would be on: Earth: orbital period 365.25 Earth days, or 31557600 seconds Mercury: orbital period 0.2408467 Earth years Venus: orbital period 0.61519726 Earth years Mars: orbital period 1.8808158 Earth years Jupiter: orbital period 11.862615 Earth years Saturn: orbital period 29.447498 Earth years Uranus: orbital period 84.016846 Earth years Neptune: orbital period 164.79132 Earth years So if you were told someone were 1,000,000,000 seconds old, you should be able to say that they're 31.69 Earth-years old.","title":"Challenge introduction"},{"location":"continuous-integration/","text":"Topics to be covered in this section include: * Continuous Integration servers * Circle CI (recommended) * GitHub Actions Configure deployment pipelines Manage environment variables Deployment and services on Heroku Hint::CircleCI example in Practicalli Clojure Web Services \u03bb\ufe0e Banking on Clojure is an example of Continuous Integration using CircleCI, with LambdaIsland/Kaocha as the test runner and Heroku as the deployment pipeline. 12 Factor approach \u03bb\ufe0e Following the 12 factor principles , the deployment is driven by source code to multiple environments. CircleCI service \u03bb\ufe0e Use Yaml language to write CI workflows and tasks, using Docker images as a consistent run-time environment A commercial service with a generous free Cloud plan - (6,000 minutes), providing highly optomises container images to run tasks efficiently. The CircleCI Clojure images contain Clojure CLI, Leiningen and Babashka pre-installed. CircleCI Orbs package up common configuration and tools, greatly simplifying the configuration and maintenance required. CircleCI Clojure language guide GitHub Actions \u03bb\ufe0e Use Yaml language to write CI workflows and tasks. A commercial service with a modest free plan (2,000 minutes) for open source projects. GitHub Marketplace contains a wide range of Actions, including Clojure related actions , simplifying the configuration of CI. Setup Clojure provides Clojure CLI, Leinigen and boot tools for use within the CI workflow GitHub Actions overview Heroku pipelines \u03bb\ufe0e Using Heroku Pipelines the staging environment is promoted to production rather than being rebuilt The Heroku dashboard can be used to promote the application into production, once the staging application is signed off. Heroku Build process \u03bb\ufe0e The build process starts when commits are pushed to Heroku, either directly or via a continuous integration service (eg. CircleCI).","title":"Index"},{"location":"continuous-integration/#hintcircleci-example-in-practicalli-clojure-web-services","text":"Banking on Clojure is an example of Continuous Integration using CircleCI, with LambdaIsland/Kaocha as the test runner and Heroku as the deployment pipeline.","title":"Hint::CircleCI example in Practicalli Clojure Web Services"},{"location":"continuous-integration/#12-factor-approach","text":"Following the 12 factor principles , the deployment is driven by source code to multiple environments.","title":"12 Factor approach"},{"location":"continuous-integration/#circleci-service","text":"Use Yaml language to write CI workflows and tasks, using Docker images as a consistent run-time environment A commercial service with a generous free Cloud plan - (6,000 minutes), providing highly optomises container images to run tasks efficiently. The CircleCI Clojure images contain Clojure CLI, Leiningen and Babashka pre-installed. CircleCI Orbs package up common configuration and tools, greatly simplifying the configuration and maintenance required. CircleCI Clojure language guide","title":"CircleCI service"},{"location":"continuous-integration/#github-actions","text":"Use Yaml language to write CI workflows and tasks. A commercial service with a modest free plan (2,000 minutes) for open source projects. GitHub Marketplace contains a wide range of Actions, including Clojure related actions , simplifying the configuration of CI. Setup Clojure provides Clojure CLI, Leinigen and boot tools for use within the CI workflow GitHub Actions overview","title":"GitHub Actions"},{"location":"continuous-integration/#heroku-pipelines","text":"Using Heroku Pipelines the staging environment is promoted to production rather than being rebuilt The Heroku dashboard can be used to promote the application into production, once the staging application is signed off.","title":"Heroku pipelines"},{"location":"continuous-integration/#heroku-build-process","text":"The build process starts when commits are pushed to Heroku, either directly or via a continuous integration service (eg. CircleCI).","title":"Heroku Build process"},{"location":"continuous-integration/circle-ci/","text":"Circle CI continuous integration service \u03bb\ufe0e Circle CI is a service to build, test and deploy projects. CircleCI uses docker images to run its workflow, either in the cloud or locally. Projects can be build, tests run, artifacts (uberjars) created and applications deployed to services such as Heroku. Integration will be supported by Git version control, a continuous integration service (CircleCI, GitLabs, GitHub Actions) and a deployment platform (Heroku). Getting Started \u03bb\ufe0e Circle CI has a free plan with unlimited projects, so its easy to get started. Sign up using an existing GitHub or Bitbucket account and login to the CircleCI dashboard. In the CircleCI dashboard use Add Project to configure any of your shared Git repositories to run build pipelines using a .circleci/config.yml file in the root of the Clojure. Every time changes are pushed to the shared code repository (GitHub, Bitbucket), CirceCI will run the pipeline for the project and show the results. Clojure images \u03bb\ufe0e Clojure specific container images are available for several versions of Java and Clojure. Pre-configured images are typically faster than installing software on top a more generic image. cimg/clojure:1.10 is the recommended image for Clojure projects. The image contains OpenJDK 17 and the latest version of Clojure CLI, Leiningen and Babashka Add the following under the docker: key in the config.yml - image : cimg/clojure:1.10 The CircleCI Clojure Language guide walks through the sections of the yaml configuration in detail. Hint::Check Clojure version \u03bb\ufe0e clojure -Sdescribe shows configuration information for the Clojure CLI tool as a hash-map, with the :version key associated with the exact install version. lein version shows the current version of Leiningen install on your development environment. java -version shows the current version of the Java installation. References \u03bb\ufe0e CircleCI Clojure Language guide CircleCI Clojure image tags - json - programmatically process names of Clojure docker images Dockerhub: CircleCI Clojure images GitHub: CircleCI-Public/cicleci-dockerfiles repository - review how docker images are constructed","title":"Circle CI continuous integration service"},{"location":"continuous-integration/circle-ci/#circle-ci-continuous-integration-service","text":"Circle CI is a service to build, test and deploy projects. CircleCI uses docker images to run its workflow, either in the cloud or locally. Projects can be build, tests run, artifacts (uberjars) created and applications deployed to services such as Heroku. Integration will be supported by Git version control, a continuous integration service (CircleCI, GitLabs, GitHub Actions) and a deployment platform (Heroku).","title":"Circle CI continuous integration service"},{"location":"continuous-integration/circle-ci/#getting-started","text":"Circle CI has a free plan with unlimited projects, so its easy to get started. Sign up using an existing GitHub or Bitbucket account and login to the CircleCI dashboard. In the CircleCI dashboard use Add Project to configure any of your shared Git repositories to run build pipelines using a .circleci/config.yml file in the root of the Clojure. Every time changes are pushed to the shared code repository (GitHub, Bitbucket), CirceCI will run the pipeline for the project and show the results.","title":"Getting Started"},{"location":"continuous-integration/circle-ci/#clojure-images","text":"Clojure specific container images are available for several versions of Java and Clojure. Pre-configured images are typically faster than installing software on top a more generic image. cimg/clojure:1.10 is the recommended image for Clojure projects. The image contains OpenJDK 17 and the latest version of Clojure CLI, Leiningen and Babashka Add the following under the docker: key in the config.yml - image : cimg/clojure:1.10 The CircleCI Clojure Language guide walks through the sections of the yaml configuration in detail.","title":"Clojure images"},{"location":"continuous-integration/circle-ci/#hintcheck-clojure-version","text":"clojure -Sdescribe shows configuration information for the Clojure CLI tool as a hash-map, with the :version key associated with the exact install version. lein version shows the current version of Leiningen install on your development environment. java -version shows the current version of the Java installation.","title":"Hint::Check Clojure version"},{"location":"continuous-integration/circle-ci/#references","text":"CircleCI Clojure Language guide CircleCI Clojure image tags - json - programmatically process names of Clojure docker images Dockerhub: CircleCI Clojure images GitHub: CircleCI-Public/cicleci-dockerfiles repository - review how docker images are constructed","title":"References"},{"location":"continuous-integration/circle-ci/circle-ci-sample-project/","text":"Circle CI example project \u03bb\ufe0e The Circle CI language guide for Clojure provides an example project that is managed by the Leiningen build automation tool and based on the Luminus micro-framework template . The project runs on the Undertow web server (wrapped by immutant), using ring to manage web requests and responses, with compojure for server-side routing. The application uses mount to manage the application lifecycle. Fork the CircleCI-Public/circleci-demo-clojure-luminus project on your GitHub or GitLab account or organisation. Go to the CircleCI dashboard and login. Select the GitHub / GitLab organisation you want to work with, this will list the repositories in that organisation. Find the project in the list of repositories for that organisation Click on the \"Set Up Project\" button and select the Clojure configuration from the drop-down menu. This template seems to be older than the sample configuration on the Clojure language page . Copy the sample configuration and paste it into the editor. Then press Add Config to automatically add it to your code repository. This will start a build and show the pipelines dashboard, with the project running the tasks defined in the configuration Oh, it failed... Clicking on the FAILED button shows details of that particular pipeline. This opens the build report for the pipeline. The build report shows all the steps that have passed and the details of the step which has failed, in this case lein do test, uberjar Hint::Failing on Java 11 \u03bb\ufe0e The example project only seems to run on Java 8. Running the project locally with either lein run or lein test Edit the .circleci/config.yml file in your fork and change the images used to openjdk-8-lein-2.9.3 . Hint::Cannot edit configuration via dashboard \u03bb\ufe0e Apart from the initial creation of the configuration, its not possible to edit the configuration via the dashboard. Then commit the change to the code in the code repository. Another build will run automatically. The dashboard shows the second build of this pipeline, showing the new commit just pushed Success. Now development can continue knowing the configuration of the pipeline works.","title":"Circle CI example project"},{"location":"continuous-integration/circle-ci/circle-ci-sample-project/#circle-ci-example-project","text":"The Circle CI language guide for Clojure provides an example project that is managed by the Leiningen build automation tool and based on the Luminus micro-framework template . The project runs on the Undertow web server (wrapped by immutant), using ring to manage web requests and responses, with compojure for server-side routing. The application uses mount to manage the application lifecycle. Fork the CircleCI-Public/circleci-demo-clojure-luminus project on your GitHub or GitLab account or organisation. Go to the CircleCI dashboard and login. Select the GitHub / GitLab organisation you want to work with, this will list the repositories in that organisation. Find the project in the list of repositories for that organisation Click on the \"Set Up Project\" button and select the Clojure configuration from the drop-down menu. This template seems to be older than the sample configuration on the Clojure language page . Copy the sample configuration and paste it into the editor. Then press Add Config to automatically add it to your code repository. This will start a build and show the pipelines dashboard, with the project running the tasks defined in the configuration Oh, it failed... Clicking on the FAILED button shows details of that particular pipeline. This opens the build report for the pipeline. The build report shows all the steps that have passed and the details of the step which has failed, in this case lein do test, uberjar","title":"Circle CI example project"},{"location":"continuous-integration/circle-ci/circle-ci-sample-project/#hintfailing-on-java-11","text":"The example project only seems to run on Java 8. Running the project locally with either lein run or lein test Edit the .circleci/config.yml file in your fork and change the images used to openjdk-8-lein-2.9.3 .","title":"Hint::Failing on Java 11"},{"location":"continuous-integration/circle-ci/circle-ci-sample-project/#hintcannot-edit-configuration-via-dashboard","text":"Apart from the initial creation of the configuration, its not possible to edit the configuration via the dashboard. Then commit the change to the code in the code repository. Another build will run automatically. The dashboard shows the second build of this pipeline, showing the new commit just pushed Success. Now development can continue knowing the configuration of the pipeline works.","title":"Hint::Cannot edit configuration via dashboard"},{"location":"continuous-integration/circle-ci/detailed-config/","text":"A detailed configuration \u03bb\ufe0e Orbs \u03bb\ufe0e CircleCI Orbs are pre-packaged configurations for specific tasks, reducing the amount of configuration to maintain. Orbs Description h-matsuo/github-release@0.1.3 GitHub release - package up releases ? Deploy to Heroku Kaocha test runner - unit and generative testing, junit-xml reports and test coverage Executors \u03bb\ufe0e Define an executor for the environment used to run the CircleCI jobs. Executor environment Description machine Linux virtual machine docker # configuration for a clojure/deps.edn application version: 2.1 orbs: github-release: h-matsuo/github-release@0.1.3 executors: tools-deps-executor: docker: - image: circleci/clojure:openjdk-11-tools-deps-1.10.1.697 working_directory: ~/repo environment: JVM_OPTS: -Xmx3200m commands: setup: steps: - checkout - restore_cache: keys: - v1-dependencies-{{ checksum \"deps.edn\" }} - v1-dependencies- - save_cache: paths: - ~/.m2 key: v1-dependencies-{{ checksum \"deps.edn\" }} acceptance-tests: steps: - run: name: check coverage command: clojure -M:test:coverage deploy-version: steps: - run: name: Update pom.xml command: clojure -Spom - run: name: Build command: clojure -M:jar - run: name: Deploy command: clojure -M:deploy store-artifact: steps: - run: name: Create jar command: clojure -M:jar - run: name: Zip up jar file command: zip --junk-paths github-api-lib github-api-lib.jar - run: name: install mvn command: | sudo apt-get update sudo apt-get -y install maven - run: name: extract version from pom command: | mvn help:evaluate -Dexpression=project.version -q -DforceStdout > current_version - persist_to_workspace: root: ~/repo paths: - github-api-lib.zip - current_version create-release: steps: - attach_workspace: at: ~/repo - github-release/create: tag: \"v$(cat ~/repo/current_version)\" title: \"Version v$(cat ~/repo/current_version)\" description: \"Github-related API calls.\" file-path: ~/repo/github-api-lib.zip jobs: test: executor: tools-deps-executor steps: - setup - acceptance-tests deploy: executor: tools-deps-executor steps: - setup - acceptance-tests - deploy-version artifact: executor: tools-deps-executor steps: - setup - store-artifact release: executor: github-release/default steps: - setup - create-release workflows: build-test-release: jobs: - test - deploy: context: clojars requires: - test filters: branches: only: main - artifact: requires: - test filters: branches: only: main - release: context: github requires: - test - deploy - artifact filters: branches: only: main","title":"A detailed configuration"},{"location":"continuous-integration/circle-ci/detailed-config/#a-detailed-configuration","text":"","title":"A detailed configuration"},{"location":"continuous-integration/circle-ci/detailed-config/#orbs","text":"CircleCI Orbs are pre-packaged configurations for specific tasks, reducing the amount of configuration to maintain. Orbs Description h-matsuo/github-release@0.1.3 GitHub release - package up releases ? Deploy to Heroku Kaocha test runner - unit and generative testing, junit-xml reports and test coverage","title":"Orbs"},{"location":"continuous-integration/circle-ci/detailed-config/#executors","text":"Define an executor for the environment used to run the CircleCI jobs. Executor environment Description machine Linux virtual machine docker # configuration for a clojure/deps.edn application version: 2.1 orbs: github-release: h-matsuo/github-release@0.1.3 executors: tools-deps-executor: docker: - image: circleci/clojure:openjdk-11-tools-deps-1.10.1.697 working_directory: ~/repo environment: JVM_OPTS: -Xmx3200m commands: setup: steps: - checkout - restore_cache: keys: - v1-dependencies-{{ checksum \"deps.edn\" }} - v1-dependencies- - save_cache: paths: - ~/.m2 key: v1-dependencies-{{ checksum \"deps.edn\" }} acceptance-tests: steps: - run: name: check coverage command: clojure -M:test:coverage deploy-version: steps: - run: name: Update pom.xml command: clojure -Spom - run: name: Build command: clojure -M:jar - run: name: Deploy command: clojure -M:deploy store-artifact: steps: - run: name: Create jar command: clojure -M:jar - run: name: Zip up jar file command: zip --junk-paths github-api-lib github-api-lib.jar - run: name: install mvn command: | sudo apt-get update sudo apt-get -y install maven - run: name: extract version from pom command: | mvn help:evaluate -Dexpression=project.version -q -DforceStdout > current_version - persist_to_workspace: root: ~/repo paths: - github-api-lib.zip - current_version create-release: steps: - attach_workspace: at: ~/repo - github-release/create: tag: \"v$(cat ~/repo/current_version)\" title: \"Version v$(cat ~/repo/current_version)\" description: \"Github-related API calls.\" file-path: ~/repo/github-api-lib.zip jobs: test: executor: tools-deps-executor steps: - setup - acceptance-tests deploy: executor: tools-deps-executor steps: - setup - acceptance-tests - deploy-version artifact: executor: tools-deps-executor steps: - setup - store-artifact release: executor: github-release/default steps: - setup - create-release workflows: build-test-release: jobs: - test - deploy: context: clojars requires: - test filters: branches: only: main - artifact: requires: - test filters: branches: only: main - release: context: github requires: - test - deploy - artifact filters: branches: only: main","title":"Executors"},{"location":"continuous-integration/circle-ci/random-clojure-function/","text":"Random Clojure Function \u03bb\ufe0e A Clojure command line application that shows a random function from the namespaces available in the Clojure Standard library, or a specific namespace from that library. This guide shows how to develop this project alongside CircleCI as the continuous integration service. Create a new project - using the Random Clojure Function guide Create a repository on GitHub Commit the project early and push changes to GitHub Add a .circleci/config.yml file and push to GitHub, choosing the relevant image Login to CircleCI dashboard and add project, choosing manual configuration Continue developing the random clojure function project, including tests After each push to GitHub, check the build status Add a CircleCI badge to the project readme {% youtube %} https://youtu.be/sXZKrD4cAFk Hint::Use the -T execution flag rather than -M or -A \u03bb\ufe0e :project/new runs the clj-new tool which does not require paths or dependencies from a project (no Clojure project exists yet anyway). The recommended approach is to use the -T execution option, i.e. clojure -T:project/new . Create a new project \u03bb\ufe0e Start following the guide to create the random clojure function project, using a deps.edn for the Clojure project configuration clojure -T:project/new :template app :name practicalli/random-clojure-function Version control the Clojure project using Git (or magit in Spacemacs ) Add a test run alias \u03bb\ufe0e Edit the deps.edn file in the root of the project and add a :test/run alias, to run the kaocha test runner which will stop if a failing test is detected. Stopping on a failed test saves running the full test suite and make the CI workflow more effective. :test/run { :extra-paths [ \"test\" ] :extra-deps { lambdaisland/kaocha { :mvn/version \"1.60.977\" }} :exec-fn kaocha.runner/exec-fn :exec-args { :randomize? false :fail-fast? true }} Create a remote repository \u03bb\ufe0e Add the remote repository URL to the local Git repository. git remote add practicalli git@github.com:practicalli/random-clojure-function.git Add CircleCI configuration \u03bb\ufe0e Adding CircleCI early in the project development cycle ensures testing from the saved source code is successful and testing is consistently repeatable. Create a new file called .circleci/config.yml in the root of the project. Edit the file and add the following configuration. version: 2.1 jobs: # basic units of work in a run build: # runs without Workflows must have a `build` job as entry point working_directory: ~/random-clojure-function # directory where steps will run docker: # run the steps with Docker - image: cimg/clojure:1.10 # image is primary container where `steps` are run environment: # environment variables for primary container JVM_OPTS: -Xmx3200m # limit maximum JVM heap size to prevent out of memory errors steps: # commands that comprise the `build` job - checkout # check out source code to working directory - restore_cache: # restores cache if checksum unchanged from last run key: random-clojure-function-{{ checksum \"deps.edn\" }} - run: clojure -P - save_cache: # generate / update cache in the .m2 directory using a key template paths: - ~/.m2 - ~/.gitlibs key: random-clojure-function-{{ checksum \"deps.edn\" }} - run: clojure -X:test/run The run: clojure -P step downloads dependencies for the project, including the :extra-deps if aliases are also included. The run: clojure -X:test/run adds the test directory to the class path and runs the Kaocha runner defined in the alias. Connect Circle CI to the project \u03bb\ufe0e Commit and push the .circleci/config.yml file to the GitHub repository. Open the CircleCI dashboard and select Add Project . If your GitHub account has multiple organizations, choose the appropriate organization first. Search the repository list for the GitHub repository and select ,,, Select the Manual configuration as a .circleci/config.yml file has already been added to the Git repository. Press Start Building button to confirm that a config.yml file has already been added and the build should start. Now the first build runs with the config.yml file. Its failed. Okay lets investigate... Thats okay, we have failing tests locally, so we know that the CircleCI build is working the same as on our local development environment. The continuous integration is now working and tests are automatically run as soon as you push changes to the remote repository. So the development of the project can continue with greater confidence Adding a Build Status badge \u03bb\ufe0e Generating a status badge documentation describes how to add a build status badge for your project, usually at the top of the README.md file in the project [ ![CircleCI ]( https://circleci.com/gh/circleci/circleci-docs.svg?style=svg )](https://circleci.com/gh/practicalli/random-clojure-function) Add this markdown to the top of the README.md file, underneath the title. Then commit and push the change to the GitHub repository. NOTE: you might want to fix the unit tests first :)","title":"Random Clojure Function"},{"location":"continuous-integration/circle-ci/random-clojure-function/#random-clojure-function","text":"A Clojure command line application that shows a random function from the namespaces available in the Clojure Standard library, or a specific namespace from that library. This guide shows how to develop this project alongside CircleCI as the continuous integration service. Create a new project - using the Random Clojure Function guide Create a repository on GitHub Commit the project early and push changes to GitHub Add a .circleci/config.yml file and push to GitHub, choosing the relevant image Login to CircleCI dashboard and add project, choosing manual configuration Continue developing the random clojure function project, including tests After each push to GitHub, check the build status Add a CircleCI badge to the project readme {% youtube %} https://youtu.be/sXZKrD4cAFk","title":"Random Clojure Function"},{"location":"continuous-integration/circle-ci/random-clojure-function/#hintuse-the-t-execution-flag-rather-than-m-or-a","text":":project/new runs the clj-new tool which does not require paths or dependencies from a project (no Clojure project exists yet anyway). The recommended approach is to use the -T execution option, i.e. clojure -T:project/new .","title":"Hint::Use the -T execution flag rather than -M or -A"},{"location":"continuous-integration/circle-ci/random-clojure-function/#create-a-new-project","text":"Start following the guide to create the random clojure function project, using a deps.edn for the Clojure project configuration clojure -T:project/new :template app :name practicalli/random-clojure-function Version control the Clojure project using Git (or magit in Spacemacs )","title":"Create a new project"},{"location":"continuous-integration/circle-ci/random-clojure-function/#add-a-test-run-alias","text":"Edit the deps.edn file in the root of the project and add a :test/run alias, to run the kaocha test runner which will stop if a failing test is detected. Stopping on a failed test saves running the full test suite and make the CI workflow more effective. :test/run { :extra-paths [ \"test\" ] :extra-deps { lambdaisland/kaocha { :mvn/version \"1.60.977\" }} :exec-fn kaocha.runner/exec-fn :exec-args { :randomize? false :fail-fast? true }}","title":"Add a test run alias"},{"location":"continuous-integration/circle-ci/random-clojure-function/#create-a-remote-repository","text":"Add the remote repository URL to the local Git repository. git remote add practicalli git@github.com:practicalli/random-clojure-function.git","title":"Create a remote repository"},{"location":"continuous-integration/circle-ci/random-clojure-function/#add-circleci-configuration","text":"Adding CircleCI early in the project development cycle ensures testing from the saved source code is successful and testing is consistently repeatable. Create a new file called .circleci/config.yml in the root of the project. Edit the file and add the following configuration. version: 2.1 jobs: # basic units of work in a run build: # runs without Workflows must have a `build` job as entry point working_directory: ~/random-clojure-function # directory where steps will run docker: # run the steps with Docker - image: cimg/clojure:1.10 # image is primary container where `steps` are run environment: # environment variables for primary container JVM_OPTS: -Xmx3200m # limit maximum JVM heap size to prevent out of memory errors steps: # commands that comprise the `build` job - checkout # check out source code to working directory - restore_cache: # restores cache if checksum unchanged from last run key: random-clojure-function-{{ checksum \"deps.edn\" }} - run: clojure -P - save_cache: # generate / update cache in the .m2 directory using a key template paths: - ~/.m2 - ~/.gitlibs key: random-clojure-function-{{ checksum \"deps.edn\" }} - run: clojure -X:test/run The run: clojure -P step downloads dependencies for the project, including the :extra-deps if aliases are also included. The run: clojure -X:test/run adds the test directory to the class path and runs the Kaocha runner defined in the alias.","title":"Add CircleCI configuration"},{"location":"continuous-integration/circle-ci/random-clojure-function/#connect-circle-ci-to-the-project","text":"Commit and push the .circleci/config.yml file to the GitHub repository. Open the CircleCI dashboard and select Add Project . If your GitHub account has multiple organizations, choose the appropriate organization first. Search the repository list for the GitHub repository and select ,,, Select the Manual configuration as a .circleci/config.yml file has already been added to the Git repository. Press Start Building button to confirm that a config.yml file has already been added and the build should start. Now the first build runs with the config.yml file. Its failed. Okay lets investigate... Thats okay, we have failing tests locally, so we know that the CircleCI build is working the same as on our local development environment. The continuous integration is now working and tests are automatically run as soon as you push changes to the remote repository. So the development of the project can continue with greater confidence","title":"Connect Circle CI to the project"},{"location":"continuous-integration/circle-ci/random-clojure-function/#adding-a-build-status-badge","text":"Generating a status badge documentation describes how to add a build status badge for your project, usually at the top of the README.md file in the project [ ![CircleCI ]( https://circleci.com/gh/circleci/circleci-docs.svg?style=svg )](https://circleci.com/gh/practicalli/random-clojure-function) Add this markdown to the top of the README.md file, underneath the title. Then commit and push the change to the GitHub repository. NOTE: you might want to fix the unit tests first :)","title":"Adding a Build Status badge"},{"location":"continuous-integration/circle-ci/status-monitor/","text":"Status Monitor Circle CI Continuous Integration \u03bb\ufe0e practicalli/webapp-status-monitor is a Leiningen project create in October 2018. The project uses ring and compojure as the basis of a web application. Configured with a project.clj file. ( defproject status-monitor \"0.1.0-SNAPSHOT\" :description \"A server side website dashboard to collate monitoring information\" :url \"https://github.com/jr0cket/status-monitor\" :min-lein-version \"2.0.0\" :dependencies [[ org.clojure/clojure \"1.9.0\" ] [ compojure \"1.6.1\" ] [ ring/ring-defaults \"0.3.2\" ] [ hiccup \"1.0.5\" ]] :plugins [[ lein-ring \"0.12.4\" ] [ lein-eftest \"0.5.3\" ]] :ring { :handler status-monitor.handler/app } :profiles { :dev { :dependencies [[ javax.servlet/servlet-api \"2.5\" ] [ ring/ring-mock \"0.3.2\" ]]}}) CircleCI Configuration \u03bb\ufe0e This configuration uses the CircleCI specific docker image with Java 17 and the latest version of Leiningen. The configuration defines that the code will be check out, Leiningen will download the dependencies and then run unit tests. version : 2 jobs : build : docker : - image : cimg/clojure:1.10 working_directory : ~/repo environment : LEIN_ROOT : \"true\" # Customize the JVM maximum heap limit JVM_OPTS : -Xmx3200m steps : - checkout # Download and cache dependencies - restore_cache : keys : - v1-dependencies-{{ checksum \"project.clj\" }} # fallback to using the latest cache if no exact match is found - v1-dependencies- - run : lein deps - save_cache : paths : - ~/.m2 key : v1-dependencies-{{ checksum \"project.clj\" }} # run tests! - run : lein test Caching dependencies \u03bb\ufe0e CircleCI create a cache of downloaded dependencies, to help speed up the running of the project. The config.yml defines the path where the dependencies are saved. A unique key is used to identify the dependencies cache.","title":"Status Monitor Circle CI Continuous Integration"},{"location":"continuous-integration/circle-ci/status-monitor/#status-monitor-circle-ci-continuous-integration","text":"practicalli/webapp-status-monitor is a Leiningen project create in October 2018. The project uses ring and compojure as the basis of a web application. Configured with a project.clj file. ( defproject status-monitor \"0.1.0-SNAPSHOT\" :description \"A server side website dashboard to collate monitoring information\" :url \"https://github.com/jr0cket/status-monitor\" :min-lein-version \"2.0.0\" :dependencies [[ org.clojure/clojure \"1.9.0\" ] [ compojure \"1.6.1\" ] [ ring/ring-defaults \"0.3.2\" ] [ hiccup \"1.0.5\" ]] :plugins [[ lein-ring \"0.12.4\" ] [ lein-eftest \"0.5.3\" ]] :ring { :handler status-monitor.handler/app } :profiles { :dev { :dependencies [[ javax.servlet/servlet-api \"2.5\" ] [ ring/ring-mock \"0.3.2\" ]]}})","title":"Status Monitor Circle CI Continuous Integration"},{"location":"continuous-integration/circle-ci/status-monitor/#circleci-configuration","text":"This configuration uses the CircleCI specific docker image with Java 17 and the latest version of Leiningen. The configuration defines that the code will be check out, Leiningen will download the dependencies and then run unit tests. version : 2 jobs : build : docker : - image : cimg/clojure:1.10 working_directory : ~/repo environment : LEIN_ROOT : \"true\" # Customize the JVM maximum heap limit JVM_OPTS : -Xmx3200m steps : - checkout # Download and cache dependencies - restore_cache : keys : - v1-dependencies-{{ checksum \"project.clj\" }} # fallback to using the latest cache if no exact match is found - v1-dependencies- - run : lein deps - save_cache : paths : - ~/.m2 key : v1-dependencies-{{ checksum \"project.clj\" }} # run tests! - run : lein test","title":"CircleCI Configuration"},{"location":"continuous-integration/circle-ci/status-monitor/#caching-dependencies","text":"CircleCI create a cache of downloaded dependencies, to help speed up the running of the project. The config.yml defines the path where the dependencies are saved. A unique key is used to identify the dependencies cache.","title":"Caching dependencies"},{"location":"continuous-integration/github-actions/","text":"Automate tasks, such as running unit tests or lint code, whenever code is committed to a GitHub repository. GitHub Actions can run one or more tasks after specific events, such as commits, raising issues or pull requests. An event triggers a configured workflow which contains one or more jobs. A job contains a one or more steps which defines actions to run. Introduction to GitHub Actions Understanding the workflow file Term Description Event Triggers a workflow , e.g. Create pull request, push commit, etc. Workflow Top level configuration containing one or more jobs, triggered by a specific event Job Set of steps executed in the same runner, multiple jobs execute in parallel within their own instance of a runner Step Individual task that runs commands (actions), sharing data with other steps Action Standalone commands defined within a step, custom commands or GitHub community Runner A GitHub Actions server, listening for available jobs Example GitHub Action \u03bb\ufe0e .github/workflows/workflow-name.yaml is a file that contains the workflow definition. Setup Java adds an OpenJDK distribution, i.e. Eclipse Temurin, at a specified version (Java 17 recommended). Setup Clojure provides Clojure via Clojure CLI, Leiningen or Boot. Clojure CLI is recommended. Cache is used to cache Clojure and Java libraries (dependencies or 'deps'). The example workflow runs on Ubuntu. The project code is checked out from the Git repository. Java and Clojure are added to the environment Unit tests are run using the :test/run alias (this alias should run Kaocha or similar test runner) The Clojure project is packaged into an Uberjar for deployment name : Test and Package project on : [ push ] jobs : clojure : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 - name : Cache Clojure Dependencies uses : actions/cache@v3 with : path : - ~/.m2 - ~/.gitlibs key : cache-${{ hashFiles('**/deps.edn') }} - name : Prepare java uses : actions/setup-java@v3.5.1 with : distribution : 'temurin' java-version : '17' - name : Install clojure tools uses : DeLaGuardo/setup-clojure@9.5 with : cli : 1.11.1.1165 # Clojure CLI based on tools.deps - name : Run Unit tests run : clojure -X:test/run - name : Package Clojure project run : clojure -X:project/uberjar References \u03bb\ufe0e Practicalli Blog - build publish a Cryogen project with Clojure CLI and publish the generated website with GitHub pages (also a Staging workflow that runs on pull requests ) Practicalli Landing Page - build a ClojureScript & Figwheel project with Clojure CLI and publish the generated site to GitHub pages Practicalli Clojure CLI user level configuration - lint the deps.edn file with clj-kondo","title":"Index"},{"location":"continuous-integration/github-actions/#example-github-action","text":".github/workflows/workflow-name.yaml is a file that contains the workflow definition. Setup Java adds an OpenJDK distribution, i.e. Eclipse Temurin, at a specified version (Java 17 recommended). Setup Clojure provides Clojure via Clojure CLI, Leiningen or Boot. Clojure CLI is recommended. Cache is used to cache Clojure and Java libraries (dependencies or 'deps'). The example workflow runs on Ubuntu. The project code is checked out from the Git repository. Java and Clojure are added to the environment Unit tests are run using the :test/run alias (this alias should run Kaocha or similar test runner) The Clojure project is packaged into an Uberjar for deployment name : Test and Package project on : [ push ] jobs : clojure : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 - name : Cache Clojure Dependencies uses : actions/cache@v3 with : path : - ~/.m2 - ~/.gitlibs key : cache-${{ hashFiles('**/deps.edn') }} - name : Prepare java uses : actions/setup-java@v3.5.1 with : distribution : 'temurin' java-version : '17' - name : Install clojure tools uses : DeLaGuardo/setup-clojure@9.5 with : cli : 1.11.1.1165 # Clojure CLI based on tools.deps - name : Run Unit tests run : clojure -X:test/run - name : Package Clojure project run : clojure -X:project/uberjar","title":"Example GitHub Action"},{"location":"continuous-integration/github-actions/#references","text":"Practicalli Blog - build publish a Cryogen project with Clojure CLI and publish the generated website with GitHub pages (also a Staging workflow that runs on pull requests ) Practicalli Landing Page - build a ClojureScript & Figwheel project with Clojure CLI and publish the generated site to GitHub pages Practicalli Clojure CLI user level configuration - lint the deps.edn file with clj-kondo","title":"References"},{"location":"continuous-integration/github-actions/clj-kondo-lint/","text":"clj-kondo provides static analysis of Clojure, ClojureScript and EDN code, which can be run on the command line to analyze a specific file or directory tree of files. GitHub Action: setup-clj-kondo GitHub Action: checkout Lint a specific file on push or pr \u03bb\ufe0e The practicalli/clojure-deps-edn contains .github/workflows/lint-with-clj-kondo.yaml action which checks the deps.edn file when ever there is a push to the live branch or a pull request is created. The configuration runs clj-kondo lint command using the DeLaGuardo/setup-clj-kondo@v1 GitHub action. The jobs run on the Ubuntu operating system. The first step installs clj-kondo on the runner. Then next step checks out the practicalli/clojure-deps-edn repository. The final step runs the lint command. name: \"Lint with clj-kondo\" on: pull_request: paths: - 'deps.edn' push: paths: - 'deps.edn' branches: - live jobs: lint: runs-on: ubuntu-20.04 steps: - uses: DeLaGuardo/setup-clj-kondo@master with: version: '2021.12.16' - uses: actions/checkout@v3 - name: Run on Ubuntu run: clj-kondo --lint deps.edn --config '{:output {:pattern \"::{{level}} file={{filename}},line={{row}},col={{col}}::{{message}}\"}}' Example run of GitHub Actions \u03bb\ufe0e Pushing a commit will automatically trigger the workflow and lint the deps.edn file. When a pull request is created, the workflow is triggered and the results shown in the pull request page. [Practicalli Clojure CLI user level configuration] - lint the deps.edn file with clj-kondo","title":"Clj kondo lint"},{"location":"continuous-integration/github-actions/clj-kondo-lint/#lint-a-specific-file-on-push-or-pr","text":"The practicalli/clojure-deps-edn contains .github/workflows/lint-with-clj-kondo.yaml action which checks the deps.edn file when ever there is a push to the live branch or a pull request is created. The configuration runs clj-kondo lint command using the DeLaGuardo/setup-clj-kondo@v1 GitHub action. The jobs run on the Ubuntu operating system. The first step installs clj-kondo on the runner. Then next step checks out the practicalli/clojure-deps-edn repository. The final step runs the lint command. name: \"Lint with clj-kondo\" on: pull_request: paths: - 'deps.edn' push: paths: - 'deps.edn' branches: - live jobs: lint: runs-on: ubuntu-20.04 steps: - uses: DeLaGuardo/setup-clj-kondo@master with: version: '2021.12.16' - uses: actions/checkout@v3 - name: Run on Ubuntu run: clj-kondo --lint deps.edn --config '{:output {:pattern \"::{{level}} file={{filename}},line={{row}},col={{col}}::{{message}}\"}}'","title":"Lint a specific file on push or pr"},{"location":"continuous-integration/github-actions/clj-kondo-lint/#example-run-of-github-actions","text":"Pushing a commit will automatically trigger the workflow and lint the deps.edn file. When a pull request is created, the workflow is triggered and the results shown in the pull request page. [Practicalli Clojure CLI user level configuration] - lint the deps.edn file with clj-kondo","title":"Example run of GitHub Actions"},{"location":"control-flow/cond/","text":"cond \u03bb\ufe0e","title":"cond"},{"location":"control-flow/cond/#cond","text":"","title":"cond"},{"location":"control-flow/if/","text":"if \u03bb\ufe0e","title":"if"},{"location":"control-flow/if/#if","text":"","title":"if"},{"location":"control-flow/when/","text":"when \u03bb\ufe0e","title":"when"},{"location":"control-flow/when/#when","text":"","title":"when"},{"location":"core.async/","text":"Introducing core.async \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Pull requests are welcome The core.async library provides a way to do concurrent programming using channels (eg. queues). It minimises the need to use complex concurrent constructs and worry less about thread management. core.async is written in Clojure and can be used with both Clojure and ClojureScript. Hint:: core.async resources \u03bb\ufe0e core.async getting started Introduction to asynchronous programming ClojureScript core.async and todos - Bruce Haurman core.async 101 Mastering concurrent processes LispCast Clojure core.async: Channels - first lesson only. core.async introduction in ClojureScrpt unravelled core.async: Concurrency without Callbacks - Stuart Halloway David Nolan - core.async for asynchronous programming Timothy Baldridge - Core.Async core.async in Use - Timothy Baldridge Timothy Baldridge - core.async - pipelines - free video Timothy Baldridge - core.async - garbage collected go blocks - free video Hint::Communicating Sequential Processes \u03bb\ufe0e Communicating Sequential Processes (CSP) is a formalism for describing concurrent systems pioneered by C. A. R. Hoare in 1978. It is a concurrency model based on message passing and synchronization through channels core.async on ClojureScript \u03bb\ufe0e core.async is very widely used withing ClojureScript applications and many libraries are built on top of it. It\u2019s a good example of the syntactic abstractions that can be achieved by transforming code with ClojureScript macros. JavaScript is single-threaded so you do not get the benefit of safe communication between threads, as there is only one. Concepts \u03bb\ufe0e Channels \u03bb\ufe0e A channel is a queue with one or more publishers and one or more consumers. Producers put data onto the queue, consumers take data from the queue. As data in Clojure is immutable, channels provide a safe way to communicate between threads. Chanel size \u03bb\ufe0e Channels do not include a buffer by default, they use a producer ( put! ) and consumer ( take! ) to transfer a value through the channel. A maximum of 1024 put! functions can be queued onto a single channel. Specify a channel using (chan) or a channel with a fixed buffer using (chan 12) . Processes \u03bb\ufe0e Processes are independently running pieces of code that use channels for communication and coordination. Calling put! and take! inside a process will stop that process until the operation completes. Processes are launched using the go macro and puts and takes use the <! and >! placeholders. The go macro rewrites your code to use callbacks but inside go everything looks like synchronous code, which makes understanding it straightforward: In ClojureScript, stopping a process doesn\u2019t block the single-threaded JavaScript environment, instead, the process will be resumed at a later time when it is no longer blocked. Important functions \u03bb\ufe0e chan \u03bb\ufe0e The chan function creates a new channel. You can give a name to a channel using the def function, eg. (def my-channel (chan)) A single channel can take a maximum of 1024 put requests. Once it has reached the maximum, then it is considered full. A buffer of a fixed size can be specified when defining a new channel: (def channel-with-fixed-buffer (chan 12)) . This buffer increases the number of puts that can be sent to the channel. A dropping or sliding buffer can be used to discard messages added when the buffer is full. A channel can also include a transducer, to manipulate the value on the channel eg. adding a timestamp (chan 32 (map (Date. now))) eg. filtering messages (chan 12 (map even?)) Channels can be explicitly closed using (close channel-name) or by adding a timeout that closes the channel after the specified number of milliseconds (timeout 6000) . put! \u03bb\ufe0e The put! function puts a value (message) on the channel. You can put messages on the channel even if nothing is listening (no waiting take! functions). Evaluating put! will always add a message on to the channel as long as the channel is open and not full. take! \u03bb\ufe0e The take! function will take a single message from the queue. If there are no messages on the queue when you evaluate take! , then the function will wait to execute as soon as something is put on the channel The take! function needs an argument that is the channel and a function that will receive any message taken from a channel. time \u03bb\ufe0e This is a macro that executes an expression and prints the time it takes Criterium is an excellent library for performance testing your code go \u03bb\ufe0e Referred to as a go block , the go function creates a lightweight process, not bound to threads. Thousands of go blocks can be created efficiently and they can all have their own channel. blocking and non-blocking \u03bb\ufe0e core.async offers two ways to write to and read from channels: blocking and non-blocking. A blocking write blocks the thread until the channel has space to be written to (the buffer size of a channel is configurable), a blocking read blocks a thread until a value becomes available on the queue to be read. More interesting, and the only type supported in ClojureScript, are asynchronous channel reads and writes to channels, which are only allowed in \"go blocks\". Go blocks are written in a synchronous style, and internally converted to a state machine that executes them asynchronously. Consider the following core.async-based code: ( let [ ch ( chan )] ( go ( while true ( let [ v ( <! ch )] ( println \"Read: \" v )))) ( go ( >! ch \"hi\" ) ( <! ( timeout 5000 )) ( >! ch \"there\" ))) In this example, let introduces a new local variable ch, which is a new channel. Within the let's scope two go blocks are defined, the first is an eternal loop that reads (<!) a new value from channel ch into variable v. It then prints \"Read: \" followed by the read value to the standard out. The second go block writes (>!) two values to channel ch: \"hi\", it then waits 5 seconds and then writes \"there\" to the channel. Waiting for 5 seconds is implemented by reading from a timeout channel, which is a channel that closes itself (returns nil) after a set timeout. When running this code in the Clojure REPL (for instance), it will return instantly. It will then print \"Read: hi\", and 5 seconds later it will print \"Read: there\". Hint:: \u03bb\ufe0e In JavaScript you cannot do blocking loops like this: the browser will freeze up for 5 seconds. The \"magic\" of core.async is that internally it converts the body of each go block into a state machine and turns the synchronous-looking channel reads and writes into asynchronous calls.","title":"Introducing core.async"},{"location":"core.async/#introducing-coreasync","text":"","title":"Introducing core.async"},{"location":"core.async/#todowork-in-progress-sorry","text":"Pull requests are welcome The core.async library provides a way to do concurrent programming using channels (eg. queues). It minimises the need to use complex concurrent constructs and worry less about thread management. core.async is written in Clojure and can be used with both Clojure and ClojureScript.","title":"TODO::work in progress, sorry"},{"location":"core.async/#hint-coreasync-resources","text":"core.async getting started Introduction to asynchronous programming ClojureScript core.async and todos - Bruce Haurman core.async 101 Mastering concurrent processes LispCast Clojure core.async: Channels - first lesson only. core.async introduction in ClojureScrpt unravelled core.async: Concurrency without Callbacks - Stuart Halloway David Nolan - core.async for asynchronous programming Timothy Baldridge - Core.Async core.async in Use - Timothy Baldridge Timothy Baldridge - core.async - pipelines - free video Timothy Baldridge - core.async - garbage collected go blocks - free video","title":"Hint:: core.async resources"},{"location":"core.async/#hintcommunicating-sequential-processes","text":"Communicating Sequential Processes (CSP) is a formalism for describing concurrent systems pioneered by C. A. R. Hoare in 1978. It is a concurrency model based on message passing and synchronization through channels","title":"Hint::Communicating Sequential Processes"},{"location":"core.async/#coreasync-on-clojurescript","text":"core.async is very widely used withing ClojureScript applications and many libraries are built on top of it. It\u2019s a good example of the syntactic abstractions that can be achieved by transforming code with ClojureScript macros. JavaScript is single-threaded so you do not get the benefit of safe communication between threads, as there is only one.","title":"core.async on ClojureScript"},{"location":"core.async/#concepts","text":"","title":"Concepts"},{"location":"core.async/#channels","text":"A channel is a queue with one or more publishers and one or more consumers. Producers put data onto the queue, consumers take data from the queue. As data in Clojure is immutable, channels provide a safe way to communicate between threads.","title":"Channels"},{"location":"core.async/#chanel-size","text":"Channels do not include a buffer by default, they use a producer ( put! ) and consumer ( take! ) to transfer a value through the channel. A maximum of 1024 put! functions can be queued onto a single channel. Specify a channel using (chan) or a channel with a fixed buffer using (chan 12) .","title":"Chanel size"},{"location":"core.async/#processes","text":"Processes are independently running pieces of code that use channels for communication and coordination. Calling put! and take! inside a process will stop that process until the operation completes. Processes are launched using the go macro and puts and takes use the <! and >! placeholders. The go macro rewrites your code to use callbacks but inside go everything looks like synchronous code, which makes understanding it straightforward: In ClojureScript, stopping a process doesn\u2019t block the single-threaded JavaScript environment, instead, the process will be resumed at a later time when it is no longer blocked.","title":"Processes"},{"location":"core.async/#important-functions","text":"","title":"Important functions"},{"location":"core.async/#chan","text":"The chan function creates a new channel. You can give a name to a channel using the def function, eg. (def my-channel (chan)) A single channel can take a maximum of 1024 put requests. Once it has reached the maximum, then it is considered full. A buffer of a fixed size can be specified when defining a new channel: (def channel-with-fixed-buffer (chan 12)) . This buffer increases the number of puts that can be sent to the channel. A dropping or sliding buffer can be used to discard messages added when the buffer is full. A channel can also include a transducer, to manipulate the value on the channel eg. adding a timestamp (chan 32 (map (Date. now))) eg. filtering messages (chan 12 (map even?)) Channels can be explicitly closed using (close channel-name) or by adding a timeout that closes the channel after the specified number of milliseconds (timeout 6000) .","title":"chan"},{"location":"core.async/#put","text":"The put! function puts a value (message) on the channel. You can put messages on the channel even if nothing is listening (no waiting take! functions). Evaluating put! will always add a message on to the channel as long as the channel is open and not full.","title":"put!"},{"location":"core.async/#take","text":"The take! function will take a single message from the queue. If there are no messages on the queue when you evaluate take! , then the function will wait to execute as soon as something is put on the channel The take! function needs an argument that is the channel and a function that will receive any message taken from a channel.","title":"take!"},{"location":"core.async/#time","text":"This is a macro that executes an expression and prints the time it takes Criterium is an excellent library for performance testing your code","title":"time"},{"location":"core.async/#go","text":"Referred to as a go block , the go function creates a lightweight process, not bound to threads. Thousands of go blocks can be created efficiently and they can all have their own channel.","title":"go"},{"location":"core.async/#blocking-and-non-blocking","text":"core.async offers two ways to write to and read from channels: blocking and non-blocking. A blocking write blocks the thread until the channel has space to be written to (the buffer size of a channel is configurable), a blocking read blocks a thread until a value becomes available on the queue to be read. More interesting, and the only type supported in ClojureScript, are asynchronous channel reads and writes to channels, which are only allowed in \"go blocks\". Go blocks are written in a synchronous style, and internally converted to a state machine that executes them asynchronously. Consider the following core.async-based code: ( let [ ch ( chan )] ( go ( while true ( let [ v ( <! ch )] ( println \"Read: \" v )))) ( go ( >! ch \"hi\" ) ( <! ( timeout 5000 )) ( >! ch \"there\" ))) In this example, let introduces a new local variable ch, which is a new channel. Within the let's scope two go blocks are defined, the first is an eternal loop that reads (<!) a new value from channel ch into variable v. It then prints \"Read: \" followed by the read value to the standard out. The second go block writes (>!) two values to channel ch: \"hi\", it then waits 5 seconds and then writes \"there\" to the channel. Waiting for 5 seconds is implemented by reading from a timeout channel, which is a channel that closes itself (returns nil) after a set timeout. When running this code in the Clojure REPL (for instance), it will return instantly. It will then print \"Read: hi\", and 5 seconds later it will print \"Read: there\".","title":"blocking and non-blocking"},{"location":"core.async/#hint","text":"In JavaScript you cannot do blocking loops like this: the browser will freeze up for 5 seconds. The \"magic\" of core.async is that internally it converts the body of each go block into a state machine and turns the synchronous-looking channel reads and writes into asynchronous calls.","title":"Hint::"},{"location":"core.async/bike-assembly-line/","text":"core.async scenario: Bike assembly line \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Pull requests are welcome In this example we are going to use a bicycle assembly line as the process we want to make concurrent. The tasks involved in making our bicycle are: Making the frame Painting the wheels Making the rims Making the wheels (adding hub and spokes to wheels - different hub for front and rear wheels) Making the handlebars Fitting tyres to the rims (solid rims, so no tubes) Attaching the handlebars to the frame Attaching wheels to the frame Attaching crank to frame Attaching peddles to the crank Connecting control system wires (gears, breaks) Current build process \u03bb\ufe0e At the moment, each person creates one bicycle all by themselves. This means they need all sorts of different tools and are switching tasks all the way through assembling the bike. We want to move to a more parallel approach, so as we automate this process we will evaluate what actions can be done in parallel and which must be done sequentially (i.e. painting the frame must come after making the frame).","title":"core.async scenario: Bike assembly line"},{"location":"core.async/bike-assembly-line/#coreasync-scenario-bike-assembly-line","text":"","title":"core.async scenario: Bike assembly line"},{"location":"core.async/bike-assembly-line/#todowork-in-progress-sorry","text":"Pull requests are welcome In this example we are going to use a bicycle assembly line as the process we want to make concurrent. The tasks involved in making our bicycle are: Making the frame Painting the wheels Making the rims Making the wheels (adding hub and spokes to wheels - different hub for front and rear wheels) Making the handlebars Fitting tyres to the rims (solid rims, so no tubes) Attaching the handlebars to the frame Attaching wheels to the frame Attaching crank to frame Attaching peddles to the crank Connecting control system wires (gears, breaks)","title":"TODO::work in progress, sorry"},{"location":"core.async/bike-assembly-line/#current-build-process","text":"At the moment, each person creates one bicycle all by themselves. This means they need all sorts of different tools and are switching tasks all the way through assembling the bike. We want to move to a more parallel approach, so as we automate this process we will evaluate what actions can be done in parallel and which must be done sequentially (i.e. painting the frame must come after making the frame).","title":"Current build process"},{"location":"core.async/clacks-messages/","text":"Clacks Messenger with core.async \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Pull requests are welcome In a previous exercise we built a simple encoder/decoder to send messages via the Clacks message service (as designed by Sir Terry Pratchett, RIP). Now we will use core.async to create a processing queue between each Clack towers, so we can then model, monitor and visualise a Clacks messenger system with multiple Clacks towers. For additional fun we will enable new Clacks towers to come on line and connect to the existing system.","title":"Clacks Messenger with core.async"},{"location":"core.async/clacks-messages/#clacks-messenger-with-coreasync","text":"","title":"Clacks Messenger with core.async"},{"location":"core.async/clacks-messages/#todowork-in-progress-sorry","text":"Pull requests are welcome In a previous exercise we built a simple encoder/decoder to send messages via the Clacks message service (as designed by Sir Terry Pratchett, RIP). Now we will use core.async to create a processing queue between each Clack towers, so we can then model, monitor and visualise a Clacks messenger system with multiple Clacks towers. For additional fun we will enable new Clacks towers to come on line and connect to the existing system.","title":"TODO::work in progress, sorry"},{"location":"core.async/toy-car-assembly-line/","text":"core.async example - toy car assembly line \u03bb\ufe0e Note::Get the example project and open it in a Clojure REPL \u03bb\ufe0e Clone or download the Lispcast: Clojure core-async Factory example Open that project in your Clojure editor or run lein repl in the top level directory of the project. The toy car factory \u03bb\ufe0e The toy car factory assembles car parts before distributing them. How can we make this process faster and more scalable? The current process \u03bb\ufe0e One worker picks out random parts of a car from the parts box until all the parts are collected to assemble the car. The time macro \u03bb\ufe0e We will use the time macro to see how long parts of our code takes to run and help find parts to optimise. A simple example would be: ( time ( map inc ( range 0 10000 ))) Timing assembly functions \u03bb\ufe0e Investigate the time it takes to carry out the different assembly line tasks ( time ( take-part )) ( time ( attach-wheel :body :wheel )) ( time ( box-up :body )) ( time ( put-in-truck :body )) And to total time it takes to get a a whole car through the assembly line ( time ( build-car )) The total time can be longer than the sum of the tasks, as the take-part function does not always give the required part needed. Hiring more workers \u03bb\ufe0e Adding 10 more workers is equivalent to adding 10 processes that run the assembly tasks. Lets use a go block for a worker ( do ( go ( dotimes [ number 10 ] ( println \"First go block processing:\" number ) ( Thread/sleep 1200 ))) ( go ( dotimes [ number 10 ] ( println \"Second go block processing:\" number ) ( Thread/sleep 1200 )))) These are two separate go blocks, so their is no co-ordination between the two. You can see the println statement from each go block intertwined.","title":"core.async example - toy car assembly line"},{"location":"core.async/toy-car-assembly-line/#coreasync-example-toy-car-assembly-line","text":"","title":"core.async example - toy car assembly line"},{"location":"core.async/toy-car-assembly-line/#noteget-the-example-project-and-open-it-in-a-clojure-repl","text":"Clone or download the Lispcast: Clojure core-async Factory example Open that project in your Clojure editor or run lein repl in the top level directory of the project.","title":"Note::Get the example project and open it in a Clojure REPL"},{"location":"core.async/toy-car-assembly-line/#the-toy-car-factory","text":"The toy car factory assembles car parts before distributing them. How can we make this process faster and more scalable?","title":"The toy car factory"},{"location":"core.async/toy-car-assembly-line/#the-current-process","text":"One worker picks out random parts of a car from the parts box until all the parts are collected to assemble the car.","title":"The current process"},{"location":"core.async/toy-car-assembly-line/#the-time-macro","text":"We will use the time macro to see how long parts of our code takes to run and help find parts to optimise. A simple example would be: ( time ( map inc ( range 0 10000 )))","title":"The time macro"},{"location":"core.async/toy-car-assembly-line/#timing-assembly-functions","text":"Investigate the time it takes to carry out the different assembly line tasks ( time ( take-part )) ( time ( attach-wheel :body :wheel )) ( time ( box-up :body )) ( time ( put-in-truck :body )) And to total time it takes to get a a whole car through the assembly line ( time ( build-car )) The total time can be longer than the sum of the tasks, as the take-part function does not always give the required part needed.","title":"Timing assembly functions"},{"location":"core.async/toy-car-assembly-line/#hiring-more-workers","text":"Adding 10 more workers is equivalent to adding 10 processes that run the assembly tasks. Lets use a go block for a worker ( do ( go ( dotimes [ number 10 ] ( println \"First go block processing:\" number ) ( Thread/sleep 1200 ))) ( go ( dotimes [ number 10 ] ( println \"Second go block processing:\" number ) ( Thread/sleep 1200 )))) These are two separate go blocks, so their is no co-ordination between the two. You can see the println statement from each go block intertwined.","title":"Hiring more workers"},{"location":"data-inspector/","text":"Clojure Data Browsers \u03bb\ufe0e Clojure has a strong focus on using the built in data structures (list, vector, hash-map, set) to represent information in the system. Tools to inspect data and browse through nested or large data sets is invaluable in understanding what the system is doing. There are many clojure.core functions that can be used to explore data structures and transform them to produce specific views on data. tap> and datafy are recent additions to Clojure that provide a more elegant way of exploring data than the classic println statement. New tools are being created to capture and visualize results from evaluated expressions (REBL, Reveal) as well as tools to specifically visualize tap> expressions (Reveal, Portal). Common approaches \u03bb\ufe0e Clojure functions (TODO) Editor data browsers ( cider-inspect , etc.) Reveal repl with data browser, also a tap> source (new project) Portal - tool to navigate your data (new project) Clojure inspector (Java Swing based inspector) Specific cases \u03bb\ufe0e Cognitect REBL data browser has been developed to assist with Datomic Clojure database development. Cognitect provides the REBL data browser as part of the Cognitect dev-tools WARNING::Sign-up and personal repository code required \u03bb\ufe0e Sign-up to the Cognitect dev-tools license which will email a user specific maven configuration, which must be added as a new server entry under servers in ~/.m2/settings.xml and as a provider entry in ~/.clojure/deps.edn","title":"Clojure Data Browsers"},{"location":"data-inspector/#clojure-data-browsers","text":"Clojure has a strong focus on using the built in data structures (list, vector, hash-map, set) to represent information in the system. Tools to inspect data and browse through nested or large data sets is invaluable in understanding what the system is doing. There are many clojure.core functions that can be used to explore data structures and transform them to produce specific views on data. tap> and datafy are recent additions to Clojure that provide a more elegant way of exploring data than the classic println statement. New tools are being created to capture and visualize results from evaluated expressions (REBL, Reveal) as well as tools to specifically visualize tap> expressions (Reveal, Portal).","title":"Clojure Data Browsers"},{"location":"data-inspector/#common-approaches","text":"Clojure functions (TODO) Editor data browsers ( cider-inspect , etc.) Reveal repl with data browser, also a tap> source (new project) Portal - tool to navigate your data (new project) Clojure inspector (Java Swing based inspector)","title":"Common approaches"},{"location":"data-inspector/#specific-cases","text":"Cognitect REBL data browser has been developed to assist with Datomic Clojure database development. Cognitect provides the REBL data browser as part of the Cognitect dev-tools","title":"Specific cases"},{"location":"data-inspector/#warningsign-up-and-personal-repository-code-required","text":"Sign-up to the Cognitect dev-tools license which will email a user specific maven configuration, which must be added as a new server entry under servers in ~/.m2/settings.xml and as a provider entry in ~/.clojure/deps.edn","title":"WARNING::Sign-up and personal repository code required"},{"location":"data-inspector/clojure-inspector/","text":"Clojure Inspector \u03bb\ufe0e A visual browser for Clojure data using the Java UI libraries. Require the clojure.inspector namespace in the REPL or project namespace definitions to use the functions {% tabs repl=\"In the REPL\", project=\"In a Clojure Project\" %} {% content \"repl\" %} ( require ' [ clojure.inspector :as inspector ]) {% content \"project\" %} ( ns practicalli.application ( :require [ clojure.inspector :as inspector ])) inspect for flat data structures inspect-tree for deeply nested / hierarchically data inspect-table a sequence of data structures with the same shape inspect \u03bb\ufe0e View flat structures especially with non-trivial size data sets. This example generated 10,000 random numbers. The Clojure inspector shows the values along with their index in the collection. ( inspector/inspect ( repeatedly 10000 # ( rand-int 101 ))) inspect-tree \u03bb\ufe0e ( inspect { :star-wars { :characters { :jedi [ \"obiwan kenobi\" \"Yoda\" \"Master Wendoo\" ] :sith [ \"Palpatine\" \"Count Dukoo\" ]}}}) inspect-table \u03bb\ufe0e Inspect a sequence of data structures that share the same form, often found in data sets for machine learning and wider data science, eg. daily weather records. This example generates mock data for a 20 day period for one or more locations. Each day contains the day, location and cumulative number of cases reported. ( defn mock-data-set \"Generates a set of mock data for each name Arguments: names as strings, names used in keys Returns: Sequence of maps, each representing confirmed cases\" [ & locations ] ( for [ location locations day ( range 20 )] { :day day :location location :cases ( + ( Math/pow ( * day ( count location )) 0.8 ) ( rand-int ( count location )))})) ( inspector/inspect-table ( mock-data-set \"England\" \"Scotland\" \"Wales\" \"Northern Ireland\" ))","title":"Clojure Inspector"},{"location":"data-inspector/clojure-inspector/#clojure-inspector","text":"A visual browser for Clojure data using the Java UI libraries. Require the clojure.inspector namespace in the REPL or project namespace definitions to use the functions {% tabs repl=\"In the REPL\", project=\"In a Clojure Project\" %} {% content \"repl\" %} ( require ' [ clojure.inspector :as inspector ]) {% content \"project\" %} ( ns practicalli.application ( :require [ clojure.inspector :as inspector ])) inspect for flat data structures inspect-tree for deeply nested / hierarchically data inspect-table a sequence of data structures with the same shape","title":"Clojure Inspector"},{"location":"data-inspector/clojure-inspector/#inspect","text":"View flat structures especially with non-trivial size data sets. This example generated 10,000 random numbers. The Clojure inspector shows the values along with their index in the collection. ( inspector/inspect ( repeatedly 10000 # ( rand-int 101 )))","title":"inspect"},{"location":"data-inspector/clojure-inspector/#inspect-tree","text":"( inspect { :star-wars { :characters { :jedi [ \"obiwan kenobi\" \"Yoda\" \"Master Wendoo\" ] :sith [ \"Palpatine\" \"Count Dukoo\" ]}}})","title":"inspect-tree"},{"location":"data-inspector/clojure-inspector/#inspect-table","text":"Inspect a sequence of data structures that share the same form, often found in data sets for machine learning and wider data science, eg. daily weather records. This example generates mock data for a 20 day period for one or more locations. Each day contains the day, location and cumulative number of cases reported. ( defn mock-data-set \"Generates a set of mock data for each name Arguments: names as strings, names used in keys Returns: Sequence of maps, each representing confirmed cases\" [ & locations ] ( for [ location locations day ( range 20 )] { :day day :location location :cases ( + ( Math/pow ( * day ( count location )) 0.8 ) ( rand-int ( count location )))})) ( inspector/inspect-table ( mock-data-set \"England\" \"Scotland\" \"Wales\" \"Northern Ireland\" ))","title":"inspect-table"},{"location":"data-inspector/portal/","text":"Portal - navigate your data \u03bb\ufe0e WARNING::New Project \u03bb\ufe0e Portal is a new project so things may change rapidly, please see the djblue/portal repository for the latest information Portal is a new project that allows exploration of Clojure data, using a browser window to visualise and inspect Clojure, JSON and Transit data. Online demo Portal as a deps.edn alias \u03bb\ufe0e practicalli/clojure-deps-edn contains the :inspect/portal alias that run a Reveal repl with data browser. inspect/portal-cli - Clojure CLI (simplest approach) inspect/portal-web - Web ClojureScript REPL inspect/portal-node - node ClojureScript REPL Run a REPL with Portal dependencies \u03bb\ufe0e Run a REPL in a terminal and include the Portal library, using the Clojure CLI tools clojure -M:inspect/portal-cli Starting Portal in the REPL \u03bb\ufe0e (require '[portal.api :as portal]) once the REPL starts. For inspector-portal-web use (require '[portal.web :as portal]) instead (portal/open) to open the web based inspector window in a browser. (portal/tap) to add portal as a tap target (add-tap) Starting Portal on REPL startup \u03bb\ufe0e Start the Portal inspector as soon as the REPL is started. This works for a terminal REPL as well as clojure aware editors . Create a dev/user.clj source code file which requires the portal.api library, opens the inspector window and adds portal as a tap source. ( ns user ( :require [ portal.api :as inspect ])) ;; Start Portal inspector on REPL start ;; Open a portal inspector window ( inspect/open ) ;; Add portal as a tap> target ( inspect/tap ) ( comment ;; Clear all values in the portal inspector window ( inspect/clear ) ;; Close the inspector ( inspect/close ) ) ;; End of rich comment block The rich comment block includes commands to clear and close the portal inspector window. Start a REPL using the :env/dev and :inspect/portal-cli aliases from practicalli/clojure-deps-edn , using the command: clojure -M :env/dev:inspect/portal-cli To use this with Emacs CIDER editor, create a .dir-locals.el file in the root of the Clojure project with the following configuration ((clojure-mode . ((cider-clojure-cli-global-options . \"-M:env/dev:inspect/portal-cli\")))) Using Portal to inspect data \u03bb\ufe0e The tap> function sends data to Portal to be shown on the inspector window. (tap> {:accounts [{:name \"jen\" :email \"jen@jen.com\"} {:name \"sara\" :email \"sara@sara.com\"}]}) to send data to the portal inspector window (or any other data you wish to send) Use portal to navigate and inspect the details of the data sent to it via tap> . (portal/clear) to clear all values from the portal inspector window. Close Portal \u03bb\ufe0e (portal/close) to close the inspector window. References \u03bb\ufe0e See the Portal project readme for more details and examples.","title":"Portal - navigate your data"},{"location":"data-inspector/portal/#portal-navigate-your-data","text":"","title":"Portal - navigate your data"},{"location":"data-inspector/portal/#warningnew-project","text":"Portal is a new project so things may change rapidly, please see the djblue/portal repository for the latest information Portal is a new project that allows exploration of Clojure data, using a browser window to visualise and inspect Clojure, JSON and Transit data. Online demo","title":"WARNING::New Project"},{"location":"data-inspector/portal/#portal-as-a-depsedn-alias","text":"practicalli/clojure-deps-edn contains the :inspect/portal alias that run a Reveal repl with data browser. inspect/portal-cli - Clojure CLI (simplest approach) inspect/portal-web - Web ClojureScript REPL inspect/portal-node - node ClojureScript REPL","title":"Portal as a deps.edn alias"},{"location":"data-inspector/portal/#run-a-repl-with-portal-dependencies","text":"Run a REPL in a terminal and include the Portal library, using the Clojure CLI tools clojure -M:inspect/portal-cli","title":"Run a REPL with Portal dependencies"},{"location":"data-inspector/portal/#starting-portal-in-the-repl","text":"(require '[portal.api :as portal]) once the REPL starts. For inspector-portal-web use (require '[portal.web :as portal]) instead (portal/open) to open the web based inspector window in a browser. (portal/tap) to add portal as a tap target (add-tap)","title":"Starting Portal in the REPL"},{"location":"data-inspector/portal/#starting-portal-on-repl-startup","text":"Start the Portal inspector as soon as the REPL is started. This works for a terminal REPL as well as clojure aware editors . Create a dev/user.clj source code file which requires the portal.api library, opens the inspector window and adds portal as a tap source. ( ns user ( :require [ portal.api :as inspect ])) ;; Start Portal inspector on REPL start ;; Open a portal inspector window ( inspect/open ) ;; Add portal as a tap> target ( inspect/tap ) ( comment ;; Clear all values in the portal inspector window ( inspect/clear ) ;; Close the inspector ( inspect/close ) ) ;; End of rich comment block The rich comment block includes commands to clear and close the portal inspector window. Start a REPL using the :env/dev and :inspect/portal-cli aliases from practicalli/clojure-deps-edn , using the command: clojure -M :env/dev:inspect/portal-cli To use this with Emacs CIDER editor, create a .dir-locals.el file in the root of the Clojure project with the following configuration ((clojure-mode . ((cider-clojure-cli-global-options . \"-M:env/dev:inspect/portal-cli\"))))","title":"Starting Portal on REPL startup"},{"location":"data-inspector/portal/#using-portal-to-inspect-data","text":"The tap> function sends data to Portal to be shown on the inspector window. (tap> {:accounts [{:name \"jen\" :email \"jen@jen.com\"} {:name \"sara\" :email \"sara@sara.com\"}]}) to send data to the portal inspector window (or any other data you wish to send) Use portal to navigate and inspect the details of the data sent to it via tap> . (portal/clear) to clear all values from the portal inspector window.","title":"Using Portal to inspect data"},{"location":"data-inspector/portal/#close-portal","text":"(portal/close) to close the inspector window.","title":"Close Portal"},{"location":"data-inspector/portal/#references","text":"See the Portal project readme for more details and examples.","title":"References"},{"location":"data-inspector/reveal/","text":"Reveal - REPL with visual data browser \u03bb\ufe0e Reveal provides a REPL with a connected visual data explorer. Reveal can also be used as a tap> target, visualizing data added to a tap> (an elegant approach compared to print statements). Reveal describes itself as a read evaluate visualize loop tool proving extra tools to explore data in Clojure visually. The extensive documentation shows the many ways to use Reveal. Use Reveal with a terminal REPL , a Clojure editor that uses nrepl , such as Emacs Cider and Spacemacs. Reveal can be added as a tap source to any running REPL, eg. using Reveal with Rebel Readline . {% youtube %} https://youtu.be/1jy09_16EeY Using Reveal in a terminal \u03bb\ufe0e practicalli/clojure-deps-edn contains the :inspect/reveal alias to run Reveal REPL in a terminal with the Reveal UI along-side. Open a terminal and run the command: clojure -M:inspect/reveal Use the clj command if the rlwrap binary is available Write Clojure code as normal in the REPL and result are also sent to the Reveal data browser window. The extensive documentation shows the many ways to use Reveal. Using Reveal with nrepl Editors \u03bb\ufe0e practicalli/clojure-deps-edn contains the :inspect/reveal-nrepl alias that run a Reveal repl with data browser and nrepl server, allowing connections from Clojure aware editors such as Emacs CIDER and VSCode Calva. :inspect/reveal-light-nrepl does the same and uses a light them with Ubuntu Mono 32 point font (good for demos, HiDPI screens) {% tabs practicalli=\"Using practicalli/clojure-deps-edn\", manual=\"Manually add Alias\" %} {% content \"practicalli\" %} {% content \"manual\" %} Add the following aliases to your user level ~/.clojure/deps.edn configuration to make reveal available to all projects. Plain nrepl server with Reveal. :inspect/reveal-nrepl { :extra-deps { vlaaad/reveal { :mvn/version \"1.1.159\" } nrepl/nrepl { :mvn/version \"0.8.3\" }} :main-opts [ \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware]\" ]} CIDER specific nrepl connection with the Cider middleware :inspect/reveal-nrepl-cider {:extra-deps {vlaaad/reveal {:mvn/version \"1.1.159\"} nrepl/nrepl {:mvn/version \"0.8.3\"} cider/cider-nrepl {:mvn/version \"0.25.4\"} refactor-nrepl/refactor-nrepl {:mvn/version \"2.5.0\"}} :main-opts [\"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,refactor-nrepl.middleware/wrap-refactor,cider.nrepl/cider-middleware]\"]} {% endtabs %} Start a Reveal REPL with nrepl server clojure -M:inspect/reveal-nrepl Connect to the Reveal repl from a Clojure aware editor , e.g cider-connect Using Reveal with Cider Jack-in \u03bb\ufe0e C-u cider-jack-in-clj in CIDER to start a reveal REPL ( SPC u , ' in Spacemacs) Edit the jack-in command by deleting the all the configuration after the clojure command and add the alias clojure -M:inspect/reveal-nrepl-cider :inspect/reveal-nrepl-cider is a light version of the above. Cider jack-in with reveal using a .dir-locals.el \u03bb\ufe0e Add a .dir-locals.el file to the root of the Clojure project. The .dir-locals.el configuration adds the :inspect/reveal-nrepl-cider via cider-clojure-cli-global-options and all other automatically injected configuration is disabled to prevent those dependencies over-riding the alias. ((clojure-mode . ((cider-preferred-build-tool . clojure-cli) (cider-clojure-cli-global-options . \"-M:inspect/reveal-nrepl-cider\") (cider-jack-in-dependencies . nil) (cider-jack-in-nrepl-middlewares . nil) (cider-jack-in-lein-plugins . nil) (cider-clojure-cli-parameters . \"\")))) Ensure the .dir-locals.el file is loaded by using revert-buffer on any open Clojure file from the project. cider-jack-in-clj should now start the Reveal REPL and send evaluations from Cider to the Reveal visualization UI. Using Reveal with Rebel and tap> \u03bb\ufe0e Reveal can be used as a tap> target with the Rebel REPL, launching the Reveal data browser when added as a tap> target. Start Rebel REPL with Reveal library as a dependency clojure -M:repl-reveal:repl/rebel Add reveal as a tap target that will receive all data from tap> function calls ( add-tap (( requiring-resolve 'vlaaad.reveal/ui ))) A reveal window opens and receives all tap> values while the REPL is running. ( tap> [ 1 2 3 4 5 ]) ( tap> { :name \"Jenny\" :skill \"Clojure\" }) ( tap> ( zipmap [ :a :b :c ] [ 1 2 3 4 ])) TODO: find more examples of using tap>. It seems you can bind specific functions to a tap set, (add-tap (bound-fn* clojure.pprint/pprint)) (add-tap (bound-fn* prn)) so am assuming if a function is bound, where ever it is used its result is sent to reveal browser window. Then functions can be removed from the tap. To stop reveal, shut down the REPL (is there another approach?) Use atom to hold tapped value \u03bb\ufe0e Create an atom for debugging purposes ( def debug-state ( atom nil )) ( add-tap # ( reset! debug-state % )) Use tap> to capture intermediate values in the middle of code that requires debugging, inspecting or watching the atom value (deref the atom and watch:latest or watch:all). This approach complements an editor debugging process Running different types of repl \u03bb\ufe0e Using Clojure exec -X flag, the default repl function can be over-ridden on the command line, supplying the io-prepl or remote-prepl functions. clojure -X:inspect/reveal io-prepl :title '\"I am a prepl repl\" clojure -X:inspect/reveal remote-prepl :title '\"I am a remote prepl repl\"' Configure theme & font \u03bb\ufe0e Add a custom theme and font via the -J command line option or create an alias using :inspect/reveal-light as an example. clojure -M:inspect/reveal -J-Dvlaaad.reveal.prefs = '{:theme :light :font-family \"Ubuntu Mono\" :font-size 32}' Rebel Readline & Reveal: Add Reveal as tap> source \u03bb\ufe0e Evaluate (add-tap ((requiring-resolve 'vlaaad.reveal/ui))) when using Rebel Readline to add Reveal as a tap source, showing (tap> ,,,) expressions in the reveal window, eg. (tap> (map inc [1 2 3 4 5])) .","title":"Reveal - REPL with visual data browser"},{"location":"data-inspector/reveal/#reveal-repl-with-visual-data-browser","text":"Reveal provides a REPL with a connected visual data explorer. Reveal can also be used as a tap> target, visualizing data added to a tap> (an elegant approach compared to print statements). Reveal describes itself as a read evaluate visualize loop tool proving extra tools to explore data in Clojure visually. The extensive documentation shows the many ways to use Reveal. Use Reveal with a terminal REPL , a Clojure editor that uses nrepl , such as Emacs Cider and Spacemacs. Reveal can be added as a tap source to any running REPL, eg. using Reveal with Rebel Readline . {% youtube %} https://youtu.be/1jy09_16EeY","title":"Reveal - REPL with visual data browser"},{"location":"data-inspector/reveal/#using-reveal-in-a-terminal","text":"practicalli/clojure-deps-edn contains the :inspect/reveal alias to run Reveal REPL in a terminal with the Reveal UI along-side. Open a terminal and run the command: clojure -M:inspect/reveal Use the clj command if the rlwrap binary is available Write Clojure code as normal in the REPL and result are also sent to the Reveal data browser window. The extensive documentation shows the many ways to use Reveal.","title":"Using Reveal in a terminal"},{"location":"data-inspector/reveal/#using-reveal-with-nrepl-editors","text":"practicalli/clojure-deps-edn contains the :inspect/reveal-nrepl alias that run a Reveal repl with data browser and nrepl server, allowing connections from Clojure aware editors such as Emacs CIDER and VSCode Calva. :inspect/reveal-light-nrepl does the same and uses a light them with Ubuntu Mono 32 point font (good for demos, HiDPI screens) {% tabs practicalli=\"Using practicalli/clojure-deps-edn\", manual=\"Manually add Alias\" %} {% content \"practicalli\" %} {% content \"manual\" %} Add the following aliases to your user level ~/.clojure/deps.edn configuration to make reveal available to all projects. Plain nrepl server with Reveal. :inspect/reveal-nrepl { :extra-deps { vlaaad/reveal { :mvn/version \"1.1.159\" } nrepl/nrepl { :mvn/version \"0.8.3\" }} :main-opts [ \"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware]\" ]} CIDER specific nrepl connection with the Cider middleware :inspect/reveal-nrepl-cider {:extra-deps {vlaaad/reveal {:mvn/version \"1.1.159\"} nrepl/nrepl {:mvn/version \"0.8.3\"} cider/cider-nrepl {:mvn/version \"0.25.4\"} refactor-nrepl/refactor-nrepl {:mvn/version \"2.5.0\"}} :main-opts [\"-m\" \"nrepl.cmdline\" \"--middleware\" \"[vlaaad.reveal.nrepl/middleware,refactor-nrepl.middleware/wrap-refactor,cider.nrepl/cider-middleware]\"]} {% endtabs %} Start a Reveal REPL with nrepl server clojure -M:inspect/reveal-nrepl Connect to the Reveal repl from a Clojure aware editor , e.g cider-connect","title":"Using Reveal with nrepl Editors"},{"location":"data-inspector/reveal/#using-reveal-with-cider-jack-in","text":"C-u cider-jack-in-clj in CIDER to start a reveal REPL ( SPC u , ' in Spacemacs) Edit the jack-in command by deleting the all the configuration after the clojure command and add the alias clojure -M:inspect/reveal-nrepl-cider :inspect/reveal-nrepl-cider is a light version of the above.","title":"Using Reveal with Cider Jack-in"},{"location":"data-inspector/reveal/#cider-jack-in-with-reveal-using-a-dir-localsel","text":"Add a .dir-locals.el file to the root of the Clojure project. The .dir-locals.el configuration adds the :inspect/reveal-nrepl-cider via cider-clojure-cli-global-options and all other automatically injected configuration is disabled to prevent those dependencies over-riding the alias. ((clojure-mode . ((cider-preferred-build-tool . clojure-cli) (cider-clojure-cli-global-options . \"-M:inspect/reveal-nrepl-cider\") (cider-jack-in-dependencies . nil) (cider-jack-in-nrepl-middlewares . nil) (cider-jack-in-lein-plugins . nil) (cider-clojure-cli-parameters . \"\")))) Ensure the .dir-locals.el file is loaded by using revert-buffer on any open Clojure file from the project. cider-jack-in-clj should now start the Reveal REPL and send evaluations from Cider to the Reveal visualization UI.","title":"Cider jack-in with reveal using a .dir-locals.el"},{"location":"data-inspector/reveal/#using-reveal-with-rebel-and-tap","text":"Reveal can be used as a tap> target with the Rebel REPL, launching the Reveal data browser when added as a tap> target. Start Rebel REPL with Reveal library as a dependency clojure -M:repl-reveal:repl/rebel Add reveal as a tap target that will receive all data from tap> function calls ( add-tap (( requiring-resolve 'vlaaad.reveal/ui ))) A reveal window opens and receives all tap> values while the REPL is running. ( tap> [ 1 2 3 4 5 ]) ( tap> { :name \"Jenny\" :skill \"Clojure\" }) ( tap> ( zipmap [ :a :b :c ] [ 1 2 3 4 ])) TODO: find more examples of using tap>. It seems you can bind specific functions to a tap set, (add-tap (bound-fn* clojure.pprint/pprint)) (add-tap (bound-fn* prn)) so am assuming if a function is bound, where ever it is used its result is sent to reveal browser window. Then functions can be removed from the tap. To stop reveal, shut down the REPL (is there another approach?)","title":"Using Reveal with Rebel and tap&gt;"},{"location":"data-inspector/reveal/#use-atom-to-hold-tapped-value","text":"Create an atom for debugging purposes ( def debug-state ( atom nil )) ( add-tap # ( reset! debug-state % )) Use tap> to capture intermediate values in the middle of code that requires debugging, inspecting or watching the atom value (deref the atom and watch:latest or watch:all). This approach complements an editor debugging process","title":"Use atom to hold tapped value"},{"location":"data-inspector/reveal/#running-different-types-of-repl","text":"Using Clojure exec -X flag, the default repl function can be over-ridden on the command line, supplying the io-prepl or remote-prepl functions. clojure -X:inspect/reveal io-prepl :title '\"I am a prepl repl\" clojure -X:inspect/reveal remote-prepl :title '\"I am a remote prepl repl\"'","title":"Running different types of repl"},{"location":"data-inspector/reveal/#configure-theme-font","text":"Add a custom theme and font via the -J command line option or create an alias using :inspect/reveal-light as an example. clojure -M:inspect/reveal -J-Dvlaaad.reveal.prefs = '{:theme :light :font-family \"Ubuntu Mono\" :font-size 32}'","title":"Configure theme &amp; font"},{"location":"data-inspector/reveal/#rebel-readline-reveal-add-reveal-as-tap-source","text":"Evaluate (add-tap ((requiring-resolve 'vlaaad.reveal/ui))) when using Rebel Readline to add Reveal as a tap source, showing (tap> ,,,) expressions in the reveal window, eg. (tap> (map inc [1 2 3 4 5])) .","title":"Rebel Readline &amp; Reveal: Add Reveal as tap&gt; source"},{"location":"data-structures/","text":"Data structures \u03bb\ufe0e Clojure is a very data-centric language. clojure.core contains a great number of functions for manipulating data structures, especially the immutable built in data structures, referred to generically as collections. Collections can take any types of elements and types can be mixed. Collections can even have other collections as an element. Collections are passed as arguments to function (either in part or in full) and functions often return collections as a result. Built-in collections \u03bb\ufe0e Values can be represented as a collection of discrete pieces of data: number, string, boolean value. Clojure has great facilities for working with collections of data, providing many types of data structures and a uniform way to use all of these data structures. The 4 commonly used built-in data structures Name syntax Description list () A linked list, optomised for sequential access from the front (head) vector [] An indexed array optimised for random access hash-map {:key \"value\"} Associative collection of key / value pairs, keys must be unique. Keys are the index set #{} A unique set of values Vector and hash-map are the most commonly collections used to model information with Clojure. Lists are not explicitly used to model data, although data may be returned by a function as a list (referred to as a sequence) Collection Characteristics \u03bb\ufe0e Clojure data structure share the following characteristics: Immutable - once a data structure is defined it cannot be changed Persistent - functions may return an altered copy of a data structure which will share common values with the original data structure for efficient memory use (structural sharing) Dynamically typed - a data structure can contain any value, including functions (as they evaluate to a value) and other data structures (nested data structures) This section will cover the Clojure built in persistent data structures in more detail. Common Data Sturctures \u03bb\ufe0e Simple data (def name value) Sequential data (list ...) sequence - always processed sequentially (vector) sequencw with randon access Dictionary (key value key1 value key2 value) Connverting data, data decoder/encoder, state machine, etc Data set ( def name [{ :identical-keys \"with evolving values\" } { :identical-keys \"values differ from each other\" } { :identical-keys \"values collectively provide meaning\" }]) Weather monitoring data, bank transactions, stock exchange rates, etc Hierachical data \u03bb\ufe0e ( def name { :simple-key value :composite-key { :nested-key value } :deeper-composite-key { :nested-key { :deeper-nested-key value }}}) representing state, structure of a website Starwars example, walk the hierachy to get the appropriate values extract only the values required by a function and pass as arguments hierachiecy can become too complex to manage, the flatest possible structure is usually simpler to work with (transform)","title":"Data structures"},{"location":"data-structures/#data-structures","text":"Clojure is a very data-centric language. clojure.core contains a great number of functions for manipulating data structures, especially the immutable built in data structures, referred to generically as collections. Collections can take any types of elements and types can be mixed. Collections can even have other collections as an element. Collections are passed as arguments to function (either in part or in full) and functions often return collections as a result.","title":"Data structures"},{"location":"data-structures/#built-in-collections","text":"Values can be represented as a collection of discrete pieces of data: number, string, boolean value. Clojure has great facilities for working with collections of data, providing many types of data structures and a uniform way to use all of these data structures. The 4 commonly used built-in data structures Name syntax Description list () A linked list, optomised for sequential access from the front (head) vector [] An indexed array optimised for random access hash-map {:key \"value\"} Associative collection of key / value pairs, keys must be unique. Keys are the index set #{} A unique set of values Vector and hash-map are the most commonly collections used to model information with Clojure. Lists are not explicitly used to model data, although data may be returned by a function as a list (referred to as a sequence)","title":"Built-in collections"},{"location":"data-structures/#collection-characteristics","text":"Clojure data structure share the following characteristics: Immutable - once a data structure is defined it cannot be changed Persistent - functions may return an altered copy of a data structure which will share common values with the original data structure for efficient memory use (structural sharing) Dynamically typed - a data structure can contain any value, including functions (as they evaluate to a value) and other data structures (nested data structures) This section will cover the Clojure built in persistent data structures in more detail.","title":"Collection Characteristics"},{"location":"data-structures/#common-data-sturctures","text":"Simple data (def name value) Sequential data (list ...) sequence - always processed sequentially (vector) sequencw with randon access Dictionary (key value key1 value key2 value) Connverting data, data decoder/encoder, state machine, etc Data set ( def name [{ :identical-keys \"with evolving values\" } { :identical-keys \"values differ from each other\" } { :identical-keys \"values collectively provide meaning\" }]) Weather monitoring data, bank transactions, stock exchange rates, etc","title":"Common Data Sturctures"},{"location":"data-structures/#hierachical-data","text":"( def name { :simple-key value :composite-key { :nested-key value } :deeper-composite-key { :nested-key { :deeper-nested-key value }}}) representing state, structure of a website Starwars example, walk the hierachy to get the appropriate values extract only the values required by a function and pass as arguments hierachiecy can become too complex to manage, the flatest possible structure is usually simpler to work with (transform)","title":"Hierachical data"},{"location":"data-structures/alternatives/","text":"Alternative data structures \u03bb\ufe0e Whist list, vector, hash-map and set are by far the most commonly used data structures, Clojure has many others of interest. Variations on hash-maps \u03bb\ufe0e Variations on sets \u03bb\ufe0e ordered-set","title":"Alternative data structures"},{"location":"data-structures/alternatives/#alternative-data-structures","text":"Whist list, vector, hash-map and set are by far the most commonly used data structures, Clojure has many others of interest.","title":"Alternative data structures"},{"location":"data-structures/alternatives/#variations-on-hash-maps","text":"","title":"Variations on hash-maps"},{"location":"data-structures/alternatives/#variations-on-sets","text":"ordered-set","title":"Variations on sets"},{"location":"data-structures/list/","text":"List \u03bb\ufe0e The list is used extensively in Clojure, it is a List (List Processing) language after all. The unique thing about lists is that the first element is always evaluated as a function call, therefore lists are most commonly used for defining and calling functions. Lists are sometimes used as a data structure and have a sequential lookup time. A list can hold any valid types of data, from numbers and strings to other data structures such as vectors, maps and sets. Types can be mix as Clojure will dynamically type each element as its evaluated. Its more common to use vectors and maps which typically offer quicker access as they can be looked up via an index or key. Note Explore the list data structure and discover which line of code fails. Try work out why that line of code fails. ( list 1 2 3 4 ) ( list -1 -0.234 0 1.3 8/5 3.1415926 ) ( list \"cat\" \"dog\" \"rabbit\" \"fish\" ) ( list :cat 1 \"fish\" 22/7 ( str \"fish\" \"n\" \"chips\" )) ( list 1 2 \"three\" [ 4 ] five ' ( 6 7 8 9 )) ( list ) ( 1 2 3 4 ) ( quote ( 1 2 3 4 )) ' ( 1 2 3 4 ) ;; Duplicate elements in a list ? ( list 1 2 3 4 1 ) ( list \"one\" \"two\" \"one\" ) ( list :fred :barney :fred ) Hint::First element of a list is a function call \u03bb\ufe0e The first element of a list is evaluated as a function call, unless the list is wrapped in a quote function We can create a list using the list function ( list 1 2 3 4 ) This evaluates to (1 2 3 4) We can give this result a name ( def my-list ( list 1 2 3 4 )) Then when we evaluate my-list it will return the list as a result However, if we create a list directly by using (1 2 3 4) , this will fail when evaluated as 1 is not a function. So when we define a data structure as a list we need to use the quote function or ' syntax ( quote ( 1 2 3 4 )) ' ( 1 2 3 4 ) Testing for a List \u03bb\ufe0e When is a list not a list? . Lists are sometimes created as other types if they are created in ways other than using the list function. If you want to know if something is list like, then you can use the seq? function. If you test with the list? function and that returns false, you can use the type function to see what its real type is. See more about the types that list-like structures actually are in the article: What is a list? The ultimate predicate showdown","title":"List"},{"location":"data-structures/list/#list","text":"The list is used extensively in Clojure, it is a List (List Processing) language after all. The unique thing about lists is that the first element is always evaluated as a function call, therefore lists are most commonly used for defining and calling functions. Lists are sometimes used as a data structure and have a sequential lookup time. A list can hold any valid types of data, from numbers and strings to other data structures such as vectors, maps and sets. Types can be mix as Clojure will dynamically type each element as its evaluated. Its more common to use vectors and maps which typically offer quicker access as they can be looked up via an index or key. Note Explore the list data structure and discover which line of code fails. Try work out why that line of code fails. ( list 1 2 3 4 ) ( list -1 -0.234 0 1.3 8/5 3.1415926 ) ( list \"cat\" \"dog\" \"rabbit\" \"fish\" ) ( list :cat 1 \"fish\" 22/7 ( str \"fish\" \"n\" \"chips\" )) ( list 1 2 \"three\" [ 4 ] five ' ( 6 7 8 9 )) ( list ) ( 1 2 3 4 ) ( quote ( 1 2 3 4 )) ' ( 1 2 3 4 ) ;; Duplicate elements in a list ? ( list 1 2 3 4 1 ) ( list \"one\" \"two\" \"one\" ) ( list :fred :barney :fred )","title":"List"},{"location":"data-structures/list/#hintfirst-element-of-a-list-is-a-function-call","text":"The first element of a list is evaluated as a function call, unless the list is wrapped in a quote function We can create a list using the list function ( list 1 2 3 4 ) This evaluates to (1 2 3 4) We can give this result a name ( def my-list ( list 1 2 3 4 )) Then when we evaluate my-list it will return the list as a result However, if we create a list directly by using (1 2 3 4) , this will fail when evaluated as 1 is not a function. So when we define a data structure as a list we need to use the quote function or ' syntax ( quote ( 1 2 3 4 )) ' ( 1 2 3 4 )","title":"Hint::First element of a list is a function call"},{"location":"data-structures/list/#testing-for-a-list","text":"When is a list not a list? . Lists are sometimes created as other types if they are created in ways other than using the list function. If you want to know if something is list like, then you can use the seq? function. If you test with the list? function and that returns false, you can use the type function to see what its real type is. See more about the types that list-like structures actually are in the article: What is a list? The ultimate predicate showdown","title":"Testing for a List"},{"location":"data-structures/naming/","text":"Naming data structures \u03bb\ufe0e We have seen that defining things is as simple as giving a name to a value using the def function. It is the same for the Clojure data structures and any other values. ( def people [ \"Jane Doe\" \"Samuel Peeps\" ]) Names are of course case sensitive, so Person is not the same as person ( def Person \"James Doh\" \"Sam Stare\" ) Clojure uses dynamic typing, this means its trivial to mix and match different kinds of data. Here we are defining a name for a vector, which contains numbers, a string and name of another def. ( def my-data [ 1 2 3 \"frog\" person ]) my-data Data structures are immutable, names are mutable \u03bb\ufe0e You can dynamically re-define a name to points to a different value. Hint This re-definition (or rebinding) of names to new values is typically used only during the development of your code, especially in REPL driven development. (def my-data [1 2 3 4 5 \"frog\" person]) The original value that defined my-data remains unchanged (its immutable), so anything using that value remains unaffected. Essentially we are re-mapping my-data to a new value. Lets define a name to point to a list of numbers (def my-list '(1 2 3)) We are returned that list of numbers when we evaluate the name my-list We can use the cons function to add a number to our list, however because lists are immutable, rather than changing the original list, a new one is returned. So if we want to keep on referring to our \"changed\" list, we need to give it a name (def my-list-updated (cons 4 my-list)) As you can see we have not changed the original list my-list ;; The new list does have the change though. my-list-updated You could therefore give the impression of mutable state by applying a function to data structure and redefining the original name to point to the resulting data structure. Hint In practice, the ability to redefine functions and data structures live helps you develop your application quickly in the REPL. In production you typical do not redefine functions or data structures in a live running application. That could be part of a new release of your application though. ( def my-list ( cons 5 my-list )) So now when we evaluate the original name, we get the updated list my-list Naming Scope \u03bb\ufe0e All def names are publicly available via their namespace. As def values are immutable, then keeping things private is of less concern than languages built around Object Oriented design. Private definitions syntax can be used to limit the access to def names to the namespace they are declared in. To limit the scope of a def, add the :private true metadata key value pair. (def ^{:private true} some-var :value) (def ^:private some-var :value) The second form is syntax sugar for the first one. You could also define a macro for def- (defmacro def- [item value] `(def ^{:private true} ~item ~value) ) You would then use this macro as follows: (def- private-definition \"This is only accessible in the namespace\")","title":"Naming data structures"},{"location":"data-structures/naming/#naming-data-structures","text":"We have seen that defining things is as simple as giving a name to a value using the def function. It is the same for the Clojure data structures and any other values. ( def people [ \"Jane Doe\" \"Samuel Peeps\" ]) Names are of course case sensitive, so Person is not the same as person ( def Person \"James Doh\" \"Sam Stare\" ) Clojure uses dynamic typing, this means its trivial to mix and match different kinds of data. Here we are defining a name for a vector, which contains numbers, a string and name of another def. ( def my-data [ 1 2 3 \"frog\" person ]) my-data","title":"Naming data structures"},{"location":"data-structures/naming/#data-structures-are-immutable-names-are-mutable","text":"You can dynamically re-define a name to points to a different value. Hint This re-definition (or rebinding) of names to new values is typically used only during the development of your code, especially in REPL driven development. (def my-data [1 2 3 4 5 \"frog\" person]) The original value that defined my-data remains unchanged (its immutable), so anything using that value remains unaffected. Essentially we are re-mapping my-data to a new value. Lets define a name to point to a list of numbers (def my-list '(1 2 3)) We are returned that list of numbers when we evaluate the name my-list We can use the cons function to add a number to our list, however because lists are immutable, rather than changing the original list, a new one is returned. So if we want to keep on referring to our \"changed\" list, we need to give it a name (def my-list-updated (cons 4 my-list)) As you can see we have not changed the original list my-list ;; The new list does have the change though. my-list-updated You could therefore give the impression of mutable state by applying a function to data structure and redefining the original name to point to the resulting data structure. Hint In practice, the ability to redefine functions and data structures live helps you develop your application quickly in the REPL. In production you typical do not redefine functions or data structures in a live running application. That could be part of a new release of your application though. ( def my-list ( cons 5 my-list )) So now when we evaluate the original name, we get the updated list my-list","title":"Data structures are immutable, names are mutable"},{"location":"data-structures/naming/#naming-scope","text":"All def names are publicly available via their namespace. As def values are immutable, then keeping things private is of less concern than languages built around Object Oriented design. Private definitions syntax can be used to limit the access to def names to the namespace they are declared in. To limit the scope of a def, add the :private true metadata key value pair. (def ^{:private true} some-var :value) (def ^:private some-var :value) The second form is syntax sugar for the first one. You could also define a macro for def- (defmacro def- [item value] `(def ^{:private true} ~item ~value) ) You would then use this macro as follows: (def- private-definition \"This is only accessible in the namespace\")","title":"Naming Scope"},{"location":"data-structures/pretty-printing/","text":"Pretty Printing data structures \u03bb\ufe0e Data structures containing small amounts of data are quite human readable, although can benefit from pretty printing to make them very easy for humans to read. The larger a data structure becomes, or if a data structure is nested, then there are tools to print out ascii views of the data structures. Pretty print hash-maps \u03bb\ufe0e ( clojure.pprint/pprint { :account-id 232443344 :account-name \"Jenny Jetpack\" :balance 9999 :last-update \"2021-12-12\" :credit-score :aa } ) Each key is printed on a new line, making the hash-map easier to read, especially when there are a large number of keys { :account-id 232443344 , :account-name \"Jenny Jetpack\" , :balance 9999 , :last-update \"2021-12-12\" , :credit-score :aa } Clojure aware editors can also have an align option when formatting hash-maps, making the results easier to read { :account-id 232443344 , :account-name \"Jenny Jetpack\" , :balance 9999 , :last-update \"2021-12-12\" , :credit-score :aa } Hint::Pretty Print evaluation results \u03bb\ufe0e Clojure aware editors should allow the pretty printing of the evaluation results. Print Table of nested data structures \u03bb\ufe0e Nested data structures can also be shown as a table, especially the common approach of using a vector of hash-maps where each map has the same keys ( clojure.pprint/print-table [{ :location \"Scotland\" :total-cases 42826 :total-mortality 9202 } { :location \"Wales\" :total-cases 50876 :total-mortality 1202 } { :location \"England\" :total-cases 5440876 :total-mortality 200202 }]) | :location | :total-cases | :total-mortality | |-----------+--------------+------------------| | Scotland | 42826 | 9202 | | Wales | 50876 | 1202 | | England | 5440876 | 200202 | References \u03bb\ufe0e Data browsers (Cider Inspector, Portal, Reveal Free) are very useful for larger and nested data structures.","title":"Pretty Printing"},{"location":"data-structures/pretty-printing/#pretty-printing-data-structures","text":"Data structures containing small amounts of data are quite human readable, although can benefit from pretty printing to make them very easy for humans to read. The larger a data structure becomes, or if a data structure is nested, then there are tools to print out ascii views of the data structures.","title":"Pretty Printing data structures"},{"location":"data-structures/pretty-printing/#pretty-print-hash-maps","text":"( clojure.pprint/pprint { :account-id 232443344 :account-name \"Jenny Jetpack\" :balance 9999 :last-update \"2021-12-12\" :credit-score :aa } ) Each key is printed on a new line, making the hash-map easier to read, especially when there are a large number of keys { :account-id 232443344 , :account-name \"Jenny Jetpack\" , :balance 9999 , :last-update \"2021-12-12\" , :credit-score :aa } Clojure aware editors can also have an align option when formatting hash-maps, making the results easier to read { :account-id 232443344 , :account-name \"Jenny Jetpack\" , :balance 9999 , :last-update \"2021-12-12\" , :credit-score :aa }","title":"Pretty print hash-maps"},{"location":"data-structures/pretty-printing/#hintpretty-print-evaluation-results","text":"Clojure aware editors should allow the pretty printing of the evaluation results.","title":"Hint::Pretty Print evaluation results"},{"location":"data-structures/pretty-printing/#print-table-of-nested-data-structures","text":"Nested data structures can also be shown as a table, especially the common approach of using a vector of hash-maps where each map has the same keys ( clojure.pprint/print-table [{ :location \"Scotland\" :total-cases 42826 :total-mortality 9202 } { :location \"Wales\" :total-cases 50876 :total-mortality 1202 } { :location \"England\" :total-cases 5440876 :total-mortality 200202 }]) | :location | :total-cases | :total-mortality | |-----------+--------------+------------------| | Scotland | 42826 | 9202 | | Wales | 50876 | 1202 | | England | 5440876 | 200202 |","title":"Print Table of nested data structures"},{"location":"data-structures/pretty-printing/#references","text":"Data browsers (Cider Inspector, Portal, Reveal Free) are very useful for larger and nested data structures.","title":"References"},{"location":"data-structures/set/","text":"Set \u03bb\ufe0e A Clojure set is a persistent data structure that holds a unique set of elements. Again the elements can be of any type, however each element must be unique for a valid set. Note Explore creating sets from existing collections. Notice what happens if you have duplicate values in the collection. Define sets directly using the #{} notation and see what happens if there are duplicate values. ( set ` ( 1 2 3 4 )) ( set ` ( 1 2 1 2 3 4 )) # { 1 2 3 4 } # { :a :b :c :d } ;; duplicate key error # { 1 2 3 4 1 } Unique but not ordered \u03bb\ufe0e A set is not ordered by the values it contains. If you need a sorted set then you can use the sorted-set function when creating a new set. Or you can run ( sorted-set 1 4 0 2 9 3 5 3 0 2 7 6 5 5 3 8 ) ( sort [ 9 8 7 6 5 ]) ( sort-by ) Looking up values in a set \u03bb\ufe0e ( # { :a :b :c } :c ) ( # { :a :b :c } :z ) Sets can also use the contains? function to see if a value exists in a set ( contains? # { \"Palpatine\" \"Darth Vader\" \"Boba Fett\" \"Darth Tyranus\" } \"Darth Vader\" )","title":"Set"},{"location":"data-structures/set/#set","text":"A Clojure set is a persistent data structure that holds a unique set of elements. Again the elements can be of any type, however each element must be unique for a valid set. Note Explore creating sets from existing collections. Notice what happens if you have duplicate values in the collection. Define sets directly using the #{} notation and see what happens if there are duplicate values. ( set ` ( 1 2 3 4 )) ( set ` ( 1 2 1 2 3 4 )) # { 1 2 3 4 } # { :a :b :c :d } ;; duplicate key error # { 1 2 3 4 1 }","title":"Set"},{"location":"data-structures/set/#unique-but-not-ordered","text":"A set is not ordered by the values it contains. If you need a sorted set then you can use the sorted-set function when creating a new set. Or you can run ( sorted-set 1 4 0 2 9 3 5 3 0 2 7 6 5 5 3 8 ) ( sort [ 9 8 7 6 5 ]) ( sort-by )","title":"Unique but not ordered"},{"location":"data-structures/set/#looking-up-values-in-a-set","text":"( # { :a :b :c } :c ) ( # { :a :b :c } :z ) Sets can also use the contains? function to see if a value exists in a set ( contains? # { \"Palpatine\" \"Darth Vader\" \"Boba Fett\" \"Darth Tyranus\" } \"Darth Vader\" )","title":"Looking up values in a set"},{"location":"data-structures/shared-memory/","text":"Shared memory with Persistent data structures \u03bb\ufe0e The Clojure data structures are immutable, so they initially seem similar to constants rather than variables. Once a collection is created, it cannot be changed. Any functions that run on a collection do not change the collection, instead they return a new collection with the respective changes. Creating a new collection each time may seem inefficient, however, the persistent collections use a sharing model. When a new collection is created, it links to all the relevant elements of the original collection and adds any new elements. Hint Read the InfoQ article on An In-Depth Look at Clojure Collections .","title":"Shared memory with Persistent data structures"},{"location":"data-structures/shared-memory/#shared-memory-with-persistent-data-structures","text":"The Clojure data structures are immutable, so they initially seem similar to constants rather than variables. Once a collection is created, it cannot be changed. Any functions that run on a collection do not change the collection, instead they return a new collection with the respective changes. Creating a new collection each time may seem inefficient, however, the persistent collections use a sharing model. When a new collection is created, it links to all the relevant elements of the original collection and adds any new elements. Hint Read the InfoQ article on An In-Depth Look at Clojure Collections .","title":"Shared memory with Persistent data structures"},{"location":"data-structures/vector/","text":"Vector \u03bb\ufe0e Vectors are an indexed sequential collections of data, basically the same as arrays in other languages. However, there are several differences. The index for a vector starts at 0, just like arrays in other languages. Vectors are written using square brackets [] with any number of pieces of data inside them, separated by spaces. Note Experiment with creating vectors for your data structures ( vector 1 2 3 4 ) [ 1 2 3 4 5 ] [ 56.9 60.2 61.8 63.1 54.3 66.4 66.5 68.1 70.2 69.2 63.1 57.1 ] [] ( def pi 3.1435893 ) [ 1 2.4 pi 11/4 5.0 6 7 ] [ :cat :dog :rabbit :fish ] [{ :cat 1 } \"fish\" \"potatoes\" \"oil\" ( str \"who ate my\" \"fish n chips\" )] ;; Include other data structures in vectors, in this example a list is an element of the vector [ 1 2 3 ' ( 4 5 6 )] ;; Are duplicate elements allowed ? [ 1 2 3 4 1 ] Note What can you do with vectors? Vectors are easy to add more items to, delete items from, or pull arbitrary items out of. Here are some functions that operate on vectors. ( vector? [ 5 10 15 ]) ( = [] []) ( = [] [ 1 ]) ( first [ 5 10 15 ]) ( rest [ 5 10 15 ]) ( nth [ 5 10 15 ] 1 ) ( count [ 5 10 15 ]) ( conj [ 5 10 ] 15 ) Hint When a function is effectively asking if a value is true or false, its referred to as a predicate function . Its common practice in Clojure to place a ? at the end of that functions name. Lookup data from a Vector \u03bb\ufe0e ([ 1 2 3 ] 1 ) ;; ([1 2 3] 1 2) ;; wrong number of arguments, vectors behaving as a function expect one parameter ;; ((1 2 3) 1) ;; you cant treat lists in the same way, there is another approach - assoc Changing vectors \u03bb\ufe0e The next two functions are used to make new vectors. The vector function takes any number of items and puts them in a new vector. conj takes a vector and an item and returns a new vector with that item added to the end. The function name is taken from the verb \"conjugate\", meaning \"to join together. Remember that collections in Clojure are immutable , so when we say that a function \"adds to\" or \"removes from\" a collection, what we mean is that the function returns a new collection with an item added or removed. Note Using one or more vectors, create a data structure of the high temperatures for the next 7 days in your area. Use the nth function to get the high temperature for next Friday","title":"Vector"},{"location":"data-structures/vector/#vector","text":"Vectors are an indexed sequential collections of data, basically the same as arrays in other languages. However, there are several differences. The index for a vector starts at 0, just like arrays in other languages. Vectors are written using square brackets [] with any number of pieces of data inside them, separated by spaces. Note Experiment with creating vectors for your data structures ( vector 1 2 3 4 ) [ 1 2 3 4 5 ] [ 56.9 60.2 61.8 63.1 54.3 66.4 66.5 68.1 70.2 69.2 63.1 57.1 ] [] ( def pi 3.1435893 ) [ 1 2.4 pi 11/4 5.0 6 7 ] [ :cat :dog :rabbit :fish ] [{ :cat 1 } \"fish\" \"potatoes\" \"oil\" ( str \"who ate my\" \"fish n chips\" )] ;; Include other data structures in vectors, in this example a list is an element of the vector [ 1 2 3 ' ( 4 5 6 )] ;; Are duplicate elements allowed ? [ 1 2 3 4 1 ] Note What can you do with vectors? Vectors are easy to add more items to, delete items from, or pull arbitrary items out of. Here are some functions that operate on vectors. ( vector? [ 5 10 15 ]) ( = [] []) ( = [] [ 1 ]) ( first [ 5 10 15 ]) ( rest [ 5 10 15 ]) ( nth [ 5 10 15 ] 1 ) ( count [ 5 10 15 ]) ( conj [ 5 10 ] 15 ) Hint When a function is effectively asking if a value is true or false, its referred to as a predicate function . Its common practice in Clojure to place a ? at the end of that functions name.","title":"Vector"},{"location":"data-structures/vector/#lookup-data-from-a-vector","text":"([ 1 2 3 ] 1 ) ;; ([1 2 3] 1 2) ;; wrong number of arguments, vectors behaving as a function expect one parameter ;; ((1 2 3) 1) ;; you cant treat lists in the same way, there is another approach - assoc","title":"Lookup data from a Vector"},{"location":"data-structures/vector/#changing-vectors","text":"The next two functions are used to make new vectors. The vector function takes any number of items and puts them in a new vector. conj takes a vector and an item and returns a new vector with that item added to the end. The function name is taken from the verb \"conjugate\", meaning \"to join together. Remember that collections in Clojure are immutable , so when we say that a function \"adds to\" or \"removes from\" a collection, what we mean is that the function returns a new collection with an item added or removed. Note Using one or more vectors, create a data structure of the high temperatures for the next 7 days in your area. Use the nth function to get the high temperature for next Friday","title":"Changing vectors"},{"location":"data-structures/hash-maps/","text":"Data Structures: Hash-maps \u03bb\ufe0e Associative collection of key value pairs Useful for defining self-describing structured data (assuming meaningful key names are used) A map is a key / value pair data structure. Keys are usually defined using a keyword, although they can be strings or anything else. Keywords point to themselves, so using them for the keys makes it very easy to get values out of the map, or for updating existing values in the map. Note Explore creating maps { :key \"value\" } { :key :value } { \"key\" \"value\" } ( \"key\" :value ) ( :meaining-of-life 42 ) { :a 1 :b 2 :c 3 } { :monday 1 :tuesday 2 :wednesday 3 :thursday 4 :friday 5 :saturday 6 :sunday 7 } { 1 \"Monday\" 2 \"Tuesday\" 3 \"Wednesday\" 4 \"Thursday\" 5 \"Friday\" 6 \"Saturday\" 7 \"Sunday\" } Hint::Comma characters are treated as white-space \u03bb\ufe0e The comma character is rarely used in Clojure hash-maps as it is ignored by Clojure. When coming from other languages, it may be initially comforting to include commas. Nested data models \u03bb\ufe0e nested maps to create a hierachy or path for data. This can add more context to the overall design various types of data Hint::One data structure to rule them all \u03bb\ufe0e It is preferred to have a single data structure to model the data of a system, which is them used by all the functions of that system. An example is in the state used for an application, e.g. Practicalli website practicalli.data namespace If there is no logical connection between data across a system, then data should be grouped into one structure per namespace as a minimal approach. Example use: Data sets \u03bb\ufe0e A collection of maps which have the same form, e.g. a vector of hash-maps with the same keys Example: meteorological recordings ( def recording-station-876WA [{ :timestamp \"2021-12-01T12:00\" :location { :latitude 24.3453434 :longitude 10.348888 } :temperature 12.4 :rainfail 0.1 :uv-level 0.4 } { :timestamp \"2021-12-01T12:10\" :location { :latitude 24.3453434 :longitude 10.348888 } :temperature 12.6 :rainfail 0.1 :uv-level 0.45 } { :timestamp \"2021-12-01T12:00\" :location { :latitude 24.3453434 :longitude 10.348888 } :temperature 12.9 :rainfail 0.1 :uv-level 0.5 }]) Providing a collection of consistent hash-map data structures is very easy to work with in Clojure. reduce , filter and map functions can easily process this form of data as part of algorithms to interpret the meaning from a data set. As each recording station creates the same types of data, then they can be merged by including the recording station id in the map","title":"Data Structures: Hash-maps"},{"location":"data-structures/hash-maps/#data-structures-hash-maps","text":"Associative collection of key value pairs Useful for defining self-describing structured data (assuming meaningful key names are used) A map is a key / value pair data structure. Keys are usually defined using a keyword, although they can be strings or anything else. Keywords point to themselves, so using them for the keys makes it very easy to get values out of the map, or for updating existing values in the map. Note Explore creating maps { :key \"value\" } { :key :value } { \"key\" \"value\" } ( \"key\" :value ) ( :meaining-of-life 42 ) { :a 1 :b 2 :c 3 } { :monday 1 :tuesday 2 :wednesday 3 :thursday 4 :friday 5 :saturday 6 :sunday 7 } { 1 \"Monday\" 2 \"Tuesday\" 3 \"Wednesday\" 4 \"Thursday\" 5 \"Friday\" 6 \"Saturday\" 7 \"Sunday\" }","title":"Data Structures: Hash-maps"},{"location":"data-structures/hash-maps/#hintcomma-characters-are-treated-as-white-space","text":"The comma character is rarely used in Clojure hash-maps as it is ignored by Clojure. When coming from other languages, it may be initially comforting to include commas.","title":"Hint::Comma characters are treated as white-space"},{"location":"data-structures/hash-maps/#nested-data-models","text":"nested maps to create a hierachy or path for data. This can add more context to the overall design various types of data","title":"Nested data models"},{"location":"data-structures/hash-maps/#hintone-data-structure-to-rule-them-all","text":"It is preferred to have a single data structure to model the data of a system, which is them used by all the functions of that system. An example is in the state used for an application, e.g. Practicalli website practicalli.data namespace If there is no logical connection between data across a system, then data should be grouped into one structure per namespace as a minimal approach.","title":"Hint::One data structure to rule them all"},{"location":"data-structures/hash-maps/#example-use-data-sets","text":"A collection of maps which have the same form, e.g. a vector of hash-maps with the same keys Example: meteorological recordings ( def recording-station-876WA [{ :timestamp \"2021-12-01T12:00\" :location { :latitude 24.3453434 :longitude 10.348888 } :temperature 12.4 :rainfail 0.1 :uv-level 0.4 } { :timestamp \"2021-12-01T12:10\" :location { :latitude 24.3453434 :longitude 10.348888 } :temperature 12.6 :rainfail 0.1 :uv-level 0.45 } { :timestamp \"2021-12-01T12:00\" :location { :latitude 24.3453434 :longitude 10.348888 } :temperature 12.9 :rainfail 0.1 :uv-level 0.5 }]) Providing a collection of consistent hash-map data structures is very easy to work with in Clojure. reduce , filter and map functions can easily process this form of data as part of algorithms to interpret the meaning from a data set. As each recording station creates the same types of data, then they can be merged by including the recording station id in the map","title":"Example use: Data sets"},{"location":"data-structures/hash-maps/access/","text":"Accessing hash-maps \u03bb\ufe0e The values in a hash-map can be accessed in multiple ways get get-in contains? using hash-map as a function use :keyword as a function threading hash-map through one or more keys Clojure provides a get function that returns the value mapped to a key in a set or map. get and get-in functions \u03bb\ufe0e get is a very explicitly named function that makes its purpose very clear. The get function works regardless of the type of keys used in the hash-map. (get map key) get-in has the same quality, for use with nested hash-maps. ( get-in nested-map [ :keys :path ]) Hint::missing or incorrect key \u03bb\ufe0e If the key in the path is missing or the path is missing (or nil) then get-in will return more of the hash-map than expected. ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} [ \"scores\" \"FSU\" ]) ;;=> 31 ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} [ \"scores\" ]) ;;=> {\"FSU\" 31, \"UF\" 7} ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} []) ;;=> {\"timestamp\" 1291578985220, \"scores\" {\"FSU\" 31, \"UF\" 7}} ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} nil ) ;;=> {\"timestamp\" 1291578985220, \"scores\" {\"FSU\" 31, \"UF\" 7}} Using hash-map as a function \u03bb\ufe0e A hash-map (and list, vector, set) can be called as a function with a key as the argument. This provides a more terse expression than using get and also works irrespective of key types used. Passing the key :star-wars to the hash-map returns the value associated with that key ({ :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}} :star-wars ) A nested hash-map (containing other hash-maps) can be accessed via multiple nested calls to the returned values. ((({ :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}} :star-wars ) :characters ) :jedi ) keyword key as a function \u03bb\ufe0e A keyword can be called as a function, taking a hash-map as an argument ( :star-wars { :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}}) A nested hash-map (containing other hash-maps) can be accessed via multiple nested calls to the returned values. ( :jedi ( :characters ( :star-wars { :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}}))) Threading macro \u03bb\ufe0e Using keyword keys as functions, the thread macros provide a consistent approach to accessing hash-map data The hash-map is passed through one or more keyword keys, so obtaining values from a flat or nested hash-map is just the same. ( -> hash-map :keyword1 ,,, ) If the keys are a type other than keywords, then a get function would be required for accessing the hash-map. ( -> hash-maps ( get \"scores\" ) ( get \"FSU\" )) As part of a processing pipeline, taking specific values from a JSON file of association football match statistics ( -> match-statistics.json ( clojure.data.json/read-str :key-fn keyword ) :totals :goals-home-team ) Checking a key or value exists in a hash-map \u03bb\ufe0e keys function will return a collection of the keys contained in a map. vals returns a collection of the values is in a map or set. In general I use the value returned from a map or set to determine if a key exists - the following snippet uses that pattern. Check if a key has a specific value ( if ( star-wars-map :space-ships ) ( do-true-behaviours ) ( do-false-behaviours )) Check a key has a specific value and also use that value TODO: is this a good case for if-lets This pattern fails if the value of :key is nil. contains? and some \u03bb\ufe0e contains? checks for the index of a collection. The index of a hash-map is the keys it contains some will check for a value in a collection ( def recipe-map { :ingredients \"tofu\" }) ( contains? recipe-map :ingredients ) ;; => true ( some # { \"tofu\" } recipe-map ) ;; => nil ( vals recipe-map ) ;; => (\"tofu\") ( some # { \"tofu\" } ( vals recipe-map )) ;; => \"tofu\" The key is contained as part of the hash-map index, irrespective of the value associated with that key (so long as there is a legal value associate with the key). ( contains? { :totals nil } :totals )","title":"Accessing hash-maps"},{"location":"data-structures/hash-maps/access/#accessing-hash-maps","text":"The values in a hash-map can be accessed in multiple ways get get-in contains? using hash-map as a function use :keyword as a function threading hash-map through one or more keys Clojure provides a get function that returns the value mapped to a key in a set or map.","title":"Accessing hash-maps"},{"location":"data-structures/hash-maps/access/#get-and-get-in-functions","text":"get is a very explicitly named function that makes its purpose very clear. The get function works regardless of the type of keys used in the hash-map. (get map key) get-in has the same quality, for use with nested hash-maps. ( get-in nested-map [ :keys :path ])","title":"get and get-in functions"},{"location":"data-structures/hash-maps/access/#hintmissing-or-incorrect-key","text":"If the key in the path is missing or the path is missing (or nil) then get-in will return more of the hash-map than expected. ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} [ \"scores\" \"FSU\" ]) ;;=> 31 ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} [ \"scores\" ]) ;;=> {\"FSU\" 31, \"UF\" 7} ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} []) ;;=> {\"timestamp\" 1291578985220, \"scores\" {\"FSU\" 31, \"UF\" 7}} ( get-in { \"timestamp\" 1291578985220 \"scores\" { \"FSU\" 31 \"UF\" 7 }} nil ) ;;=> {\"timestamp\" 1291578985220, \"scores\" {\"FSU\" 31, \"UF\" 7}}","title":"Hint::missing or incorrect key"},{"location":"data-structures/hash-maps/access/#using-hash-map-as-a-function","text":"A hash-map (and list, vector, set) can be called as a function with a key as the argument. This provides a more terse expression than using get and also works irrespective of key types used. Passing the key :star-wars to the hash-map returns the value associated with that key ({ :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}} :star-wars ) A nested hash-map (containing other hash-maps) can be accessed via multiple nested calls to the returned values. ((({ :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}} :star-wars ) :characters ) :jedi )","title":"Using hash-map as a function"},{"location":"data-structures/hash-maps/access/#keyword-key-as-a-function","text":"A keyword can be called as a function, taking a hash-map as an argument ( :star-wars { :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}}) A nested hash-map (containing other hash-maps) can be accessed via multiple nested calls to the returned values. ( :jedi ( :characters ( :star-wars { :star-wars { :characters { :jedi [ \"Luke\" \"Obiwan\" ]}}})))","title":"keyword key as a function"},{"location":"data-structures/hash-maps/access/#threading-macro","text":"Using keyword keys as functions, the thread macros provide a consistent approach to accessing hash-map data The hash-map is passed through one or more keyword keys, so obtaining values from a flat or nested hash-map is just the same. ( -> hash-map :keyword1 ,,, ) If the keys are a type other than keywords, then a get function would be required for accessing the hash-map. ( -> hash-maps ( get \"scores\" ) ( get \"FSU\" )) As part of a processing pipeline, taking specific values from a JSON file of association football match statistics ( -> match-statistics.json ( clojure.data.json/read-str :key-fn keyword ) :totals :goals-home-team )","title":"Threading macro"},{"location":"data-structures/hash-maps/access/#checking-a-key-or-value-exists-in-a-hash-map","text":"keys function will return a collection of the keys contained in a map. vals returns a collection of the values is in a map or set. In general I use the value returned from a map or set to determine if a key exists - the following snippet uses that pattern. Check if a key has a specific value ( if ( star-wars-map :space-ships ) ( do-true-behaviours ) ( do-false-behaviours )) Check a key has a specific value and also use that value TODO: is this a good case for if-lets This pattern fails if the value of :key is nil.","title":"Checking a key or value exists in a hash-map"},{"location":"data-structures/hash-maps/access/#contains-and-some","text":"contains? checks for the index of a collection. The index of a hash-map is the keys it contains some will check for a value in a collection ( def recipe-map { :ingredients \"tofu\" }) ( contains? recipe-map :ingredients ) ;; => true ( some # { \"tofu\" } recipe-map ) ;; => nil ( vals recipe-map ) ;; => (\"tofu\") ( some # { \"tofu\" } ( vals recipe-map )) ;; => \"tofu\" The key is contained as part of the hash-map index, irrespective of the value associated with that key (so long as there is a legal value associate with the key). ( contains? { :totals nil } :totals )","title":"contains? and some"},{"location":"data-structures/hash-maps/accessing-nested-hash-maps/","text":"Accessing Nested Hash-maps \u03bb\ufe0e Its also quite common to have maps made up of other maps, maps of vectors or vectors of maps. Now we can refer to the characters using keywords. Using the get function we return all the information about Luke ( get star-wars-characters :luke ) ( get ( get star-wars-characters :luke ) :fullname ) By wrapping the get function around our first, we can get a specific piece of information about Luke. There is also the get-in function that makes the syntax a little easier to read ( get-in star-wars-characters [ :luke :fullname ]) ( get-in star-wars-characters [ :vader :fullname ]) Or if you want the data driven approach, just talk to the map directly ( star-wars-characters :luke ) ( :fullname ( :luke star-wars-characters )) ( :skill ( :luke star-wars-characters )) ( star-wars-characters :vader ) ( :skill ( :vader star-wars-characters )) ( :fullname ( :vader star-wars-characters )) And finally we can also use the threading macro to minimise our code further ( -> star-wars-characters :luke ) ( -> star-wars-characters :luke :fullname ) ( -> star-wars-characters :luke :skill ) This technique is called destructuring. Find out more on Destructuring Duplicate keys in a map are not allowed, so the following maps... { \"fish\" \"battered\" \"chips\" \"fried\" \"fish\" \"battered and fried\" } { :fish \"battered\" :chips \"fried\" :fish \"battered & fried\" } ;; ...throw duplicate key errors ;; Duplicate values are okay though { :fish \"fried\" :chips \"fried\" :peas \"mushy\" }","title":"Accessing Nested Hash-maps"},{"location":"data-structures/hash-maps/accessing-nested-hash-maps/#accessing-nested-hash-maps","text":"Its also quite common to have maps made up of other maps, maps of vectors or vectors of maps. Now we can refer to the characters using keywords. Using the get function we return all the information about Luke ( get star-wars-characters :luke ) ( get ( get star-wars-characters :luke ) :fullname ) By wrapping the get function around our first, we can get a specific piece of information about Luke. There is also the get-in function that makes the syntax a little easier to read ( get-in star-wars-characters [ :luke :fullname ]) ( get-in star-wars-characters [ :vader :fullname ]) Or if you want the data driven approach, just talk to the map directly ( star-wars-characters :luke ) ( :fullname ( :luke star-wars-characters )) ( :skill ( :luke star-wars-characters )) ( star-wars-characters :vader ) ( :skill ( :vader star-wars-characters )) ( :fullname ( :vader star-wars-characters )) And finally we can also use the threading macro to minimise our code further ( -> star-wars-characters :luke ) ( -> star-wars-characters :luke :fullname ) ( -> star-wars-characters :luke :skill ) This technique is called destructuring. Find out more on Destructuring Duplicate keys in a map are not allowed, so the following maps... { \"fish\" \"battered\" \"chips\" \"fried\" \"fish\" \"battered and fried\" } { :fish \"battered\" :chips \"fried\" :fish \"battered & fried\" } ;; ...throw duplicate key errors ;; Duplicate values are okay though { :fish \"fried\" :chips \"fried\" :peas \"mushy\" }","title":"Accessing Nested Hash-maps"},{"location":"data-structures/hash-maps/create/","text":"Creating Hash-maps \u03bb\ufe0e Hash-maps can be defined literally using {} and including zero or more key / value pairs. Keys and values can be any legal Clojure type. Keywords are very commonly used for keys as they provide a convenient way to look up values. Literal hash-map examples \u03bb\ufe0e A hash-map defining Obi-wan, a character from the Star Wars universe. { :name \"Obi-wan Kenobi\" :homeworld \"Stewjon\" } A hash-map defining Leia, another character from the Star Wars with additional information { :name \"Leia Skywalker\" :homeworld \"Alderaan\" :birthplace \"Polis Massa\" } Use def to bind a name to a hash-map, making it easier to pass the map to a function as an argument. ( def luke { :name \"Luke Skywalker\" :homeworld \"Tatooine\" :birthplace \"Polis Massa\" }) Data set of maps \u03bb\ufe0e Create a data set by defining a vector of hash-maps [{ :name \"Obi-wan Kenobi\" :homeworld \"Stewjon\" :occupation \"Jedi\" } { :name \"Jyn Erso\" :homeworld \"Vallt\" :occupation \"Soldier\" } { :name \"Leia Skywalker\" :homeworld \"Alderaan\" :occupation \"Senator\" } { :name \"Luke Skywalker\" :homeworld \"Tatooine\" :occupation \"Jedi\" } { :name \"Qui-Gon Jinn\" :homeworld \"Coruscant\" :occupation \"Jedi\" } { :name \"Padm\u00e9 Amidala\" :homeworld \"Naboo\" :occupation \"Senator\" } { :name \"Sheev Palpatine\" :homeworld \"Naboo\" :occupation \"Supreme Chancellor\" }] Example: nested hash-maps \u03bb\ufe0e Create a map to represent the world of Star Wars, including various characters & ships, indicating the factions that characters and ships belong to. Individual Star Wars characters can be defined using a map of maps { :luke { :name \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :name \"Darth Vader\" :skill \"Breaking the rules and peoples hearts\" } :jarjar { :name \"JarJar Binks\" :skill \"Failing upwards\" }} Hash-maps can also use other collections as values { :characters { :jedi [ \"Luke Skywalker\" \"Obiwan Kenobi\" ] :sith [ \"Darth Vader\" \"Darth Sideous\" ] :droids [ \"C3P0\" \"R2D2\" \"BB8\" ]} :ships { :rebel-alliance [ \"Millennium Falcon\" \"X-wing fighter\" ] :imperial-empire [ \"Intergalactic Cruiser\" \"Destroyer\" \"Im just making these up now\" ]}} Use the def function to bind a name to the Star Wars character information, making it easier to pass to several functions ( def star-wars-characters { :luke { :fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :fullname \"Darth Vader\" :skill \"Breaking the rules and peoples hearts\" } :jarjar { :fullname \"JarJar Binks\" :skill \"Failing upwards\" }}) Generating hash-maps \u03bb\ufe0e hash-map is a clojure.core function that returns a hash-map of the given arguments, or an empty hash-map, {} , if no arguments are given. Arguments should be key-value pairs, otherwise the function will return nil Converting collections to hash-maps \u03bb\ufe0e ( apply hash-map [ :a 1 :b 2 ]) ;;=> {:b 2 :a 1} Order of keys in a hash-map is not guaranteed. However, order of keys should be irrelevant as the keys are unique within a map. ( into {} ,,, ) map reduce merge returns a hash-map that is a merging of the key value pairs from all maps, for any duplicate keys the value from the last key (left to right) is used Setting default values \u03bb\ufe0e Calling a function with a hash-map as an argument is a flexible way to design the API of a namespace and Clojure application in general. As functions are talking a map, a function call with fewer or more keys than needed will still result in a successful call (alhtough results could be interesting) If fewer keys are passed then defaults can be set. merge can be used to ensure any required keys with default values are always present, and still over-ridden by keys passed in as an argument merge should passed the default key values first, with the argument map merged on top. This ensures all keys are present and that the argument values are used if duplicate keys exist between the maps. ( merge { :option1 \"default-value\" :option2 \"default-value\" } { :option1 \"custom-value\" }) ;;=> {:option1 \"custom-value\" :option2 \"default-value\"} The merge function can be used in a function to return the merged map of default and argument values When a function has a number of options with default values. ( defn parse-cli-tool-options \"Return the merged default options with any provided as a hash-map argument\" [ arguments ] ( merge { :replace false :report true :paths [ \".\" ]} arguments )) ( parse-cli-tool-options { :paths [ \"src\" \"test\" ] :report false }) ;; => {:replace false, :report false, :paths [\"src\" \"test\"]} If an empty hash-map is sent as an argument, the default values are returned ( parse-cli-tool-options {}) ;; => {:replace false, :report true, :paths [\".\"]} zipmap ( zipmap [ :a :b :c ] [ 1 2 3 ]) ;; => {:a 1, :b 2, :c 3} Custom merging with a function \u03bb\ufe0e Create a sub-set of existing map \u03bb\ufe0e filter \u03bb\ufe0e Create a sub-set of an existing map ;; #61 - Map Construction ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Difficulty: Easy ;; Topics: core-functions ;; Special Restrictions: zipmap ;; Write a function which takes a vector of keys and a vector of values and constructs a map from them. ;; Tests (= ( [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3}) (= ( [1 2 3 4] [\"one\" \"two\" \"three\"]) {1 \"one\", 2 \"two\", 3 \"three\"}) (= (__ [:foo :bar] [\"foo\" \"bar\" \"baz\"]) {:foo \"foo\", :bar \"bar\"}) ;; If we could use zipmap then the answer would be simple (zipmap [:a :b :c] [1 2 3]) ;; => {:a 1, :b 2, :c 3} (= (zipmap [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3}) ;; => true ;; So now we have to figure out the algorithm that zipmap uses ;; Analyse the problem ;; We want to create a paring of values from the first and second vectors ;; Then each pair should be made into a key value pair within a map data structure. ;; The map function will work over multiple collections, returning a single collection ;; A simple example of map function in action: (map str [:a :b :c] [1 2 3]) ;; => (\":a1\" \":b2\" \":c3\") ;; In stead of string, we could use hash-map (map hash-map [:a :b :c] [1 2 3]) ;; => ({:a 1} {:b 2} {:c 3}) ;; now we just need to put all the maps into one map, so perhaps merge will work (merge (map hash-map [:a :b :c] [1 2 3])) ;; => ({:a 1} {:b 2} {:c 3}) (conj (map hash-map [:a :b :c] [1 2 3])) ;; => ({:a 1} {:b 2} {:c 3}) (reduce conj (map hash-map [:a :b :c] [1 2 3])) ;; => {:c 3, :b 2, :a 1} ;; (reduce conj (map vectork ks vs)) ((fn [key-sequence value-sequence] (into {} (map vector key-sequence value-sequence))) [:a :b :c] [1 2 3]) ;; => {:a 1, :b 2, :c 3}","title":"Creating Hash-maps"},{"location":"data-structures/hash-maps/create/#creating-hash-maps","text":"Hash-maps can be defined literally using {} and including zero or more key / value pairs. Keys and values can be any legal Clojure type. Keywords are very commonly used for keys as they provide a convenient way to look up values.","title":"Creating Hash-maps"},{"location":"data-structures/hash-maps/create/#literal-hash-map-examples","text":"A hash-map defining Obi-wan, a character from the Star Wars universe. { :name \"Obi-wan Kenobi\" :homeworld \"Stewjon\" } A hash-map defining Leia, another character from the Star Wars with additional information { :name \"Leia Skywalker\" :homeworld \"Alderaan\" :birthplace \"Polis Massa\" } Use def to bind a name to a hash-map, making it easier to pass the map to a function as an argument. ( def luke { :name \"Luke Skywalker\" :homeworld \"Tatooine\" :birthplace \"Polis Massa\" })","title":"Literal hash-map examples"},{"location":"data-structures/hash-maps/create/#data-set-of-maps","text":"Create a data set by defining a vector of hash-maps [{ :name \"Obi-wan Kenobi\" :homeworld \"Stewjon\" :occupation \"Jedi\" } { :name \"Jyn Erso\" :homeworld \"Vallt\" :occupation \"Soldier\" } { :name \"Leia Skywalker\" :homeworld \"Alderaan\" :occupation \"Senator\" } { :name \"Luke Skywalker\" :homeworld \"Tatooine\" :occupation \"Jedi\" } { :name \"Qui-Gon Jinn\" :homeworld \"Coruscant\" :occupation \"Jedi\" } { :name \"Padm\u00e9 Amidala\" :homeworld \"Naboo\" :occupation \"Senator\" } { :name \"Sheev Palpatine\" :homeworld \"Naboo\" :occupation \"Supreme Chancellor\" }]","title":"Data set of maps"},{"location":"data-structures/hash-maps/create/#example-nested-hash-maps","text":"Create a map to represent the world of Star Wars, including various characters & ships, indicating the factions that characters and ships belong to. Individual Star Wars characters can be defined using a map of maps { :luke { :name \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :name \"Darth Vader\" :skill \"Breaking the rules and peoples hearts\" } :jarjar { :name \"JarJar Binks\" :skill \"Failing upwards\" }} Hash-maps can also use other collections as values { :characters { :jedi [ \"Luke Skywalker\" \"Obiwan Kenobi\" ] :sith [ \"Darth Vader\" \"Darth Sideous\" ] :droids [ \"C3P0\" \"R2D2\" \"BB8\" ]} :ships { :rebel-alliance [ \"Millennium Falcon\" \"X-wing fighter\" ] :imperial-empire [ \"Intergalactic Cruiser\" \"Destroyer\" \"Im just making these up now\" ]}} Use the def function to bind a name to the Star Wars character information, making it easier to pass to several functions ( def star-wars-characters { :luke { :fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :fullname \"Darth Vader\" :skill \"Breaking the rules and peoples hearts\" } :jarjar { :fullname \"JarJar Binks\" :skill \"Failing upwards\" }})","title":"Example: nested hash-maps"},{"location":"data-structures/hash-maps/create/#generating-hash-maps","text":"hash-map is a clojure.core function that returns a hash-map of the given arguments, or an empty hash-map, {} , if no arguments are given. Arguments should be key-value pairs, otherwise the function will return nil","title":"Generating hash-maps"},{"location":"data-structures/hash-maps/create/#converting-collections-to-hash-maps","text":"( apply hash-map [ :a 1 :b 2 ]) ;;=> {:b 2 :a 1} Order of keys in a hash-map is not guaranteed. However, order of keys should be irrelevant as the keys are unique within a map. ( into {} ,,, ) map reduce merge returns a hash-map that is a merging of the key value pairs from all maps, for any duplicate keys the value from the last key (left to right) is used","title":"Converting collections to hash-maps"},{"location":"data-structures/hash-maps/create/#setting-default-values","text":"Calling a function with a hash-map as an argument is a flexible way to design the API of a namespace and Clojure application in general. As functions are talking a map, a function call with fewer or more keys than needed will still result in a successful call (alhtough results could be interesting) If fewer keys are passed then defaults can be set. merge can be used to ensure any required keys with default values are always present, and still over-ridden by keys passed in as an argument merge should passed the default key values first, with the argument map merged on top. This ensures all keys are present and that the argument values are used if duplicate keys exist between the maps. ( merge { :option1 \"default-value\" :option2 \"default-value\" } { :option1 \"custom-value\" }) ;;=> {:option1 \"custom-value\" :option2 \"default-value\"} The merge function can be used in a function to return the merged map of default and argument values When a function has a number of options with default values. ( defn parse-cli-tool-options \"Return the merged default options with any provided as a hash-map argument\" [ arguments ] ( merge { :replace false :report true :paths [ \".\" ]} arguments )) ( parse-cli-tool-options { :paths [ \"src\" \"test\" ] :report false }) ;; => {:replace false, :report false, :paths [\"src\" \"test\"]} If an empty hash-map is sent as an argument, the default values are returned ( parse-cli-tool-options {}) ;; => {:replace false, :report true, :paths [\".\"]} zipmap ( zipmap [ :a :b :c ] [ 1 2 3 ]) ;; => {:a 1, :b 2, :c 3}","title":"Setting default values"},{"location":"data-structures/hash-maps/create/#custom-merging-with-a-function","text":"","title":"Custom merging with a function"},{"location":"data-structures/hash-maps/create/#create-a-sub-set-of-existing-map","text":"","title":"Create a sub-set of existing map"},{"location":"data-structures/hash-maps/create/#filter","text":"Create a sub-set of an existing map ;; #61 - Map Construction ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Difficulty: Easy ;; Topics: core-functions ;; Special Restrictions: zipmap ;; Write a function which takes a vector of keys and a vector of values and constructs a map from them. ;; Tests (= ( [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3}) (= ( [1 2 3 4] [\"one\" \"two\" \"three\"]) {1 \"one\", 2 \"two\", 3 \"three\"}) (= (__ [:foo :bar] [\"foo\" \"bar\" \"baz\"]) {:foo \"foo\", :bar \"bar\"}) ;; If we could use zipmap then the answer would be simple (zipmap [:a :b :c] [1 2 3]) ;; => {:a 1, :b 2, :c 3} (= (zipmap [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3}) ;; => true ;; So now we have to figure out the algorithm that zipmap uses ;; Analyse the problem ;; We want to create a paring of values from the first and second vectors ;; Then each pair should be made into a key value pair within a map data structure. ;; The map function will work over multiple collections, returning a single collection ;; A simple example of map function in action: (map str [:a :b :c] [1 2 3]) ;; => (\":a1\" \":b2\" \":c3\") ;; In stead of string, we could use hash-map (map hash-map [:a :b :c] [1 2 3]) ;; => ({:a 1} {:b 2} {:c 3}) ;; now we just need to put all the maps into one map, so perhaps merge will work (merge (map hash-map [:a :b :c] [1 2 3])) ;; => ({:a 1} {:b 2} {:c 3}) (conj (map hash-map [:a :b :c] [1 2 3])) ;; => ({:a 1} {:b 2} {:c 3}) (reduce conj (map hash-map [:a :b :c] [1 2 3])) ;; => {:c 3, :b 2, :a 1} ;; (reduce conj (map vectork ks vs)) ((fn [key-sequence value-sequence] (into {} (map vector key-sequence value-sequence))) [:a :b :c] [1 2 3]) ;; => {:a 1, :b 2, :c 3}","title":"filter"},{"location":"data-structures/hash-maps/update/","text":"Update Hash-maps \u03bb\ufe0e","title":"Update Hash-maps"},{"location":"data-structures/hash-maps/update/#update-hash-maps","text":"","title":"Update Hash-maps"},{"location":"defining-behaviour-with-functions/","text":"Defining behaviours with functions \u03bb\ufe0e Clojure has functions, rather than methods for defining behaviour / \"algorithms\" Clojure design at its most basic comprises: - one or more data structures - functions that process those data-structures There is a common saying in Clojure: \"Its better to have one data structure and many functions, than many data structures and many functions\"","title":"Defining behaviours with functions"},{"location":"defining-behaviour-with-functions/#defining-behaviours-with-functions","text":"Clojure has functions, rather than methods for defining behaviour / \"algorithms\" Clojure design at its most basic comprises: - one or more data structures - functions that process those data-structures There is a common saying in Clojure: \"Its better to have one data structure and many functions, than many data structures and many functions\"","title":"Defining behaviours with functions"},{"location":"defining-behaviour-with-functions/anonymous-functions/","text":"Anonymous Functions \u03bb\ufe0e clojure.core/fn is a function for defining custom functions. fn is called the anonymous function as it has no external name by which it can be referred by. They are used within the scope of another function call, as having no name they cannot be called from another part of the code. ( map ( fn [ args ] ,,, ) [ 1 2 3 ]) (( fn [ args ] ,,, )) The value of using anonymous functions comes when there is a short, specific piece of behaviour required which is unlikely to be needed elsewhere in the code. An anonymous function can always be refactored into a defn expression if used in multiple places. Definition of an anonymous function \u03bb\ufe0e ( fn [ argument ] ( str \"some behaviour, typically using the arguments passed:\" argument )) This expression is a function call to fn which has the arguments called argument Calling an anonymous function \u03bb\ufe0e To get a value from evaluating this function you need to pass it a value (or another function) as an argument, as well as calling it as a function by placing the anonymous function as the first element of a list. ((fn [arguments] (str \"behaviour, typically using the arguments passed: \" arguments )) \"Is this the right room for an argument\") Binding a local names \u03bb\ufe0e fn can have a local name which can be used to write a recursive function (a fn that calls itself). Adding a name also helps with debugging code, as the name will be used to identify that function call if it appears in a stack trace of an exception. A recursive function that counts the elements in a collection ( fn -count [ xs ] ( if ( empty? xs ) 0 ( inc ( -count ( rest xs ))))) ( fn meaningful-name [] ( str \"If I fail, you will know my name\" )) Anonymous function Syntactic Sugar \u03bb\ufe0e There is a short form of the function definition using the #( ,,, ) syntax. For example, if we want to increment an argument we could start to define an anonymous function as follows: #(inc %) The % represents a placeholder for an argument that is passed into the anonymous function. This argument is anonymous as well as the value is simply swapped into the position of % . To evaluate this anonymous function we need to give it an argument to work on. Anything after the anonymous function is taken as its argument. So in the following expression we pass the value 1 as the argument and we should get the result of incrementing 1 as a result ( #(inc %) 1 ) ;; => 2 The % placeholder can also refer to a specific argument by adding an index number. The index numbers refer to the position of the arguments supplied to the anonymous function. Here we will add two different arguments together ( #(+ %1 %2) 20 22) So %1 will represent the first argument and the %2 will represent the second argument passed to this function. Sometimes position can be important as the following two versions of code demonstrate ( #(/ %1 %2) 24 6) ( #(/ %2 %1) 24 6) These two expressions give different values (and return different types, Integer and Ratio) as the positions of the arguments have been reversed.","title":"Anonymous Functions"},{"location":"defining-behaviour-with-functions/anonymous-functions/#anonymous-functions","text":"clojure.core/fn is a function for defining custom functions. fn is called the anonymous function as it has no external name by which it can be referred by. They are used within the scope of another function call, as having no name they cannot be called from another part of the code. ( map ( fn [ args ] ,,, ) [ 1 2 3 ]) (( fn [ args ] ,,, )) The value of using anonymous functions comes when there is a short, specific piece of behaviour required which is unlikely to be needed elsewhere in the code. An anonymous function can always be refactored into a defn expression if used in multiple places.","title":"Anonymous Functions"},{"location":"defining-behaviour-with-functions/anonymous-functions/#definition-of-an-anonymous-function","text":"( fn [ argument ] ( str \"some behaviour, typically using the arguments passed:\" argument )) This expression is a function call to fn which has the arguments called argument","title":"Definition of an anonymous function"},{"location":"defining-behaviour-with-functions/anonymous-functions/#calling-an-anonymous-function","text":"To get a value from evaluating this function you need to pass it a value (or another function) as an argument, as well as calling it as a function by placing the anonymous function as the first element of a list. ((fn [arguments] (str \"behaviour, typically using the arguments passed: \" arguments )) \"Is this the right room for an argument\")","title":"Calling an anonymous function"},{"location":"defining-behaviour-with-functions/anonymous-functions/#binding-a-local-names","text":"fn can have a local name which can be used to write a recursive function (a fn that calls itself). Adding a name also helps with debugging code, as the name will be used to identify that function call if it appears in a stack trace of an exception. A recursive function that counts the elements in a collection ( fn -count [ xs ] ( if ( empty? xs ) 0 ( inc ( -count ( rest xs ))))) ( fn meaningful-name [] ( str \"If I fail, you will know my name\" ))","title":"Binding a local names"},{"location":"defining-behaviour-with-functions/anonymous-functions/#anonymous-function-syntactic-sugar","text":"There is a short form of the function definition using the #( ,,, ) syntax. For example, if we want to increment an argument we could start to define an anonymous function as follows: #(inc %) The % represents a placeholder for an argument that is passed into the anonymous function. This argument is anonymous as well as the value is simply swapped into the position of % . To evaluate this anonymous function we need to give it an argument to work on. Anything after the anonymous function is taken as its argument. So in the following expression we pass the value 1 as the argument and we should get the result of incrementing 1 as a result ( #(inc %) 1 ) ;; => 2 The % placeholder can also refer to a specific argument by adding an index number. The index numbers refer to the position of the arguments supplied to the anonymous function. Here we will add two different arguments together ( #(+ %1 %2) 20 22) So %1 will represent the first argument and the %2 will represent the second argument passed to this function. Sometimes position can be important as the following two versions of code demonstrate ( #(/ %1 %2) 24 6) ( #(/ %2 %1) 24 6) These two expressions give different values (and return different types, Integer and Ratio) as the positions of the arguments have been reversed.","title":"Anonymous function Syntactic Sugar"},{"location":"defining-behaviour-with-functions/calling-functions/","text":"Calling Functions \u03bb\ufe0e To call a function in Clojure you use the name of the function as the first element of a list. In this simple example, a function is defined that takes no arguments, then that function is called. ( defn my-function [] ( str \"I only return this string\" )) ( my-function ) Functions can be defined to take arguments. Arity \u03bb\ufe0e This is the term to describe the number of arguments a function takes. This can be a fixed number or variable number of arguments. Simple polymorphism can also be used to have one function take different numbers of arguments, as with the multi-arity function in the examples below. ( defn single-arity [] ( str \"I do not take any arguments\" )) ( defn single-arity [ argument ] ( str \"I take 1 argument only\" )) ( defn triple-arity [ argument1 argument2 argument3 ] ( str \"I take 3 arguments only\" )) ( defn multi-arity ([ argument ] ( str \"I match 1 argument only\" )) ([ argument1 argument2 ] ( str \"I match when 2 arguments are used\" ))) ( defn variable-arity [ argument & more-arguments ] ( str \"I assign the first argument to argument, all other arguments to more-arguments\" ))","title":"Calling Functions"},{"location":"defining-behaviour-with-functions/calling-functions/#calling-functions","text":"To call a function in Clojure you use the name of the function as the first element of a list. In this simple example, a function is defined that takes no arguments, then that function is called. ( defn my-function [] ( str \"I only return this string\" )) ( my-function ) Functions can be defined to take arguments.","title":"Calling Functions"},{"location":"defining-behaviour-with-functions/calling-functions/#arity","text":"This is the term to describe the number of arguments a function takes. This can be a fixed number or variable number of arguments. Simple polymorphism can also be used to have one function take different numbers of arguments, as with the multi-arity function in the examples below. ( defn single-arity [] ( str \"I do not take any arguments\" )) ( defn single-arity [ argument ] ( str \"I take 1 argument only\" )) ( defn triple-arity [ argument1 argument2 argument3 ] ( str \"I take 3 arguments only\" )) ( defn multi-arity ([ argument ] ( str \"I match 1 argument only\" )) ([ argument1 argument2 ] ( str \"I match when 2 arguments are used\" ))) ( defn variable-arity [ argument & more-arguments ] ( str \"I assign the first argument to argument, all other arguments to more-arguments\" ))","title":"Arity"},{"location":"defining-behaviour-with-functions/examples/","text":"Examples \u03bb\ufe0e","title":"Examples"},{"location":"defining-behaviour-with-functions/examples/#examples","text":"","title":"Examples"},{"location":"defining-behaviour-with-functions/parameters/","text":"Parameters \u03bb\ufe0e","title":"Parameters"},{"location":"defining-behaviour-with-functions/parameters/#parameters","text":"","title":"Parameters"},{"location":"defining-behaviour-with-functions/syntax/","text":"Syntax \u03bb\ufe0e Defining functions is done with the fn function We have already seen the def function to assign names to values. We can also use the same function to give a name to our functions.","title":"Syntax"},{"location":"defining-behaviour-with-functions/syntax/#syntax","text":"Defining functions is done with the fn function We have already seen the def function to assign names to values. We can also use the same function to give a name to our functions.","title":"Syntax"},{"location":"designing-data-structures/","text":"Designing Data Structures \u03bb\ufe0e Some common design guides for data structures in Clojure The Basics design approach \u03bb\ufe0e Most data structures in Clojure seem to be created from either vectors or maps or a combination of both. Sets are used where uniqueness of values is important and lists are often used for their lazy properties. Vectors are the most flexible data structure in Clojure and support none-sequential access as they are indexed. Maps are really useful for defining semantic meaning to your data structures, helping you create data structures that express the context of the model they represent. Maps give you unordered, arbitrary index arrangement. Access is iteration of key/value pairs or getting a value for a given key. Lists give you sequential, one-at-a-time arrangement. They allow for efficient iteration, lazy generation, and stack discipline. Sets give you unordered, unique constraint arrangement. Access is iteration of elements or checking containment.","title":"Designing Data Structures"},{"location":"designing-data-structures/#designing-data-structures","text":"Some common design guides for data structures in Clojure","title":"Designing Data Structures"},{"location":"designing-data-structures/#the-basics-design-approach","text":"Most data structures in Clojure seem to be created from either vectors or maps or a combination of both. Sets are used where uniqueness of values is important and lists are often used for their lazy properties. Vectors are the most flexible data structure in Clojure and support none-sequential access as they are indexed. Maps are really useful for defining semantic meaning to your data structures, helping you create data structures that express the context of the model they represent. Maps give you unordered, arbitrary index arrangement. Access is iteration of key/value pairs or getting a value for a given key. Lists give you sequential, one-at-a-time arrangement. They allow for efficient iteration, lazy generation, and stack discipline. Sets give you unordered, unique constraint arrangement. Access is iteration of elements or checking containment.","title":"The Basics design approach"},{"location":"designing-data-structures/modeling-alphabet-codes/","text":"Model alphabet codes \u03bb\ufe0e Maps in Clojure are used to model key and value pairs. Keys must be unique within a map. A key can be a number, string or keyword. Vectors in Clojure are a general data structure that are good for handing any kind of information. Note Define a data structure where each letter of the alphabet is represented by a 6 digit binary code Lets define a name called alphabet that is bound to a map. Each key in the map is a character of the alphabet and each value is a vector of numbers that represent a binary code. The map also includes a binary code for a full stop and space character ( def alphabet { \"A\" [ 0 1 0 0 0 1 ] \"B\" [ 0 0 1 0 1 0 ] \"C\" [ 0 1 0 0 1 0 ] \"D\" [ 1 0 1 0 0 0 ] \"E\" [ 1 0 1 1 0 0 ] \"F\" [ 1 1 0 1 0 0 ] \"G\" [ 1 0 0 1 1 0 ] \"H\" [ 1 0 1 0 0 1 ] \"I\" [ 1 1 1 0 0 0 ] \"J\" [ 0 0 1 1 1 1 ] \"K\" [ 0 1 0 1 0 1 ] \"L\" [ 1 1 1 0 0 1 ] \"M\" [ 1 1 1 0 1 1 ] \"N\" [ 0 1 1 1 0 1 ] \"O\" [ 1 1 0 1 1 0 ] \"P\" [ 1 1 1 1 1 0 ] \"Q\" [ 1 0 1 1 1 0 ] \"R\" [ 1 1 1 1 0 0 ] \"S\" [ 0 1 1 1 1 0 ] \"T\" [ 1 0 0 1 1 1 ] \"U\" [ 0 0 1 0 1 1 ] \"V\" [ 0 1 1 0 0 1 ] \"W\" [ 1 1 0 1 0 1 ] \"X\" [ 1 0 1 0 1 0 ] \"Y\" [ 1 0 0 0 1 1 ] \"Z\" [ 1 1 0 0 1 1 ] \".\" [ 1 0 1 1 0 1 ] \" \" [ 0 0 1 0 0 0 ]})","title":"Model alphabet codes"},{"location":"designing-data-structures/modeling-alphabet-codes/#model-alphabet-codes","text":"Maps in Clojure are used to model key and value pairs. Keys must be unique within a map. A key can be a number, string or keyword. Vectors in Clojure are a general data structure that are good for handing any kind of information. Note Define a data structure where each letter of the alphabet is represented by a 6 digit binary code Lets define a name called alphabet that is bound to a map. Each key in the map is a character of the alphabet and each value is a vector of numbers that represent a binary code. The map also includes a binary code for a full stop and space character ( def alphabet { \"A\" [ 0 1 0 0 0 1 ] \"B\" [ 0 0 1 0 1 0 ] \"C\" [ 0 1 0 0 1 0 ] \"D\" [ 1 0 1 0 0 0 ] \"E\" [ 1 0 1 1 0 0 ] \"F\" [ 1 1 0 1 0 0 ] \"G\" [ 1 0 0 1 1 0 ] \"H\" [ 1 0 1 0 0 1 ] \"I\" [ 1 1 1 0 0 0 ] \"J\" [ 0 0 1 1 1 1 ] \"K\" [ 0 1 0 1 0 1 ] \"L\" [ 1 1 1 0 0 1 ] \"M\" [ 1 1 1 0 1 1 ] \"N\" [ 0 1 1 1 0 1 ] \"O\" [ 1 1 0 1 1 0 ] \"P\" [ 1 1 1 1 1 0 ] \"Q\" [ 1 0 1 1 1 0 ] \"R\" [ 1 1 1 1 0 0 ] \"S\" [ 0 1 1 1 1 0 ] \"T\" [ 1 0 0 1 1 1 ] \"U\" [ 0 0 1 0 1 1 ] \"V\" [ 0 1 1 0 0 1 ] \"W\" [ 1 1 0 1 0 1 ] \"X\" [ 1 0 1 0 1 0 ] \"Y\" [ 1 0 0 0 1 1 ] \"Z\" [ 1 1 0 0 1 1 ] \".\" [ 1 0 1 1 0 1 ] \" \" [ 0 0 1 0 0 0 ]})","title":"Model alphabet codes"},{"location":"designing-data-structures/modeling-name-generation-map/","text":"Design a map for name generation \u03bb\ufe0e Imagine you are writing a simple name generator that takes your name and creates an alternative version. For example this could be a generator of your \"Posh\" or \"Hipster\" name. Note Define a data structure to model sloane names that has three names for every letter of the alphabet. For name suggestions, see the Tattler sloane name generator . The following seems to be the simplest way to model the sloane names. This follows the representation in the original source material. ( def sloane-first-name { \"a\" \"Ally-Pally\" \"b\" \"Bongo\" \"c\" \"Chipper\" }) ( def slone-second-name { \"a\" \"Anstruther\" \"b\" \"Beaufort\" \"c\" \"Cholmondeley\" }) ( def slone-third-name { \"a\" \"Arbuthnot\" \"b\" \"Battenburg\" \"c\" \"Coutts\" }) The following alternative data structure design is very simple and more concise, however it does loose some of the semantic meaning. The position of the names is not defined in terms of the context of the problem. ( def slone-names { :a [ \"Ally-Pally\" \"Anstruther\" \"Arbuthnot\" ]}) This next design removes some of the redundancy in defining each letter of the alphabet several times. Apart from less typing and therefore reading by the development team, it also explicitly defines the semantic meaning of each name within the context of this problem. ( def slone-names { :a { :first \"Ally-Pally\" :second \"Anstruther\" :third \"Arbuthnot\" }}) For extra points you could try and implement a function that generated your sloane name. Creating the algorithm to construct your sloane name \u03bb\ufe0e The first sloane name is chosen from the first character of the first name The second sloane name chosen from the first character of the second name The third sloane name is chosen from the second character of the second name You can get the first element of a string by treating it just like a collection. However this returns a character ( first \"Strings also act as collections\" ) A string can be converted to a keyword, a character cannot ( keyword \"a\" ) A character can be converted to a string using the str function ( str ( first \"Strings also act as collections\" )) The keywords need to be the same case, so convert the first character to lower case (which returns a string, so the explicit str function is no longer required.) ( clojure.string/lower-case ( first \"Strings also act as collections\" )) Putting it all together. ( keyword ( clojure.string/lower-case ( first \"Strings also act as collections\" ))) Create a function to calculate your sloane name \u03bb\ufe0e Putting all this together in a function to generate your sloan name, given your a string with your first and last name. ( defn sloane-name \"Given a first and last name as a string, returns your equivalent Sloane name as a string\" [ name ] ( let [ first-name ( keyword ( clojure.string/lower-case ( first ( first ( clojure.string/split name # \" \" ))))) middle-name ( keyword ( clojure.string/lower-case ( first ( second ( clojure.string/split name # \" \" ))))) last-name ( keyword ( clojure.string/lower-case ( second ( second ( clojure.string/split name # \" \" )))))] ( str ( get-in slone-names [ first-name :first ]) \" \" ( get-in slone-names [ middle-name :second ]) \" \" ( get-in slone-names [ last-name :third ])))) Supply a name that will test if the sloane-name function works ( sloane-name \"Billy Abstainer\" ) ;; => \"Bongo Anstruther Battenburg\"","title":"Design a map for name generation"},{"location":"designing-data-structures/modeling-name-generation-map/#design-a-map-for-name-generation","text":"Imagine you are writing a simple name generator that takes your name and creates an alternative version. For example this could be a generator of your \"Posh\" or \"Hipster\" name. Note Define a data structure to model sloane names that has three names for every letter of the alphabet. For name suggestions, see the Tattler sloane name generator . The following seems to be the simplest way to model the sloane names. This follows the representation in the original source material. ( def sloane-first-name { \"a\" \"Ally-Pally\" \"b\" \"Bongo\" \"c\" \"Chipper\" }) ( def slone-second-name { \"a\" \"Anstruther\" \"b\" \"Beaufort\" \"c\" \"Cholmondeley\" }) ( def slone-third-name { \"a\" \"Arbuthnot\" \"b\" \"Battenburg\" \"c\" \"Coutts\" }) The following alternative data structure design is very simple and more concise, however it does loose some of the semantic meaning. The position of the names is not defined in terms of the context of the problem. ( def slone-names { :a [ \"Ally-Pally\" \"Anstruther\" \"Arbuthnot\" ]}) This next design removes some of the redundancy in defining each letter of the alphabet several times. Apart from less typing and therefore reading by the development team, it also explicitly defines the semantic meaning of each name within the context of this problem. ( def slone-names { :a { :first \"Ally-Pally\" :second \"Anstruther\" :third \"Arbuthnot\" }}) For extra points you could try and implement a function that generated your sloane name.","title":"Design a map for name generation"},{"location":"designing-data-structures/modeling-name-generation-map/#creating-the-algorithm-to-construct-your-sloane-name","text":"The first sloane name is chosen from the first character of the first name The second sloane name chosen from the first character of the second name The third sloane name is chosen from the second character of the second name You can get the first element of a string by treating it just like a collection. However this returns a character ( first \"Strings also act as collections\" ) A string can be converted to a keyword, a character cannot ( keyword \"a\" ) A character can be converted to a string using the str function ( str ( first \"Strings also act as collections\" )) The keywords need to be the same case, so convert the first character to lower case (which returns a string, so the explicit str function is no longer required.) ( clojure.string/lower-case ( first \"Strings also act as collections\" )) Putting it all together. ( keyword ( clojure.string/lower-case ( first \"Strings also act as collections\" )))","title":"Creating the algorithm to construct your sloane name"},{"location":"designing-data-structures/modeling-name-generation-map/#create-a-function-to-calculate-your-sloane-name","text":"Putting all this together in a function to generate your sloan name, given your a string with your first and last name. ( defn sloane-name \"Given a first and last name as a string, returns your equivalent Sloane name as a string\" [ name ] ( let [ first-name ( keyword ( clojure.string/lower-case ( first ( first ( clojure.string/split name # \" \" ))))) middle-name ( keyword ( clojure.string/lower-case ( first ( second ( clojure.string/split name # \" \" ))))) last-name ( keyword ( clojure.string/lower-case ( second ( second ( clojure.string/split name # \" \" )))))] ( str ( get-in slone-names [ first-name :first ]) \" \" ( get-in slone-names [ middle-name :second ]) \" \" ( get-in slone-names [ last-name :third ])))) Supply a name that will test if the sloane-name function works ( sloane-name \"Billy Abstainer\" ) ;; => \"Bongo Anstruther Battenburg\"","title":"Create a function to calculate your sloane name"},{"location":"designing-data-structures/with-maps-of-maps/","text":"With Maps of Maps \u03bb\ufe0e Note Define a collection of star-wars characters using a map of maps. Each character should have an name that they are typically referred to, along with their fullname and skill ( def star-wars-characters { :luke { :fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :fullname \"Darth Vader\" :skill \"Crank phone calls\" } :jarjar { :fullname \"JarJar Binks\" :skill \"Upsetting a generation of fans\" }}) Now we can refer to the characters using keywords. Using the get function we return all the information about Luke ( get star-wars-characters :luke ) By wrapping the get function around our first, we can get a specific piece of information about Luke ( get ( get star-wars-characters :luke ) :fullname ) There is also the get-in function that makes the syntax a little easier to read ( get-in star-wars-characters [ :luke :fullname ]) ( get-in star-wars-characters [ :vader :fullname ]) Or you can get really concise by just talking to the map directly ( star-wars-characters :luke ) ( :fullname ( :luke star-wars-characters )) ( :skill ( :luke star-wars-characters )) ( star-wars-characters :vader ) ( :skill ( :vader star-wars-characters )) ( :fullname ( :vader star-wars-characters )) And finally we can also use the threading macro to minimise our code further ( -> star-wars-characters :luke ) ( -> star-wars-characters :luke :fullname ) ( -> star-wars-characters :luke :skill ) Note * Create a slightly data structure holding data around several developer events. Each event should have a website address, event type, number of attendees, call for papers. ( def dev-event-details { :devoxxuk { :URL \"http://jaxlondon.co.uk\" :event-type \"Conference\" :number-of-attendees 700 :call-for-papers \"open\" } :hackthetower { :URL \"http://hackthetower.co.uk\" :event-type \"hackday\" :number-of-attendees 99 :call-for-papers \"closed\" }}) This data structure is just a map, with each key being the unique name of the developer event. The details of each event (the value to go with the event name key) is itself a map as there are several pieces of data associated with each event name. So we have a map where each value is itself a map. Call the data structure and see what it evaluates too, it should not be a surprise dev-event-details We can ask for the value of a specific key, and just that value is returned ( dev-event-details :devoxxuk ) In our example, the value returned from the :devoxxuk key is also a map, so we can ask for a specific part of that map value by again using its key ( :URL ( dev-event-details :devoxxuk ))","title":"With Maps of Maps"},{"location":"designing-data-structures/with-maps-of-maps/#with-maps-of-maps","text":"Note Define a collection of star-wars characters using a map of maps. Each character should have an name that they are typically referred to, along with their fullname and skill ( def star-wars-characters { :luke { :fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :fullname \"Darth Vader\" :skill \"Crank phone calls\" } :jarjar { :fullname \"JarJar Binks\" :skill \"Upsetting a generation of fans\" }}) Now we can refer to the characters using keywords. Using the get function we return all the information about Luke ( get star-wars-characters :luke ) By wrapping the get function around our first, we can get a specific piece of information about Luke ( get ( get star-wars-characters :luke ) :fullname ) There is also the get-in function that makes the syntax a little easier to read ( get-in star-wars-characters [ :luke :fullname ]) ( get-in star-wars-characters [ :vader :fullname ]) Or you can get really concise by just talking to the map directly ( star-wars-characters :luke ) ( :fullname ( :luke star-wars-characters )) ( :skill ( :luke star-wars-characters )) ( star-wars-characters :vader ) ( :skill ( :vader star-wars-characters )) ( :fullname ( :vader star-wars-characters )) And finally we can also use the threading macro to minimise our code further ( -> star-wars-characters :luke ) ( -> star-wars-characters :luke :fullname ) ( -> star-wars-characters :luke :skill ) Note * Create a slightly data structure holding data around several developer events. Each event should have a website address, event type, number of attendees, call for papers. ( def dev-event-details { :devoxxuk { :URL \"http://jaxlondon.co.uk\" :event-type \"Conference\" :number-of-attendees 700 :call-for-papers \"open\" } :hackthetower { :URL \"http://hackthetower.co.uk\" :event-type \"hackday\" :number-of-attendees 99 :call-for-papers \"closed\" }}) This data structure is just a map, with each key being the unique name of the developer event. The details of each event (the value to go with the event name key) is itself a map as there are several pieces of data associated with each event name. So we have a map where each value is itself a map. Call the data structure and see what it evaluates too, it should not be a surprise dev-event-details We can ask for the value of a specific key, and just that value is returned ( dev-event-details :devoxxuk ) In our example, the value returned from the :devoxxuk key is also a map, so we can ask for a specific part of that map value by again using its key ( :URL ( dev-event-details :devoxxuk ))","title":"With Maps of Maps"},{"location":"designing-data-structures/with-maps/","text":"With Maps \u03bb\ufe0e Maps allow you to model data with its contextual meaning. The keys of a map can give the context and the values are the specific data. Note Define a shopping list of items you want, including how many of each item you want to buy ( def shopping-list { \"cat food\" 10 \"soya milk\" 4 \"bread\" 1 \"cheese\" 2 }) Note Define a star-wars characters, eg. luke skywalker, jarjar binks. The star-wars character should include a name and a skill (it doesn't matter what these are). Use the 'get' function to return the value of a given key, eg. name. Use keywords to return a given value if you used keywords for the map keys. In this answer we have defined three different star-wars characters, all using the same map keys. ( def luke { :name \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" }) ( def darth { :name \"Darth Vader\" :skill \"Crank phone calls\" }) ( def jarjar { :name \"JarJar Binks\" :skill \"Upsetting a generation of fans\" }) Lets see what the specific skill luke has ( get luke :skill ) When you use a keyword, eg. :name, as the key in a map, then that keyword can be used as a function call on the map to return its associated value. Maps can also act as functions too. ( :name luke ) ( luke :name ) There are also specific functions that work on maps that give all the keys of a map and all the values of that map ( keys luke ) ( vals luke )","title":"With Maps"},{"location":"designing-data-structures/with-maps/#with-maps","text":"Maps allow you to model data with its contextual meaning. The keys of a map can give the context and the values are the specific data. Note Define a shopping list of items you want, including how many of each item you want to buy ( def shopping-list { \"cat food\" 10 \"soya milk\" 4 \"bread\" 1 \"cheese\" 2 }) Note Define a star-wars characters, eg. luke skywalker, jarjar binks. The star-wars character should include a name and a skill (it doesn't matter what these are). Use the 'get' function to return the value of a given key, eg. name. Use keywords to return a given value if you used keywords for the map keys. In this answer we have defined three different star-wars characters, all using the same map keys. ( def luke { :name \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" }) ( def darth { :name \"Darth Vader\" :skill \"Crank phone calls\" }) ( def jarjar { :name \"JarJar Binks\" :skill \"Upsetting a generation of fans\" }) Lets see what the specific skill luke has ( get luke :skill ) When you use a keyword, eg. :name, as the key in a map, then that keyword can be used as a function call on the map to return its associated value. Maps can also act as functions too. ( :name luke ) ( luke :name ) There are also specific functions that work on maps that give all the keys of a map and all the values of that map ( keys luke ) ( vals luke )","title":"With Maps"},{"location":"designing-data-structures/with-vectors-of-maps/","text":"A Vector of Maps \u03bb\ufe0e Vectors are good for holding any information whether that be simple values or other collections. Maps are good for defining data with semantic meaning, using the keys to express the context of the values. * Note Define a simple data structure for a collection of stocks in a portfolio. This would contain a collection of stock information, with each stock holding the ticker name, last trading monetary value and opening monetary value. This is a vector of maps, as there will be one or more company stocks to track. Each map represents the stock information for a company. ( def portfolio [ { :ticker \"CRM\" :lastTrade 233.12 :open 230.66 } { :ticker \"AAPL\" :lastTrade 203.25 :open 204.50 } { :ticker \"MSFT\" :lastTrade 29.12 :open 29.08 } { :ticker \"ORCL\" :lastTrade 21.90 :open 21.83 }]) We can get the value of the whole data structure by referring to it by name portfolio As the data structure is a vector (ie. array like) then we can ask for a specific element by its position in the array using the nth function Lets get the map that is the first element (again as a vector has array-like properties, the first element is referenced by zero) ( nth portfolio 0 ) The vector has 4 elements, so we can access the last element by referencing the vector using 3 ( nth portfolio 3 ) As portfolio is a collection, also known as a sequence, then we can use a number of functions that provide common ways of getting data from a data structure ( first portfolio ) ( rest portfolio ) ( last portfolio ) We can get specific information about the share in our portfolio, or as the keys in each map are defined with Clojure keywords, we can also use the keywords to return the specific values they pair with. ( get ( second portfolio ) :ticker ) ;; => \"AAPL\" ( :ticker ( first portfolio )) ;; => \"CRM\" If we want to get specific share information across the whole portfolio, then we can simply map the :ticker keyword over each share in portfolio ( map :ticker portfolio ) ;; => (\"CRM\" \"AAPL\" \"MSFT\" \"ORCL\") ( mapv :ticker portfolio ) ;; => [\"CRM\" \"AAPL\" \"MSFT\" \"ORCL\"]","title":"A Vector of Maps"},{"location":"designing-data-structures/with-vectors-of-maps/#a-vector-of-maps","text":"Vectors are good for holding any information whether that be simple values or other collections. Maps are good for defining data with semantic meaning, using the keys to express the context of the values. * Note Define a simple data structure for a collection of stocks in a portfolio. This would contain a collection of stock information, with each stock holding the ticker name, last trading monetary value and opening monetary value. This is a vector of maps, as there will be one or more company stocks to track. Each map represents the stock information for a company. ( def portfolio [ { :ticker \"CRM\" :lastTrade 233.12 :open 230.66 } { :ticker \"AAPL\" :lastTrade 203.25 :open 204.50 } { :ticker \"MSFT\" :lastTrade 29.12 :open 29.08 } { :ticker \"ORCL\" :lastTrade 21.90 :open 21.83 }]) We can get the value of the whole data structure by referring to it by name portfolio As the data structure is a vector (ie. array like) then we can ask for a specific element by its position in the array using the nth function Lets get the map that is the first element (again as a vector has array-like properties, the first element is referenced by zero) ( nth portfolio 0 ) The vector has 4 elements, so we can access the last element by referencing the vector using 3 ( nth portfolio 3 ) As portfolio is a collection, also known as a sequence, then we can use a number of functions that provide common ways of getting data from a data structure ( first portfolio ) ( rest portfolio ) ( last portfolio ) We can get specific information about the share in our portfolio, or as the keys in each map are defined with Clojure keywords, we can also use the keywords to return the specific values they pair with. ( get ( second portfolio ) :ticker ) ;; => \"AAPL\" ( :ticker ( first portfolio )) ;; => \"CRM\" If we want to get specific share information across the whole portfolio, then we can simply map the :ticker keyword over each share in portfolio ( map :ticker portfolio ) ;; => (\"CRM\" \"AAPL\" \"MSFT\" \"ORCL\") ( mapv :ticker portfolio ) ;; => [\"CRM\" \"AAPL\" \"MSFT\" \"ORCL\"]","title":"A Vector of Maps"},{"location":"designing-data-structures/with-vectors-of-vectors/","text":"With Vectors of Vectors \u03bb\ufe0e The most frequent use of you will see is in the project.clj file, where a vector of vectors is used to model the library dependencies for a project [[ org.clojure/clojure \"1.8.0\" ] [ org.clojure/core.match \"0.3.0-alpha4\" ]] [[ org.clojure/clojure \"1.6.0\" ] [ ring \"1.4.0-beta2\" ] [ compojure \"1.3.4\" ] [ hiccup \"1.0.5\" ]] Fixme Think of an exercise to create a vector of vectors as a data model","title":"With Vectors of Vectors"},{"location":"designing-data-structures/with-vectors-of-vectors/#with-vectors-of-vectors","text":"The most frequent use of you will see is in the project.clj file, where a vector of vectors is used to model the library dependencies for a project [[ org.clojure/clojure \"1.8.0\" ] [ org.clojure/core.match \"0.3.0-alpha4\" ]] [[ org.clojure/clojure \"1.6.0\" ] [ ring \"1.4.0-beta2\" ] [ compojure \"1.3.4\" ] [ hiccup \"1.0.5\" ]] Fixme Think of an exercise to create a vector of vectors as a data model","title":"With Vectors of Vectors"},{"location":"designing-data-structures/with-vectors/","text":"With Vectors \u03bb\ufe0e Vectors as the simplest data structure in Clojure to work with. They are very similar to an array in other languages, although they have additional qualities in Clojure. Vectors * can be of any length * are indexed so have fast random access * can contain any types * are immutable Define a data structure for a simple shopping list with any items you would typically want to buy. ( def shopping-list [ \"Cerial\" \"Baked Beans\" \"Cat food\" \"Quorn chicken pieces\" ])","title":"With Vectors"},{"location":"designing-data-structures/with-vectors/#with-vectors","text":"Vectors as the simplest data structure in Clojure to work with. They are very similar to an array in other languages, although they have additional qualities in Clojure. Vectors * can be of any length * are indexed so have fast random access * can contain any types * are immutable Define a data structure for a simple shopping list with any items you would typically want to buy. ( def shopping-list [ \"Cerial\" \"Baked Beans\" \"Cat food\" \"Quorn chicken pieces\" ])","title":"With Vectors"},{"location":"development-environments/","text":"Development Environments \u03bb\ufe0e This workshop encourages LightTable & Leiningen as the development environment, as they are the easiest tools to set up. Leiningen is the build automation tool used to manage Clojure projects. It will create projects from templates and run our Clojure environment (REPL). LightTable is a Clojure aware editor that supports the dynamic workflow of Clojure development in a REPL. LightTable is also written in Clojure (and ClojureScript). The following pages will show you how to set up LightTable and Leiningen.","title":"Development Environments"},{"location":"development-environments/#development-environments","text":"This workshop encourages LightTable & Leiningen as the development environment, as they are the easiest tools to set up. Leiningen is the build automation tool used to manage Clojure projects. It will create projects from templates and run our Clojure environment (REPL). LightTable is a Clojure aware editor that supports the dynamic workflow of Clojure development in a REPL. LightTable is also written in Clojure (and ClojureScript). The following pages will show you how to set up LightTable and Leiningen.","title":"Development Environments"},{"location":"development-environments/java/","text":"Java - a host platform for Clojure \u03bb\ufe0e You will need to have a Java Runtime Edition (usually installed on most computers by default) to run any Clojure applications. Version 8 is recommended (although version 6 & 7 should work). To test if you have Java on your computer, open a command line window and run the command java -version Installing the Java Runtime Edition \u03bb\ufe0e Download and install the latest Oracle Java SDK (version 1.8 at time of writing). Alternatively, install OpenJDK or Zulu build of OpenJDK Ubuntu \u03bb\ufe0e The OpenJDK is available as a package on Ubuntu and can be installed via the Ubuntu software center or via the command line: sudo apt-get install openjdk-8-jre Why is Java Required \u03bb\ufe0e Clojure was designed as a hosted language, which means it is developed and run on top of Java's Virtual Machine (JVM). However, its not necessary to learn the Java language to use Clojure . Clojure is compiled into Java bytecode when you evaluate the code. This compilation happens in the background so you dont usually see it happening. For example, if you are using the Clojure REPL then each time you evaluate an expression it is compiled into Java bytecode and then injected into the running REPL and the results are then returned. This all happens pretty instantaneously. Most of the current Clojure tooling was developed for Clojure on the JVM, for example Leiningen. As Clojure runs on Java you can also use all the other libraries that run on the Java Virtual machine, regardless of whether those libraries were written in Java, Clojure, Scala, JRuby, jython, Groovy, etc.","title":"Java"},{"location":"development-environments/java/#java-a-host-platform-for-clojure","text":"You will need to have a Java Runtime Edition (usually installed on most computers by default) to run any Clojure applications. Version 8 is recommended (although version 6 & 7 should work). To test if you have Java on your computer, open a command line window and run the command java -version","title":"Java - a host platform for Clojure"},{"location":"development-environments/java/#installing-the-java-runtime-edition","text":"Download and install the latest Oracle Java SDK (version 1.8 at time of writing). Alternatively, install OpenJDK or Zulu build of OpenJDK","title":"Installing the Java Runtime Edition"},{"location":"development-environments/java/#ubuntu","text":"The OpenJDK is available as a package on Ubuntu and can be installed via the Ubuntu software center or via the command line: sudo apt-get install openjdk-8-jre","title":"Ubuntu"},{"location":"development-environments/java/#why-is-java-required","text":"Clojure was designed as a hosted language, which means it is developed and run on top of Java's Virtual Machine (JVM). However, its not necessary to learn the Java language to use Clojure . Clojure is compiled into Java bytecode when you evaluate the code. This compilation happens in the background so you dont usually see it happening. For example, if you are using the Clojure REPL then each time you evaluate an expression it is compiled into Java bytecode and then injected into the running REPL and the results are then returned. This all happens pretty instantaneously. Most of the current Clojure tooling was developed for Clojure on the JVM, for example Leiningen. As Clojure runs on Java you can also use all the other libraries that run on the Java Virtual machine, regardless of whether those libraries were written in Java, Clojure, Scala, JRuby, jython, Groovy, etc.","title":"Why is Java Required"},{"location":"development-environments/leiningen/","text":"Leiningen Build tool \u03bb\ufe0e leiningen.org (pronounced line-ing-en) is a very powerful build automation tool for automating Clojure projects. With Leiningen you can: Create Clojure Projects with templates Define and manage dependencies Run an interactive Clojure environment (REPL) Run unit tests using Clojure.test Run your Clojure application Create a deployable Clojure application, as Java Jar file Deploy a Clojure library to a remote repository Install Leiningen \u03bb\ufe0e Download the install script from leiningen.org and run the Leiningen script in a terminal On Linux and MacOSX, make the script executable first chmod a+x lein ./lein Hint I put the lein script in ~/bin directory which is part of my operating system execution path ($PATH). To include the ~/bin directory in the system path, I add the following code to the ~/.profile file Testing Leiningen is working \u03bb\ufe0e Test that Leiningen is installed with the following command lein version Output should look similar to: Leiningen 2.6.1 on Java 9-internal OpenJDK 64-Bit Server VM","title":"Leiningen Build tool"},{"location":"development-environments/leiningen/#leiningen-build-tool","text":"leiningen.org (pronounced line-ing-en) is a very powerful build automation tool for automating Clojure projects. With Leiningen you can: Create Clojure Projects with templates Define and manage dependencies Run an interactive Clojure environment (REPL) Run unit tests using Clojure.test Run your Clojure application Create a deployable Clojure application, as Java Jar file Deploy a Clojure library to a remote repository","title":"Leiningen Build tool"},{"location":"development-environments/leiningen/#install-leiningen","text":"Download the install script from leiningen.org and run the Leiningen script in a terminal On Linux and MacOSX, make the script executable first chmod a+x lein ./lein Hint I put the lein script in ~/bin directory which is part of my operating system execution path ($PATH). To include the ~/bin directory in the system path, I add the following code to the ~/.profile file","title":"Install Leiningen"},{"location":"development-environments/leiningen/#testing-leiningen-is-working","text":"Test that Leiningen is installed with the following command lein version Output should look similar to: Leiningen 2.6.1 on Java 9-internal OpenJDK 64-Bit Server VM","title":"Testing Leiningen is working"},{"location":"development-environments/lighttable/","text":"LightTable \u03bb\ufe0e LightTable is a simple development tool that supports Clojure, ClojureScript, JavaScript and Python languages. The tool is open source and written in Clojure & ClojureScript (with a little JavaScript & CSS) Install Lighttable \u03bb\ufe0e Download lighttable.com and follow the suggested instructions: MacOSX Install the lighttable.dmg file just as any other MacOSX package Linux Extract the contents of the downloaded lighttable file to a suitable directory ( /usr/local or ~/apps ). Add LightTable to the system $PATH , or add the following script to the system $PATH . Windows Download the windows zip file for LightTable and extract the installer, following the instructions inside the installer. LightTable configuration \u03bb\ufe0e Lighttable configuration is in the file user.behaviours . Open the user behaviours file, Ctrl-space and type user behaviors . When you save the file, Ctrl-s , changes are applied immediately. Sample User Behaviours file Here is a sample of user behaviours file for LightTable Using LightTable \u03bb\ufe0e LightTable has an online tutorial entitled Getting started with LightTable I create a project first with Leiningen, open the project directory in the LightTable workspace and open any files I want to work with. I then connect the open editor window for the file by pressing Ctrl-Enter at the end of an expression. Hint my approach is documented in the quick demo section of my Clojure & LightTable slides from JAXLondon 2013.","title":"LightTable"},{"location":"development-environments/lighttable/#lighttable","text":"LightTable is a simple development tool that supports Clojure, ClojureScript, JavaScript and Python languages. The tool is open source and written in Clojure & ClojureScript (with a little JavaScript & CSS)","title":"LightTable"},{"location":"development-environments/lighttable/#install-lighttable","text":"Download lighttable.com and follow the suggested instructions: MacOSX Install the lighttable.dmg file just as any other MacOSX package Linux Extract the contents of the downloaded lighttable file to a suitable directory ( /usr/local or ~/apps ). Add LightTable to the system $PATH , or add the following script to the system $PATH . Windows Download the windows zip file for LightTable and extract the installer, following the instructions inside the installer.","title":"Install Lighttable"},{"location":"development-environments/lighttable/#lighttable-configuration","text":"Lighttable configuration is in the file user.behaviours . Open the user behaviours file, Ctrl-space and type user behaviors . When you save the file, Ctrl-s , changes are applied immediately. Sample User Behaviours file Here is a sample of user behaviours file for LightTable","title":"LightTable configuration"},{"location":"development-environments/lighttable/#using-lighttable","text":"LightTable has an online tutorial entitled Getting started with LightTable I create a project first with Leiningen, open the project directory in the LightTable workspace and open any files I want to work with. I then connect the open editor window for the file by pressing Ctrl-Enter at the end of an expression. Hint my approach is documented in the quick demo section of my Clojure & LightTable slides from JAXLondon 2013.","title":"Using LightTable"},{"location":"development-environments/other-tools/","text":"Other Development tools for Clojure \u03bb\ufe0e There are several development tools you can use to support your Clojure development. My current choice of development environment is Spacemacs, a feature rich configuration for Emacs. See my article on Spacemacs for Clojure development Some common setups I have seen in use for Clojure development are: Modern - LightTable , Leiningen , Git Modern Classic - Spacemacs with Clojure layer, Leiningen , magit Classic - Emacs with Cider , Leiningen , magit Java (IntelliJ) - Cursive Clojure Java (Eclipse) - Counterclockwise documentation site Ubiquitous - Vim, nailgun, Leiningen , Git Simple - Nightcode , Leiningen , Git Lightweight - Atom, Protorepl, Leiningen , Git There may be many more variations, however you should find a development environment with at minimum the following features: starting & using a REPL, with in-line evaluation syntax highlighting & coloured brackets (eg. rainbow-delimiters in Emacs) autocomplete of names (functions, symbols, keywords, etc) snippets / templates Tools for developers with a Java background \u03bb\ufe0e Clojure runs on the Java Virtual Machine so its not surprising that there is good support for Clojure in the major Java IDEs. Eclipse \u03bb\ufe0e Counterclockwise is an Eclipse IDE plugin to provide an integrated development environment for Clojure. Take a look at the Counterclockwise documentation site for installation instructions IntelliJ \u03bb\ufe0e Cursive is a Clojure IDE that aims to understands your code. Advanced structural editing, refactor, VCS integration and much more, all out of the box. It is currently a standalone tool, although will eventually become an IntelliJ plugin. La Clojure is a plugin for IntelliJ IDEA. Provides Clojure language support: syntax and error highlighting, completion, navigation and refactor. Netbeans \u03bb\ufe0e Netbeans did have great support for Clojure, but unfortunately at the time of writing the Clojure plugin has been unmaintained for so long it is not a viable tool to use for Clojure development.","title":"Other Development tools for Clojure"},{"location":"development-environments/other-tools/#other-development-tools-for-clojure","text":"There are several development tools you can use to support your Clojure development. My current choice of development environment is Spacemacs, a feature rich configuration for Emacs. See my article on Spacemacs for Clojure development Some common setups I have seen in use for Clojure development are: Modern - LightTable , Leiningen , Git Modern Classic - Spacemacs with Clojure layer, Leiningen , magit Classic - Emacs with Cider , Leiningen , magit Java (IntelliJ) - Cursive Clojure Java (Eclipse) - Counterclockwise documentation site Ubiquitous - Vim, nailgun, Leiningen , Git Simple - Nightcode , Leiningen , Git Lightweight - Atom, Protorepl, Leiningen , Git There may be many more variations, however you should find a development environment with at minimum the following features: starting & using a REPL, with in-line evaluation syntax highlighting & coloured brackets (eg. rainbow-delimiters in Emacs) autocomplete of names (functions, symbols, keywords, etc) snippets / templates","title":"Other Development tools for Clojure"},{"location":"development-environments/other-tools/#tools-for-developers-with-a-java-background","text":"Clojure runs on the Java Virtual Machine so its not surprising that there is good support for Clojure in the major Java IDEs.","title":"Tools for developers with a Java background"},{"location":"development-environments/other-tools/#eclipse","text":"Counterclockwise is an Eclipse IDE plugin to provide an integrated development environment for Clojure. Take a look at the Counterclockwise documentation site for installation instructions","title":"Eclipse"},{"location":"development-environments/other-tools/#intellij","text":"Cursive is a Clojure IDE that aims to understands your code. Advanced structural editing, refactor, VCS integration and much more, all out of the box. It is currently a standalone tool, although will eventually become an IntelliJ plugin. La Clojure is a plugin for IntelliJ IDEA. Provides Clojure language support: syntax and error highlighting, completion, navigation and refactor.","title":"IntelliJ"},{"location":"development-environments/other-tools/#netbeans","text":"Netbeans did have great support for Clojure, but unfortunately at the time of writing the Clojure plugin has been unmaintained for so long it is not a viable tool to use for Clojure development.","title":"Netbeans"},{"location":"games/","text":"Writing Games with Clojure \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Pull requests are welcome Games are driven by events and require state to be managed, so are a good way to explore how to manage state with immutable values. For games in Clojure the events are simply function calls and we prefer to pass the state around rather than have a central mutable container for our state. This section will contain several games that have been built using a functional approach with immutable data structures. TicTacToe on the command line Hint::Games in ClojureScript \u03bb\ufe0e There is a section on games in the Practicalli ClojureScript book, including a TicTacToe game using Reagent (react.js style library) and Scalable Vector Graphics (SVG).","title":"Writing Games with Clojure"},{"location":"games/#writing-games-with-clojure","text":"","title":"Writing Games with Clojure"},{"location":"games/#todowork-in-progress-sorry","text":"Pull requests are welcome Games are driven by events and require state to be managed, so are a good way to explore how to manage state with immutable values. For games in Clojure the events are simply function calls and we prefer to pass the state around rather than have a central mutable container for our state. This section will contain several games that have been built using a functional approach with immutable data structures. TicTacToe on the command line","title":"TODO::work in progress, sorry"},{"location":"games/#hintgames-in-clojurescript","text":"There is a section on games in the Practicalli ClojureScript book, including a TicTacToe game using Reagent (react.js style library) and Scalable Vector Graphics (SVG).","title":"Hint::Games in ClojureScript"},{"location":"games/tictactoe-cli/","text":"TicTacToe on the command line \u03bb\ufe0e Tic-tac-toe is a paper-and-pencil game for two players, X and O, who take turns marking the spaces in a 3\u00d73 grid. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game {% youtube %} https://youtu.be/_eO7EsXO2XE?t=343 The code for this section is published on GitHub at: practicalli/tictactoe-cli A TicTacToe game that you run on the command line. The game takes input from a human player and the program is the second player. Output from the game appears in the REPL Current board : 1 | 2 | 3 --------- 4 | 5 | 6 --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | 2 | 3 --------- 4 | 5 | 6 --------- 7 | 8 | 9 O : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | 3 --------- 4 | 5 | 6 --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- 4 | 5 | 6 --------- 7 | 8 | 9 O : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | 5 | 6 --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | X | 6 --------- 7 | 8 | 9 O : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | X | O --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | X | O --------- X | 8 | 9 Player X wins! References \u03bb\ufe0e TicTacToe game created by Brian Will .","title":"TicTacToe on the command line"},{"location":"games/tictactoe-cli/#tictactoe-on-the-command-line","text":"Tic-tac-toe is a paper-and-pencil game for two players, X and O, who take turns marking the spaces in a 3\u00d73 grid. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game {% youtube %} https://youtu.be/_eO7EsXO2XE?t=343 The code for this section is published on GitHub at: practicalli/tictactoe-cli A TicTacToe game that you run on the command line. The game takes input from a human player and the program is the second player. Output from the game appears in the REPL Current board : 1 | 2 | 3 --------- 4 | 5 | 6 --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | 2 | 3 --------- 4 | 5 | 6 --------- 7 | 8 | 9 O : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | 3 --------- 4 | 5 | 6 --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- 4 | 5 | 6 --------- 7 | 8 | 9 O : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | 5 | 6 --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | X | 6 --------- 7 | 8 | 9 O : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | X | O --------- 7 | 8 | 9 X : Select your move ( press a number between 1 and 9 then press enter ) Current board : X | O | X --------- O | X | O --------- X | 8 | 9 Player X wins!","title":"TicTacToe on the command line"},{"location":"games/tictactoe-cli/#references","text":"TicTacToe game created by Brian Will .","title":"References"},{"location":"games/tictactoe-cli/create-project/","text":"Create a Clojure project \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Create a project for our game. {% tabs deps=\"deps.edn projects\", lein=\"Leiningnen projects\" %} {% content \"deps\" %} Create a new project using clj-new alias, found in practicalli/clojure-deps-edn clojure -M:new practicalli/tictactoe-cli Open the project in a Clojure aware editor or run a rebel REPL clojure -M:repl/rebel Once the rebel REPL is running, load the project and change to the main namespace ( require 'practicalli/tictactoe-cli ) ( in-ns 'practicalli/tictactoe-cli ) {% content \"lein\" %} The default Leiningen template is suitable fine for the project as no additional libraries are used. lein new tictactoe-cli Hint::Alternatively clone the github repository \u03bb\ufe0e You can also clone the tictactoe-cli game from GitHub git clone https://github.com/practicalli/tictactoe-cli.git Updating Clojure version and licence \u03bb\ufe0e In the project.clj file I have updated Clojure to version 1.10.0 and changed the licence to be the more open Creative Commons license. ( defproject tictactoe-cli \"0.1.0-SNAPSHOT\" :description \"TicTacToe game played on the command line\" :url \"https://github.com/practicalli/tictactoe-cli\" :license { :name \"Creative Commons Attribution Share-Alike 4.0 International\" :url \"https://creativecommons.org\" } :dependencies [[ org.clojure/clojure \"1.10.0\" ]]) I also removed the license file and added a brief description of the project to the README.md file {% endtabs %}","title":"Create a Clojure project"},{"location":"games/tictactoe-cli/create-project/#create-a-clojure-project","text":"","title":"Create a Clojure project"},{"location":"games/tictactoe-cli/create-project/#todowork-in-progress-sorry","text":"Create a project for our game. {% tabs deps=\"deps.edn projects\", lein=\"Leiningnen projects\" %} {% content \"deps\" %} Create a new project using clj-new alias, found in practicalli/clojure-deps-edn clojure -M:new practicalli/tictactoe-cli Open the project in a Clojure aware editor or run a rebel REPL clojure -M:repl/rebel Once the rebel REPL is running, load the project and change to the main namespace ( require 'practicalli/tictactoe-cli ) ( in-ns 'practicalli/tictactoe-cli ) {% content \"lein\" %} The default Leiningen template is suitable fine for the project as no additional libraries are used. lein new tictactoe-cli","title":"TODO::work in progress, sorry"},{"location":"games/tictactoe-cli/create-project/#hintalternatively-clone-the-github-repository","text":"You can also clone the tictactoe-cli game from GitHub git clone https://github.com/practicalli/tictactoe-cli.git","title":"Hint::Alternatively clone the github repository"},{"location":"games/tictactoe-cli/create-project/#updating-clojure-version-and-licence","text":"In the project.clj file I have updated Clojure to version 1.10.0 and changed the licence to be the more open Creative Commons license. ( defproject tictactoe-cli \"0.1.0-SNAPSHOT\" :description \"TicTacToe game played on the command line\" :url \"https://github.com/practicalli/tictactoe-cli\" :license { :name \"Creative Commons Attribution Share-Alike 4.0 International\" :url \"https://creativecommons.org\" } :dependencies [[ org.clojure/clojure \"1.10.0\" ]]) I also removed the license file and added a brief description of the project to the README.md file {% endtabs %}","title":"Updating Clojure version and licence"},{"location":"install/","text":"Install Clojure \u03bb\ufe0e Clojure CLI is the minimum Clojure environment, although a Clojure aware editor with a and Clojure LSP server Clojure CLI provide the foundation for Clojure development, providing a simple and configurable way to: Run Clojure programs and tools Run a REPL process (Read-Eval-Print Loop) and provides a basic interactive terminal UI Manage packaged dependencies from Maven (jars) and use Git repositories as dependencies Practicalli Clojure CLI config extends Clojure CLI with tasks to create, develop, build and deploy Clojure applications and services. Clojure aware editors provide the most effective way to write and maintaine Clojure projects, connecting to (or even starting) a Clojure REPL and evaluating code as its typed and seeing the results instantly in line with the code. Complete Clojure environment \u03bb\ufe0e Establish an effective Clojure development environment by installing the following: Fundamental Tools Purpose Java 17 LTS Java virtual machine hosts Clojure. Java 17 is the Long Term Support version which provides a stable platform to run Clojure Clojure CLI Run Clojure REPL and other tools for development and production Practicalli Clojure CLI config Curated aliases providing common development tasks and tools across all projects (used heavily in this guide) Recommended Tools Purpose Clojure aware editors Editors providing a complete Clojure development environment Clojure LSP server Lint tool to detect syntax bugs and suggest idiomatic code Data browsers Visualize results of Clojure code, navigate nested data and page through large data sets Aliases in Practicalli Clojure provided by Practicalli Clojure CLI config practicalli/clojure-deps-edn provides a user configuration of over 50 aliases to support Clojure development. These aliases are used heavily in the Practicalli Clojure book. If the Practicalli Clojure CLI config is not used, review the deps.edn file from the GitHub repository and add relevant aliases definitions to your own Clojure CLI configuration. optional: clj-kondo static analysis tool Code analysis (clj-kondo) is a Clojure syntax analysis tool that can detect syntax bugs and suggest idiomatic code. clj-kondo is included in Clojure-lsp so is an optional install Alternative development tools Leiningen is the classic development tool for Clojure. All the code examples in this book should work with Leiningen when a correctly configured project.clj file is created which includes all the neccessary library dependencies. Libraries included via aliases should be added as either :dev-dependencies or :aliases in the Leiningen project.clj file.","title":"Install Clojure"},{"location":"install/#install-clojure","text":"Clojure CLI is the minimum Clojure environment, although a Clojure aware editor with a and Clojure LSP server Clojure CLI provide the foundation for Clojure development, providing a simple and configurable way to: Run Clojure programs and tools Run a REPL process (Read-Eval-Print Loop) and provides a basic interactive terminal UI Manage packaged dependencies from Maven (jars) and use Git repositories as dependencies Practicalli Clojure CLI config extends Clojure CLI with tasks to create, develop, build and deploy Clojure applications and services. Clojure aware editors provide the most effective way to write and maintaine Clojure projects, connecting to (or even starting) a Clojure REPL and evaluating code as its typed and seeing the results instantly in line with the code.","title":"Install Clojure"},{"location":"install/#complete-clojure-environment","text":"Establish an effective Clojure development environment by installing the following: Fundamental Tools Purpose Java 17 LTS Java virtual machine hosts Clojure. Java 17 is the Long Term Support version which provides a stable platform to run Clojure Clojure CLI Run Clojure REPL and other tools for development and production Practicalli Clojure CLI config Curated aliases providing common development tasks and tools across all projects (used heavily in this guide) Recommended Tools Purpose Clojure aware editors Editors providing a complete Clojure development environment Clojure LSP server Lint tool to detect syntax bugs and suggest idiomatic code Data browsers Visualize results of Clojure code, navigate nested data and page through large data sets Aliases in Practicalli Clojure provided by Practicalli Clojure CLI config practicalli/clojure-deps-edn provides a user configuration of over 50 aliases to support Clojure development. These aliases are used heavily in the Practicalli Clojure book. If the Practicalli Clojure CLI config is not used, review the deps.edn file from the GitHub repository and add relevant aliases definitions to your own Clojure CLI configuration. optional: clj-kondo static analysis tool Code analysis (clj-kondo) is a Clojure syntax analysis tool that can detect syntax bugs and suggest idiomatic code. clj-kondo is included in Clojure-lsp so is an optional install Alternative development tools Leiningen is the classic development tool for Clojure. All the code examples in this book should work with Leiningen when a correctly configured project.clj file is created which includes all the neccessary library dependencies. Libraries included via aliases should be added as either :dev-dependencies or :aliases in the Leiningen project.clj file.","title":"Complete Clojure environment"},{"location":"install/clojure-cli/","text":"Install Clojure CLI \u03bb\ufe0e Install the Clojure CLI which provides the essential tools for Clojure development. The Clojure CLI automatically downloads all library dependencies, including the Clojure Standard library. As Clojure itself is packages as a library ( .jar Java ARchive), any version of Clojure can easily be used with a project or the Clojure CLI tool. Linux homebrew windows Practically recommends setting XDG_CONFIG_HOME to the .config directory, to avoid creating another dot directory in the root of the user account. Add the following to ~/.bashrc for the bash shell or ~/.zshenv for Zsh. export XDG_CONFIG_HOME=\"$HOME/.config\" Use the Linux script installer from Clojure.org - Getting Started The instructions should be as follows, possibly with a newer version curl -O https://download.clojure.org/install/linux-install-1.11.1.1208.sh chmod +x linux-install-1.11.1.1208.sh sudo ./linux-install-1.11.1.1208.sh The installation creates /usr/local/bin/clojure , /usr/local/bin/clj wrapper and /usr/local/lib/clojure directory. Practically recommends setting XDG_CONFIG_HOME to the .config directory, to avoid creating another dot directory in the root of the user account. Add the following to ~/.bashrc for the bash shell or ~/.zshenv for Zsh. export XDG_CONFIG_HOME=\"$HOME/.config\" Use the Homebrew command with the clojure/tools tap , as defined in the Clojure.org Getting started guide brew install clojure/tools/clojure Use Homebrew to update an install of Clojure CLI to the latest release brew upgrade clojure/tools/clojure Homebrew on Linux or Windows with WSL For Windows 10 use Windows Subsystem for Linux and Windows Terminal are recommended if you have administrative privileges and are comfortable using a Unix system on the command line. Alternatively install scoop.sh , a command line installer for windows. Powershell 5 or greater is required. Follow the scoop-clojure getting started guide , summarized here: Open \"Windows PowerShell\" and enter the following commands to configure the shell: iwr -useb get.scoop.sh | iex Set-ExecutionPolicy RemoteSigned -Scope CurrentUser -Force Then in the same PowerShell window, install the Clojure related tools using the following commands: scoop bucket add extras scoop bucket add java scoop bucket add scoop-clojure https://github.com/littleli/scoop-clojure scoop install git 7zip pshazz adoptopenjdk-lts-hotspot clojure leiningen clj-kondo vscode coreutils windows-terminal Reference: Clojure CLI Install - Clojure.org Getting Started - official guide Practicalli Clojure CLI Config \u03bb\ufe0e Add a wide range of community tools to extend the capabilities of Clojure CLI via the aliases contained within Practicalli Clojure CLI configuration. Fork or clone practicalli/clojure-deps-edn GitHub repository, first removing the $XDG_CONFIG_HOME/clojure or $HOME/.clojure directory if they exist. Check Clojure CLI configuration location Check the location of your Clojure configuration directory by running clojure -Sdescribe and checking the :user-config value. Free Desktop XDG CONFIG Classic Config If XDG_CONFIG_HOME environment variable is set, clone the repository to $XDG_CONFIG_HOME/clojure https://github.com/practicalli/clojure-deps-edn.git $XDG_CONFIG_HOME/clojure Clojure CLI will look for its configuration in $HOME/.clojure directory if $XDG_CONFIG_HOME and CLJ_CONFIG environment variables not set. https://github.com/practicalli/clojure-deps-edn.git $HOME/.clojure Check Configuration \u03bb\ufe0e clojure -Sdescribe shows the version of Clojure CLI installed and configuration locations used. clojure -Sdescribe The output of the command includes the version of Clojure CLI in the :version key { :version \"1.11.1.1208\" :config-files [ \"/usr/local/lib/clojure/deps.edn\" \"/home/practicalli/.config/clojure/deps.edn\" ] :config-user \"/home/practicalli/.config/clojure/deps.edn\" :config-project \"deps.edn\" :install-dir \"/usr/local/lib/clojure\" :config-dir \"/home/practicalli/.config/clojure\" :cache-dir \"/home/practicalli/.cache/clojure\" :force false :repro false :main-aliases \"\" :repl-aliases \"\" } clojure -Sversion will shows the version of Clojure CLI being when the clojure command is used to run a REPL or other Clojure command. Optional rlwrap readline \u03bb\ufe0e The rlwrap binary is a basic readline tool that provides a history of commands entered into a terminal UI when running a Clojure REPL with the clj wrapper script. Pressing the Up and Down keys will scroll through the code previously entered in the REPL. rlwrap is available with most Linux systems. Look for install instructions by searching for rlwrap in a web browser or build from source from the rlwrap GitHub repository . Use Rebel Readline for a rich terminal UI experience rebel readline provides a auto-completion, documentation, signature help and multi-line editing all within a terminal UI, providing a much richer experience than the clj wrapper and rlwrap . Rebel Readline is part of the Practicalli Clojure CLI config .","title":"Clojure CLI"},{"location":"install/clojure-cli/#install-clojure-cli","text":"Install the Clojure CLI which provides the essential tools for Clojure development. The Clojure CLI automatically downloads all library dependencies, including the Clojure Standard library. As Clojure itself is packages as a library ( .jar Java ARchive), any version of Clojure can easily be used with a project or the Clojure CLI tool. Linux homebrew windows Practically recommends setting XDG_CONFIG_HOME to the .config directory, to avoid creating another dot directory in the root of the user account. Add the following to ~/.bashrc for the bash shell or ~/.zshenv for Zsh. export XDG_CONFIG_HOME=\"$HOME/.config\" Use the Linux script installer from Clojure.org - Getting Started The instructions should be as follows, possibly with a newer version curl -O https://download.clojure.org/install/linux-install-1.11.1.1208.sh chmod +x linux-install-1.11.1.1208.sh sudo ./linux-install-1.11.1.1208.sh The installation creates /usr/local/bin/clojure , /usr/local/bin/clj wrapper and /usr/local/lib/clojure directory. Practically recommends setting XDG_CONFIG_HOME to the .config directory, to avoid creating another dot directory in the root of the user account. Add the following to ~/.bashrc for the bash shell or ~/.zshenv for Zsh. export XDG_CONFIG_HOME=\"$HOME/.config\" Use the Homebrew command with the clojure/tools tap , as defined in the Clojure.org Getting started guide brew install clojure/tools/clojure Use Homebrew to update an install of Clojure CLI to the latest release brew upgrade clojure/tools/clojure Homebrew on Linux or Windows with WSL For Windows 10 use Windows Subsystem for Linux and Windows Terminal are recommended if you have administrative privileges and are comfortable using a Unix system on the command line. Alternatively install scoop.sh , a command line installer for windows. Powershell 5 or greater is required. Follow the scoop-clojure getting started guide , summarized here: Open \"Windows PowerShell\" and enter the following commands to configure the shell: iwr -useb get.scoop.sh | iex Set-ExecutionPolicy RemoteSigned -Scope CurrentUser -Force Then in the same PowerShell window, install the Clojure related tools using the following commands: scoop bucket add extras scoop bucket add java scoop bucket add scoop-clojure https://github.com/littleli/scoop-clojure scoop install git 7zip pshazz adoptopenjdk-lts-hotspot clojure leiningen clj-kondo vscode coreutils windows-terminal Reference: Clojure CLI Install - Clojure.org Getting Started - official guide","title":"Install Clojure CLI"},{"location":"install/clojure-cli/#practicalli-clojure-cli-config","text":"Add a wide range of community tools to extend the capabilities of Clojure CLI via the aliases contained within Practicalli Clojure CLI configuration. Fork or clone practicalli/clojure-deps-edn GitHub repository, first removing the $XDG_CONFIG_HOME/clojure or $HOME/.clojure directory if they exist. Check Clojure CLI configuration location Check the location of your Clojure configuration directory by running clojure -Sdescribe and checking the :user-config value. Free Desktop XDG CONFIG Classic Config If XDG_CONFIG_HOME environment variable is set, clone the repository to $XDG_CONFIG_HOME/clojure https://github.com/practicalli/clojure-deps-edn.git $XDG_CONFIG_HOME/clojure Clojure CLI will look for its configuration in $HOME/.clojure directory if $XDG_CONFIG_HOME and CLJ_CONFIG environment variables not set. https://github.com/practicalli/clojure-deps-edn.git $HOME/.clojure","title":"Practicalli Clojure CLI Config"},{"location":"install/clojure-cli/#check-configuration","text":"clojure -Sdescribe shows the version of Clojure CLI installed and configuration locations used. clojure -Sdescribe The output of the command includes the version of Clojure CLI in the :version key { :version \"1.11.1.1208\" :config-files [ \"/usr/local/lib/clojure/deps.edn\" \"/home/practicalli/.config/clojure/deps.edn\" ] :config-user \"/home/practicalli/.config/clojure/deps.edn\" :config-project \"deps.edn\" :install-dir \"/usr/local/lib/clojure\" :config-dir \"/home/practicalli/.config/clojure\" :cache-dir \"/home/practicalli/.cache/clojure\" :force false :repro false :main-aliases \"\" :repl-aliases \"\" } clojure -Sversion will shows the version of Clojure CLI being when the clojure command is used to run a REPL or other Clojure command.","title":"Check Configuration"},{"location":"install/clojure-cli/#optional-rlwrap-readline","text":"The rlwrap binary is a basic readline tool that provides a history of commands entered into a terminal UI when running a Clojure REPL with the clj wrapper script. Pressing the Up and Down keys will scroll through the code previously entered in the REPL. rlwrap is available with most Linux systems. Look for install instructions by searching for rlwrap in a web browser or build from source from the rlwrap GitHub repository . Use Rebel Readline for a rich terminal UI experience rebel readline provides a auto-completion, documentation, signature help and multi-line editing all within a terminal UI, providing a much richer experience than the clj wrapper and rlwrap . Rebel Readline is part of the Practicalli Clojure CLI config .","title":"Optional rlwrap readline"},{"location":"install/clojure-lsp/","text":"Document Title \u03bb\ufe0e","title":"Document Title"},{"location":"install/clojure-lsp/#document-title","text":"","title":"Document Title"},{"location":"install/code-analysis/","text":"Code Analysis \u03bb\ufe0e clj-kondo is a lint tool that highlights syntactic errors and suggests idioms for Clojure, ClojureScript and EDN. Use clj-kondo with your preferred editor to warning about errors as you type so issues can be fixed as soon as they occur, enhancing your joy of Clojure. clj-kondo can also be used as a command line tool for checking projects in development environments and continuous integration service, such as the setup-clojure GitHub action . Clojure LSP includes clj-kondo Clojure LSP install includes clj-kondo, removing the need for a separate install of clj-kondo Install \u03bb\ufe0e Follow the clj-kondo install guide for your operating system. Clj-kondo config contains additional configuration for using clj-kondo with libraries that extend the Clojure language via macros. Spacemacs Doom Emacs Neovim clj-kondo can be used if cider is configured as the clojure layer backend. If LSP is configured as the backend, should not be used as it may duplicate analysis results (e.g. doubling error and warning messgeas). Use Clojure LSP with Doom rather than clj-kondo by itself. Add the +lsp feature to the Clojure module and enable the lsp module .config/doom/init.el (clojure +lsp) lsp Add the respective LSP server implementation to the operating system Practicalli Neovim provides a guide to configure Neovim with Treesitter as an LSP client, as well as a fennel based configuration for Neovim. Command Line analysis \u03bb\ufe0e Run clj-kondo with the --lint option and specify a file or path To analyse a specific file clj-kondon --lint ~/.config/deps.edn Analyse a project, running the clj-kondo command from the root of the project clj-kondon --lint . clj-kondo with GitHub actions \u03bb\ufe0e Add clj-kondo linting to continuous integration workflow .","title":"Code Analysis"},{"location":"install/code-analysis/#code-analysis","text":"clj-kondo is a lint tool that highlights syntactic errors and suggests idioms for Clojure, ClojureScript and EDN. Use clj-kondo with your preferred editor to warning about errors as you type so issues can be fixed as soon as they occur, enhancing your joy of Clojure. clj-kondo can also be used as a command line tool for checking projects in development environments and continuous integration service, such as the setup-clojure GitHub action . Clojure LSP includes clj-kondo Clojure LSP install includes clj-kondo, removing the need for a separate install of clj-kondo","title":"Code Analysis"},{"location":"install/code-analysis/#install","text":"Follow the clj-kondo install guide for your operating system. Clj-kondo config contains additional configuration for using clj-kondo with libraries that extend the Clojure language via macros. Spacemacs Doom Emacs Neovim clj-kondo can be used if cider is configured as the clojure layer backend. If LSP is configured as the backend, should not be used as it may duplicate analysis results (e.g. doubling error and warning messgeas). Use Clojure LSP with Doom rather than clj-kondo by itself. Add the +lsp feature to the Clojure module and enable the lsp module .config/doom/init.el (clojure +lsp) lsp Add the respective LSP server implementation to the operating system Practicalli Neovim provides a guide to configure Neovim with Treesitter as an LSP client, as well as a fennel based configuration for Neovim.","title":"Install"},{"location":"install/code-analysis/#command-line-analysis","text":"Run clj-kondo with the --lint option and specify a file or path To analyse a specific file clj-kondon --lint ~/.config/deps.edn Analyse a project, running the clj-kondo command from the root of the project clj-kondon --lint .","title":"Command Line analysis"},{"location":"install/code-analysis/#clj-kondo-with-github-actions","text":"Add clj-kondo linting to continuous integration workflow .","title":"clj-kondo with GitHub actions"},{"location":"install/java/","text":"Java is a host platform for Clojure, on which Clojure projects and tools run. No experience of Java or its platform is required for successful Clojure projects. Install Java \u03bb\ufe0e Check to see if there is an appropriate version of Java already installed. Open a terminal and run the command java -version If Java is installed, you will see something like this in your terminal: If the version is 17 or above, then jump to the Clojure install page Ubuntu Homebrew Windows Manual Open a terminal and run the following command (you will be prompted for your login password to complete the install) sudo apt install openjdk-17-jdk Optionally add Java sources Install the openjdk-17-source package to support navigation of Java Object and Method source code, especially useful when using Java Interoperability from within Clojure code. practicalli/clojure-deps-edn provides the [ :lib/java17-source alias](https://github.com/practicalli/clojure-deps-edn#java-sources){target=_blank} to include the installed package in the classpath when running a REPL. If openjdk-17-jdk package is not available, add the Ubuntu OpenJDK personal package archive sudo add-apt-repository ppa:openjdk-r/ppa sudo apt-get update If you have more than one version of Java installed, set the version by opening a terminal and using the following command sudo update-alternatives --config java Available java versions will be listed. Enter the list number for the version you wish to use. Using Homebrew , run the following command in a terminal to install Java 17: brew install openjdk@17 Switching between Java versions More than one version of Java can be installed on MacOSX. Set the Java version by opening a terminal and using one of the following commands Show the Java versions installed /usr/libexec/java_home -V Switch to Java version 17 export JAVA_HOME = $( /usr/libexec/java_home -v 17 ) Alternatively, install JEnv Java version manager For Windows 10 use Windows Subsystem for Linux and Windows Terminal are recommended if you have administrative privileges and are happy to use a Unix system on the command line. Alternatively use scoop.sh , a command line installer for windows. Powershell 5 or greater is required. Follow the scoop-clojure install instructions , summarized here: scoop install git scoop bucket add java scoop bucket add scoop-clojure https://github.com/littleli/scoop-clojure scoop install adoptopenjdk-lts-hotspot scoop can also be used to install clojure If neither Scoop or Windows Subsystem for Linux work, try the Chocolatey package manager. Install the Java Runtime (JRE) using the following command in a command line window choco install javaruntime If Chocolatey does not work, then try the manual Java install . Download OpenJDK 17 Hotspot from Adoptium - prebuild OpenJDK binaries freely available for multiple operating systems. Run the file once downloaded and follow the install instructions. Java Knowldege required? \u03bb\ufe0e Very little knowledge of the Java lanaguage or the Java Virtual Machine is required. It is quite simple to call Java methods from Clojure, although there are a wealth of functions and libraries provided by Clojure and its community to minimise the need for Java Interoperability. Reading stack traces may benefit from some Java experience, although its usually the first couple of lines in a stack trace that describe the issue. Clojure uses its own build tools (Leiningen, Clojure CLI tools) and so Java build tool knowledge is not required. When libraries are added to a project, they are downloaded to the $HOME/.m2 directory. This is the default Maven cache used by all JVM libraries. clojure -Spom will generate a Maven pom.xml file used for deployment. Understanding of a minimal Maven POM (pom.xml) file is useful when managing issues with packaging and deployment. Maven in 5 minutes The Java Virtual Machine is highly optimised and does not usually require any options to enhance its performance. The most likely configuration to supply to the JVM are to manage the amount of memory assigned, specifically for resource constrained environments.","title":"Java Host"},{"location":"install/java/#install-java","text":"Check to see if there is an appropriate version of Java already installed. Open a terminal and run the command java -version If Java is installed, you will see something like this in your terminal: If the version is 17 or above, then jump to the Clojure install page Ubuntu Homebrew Windows Manual Open a terminal and run the following command (you will be prompted for your login password to complete the install) sudo apt install openjdk-17-jdk Optionally add Java sources Install the openjdk-17-source package to support navigation of Java Object and Method source code, especially useful when using Java Interoperability from within Clojure code. practicalli/clojure-deps-edn provides the [ :lib/java17-source alias](https://github.com/practicalli/clojure-deps-edn#java-sources){target=_blank} to include the installed package in the classpath when running a REPL. If openjdk-17-jdk package is not available, add the Ubuntu OpenJDK personal package archive sudo add-apt-repository ppa:openjdk-r/ppa sudo apt-get update If you have more than one version of Java installed, set the version by opening a terminal and using the following command sudo update-alternatives --config java Available java versions will be listed. Enter the list number for the version you wish to use. Using Homebrew , run the following command in a terminal to install Java 17: brew install openjdk@17 Switching between Java versions More than one version of Java can be installed on MacOSX. Set the Java version by opening a terminal and using one of the following commands Show the Java versions installed /usr/libexec/java_home -V Switch to Java version 17 export JAVA_HOME = $( /usr/libexec/java_home -v 17 ) Alternatively, install JEnv Java version manager For Windows 10 use Windows Subsystem for Linux and Windows Terminal are recommended if you have administrative privileges and are happy to use a Unix system on the command line. Alternatively use scoop.sh , a command line installer for windows. Powershell 5 or greater is required. Follow the scoop-clojure install instructions , summarized here: scoop install git scoop bucket add java scoop bucket add scoop-clojure https://github.com/littleli/scoop-clojure scoop install adoptopenjdk-lts-hotspot scoop can also be used to install clojure If neither Scoop or Windows Subsystem for Linux work, try the Chocolatey package manager. Install the Java Runtime (JRE) using the following command in a command line window choco install javaruntime If Chocolatey does not work, then try the manual Java install . Download OpenJDK 17 Hotspot from Adoptium - prebuild OpenJDK binaries freely available for multiple operating systems. Run the file once downloaded and follow the install instructions.","title":"Install Java"},{"location":"install/java/#java-knowldege-required","text":"Very little knowledge of the Java lanaguage or the Java Virtual Machine is required. It is quite simple to call Java methods from Clojure, although there are a wealth of functions and libraries provided by Clojure and its community to minimise the need for Java Interoperability. Reading stack traces may benefit from some Java experience, although its usually the first couple of lines in a stack trace that describe the issue. Clojure uses its own build tools (Leiningen, Clojure CLI tools) and so Java build tool knowledge is not required. When libraries are added to a project, they are downloaded to the $HOME/.m2 directory. This is the default Maven cache used by all JVM libraries. clojure -Spom will generate a Maven pom.xml file used for deployment. Understanding of a minimal Maven POM (pom.xml) file is useful when managing issues with packaging and deployment. Maven in 5 minutes The Java Virtual Machine is highly optimised and does not usually require any options to enhance its performance. The most likely configuration to supply to the JVM are to manage the amount of memory assigned, specifically for resource constrained environments.","title":"Java Knowldege required?"},{"location":"introduction/clojure-in-15-minutes/","text":"Clojure in 15 minutes \u03bb\ufe0e A quick tour of the Clojure syntax, which is so terse you can read through this section in around 15 minutes (or less). Comments \u03bb\ufe0e ;; two semi-colons for a line comment, ; single semi-colon to comment the rest of the line #_ comment reader macro to comment out the next form (comment ) form to comment all the containing forms Clojure written in forms \u03bb\ufe0e Clojure is written in \"forms\", which are just a lists of things inside parentheses, () , separated by whitespace. Clojure evaluates the first thing in a form as a function call. Additional values in the form are passed as arguments to the called function. Clojure is organised into one or more namespaces. The namespace represents the directory path and file name that contains the code of the particular namespace. ;; Define the namespace test ( ns test.code ) ;; src/test/code.clj ;; Define a longer namespace ( ns com.company.product.component.core ) ;; src/com/company/product/component/core.clj String manipulation \u03bb\ufe0e The str function creates a new string from all the arguments passed ( str \"Hello\" \" \" \"World\" ) ; => \"Hello World\" clojure.string returns string values (other functions my return characters as results) Math, Truth & prefix notation \u03bb\ufe0e Functions use prefix notation, so you can do math with multiple values very easily ( + 1 2 3 5 7 9 12 ) ; => 40 ( - 24 7 3 ) ; => 14 ( * 1 2 ) ; => 2 ( / 27 7 ) ; => 22/7 Math is very precise, no need for operator precedence rules (as there are no operators) Nesting forms defined a very precise calculation ( + 1 ( - 3 2 )) ; = 1 + (3 - 2) => 2 Equality is = ( = 1 1 ) ; => true ( = 2 1 ) ; => false ; You need not for logic, too (not true) ; => false (not= true false) ; => true Types \u03bb\ufe0e Clojure is stronly typed, so everything is a type in Clojure. Clojure is dynamically typed, so Clojure infers the type. A type does not need to be specified in the code, making the code simpler and more concise. As Clojure is a hosted language it uses the type system of its host where relevant. For example, Clojure uses Java object types for booleans, strings and numbers under the covers. Use class or type functions to inspect the type of some code in Clojure. ( class 1 ) ; Integer literals are java.lang.Long by default ( class 1 . ) ; Float literals are java.lang.Double ( class \"\" ) ; Strings always double-quoted, and are java.lang.String ( class false ) ; Booleans are java.lang.Boolean ( class nil ) ; The \"null\" value is called nil Vectors and Lists are java classes too! (class [1 2 3]); => clojure.lang.PersistentVector (class '(1 2 3)); => clojure.lang.PersistentList Collections & Sequences \u03bb\ufe0e The most common data collections in Clojure: (1 2 \"three\") or (list 1 2 \"three\") - a list of values read from start to end (sequential access) [1 2 \"three\"] or (list 1 2 \"three\") - a vector of values with index (random access) {:key \"value\"} or (hash-map :key \"value\") - a hash-map with zero or more key value pairs (associative relation) #{1 2 \"three\"} or (set 1 2 \"three\") - a unique set of values A list () is evaluated as a function call. The first element of the list the name of the function to call and additional values are arguments to the function. The ' quote function informs the Clojure reader to treat the list as data only. ' ( 1 2 3 ) Lists and vectors are collections ( coll? ' ( 1 2 3 )) ; => true ( coll? [ 1 2 3 ]) ; => true Only lists are sequences ( seq? ' ( 1 2 3 )) ; => true ( seq? [ 1 2 3 ]) ; => false Sequences are an interface for logical lists, which can be lazy. \"Lazy\" means that a sequence of valus are not evaluated until accessed. A lazy sequence enables the use of large or even an infinite series, like so: ( range ) ; => (0 1 2 3 4 ...) - an infinite series ( take 4 ( range )) ; (0 1 2 3) - lazyily evaluate range and stop when enough values are taken Use cons to add an item to the beginning of a list or vector ( cons 4 [ 1 2 3 ]) ; => (4 1 2 3) ( cons 4 ' ( 1 2 3 )) ; => (4 1 2 3) Use conj to add an item relative to the type of collection, to the beginning of a list or the end of a vector ( conj [ 1 2 3 ] 4 ) ; => [1 2 3 4] ( conj ' ( 1 2 3 ) 4 ) ; => (4 1 2 3) Use concat to add lists or vectors together ( concat [ 1 2 ] ' ( 3 4 )) ; => (1 2 3 4) Use filter, map to interact with collections ( map inc [ 1 2 3 ]) ; => (2 3 4) ( filter even? [ 1 2 3 ]) ; => (2) Use reduce to reduce them ( reduce + [ 1 2 3 4 ]) ; = (+ (+ (+ 1 2) 3) 4) ; => 10 Reduce can take an initial-value argument too ( reduce conj [] ' ( 3 2 1 )) ; => [3 2 1] Equivalent of (conj (conj (conj [] 3) 2) 1) Functions \u03bb\ufe0e Use fn to create new functions that defines some behaviour. fn is referred to as an anonymous fuction as it has no external name to be referenced by and must be called within a list form. ( fn hello [] \"Hello World\" ) ; => hello Wrap a (fn ,,,) form in parens to call it and return the result (( fn hello [] \"Hello World\" )) ; => \"Hello World\" Create a reusable function using def , creating a name that is a var . The function behaviour defined in def can be changed and the expression re-evaluated to use the new behaviour. ( defn hello-world [] \"Hello World\" ) ;; => \"Hello World\" The [] is the list of arguments for the function. ( defn hello [ name ] ( str \"Hello \" name )) ( hello \"Steve\" ) ; => \"Hello Steve\" Clojure supports multi-variadic functions, allowing one function definition to respond to a function call with different number of arguments ( defn hello3 ([] \"Hello World\" ) ([ name ] ( str \"Hello \" name ))) ( hello3 \"Jake\" ) ; => \"Hello Jake\" ( hello3 ) ; => \"Hello World\" Functions can pack extra arguments up in a seq for you ( defn count-args [ & args ] ( str \"You passed \" ( count args ) \" args: \" args )) ( count-args 1 2 3 ) ; => \"You passed 3 args: (1 2 3)\" You can mix regular and packed arguments ( defn hello-count [ name & args ] ( str \"Hello \" name \", you passed \" ( count args ) \" extra args\" )) ( hello-count \"Finn\" 1 2 3 ) ; => \"Hello Finn, you passed 3 extra args\" Hash-map collections \u03bb\ufe0e ( class { :a 1 :b 2 :c 3 }) ; => clojure.lang.PersistentArrayMap Keywords are like strings with some efficiency bonuses ( class :a ) ; => clojure.lang.Keyword Maps can use any type as a key, but usually keywords are best ( def stringmap ( hash-map \"a\" 1 , \"b\" 2 , \"c\" 3 )) stringmap ; => {\"a\" 1, \"b\" 2, \"c\" 3} ( def keymap ( hash-map :a 1 :b 2 :c 3 )) keymap ; => {:a 1, :c 3, :b 2} (order is not guaranteed) Commas are whitespace commas are always treated as whitespace and are ignored by the Clojure reader Retrieve a value from a map by calling it as a function ( stringmap \"a\" ) ; => 1 ( keymap :a ) ; => 1 Keywords can be used to retrieve their value from a map. Strings cannot be used. ( :b keymap ) ; => 2 ( \"a\" stringmap ) ; => Exception: java.lang.String cannot be cast to clojure.lang.IFn Retrieving a non-present value returns nil ( stringmap \"d\" ) ; => nil Use assoc to add new keys to hash-maps ( assoc keymap :d 4 ) ; => {:a 1, :b 2, :c 3, :d 4} But remember, clojure types are immutable! keymap ; => {:a 1, :b 2, :c 3} Use dissoc to remove keys ( dissoc keymap :a :b ) ; => {:c 3} Sets \u03bb\ufe0e ( class # { 1 2 3 }) ; => clojure.lang.PersistentHashSet ( set [ 1 2 3 1 2 3 3 2 1 3 2 1 ]) ; => #{1 2 3} Add a member with conj ( conj # { 1 2 3 } 4 ) ; => #{1 2 3 4} Remove one with disj ( disj # { 1 2 3 } 1 ) ; => #{2 3} ```` Test for existence by using the set as a function : ``` clojure ( # { 1 2 3 } 1 ) ; => 1 ( # { 1 2 3 } 4 ) ; => nil There are more functions in the clojure.sets namespace. Useful forms \u03bb\ufe0e Logic constructs in clojure are just macros, and look like everything else ( if false \"a\" \"b\" ) ; => \"b\" ( if false \"a\" ) ; => nil Use let to create temporary bindings ( let [ a 1 b 2 ] ( > a b )) ; => false Group statements together with do ( do ( print \"Hello\" ) \"World\" ) ; => \"World\" (prints \"Hello\") Functions have an implicit do ( defn print-and-say-hello [ name ] ( print \"Saying hello to \" name ) ( str \"Hello \" name )) ( print-and-say-hello \"Jeff\" ) ;=> \"Hello Jeff\" (prints \"Saying hello to Jeff\") So does let ( let [ name \"Urkel\" ] ( print \"Saying hello to \" name ) ( str \"Hello \" name )) ; => \"Hello Urkel\" (prints \"Saying hello to Urkel\") Namespaces and Libraries \u03bb\ufe0e Namespaces are used to organise code into logical groups. The top of each Clojure file has an ns form that defines the namespace name. The domain part of the namespace name is typically the organisation or community name (e.g. GitHub user/organisation) ( ns domain.namespace-name ) All Practicalli projects have namespace domains of practicalli ( ns practicalli.service-name ) require allows code from one namespace to be accessed from another namespace, either from a the same Clojure project or from a library added to the project classpath. The :as directive with require is used to specify an alias name, a short-hand for the full library name Or :refer [function-name var-name] can be used to specify specific functions and data (vars) that are available directly A required directive is typically added to a namespace form ( ns practicalli.service-name ( require [ clojure.set :as set ])) The functions from clojure.set can be used via the alias name, rather than the fully qualified name, i.e. clojure.set/intersection ( set/intersection # { 1 2 3 } # { 2 3 4 }) ; => #{2 3} ( set/difference # { 1 2 3 } # { 2 3 4 }) ; => #{1} :require directive can be used to include multiple library namespaces ( ns test ( :require [ clojure.string :as string ] [ clojure.set :as set ])) require can be used by itself, usually within a rich code block ( comment ( require 'clojure.set :as set )) Java \u03bb\ufe0e Java has a huge and useful standard library, so you'll want to learn how to get at it. Use import to load a java package ( import java.util.Date ) Or import from a java package name ( ns test ( :import java.util.Date java.util.Calendar )) Use the class name with a \".\" at the end to make a new instance ( Date. ) ; <a date object> Use . to call methods. Or, use the \".method\" shortcut ( . ( Date. ) getTime ) ; <a timestamp> ( .getTime ( Date. )) ; exactly the same thing. Use / to call static methods ( System/currentTimeMillis ) ; <a timestamp> (system is always present) Use doto to make dealing with (mutable) classes more tolerable ( import java.util.Calendar ) ( doto ( Calendar/getInstance ) ( .set 2000 1 1 0 0 0 ) .getTime ) ; => A Date. set to 2000-01-01 00:00:00","title":"Clojure in Fifteen Mins"},{"location":"introduction/clojure-in-15-minutes/#clojure-in-15-minutes","text":"A quick tour of the Clojure syntax, which is so terse you can read through this section in around 15 minutes (or less).","title":"Clojure in 15 minutes"},{"location":"introduction/clojure-in-15-minutes/#comments","text":";; two semi-colons for a line comment, ; single semi-colon to comment the rest of the line #_ comment reader macro to comment out the next form (comment ) form to comment all the containing forms","title":"Comments"},{"location":"introduction/clojure-in-15-minutes/#clojure-written-in-forms","text":"Clojure is written in \"forms\", which are just a lists of things inside parentheses, () , separated by whitespace. Clojure evaluates the first thing in a form as a function call. Additional values in the form are passed as arguments to the called function. Clojure is organised into one or more namespaces. The namespace represents the directory path and file name that contains the code of the particular namespace. ;; Define the namespace test ( ns test.code ) ;; src/test/code.clj ;; Define a longer namespace ( ns com.company.product.component.core ) ;; src/com/company/product/component/core.clj","title":"Clojure written in forms"},{"location":"introduction/clojure-in-15-minutes/#string-manipulation","text":"The str function creates a new string from all the arguments passed ( str \"Hello\" \" \" \"World\" ) ; => \"Hello World\" clojure.string returns string values (other functions my return characters as results)","title":"String manipulation"},{"location":"introduction/clojure-in-15-minutes/#math-truth-prefix-notation","text":"Functions use prefix notation, so you can do math with multiple values very easily ( + 1 2 3 5 7 9 12 ) ; => 40 ( - 24 7 3 ) ; => 14 ( * 1 2 ) ; => 2 ( / 27 7 ) ; => 22/7 Math is very precise, no need for operator precedence rules (as there are no operators) Nesting forms defined a very precise calculation ( + 1 ( - 3 2 )) ; = 1 + (3 - 2) => 2 Equality is = ( = 1 1 ) ; => true ( = 2 1 ) ; => false ; You need not for logic, too (not true) ; => false (not= true false) ; => true","title":"Math, Truth &amp; prefix notation"},{"location":"introduction/clojure-in-15-minutes/#types","text":"Clojure is stronly typed, so everything is a type in Clojure. Clojure is dynamically typed, so Clojure infers the type. A type does not need to be specified in the code, making the code simpler and more concise. As Clojure is a hosted language it uses the type system of its host where relevant. For example, Clojure uses Java object types for booleans, strings and numbers under the covers. Use class or type functions to inspect the type of some code in Clojure. ( class 1 ) ; Integer literals are java.lang.Long by default ( class 1 . ) ; Float literals are java.lang.Double ( class \"\" ) ; Strings always double-quoted, and are java.lang.String ( class false ) ; Booleans are java.lang.Boolean ( class nil ) ; The \"null\" value is called nil Vectors and Lists are java classes too! (class [1 2 3]); => clojure.lang.PersistentVector (class '(1 2 3)); => clojure.lang.PersistentList","title":"Types"},{"location":"introduction/clojure-in-15-minutes/#collections-sequences","text":"The most common data collections in Clojure: (1 2 \"three\") or (list 1 2 \"three\") - a list of values read from start to end (sequential access) [1 2 \"three\"] or (list 1 2 \"three\") - a vector of values with index (random access) {:key \"value\"} or (hash-map :key \"value\") - a hash-map with zero or more key value pairs (associative relation) #{1 2 \"three\"} or (set 1 2 \"three\") - a unique set of values A list () is evaluated as a function call. The first element of the list the name of the function to call and additional values are arguments to the function. The ' quote function informs the Clojure reader to treat the list as data only. ' ( 1 2 3 ) Lists and vectors are collections ( coll? ' ( 1 2 3 )) ; => true ( coll? [ 1 2 3 ]) ; => true Only lists are sequences ( seq? ' ( 1 2 3 )) ; => true ( seq? [ 1 2 3 ]) ; => false Sequences are an interface for logical lists, which can be lazy. \"Lazy\" means that a sequence of valus are not evaluated until accessed. A lazy sequence enables the use of large or even an infinite series, like so: ( range ) ; => (0 1 2 3 4 ...) - an infinite series ( take 4 ( range )) ; (0 1 2 3) - lazyily evaluate range and stop when enough values are taken Use cons to add an item to the beginning of a list or vector ( cons 4 [ 1 2 3 ]) ; => (4 1 2 3) ( cons 4 ' ( 1 2 3 )) ; => (4 1 2 3) Use conj to add an item relative to the type of collection, to the beginning of a list or the end of a vector ( conj [ 1 2 3 ] 4 ) ; => [1 2 3 4] ( conj ' ( 1 2 3 ) 4 ) ; => (4 1 2 3) Use concat to add lists or vectors together ( concat [ 1 2 ] ' ( 3 4 )) ; => (1 2 3 4) Use filter, map to interact with collections ( map inc [ 1 2 3 ]) ; => (2 3 4) ( filter even? [ 1 2 3 ]) ; => (2) Use reduce to reduce them ( reduce + [ 1 2 3 4 ]) ; = (+ (+ (+ 1 2) 3) 4) ; => 10 Reduce can take an initial-value argument too ( reduce conj [] ' ( 3 2 1 )) ; => [3 2 1] Equivalent of (conj (conj (conj [] 3) 2) 1)","title":"Collections &amp; Sequences"},{"location":"introduction/clojure-in-15-minutes/#functions","text":"Use fn to create new functions that defines some behaviour. fn is referred to as an anonymous fuction as it has no external name to be referenced by and must be called within a list form. ( fn hello [] \"Hello World\" ) ; => hello Wrap a (fn ,,,) form in parens to call it and return the result (( fn hello [] \"Hello World\" )) ; => \"Hello World\" Create a reusable function using def , creating a name that is a var . The function behaviour defined in def can be changed and the expression re-evaluated to use the new behaviour. ( defn hello-world [] \"Hello World\" ) ;; => \"Hello World\" The [] is the list of arguments for the function. ( defn hello [ name ] ( str \"Hello \" name )) ( hello \"Steve\" ) ; => \"Hello Steve\" Clojure supports multi-variadic functions, allowing one function definition to respond to a function call with different number of arguments ( defn hello3 ([] \"Hello World\" ) ([ name ] ( str \"Hello \" name ))) ( hello3 \"Jake\" ) ; => \"Hello Jake\" ( hello3 ) ; => \"Hello World\" Functions can pack extra arguments up in a seq for you ( defn count-args [ & args ] ( str \"You passed \" ( count args ) \" args: \" args )) ( count-args 1 2 3 ) ; => \"You passed 3 args: (1 2 3)\" You can mix regular and packed arguments ( defn hello-count [ name & args ] ( str \"Hello \" name \", you passed \" ( count args ) \" extra args\" )) ( hello-count \"Finn\" 1 2 3 ) ; => \"Hello Finn, you passed 3 extra args\"","title":"Functions"},{"location":"introduction/clojure-in-15-minutes/#hash-map-collections","text":"( class { :a 1 :b 2 :c 3 }) ; => clojure.lang.PersistentArrayMap Keywords are like strings with some efficiency bonuses ( class :a ) ; => clojure.lang.Keyword Maps can use any type as a key, but usually keywords are best ( def stringmap ( hash-map \"a\" 1 , \"b\" 2 , \"c\" 3 )) stringmap ; => {\"a\" 1, \"b\" 2, \"c\" 3} ( def keymap ( hash-map :a 1 :b 2 :c 3 )) keymap ; => {:a 1, :c 3, :b 2} (order is not guaranteed) Commas are whitespace commas are always treated as whitespace and are ignored by the Clojure reader Retrieve a value from a map by calling it as a function ( stringmap \"a\" ) ; => 1 ( keymap :a ) ; => 1 Keywords can be used to retrieve their value from a map. Strings cannot be used. ( :b keymap ) ; => 2 ( \"a\" stringmap ) ; => Exception: java.lang.String cannot be cast to clojure.lang.IFn Retrieving a non-present value returns nil ( stringmap \"d\" ) ; => nil Use assoc to add new keys to hash-maps ( assoc keymap :d 4 ) ; => {:a 1, :b 2, :c 3, :d 4} But remember, clojure types are immutable! keymap ; => {:a 1, :b 2, :c 3} Use dissoc to remove keys ( dissoc keymap :a :b ) ; => {:c 3}","title":"Hash-map collections"},{"location":"introduction/clojure-in-15-minutes/#sets","text":"( class # { 1 2 3 }) ; => clojure.lang.PersistentHashSet ( set [ 1 2 3 1 2 3 3 2 1 3 2 1 ]) ; => #{1 2 3} Add a member with conj ( conj # { 1 2 3 } 4 ) ; => #{1 2 3 4} Remove one with disj ( disj # { 1 2 3 } 1 ) ; => #{2 3} ```` Test for existence by using the set as a function : ``` clojure ( # { 1 2 3 } 1 ) ; => 1 ( # { 1 2 3 } 4 ) ; => nil There are more functions in the clojure.sets namespace.","title":"Sets"},{"location":"introduction/clojure-in-15-minutes/#useful-forms","text":"Logic constructs in clojure are just macros, and look like everything else ( if false \"a\" \"b\" ) ; => \"b\" ( if false \"a\" ) ; => nil Use let to create temporary bindings ( let [ a 1 b 2 ] ( > a b )) ; => false Group statements together with do ( do ( print \"Hello\" ) \"World\" ) ; => \"World\" (prints \"Hello\") Functions have an implicit do ( defn print-and-say-hello [ name ] ( print \"Saying hello to \" name ) ( str \"Hello \" name )) ( print-and-say-hello \"Jeff\" ) ;=> \"Hello Jeff\" (prints \"Saying hello to Jeff\") So does let ( let [ name \"Urkel\" ] ( print \"Saying hello to \" name ) ( str \"Hello \" name )) ; => \"Hello Urkel\" (prints \"Saying hello to Urkel\")","title":"Useful forms"},{"location":"introduction/clojure-in-15-minutes/#namespaces-and-libraries","text":"Namespaces are used to organise code into logical groups. The top of each Clojure file has an ns form that defines the namespace name. The domain part of the namespace name is typically the organisation or community name (e.g. GitHub user/organisation) ( ns domain.namespace-name ) All Practicalli projects have namespace domains of practicalli ( ns practicalli.service-name ) require allows code from one namespace to be accessed from another namespace, either from a the same Clojure project or from a library added to the project classpath. The :as directive with require is used to specify an alias name, a short-hand for the full library name Or :refer [function-name var-name] can be used to specify specific functions and data (vars) that are available directly A required directive is typically added to a namespace form ( ns practicalli.service-name ( require [ clojure.set :as set ])) The functions from clojure.set can be used via the alias name, rather than the fully qualified name, i.e. clojure.set/intersection ( set/intersection # { 1 2 3 } # { 2 3 4 }) ; => #{2 3} ( set/difference # { 1 2 3 } # { 2 3 4 }) ; => #{1} :require directive can be used to include multiple library namespaces ( ns test ( :require [ clojure.string :as string ] [ clojure.set :as set ])) require can be used by itself, usually within a rich code block ( comment ( require 'clojure.set :as set ))","title":"Namespaces and Libraries"},{"location":"introduction/clojure-in-15-minutes/#java","text":"Java has a huge and useful standard library, so you'll want to learn how to get at it. Use import to load a java package ( import java.util.Date ) Or import from a java package name ( ns test ( :import java.util.Date java.util.Calendar )) Use the class name with a \".\" at the end to make a new instance ( Date. ) ; <a date object> Use . to call methods. Or, use the \".method\" shortcut ( . ( Date. ) getTime ) ; <a timestamp> ( .getTime ( Date. )) ; exactly the same thing. Use / to call static methods ( System/currentTimeMillis ) ; <a timestamp> (system is always present) Use doto to make dealing with (mutable) classes more tolerable ( import java.util.Calendar ) ( doto ( Calendar/getInstance ) ( .set 2000 1 1 0 0 0 ) .getTime ) ; => A Date. set to 2000-01-01 00:00:00","title":"Java"},{"location":"introduction/contributing/","text":"Contributing to Practicalli Clojure \u03bb\ufe0e practicalli/clojure is written in markdown and uses GitBook to generate the website via a GitHub action. By submitting content ideas and corrections you are agreeing they can be used in this workshop under the Creative Commons Attribution ShareAlike 4.0 International license . Attribution will be detailed via GitHub contributors . All content and interaction with any persons or systems must be done so with respect and within the Practicalli Code of Conduct. Book status \u03bb\ufe0e Submit and issue or idea \u03bb\ufe0e If something doesnt seem quite right or something is missing from the book, please raise an issue via the GitHub repository explaining in as much detail as you can. Considering a Pull request? \u03bb\ufe0e Before investing any time in a pull request, please raise an issue explaining the situation. This can save you and the maintainer time and avoid rejected pull requests. Please keep pull requests small and focused, as they are much quicker to review and easier to accept. Ideally PR's should be for a specific page or at most a section. A PR with a list of changes across different sections will not be merged, it will be reviewed eventually though. Thank you to everyone that has contributed \u03bb\ufe0e A huge thank you to Rich Hickey and the team at Cognitect for creating and continually guiding the Clojure language. Special thank you to Alex Miller who has provided excellent advice on working with Clojure and the CLI tooling. The Clojure community has been highly supportive of everyone using Clojure and I'd like to thank everyone for the feedback and contributions. I would also like to thank everyone that has joined in with the London Clojurins community , ClojureBridgeLondon , Clojurians Slack community , Clojurians Zulip community and Clojureverse community . Thank you to everyone who sponsors the Practicalli websites and videos and for the Clojurists Together sponsorship , it helps me continue the work at a much faster pace. Special thanks to Bruce Durling for getting me into Cloure in the first place.","title":"Contributing"},{"location":"introduction/contributing/#contributing-to-practicalli-clojure","text":"practicalli/clojure is written in markdown and uses GitBook to generate the website via a GitHub action. By submitting content ideas and corrections you are agreeing they can be used in this workshop under the Creative Commons Attribution ShareAlike 4.0 International license . Attribution will be detailed via GitHub contributors . All content and interaction with any persons or systems must be done so with respect and within the Practicalli Code of Conduct.","title":"Contributing to Practicalli Clojure"},{"location":"introduction/contributing/#book-status","text":"","title":"Book status"},{"location":"introduction/contributing/#submit-and-issue-or-idea","text":"If something doesnt seem quite right or something is missing from the book, please raise an issue via the GitHub repository explaining in as much detail as you can.","title":"Submit and issue or idea"},{"location":"introduction/contributing/#considering-a-pull-request","text":"Before investing any time in a pull request, please raise an issue explaining the situation. This can save you and the maintainer time and avoid rejected pull requests. Please keep pull requests small and focused, as they are much quicker to review and easier to accept. Ideally PR's should be for a specific page or at most a section. A PR with a list of changes across different sections will not be merged, it will be reviewed eventually though.","title":"Considering a Pull request?"},{"location":"introduction/contributing/#thank-you-to-everyone-that-has-contributed","text":"A huge thank you to Rich Hickey and the team at Cognitect for creating and continually guiding the Clojure language. Special thank you to Alex Miller who has provided excellent advice on working with Clojure and the CLI tooling. The Clojure community has been highly supportive of everyone using Clojure and I'd like to thank everyone for the feedback and contributions. I would also like to thank everyone that has joined in with the London Clojurins community , ClojureBridgeLondon , Clojurians Slack community , Clojurians Zulip community and Clojureverse community . Thank you to everyone who sponsors the Practicalli websites and videos and for the Clojurists Together sponsorship , it helps me continue the work at a much faster pace. Special thanks to Bruce Durling for getting me into Cloure in the first place.","title":"Thank you to everyone that has contributed"},{"location":"introduction/first-taste-of-clojure/","text":"Clojure Quick Reference \u03bb\ufe0e The basic Clojure syntax and a few common functions you should probably learn first. The examples are editable (using an embedded REPL) so feel free to experiment and watch as the return value changes as you change the code. Reload the page if you want to reset all the code back to the starting point. Install Clojure on your computer if you want to experiment even further. Want to go deeper already? Watch the Clojure language video series by Brian Will for a detailed introduction to key parts of the language. Or discover Clojure core functions by completing challenges on 4Clojure.org and then watching how Practicalli solved them . Calling functions \u03bb\ufe0e The first element in a list, () , is a call to a function. Any other elements are passed to the function as arguments. The examples show how to call functions with multiple arguments. ( + 1 2 ) ( + 3 ( * 2 ( - 7 2 ) 4 ) ( / 16 4 )) ( str \"Clojure is \" ( - 2021 2007 ) \" years old\" ) ( inc 1 ) ( map inc [ 1 2 3 4 5 ]) ( filter odd? ( range 11 )) Prefix notation and parens Hugging code with () is a simple syntax to define the scope of code expressions. No additional ; , , or spaces are required. Treating the first element of a list as a function call is referred to as prefix notation, which greatly simplifies Clojure syntax. Prefix notation makes mathematical expressions completely deterministic, eliminating the need for operator precedence . Understanding functions \u03bb\ufe0e clojure.repl/doc function returns the doc-string of the given function. A doc-string should be part of all public function definitions. Clojure editors should provide commands to view doc-strings and the ability to jump to function definitions to view their source code ( clojure.repl/ddoc doc ) Modeling data with Collection types \u03bb\ufe0e Clojure has 4 main collection types, all immutable (cannot change once created) and can contain any Clojure types. A list, () , used for calling functions and representing sequences. A linked list for sequential access. ( str \"lists used mainly \" ( * 2 2 ) \" \" :code ) A vector, [] , used for simple collections of values. An indexed data structure for random access [ 0 \"indexed\" :array ( * 2 2 ) \"random-access\" 4 :data ] A map, {} , use for descriptive data collections. An associative data structure for value lookup by unique keys (also known as a dictionary). { :hash-map :associative-collection :pairs { :key \"value\" } :aka \"dictionary\" } A set, #{} , use as a unique set of values. Sets are used to test if a value is contained within, i.e. predicates. # { 1 2 3 4 \"unique\" \"set\" \"of\" \"values\" \"unordered\" ( * 3 9 )} Persistent data types Values are immutable so when a function changes a value a new immutable value is created. When creating new collection values, unchanged values are shared with the original collection. This sharing model is called persistent data types and enables immutable data to be used efficiently. Using data structures \u03bb\ufe0e Using the map and inc function, increment all the numbers in a vector ( map inc [ 1 2 3 4 5 ]) The above map function is roughly equivalent to the following expression ( conj [] ( inc 1 ) ( inc 2 ) ( inc 3 ) ( inc 4 ) ( inc 5 )) The conj function creates a new collection by combining a collection and one or more values. map reduce filter are common functions for iterating through a collection / sequence of values ( map * [ 1 3 5 8 13 21 ] [ 3 5 8 13 21 34 ]) ( filter even? [ 1 3 5 8 13 21 34 ]) ( reduce + [ 31 28 30 31 30 31 ]) ( empty? []) Many Clojure core functions for collections map , reduce , apply , filter , remove are just a few examples of Clojure core functions that work with data structures. Defining custom functions \u03bb\ufe0e ( defn square-of \"Calculates the square of a given number\" [ number ] ( * number number )) ( square-of 9 ) Function definitions can also be used within other expressions, useful for mapping custom functions over a collection ( map ( fn [ number ] ( * number number )) [ 1 2 3 4 5 ]) Defining local names \u03bb\ufe0e Use the let function as a simple way to experiment with code designs ( let [ data ( range 24 188 ) total ( reduce + data ) values ( count data )] ( str \"Average value: \" ( / total values ))) Define local names to remove duplication in function definitions, or to simplify algorithms ( defn square-of \"Calculates the square of a given number\" [ number ] ( * number number )) ( square-of 9 ) Defining names for values (vars) \u03bb\ufe0e A name bound to a value can be used to represent that value throughout the code. Names can be bound to simple values (numbers, strings, etc.), collections or even function calls. def binds a name to a value with the scope of the current namespace. def is useful for data that is passed to multiple functions within a namespace. Evaluating a name will return the value it is bound to. ( def public-health-data [{ :date \"2020-01-01\" :confirmed-cases 23814 :recovery-percent 15 } { :date \"2020-01-02\" :confirmed-cases 24329 :recovery-percent 14 } { :date \"2020-01-03\" :confirmed-cases 25057 :recovery-percent 12 }]) public-health-data def for shared values, let for locally scoped values let function is used to bind names to values locally, such as within a function definition. Names bound with def have namespace scope so can be used with any code in that namespace. Iterating over collections \u03bb\ufe0e map iterates a function over a collection of values, returning a new collection of values ( map inc ( range 20 )) reduce iterates a function over the values of a collection to produce a new result (reduce + (range 101)) Reducing functions are function definitions used by the reduce function over a collection ( reduce ( fn [[ numerator denominator ] accumulator ] [( + numerator accumulator ) ( inc denominator )]) [ 0 0 ] ( range 1 20 )) Functions can call themselves to iterate over a collection. Using a lazy sequence means only the required numbers are generated, ensuring efficiency of operation and making the function usable in many different scenarios. ( defn fibonacci-sequence [ current-number next-number ] ( lazy-seq ( cons current-number ( fibonacci-sequence next-number ( + current-number next-number ))))) ( take 10 ( fibonacci-sequence 0 1 )) Host Interoperability \u03bb\ufe0e The REPL in this web page is running inside a JavaScript engine, so JavaScript functions can be used from within ClojureScript code (ClojureScript is Clojure that runs in JavaScript environments). In the box below, replace () with (js/alert \"I am a pop-up alert\") () Java libraries in Clojure java.lang library is available in Clojure by default and many other Java methods can be included by using their full name, e.g. (java.lang.Date.) will return the current date. Next steps \u03bb\ufe0e Install Clojure on your computer if you want to experiment even further or keep on reading more about Clojure.","title":"Clojure Quick Reference"},{"location":"introduction/first-taste-of-clojure/#clojure-quick-reference","text":"The basic Clojure syntax and a few common functions you should probably learn first. The examples are editable (using an embedded REPL) so feel free to experiment and watch as the return value changes as you change the code. Reload the page if you want to reset all the code back to the starting point. Install Clojure on your computer if you want to experiment even further. Want to go deeper already? Watch the Clojure language video series by Brian Will for a detailed introduction to key parts of the language. Or discover Clojure core functions by completing challenges on 4Clojure.org and then watching how Practicalli solved them .","title":"Clojure Quick Reference"},{"location":"introduction/first-taste-of-clojure/#calling-functions","text":"The first element in a list, () , is a call to a function. Any other elements are passed to the function as arguments. The examples show how to call functions with multiple arguments. ( + 1 2 ) ( + 3 ( * 2 ( - 7 2 ) 4 ) ( / 16 4 )) ( str \"Clojure is \" ( - 2021 2007 ) \" years old\" ) ( inc 1 ) ( map inc [ 1 2 3 4 5 ]) ( filter odd? ( range 11 )) Prefix notation and parens Hugging code with () is a simple syntax to define the scope of code expressions. No additional ; , , or spaces are required. Treating the first element of a list as a function call is referred to as prefix notation, which greatly simplifies Clojure syntax. Prefix notation makes mathematical expressions completely deterministic, eliminating the need for operator precedence .","title":"Calling functions"},{"location":"introduction/first-taste-of-clojure/#understanding-functions","text":"clojure.repl/doc function returns the doc-string of the given function. A doc-string should be part of all public function definitions. Clojure editors should provide commands to view doc-strings and the ability to jump to function definitions to view their source code ( clojure.repl/ddoc doc )","title":"Understanding functions"},{"location":"introduction/first-taste-of-clojure/#modeling-data-with-collection-types","text":"Clojure has 4 main collection types, all immutable (cannot change once created) and can contain any Clojure types. A list, () , used for calling functions and representing sequences. A linked list for sequential access. ( str \"lists used mainly \" ( * 2 2 ) \" \" :code ) A vector, [] , used for simple collections of values. An indexed data structure for random access [ 0 \"indexed\" :array ( * 2 2 ) \"random-access\" 4 :data ] A map, {} , use for descriptive data collections. An associative data structure for value lookup by unique keys (also known as a dictionary). { :hash-map :associative-collection :pairs { :key \"value\" } :aka \"dictionary\" } A set, #{} , use as a unique set of values. Sets are used to test if a value is contained within, i.e. predicates. # { 1 2 3 4 \"unique\" \"set\" \"of\" \"values\" \"unordered\" ( * 3 9 )} Persistent data types Values are immutable so when a function changes a value a new immutable value is created. When creating new collection values, unchanged values are shared with the original collection. This sharing model is called persistent data types and enables immutable data to be used efficiently.","title":"Modeling data with Collection types"},{"location":"introduction/first-taste-of-clojure/#using-data-structures","text":"Using the map and inc function, increment all the numbers in a vector ( map inc [ 1 2 3 4 5 ]) The above map function is roughly equivalent to the following expression ( conj [] ( inc 1 ) ( inc 2 ) ( inc 3 ) ( inc 4 ) ( inc 5 )) The conj function creates a new collection by combining a collection and one or more values. map reduce filter are common functions for iterating through a collection / sequence of values ( map * [ 1 3 5 8 13 21 ] [ 3 5 8 13 21 34 ]) ( filter even? [ 1 3 5 8 13 21 34 ]) ( reduce + [ 31 28 30 31 30 31 ]) ( empty? []) Many Clojure core functions for collections map , reduce , apply , filter , remove are just a few examples of Clojure core functions that work with data structures.","title":"Using data structures"},{"location":"introduction/first-taste-of-clojure/#defining-custom-functions","text":"( defn square-of \"Calculates the square of a given number\" [ number ] ( * number number )) ( square-of 9 ) Function definitions can also be used within other expressions, useful for mapping custom functions over a collection ( map ( fn [ number ] ( * number number )) [ 1 2 3 4 5 ])","title":"Defining custom functions"},{"location":"introduction/first-taste-of-clojure/#defining-local-names","text":"Use the let function as a simple way to experiment with code designs ( let [ data ( range 24 188 ) total ( reduce + data ) values ( count data )] ( str \"Average value: \" ( / total values ))) Define local names to remove duplication in function definitions, or to simplify algorithms ( defn square-of \"Calculates the square of a given number\" [ number ] ( * number number )) ( square-of 9 )","title":"Defining local names"},{"location":"introduction/first-taste-of-clojure/#defining-names-for-values-vars","text":"A name bound to a value can be used to represent that value throughout the code. Names can be bound to simple values (numbers, strings, etc.), collections or even function calls. def binds a name to a value with the scope of the current namespace. def is useful for data that is passed to multiple functions within a namespace. Evaluating a name will return the value it is bound to. ( def public-health-data [{ :date \"2020-01-01\" :confirmed-cases 23814 :recovery-percent 15 } { :date \"2020-01-02\" :confirmed-cases 24329 :recovery-percent 14 } { :date \"2020-01-03\" :confirmed-cases 25057 :recovery-percent 12 }]) public-health-data def for shared values, let for locally scoped values let function is used to bind names to values locally, such as within a function definition. Names bound with def have namespace scope so can be used with any code in that namespace.","title":"Defining names for values (vars)"},{"location":"introduction/first-taste-of-clojure/#iterating-over-collections","text":"map iterates a function over a collection of values, returning a new collection of values ( map inc ( range 20 )) reduce iterates a function over the values of a collection to produce a new result (reduce + (range 101)) Reducing functions are function definitions used by the reduce function over a collection ( reduce ( fn [[ numerator denominator ] accumulator ] [( + numerator accumulator ) ( inc denominator )]) [ 0 0 ] ( range 1 20 )) Functions can call themselves to iterate over a collection. Using a lazy sequence means only the required numbers are generated, ensuring efficiency of operation and making the function usable in many different scenarios. ( defn fibonacci-sequence [ current-number next-number ] ( lazy-seq ( cons current-number ( fibonacci-sequence next-number ( + current-number next-number ))))) ( take 10 ( fibonacci-sequence 0 1 ))","title":"Iterating over collections"},{"location":"introduction/first-taste-of-clojure/#host-interoperability","text":"The REPL in this web page is running inside a JavaScript engine, so JavaScript functions can be used from within ClojureScript code (ClojureScript is Clojure that runs in JavaScript environments). In the box below, replace () with (js/alert \"I am a pop-up alert\") () Java libraries in Clojure java.lang library is available in Clojure by default and many other Java methods can be included by using their full name, e.g. (java.lang.Date.) will return the current date.","title":"Host Interoperability"},{"location":"introduction/first-taste-of-clojure/#next-steps","text":"Install Clojure on your computer if you want to experiment even further or keep on reading more about Clojure.","title":"Next steps"},{"location":"introduction/five-steps-to-clojure/","text":"5 Steps to Clojure \u03bb\ufe0e Set up your environment \u03bb\ufe0e Install Clojure and a build tool Setup a Clojure aware editor * Emacs & CIDER - Spacemacs, Doom, Prelude * Neovim & Conjure * VSCode & Clover or Calva * Sublime Text & SublimedClojure Learn the syntax \u03bb\ufe0e Practice the core functions \u03bb\ufe0e 4clojure.org Exercism.io def / defn / let \u03bb\ufe0e map / reduce / apply \u03bb\ufe0e for / while / loop / recur \u03bb\ufe0e Adopt functional programming practices \u03bb\ufe0e Learn the commonly used libraries \u03bb\ufe0e Server-side websites \u03bb\ufe0e Ring / Compojure / Reitit / Hiccup | Selma \u03bb\ufe0e React client-side single page apps \u03bb\ufe0e React.js / Om-next / Reagent / Re-frame \u03bb\ufe0e core.async \u03bb\ufe0e Full Stack apps \u03bb\ufe0e Kit Framework \u03bb\ufe0e","title":"5 Steps to Clojure"},{"location":"introduction/five-steps-to-clojure/#5-steps-to-clojure","text":"","title":"5 Steps to Clojure"},{"location":"introduction/five-steps-to-clojure/#set-up-your-environment","text":"Install Clojure and a build tool Setup a Clojure aware editor * Emacs & CIDER - Spacemacs, Doom, Prelude * Neovim & Conjure * VSCode & Clover or Calva * Sublime Text & SublimedClojure","title":"Set up your environment"},{"location":"introduction/five-steps-to-clojure/#learn-the-syntax","text":"","title":"Learn the syntax"},{"location":"introduction/five-steps-to-clojure/#practice-the-core-functions","text":"4clojure.org Exercism.io","title":"Practice the core functions"},{"location":"introduction/five-steps-to-clojure/#def-defn-let","text":"","title":"def / defn / let"},{"location":"introduction/five-steps-to-clojure/#map-reduce-apply","text":"","title":"map / reduce / apply"},{"location":"introduction/five-steps-to-clojure/#for-while-loop-recur","text":"","title":"for / while / loop / recur"},{"location":"introduction/five-steps-to-clojure/#adopt-functional-programming-practices","text":"","title":"Adopt functional programming practices"},{"location":"introduction/five-steps-to-clojure/#learn-the-commonly-used-libraries","text":"","title":"Learn the commonly used libraries"},{"location":"introduction/five-steps-to-clojure/#server-side-websites","text":"","title":"Server-side websites"},{"location":"introduction/five-steps-to-clojure/#ring-compojure-reitit-hiccup-selma","text":"","title":"Ring / Compojure / Reitit / Hiccup | Selma"},{"location":"introduction/five-steps-to-clojure/#react-client-side-single-page-apps","text":"","title":"React client-side single page apps"},{"location":"introduction/five-steps-to-clojure/#reactjs-om-next-reagent-re-frame","text":"","title":"React.js / Om-next / Reagent / Re-frame"},{"location":"introduction/five-steps-to-clojure/#coreasync","text":"","title":"core.async"},{"location":"introduction/five-steps-to-clojure/#full-stack-apps","text":"","title":"Full Stack apps"},{"location":"introduction/five-steps-to-clojure/#kit-framework","text":"","title":"Kit Framework"},{"location":"introduction/learning-clojure/","text":"Learning Clojure \u03bb\ufe0e Learning the syntax of Clojure is really quick (its very small and simple). Learning to think functionally and discovering the 700+ functions in the Clojure API can take a little longer. I recommend you find someone with a bit of Clojure experience to guide you. Here is my suggested path to learning Clojure and thinking functionally. Many of the tasks can be done in parallel. Simple rather than complex - the foundation of Clojure \u03bb\ufe0e Gaining an appreciation that systems should be simple is a crucial step truly understanding Clojure. So early in your journey into Clojure, spend an hour watching Rich Hickey talk about Simple made Easy - ( transcript of talk ). Experience the Clojure syntax \u03bb\ufe0e Take a quick look at the Syntax of Clojure. The syntax is very small, so this will take about 15 minutes to 1 hour (dependent on your own experiences with coding). Don't try to remember all the syntax, it will come through practise. - eg. Clojure in 15 minutes Set up an enjoyable environment to work in \u03bb\ufe0e Find how to use Clojure with your favourite editor or IDE. Configure this tool so you can easily run a REPL and evaluate some expressions. - repl.it - web based repl you can share / fork - Spacemacs - for the ultimate Emacs & Vim experience - IntelliJ and Cursive - Leiningen & any editor you like Building a frame of reference for functional programming \u03bb\ufe0e Find an introductory book that you like which provides lots of example code to help you feel more comfortable with the syntax and more importantly the major concepts of functional programming with Clojure. Type in the exercises as you read and don't be afraid to play around with code examples Clojure for the Brave and the True Living Clojure - includes a training guide Practicalli Clojure - you are already here :) ClojureBridge London workshop - aimed at those new to coding PurelyFunctional - Introduction to Clojure Practice Clojure standard library (clojure.core) \u03bb\ufe0e Practice Clojure. Write lots of small and relatively simple examples in Clojure and experiment with the code in the REPL and try break things. This will start helping you learn the Clojure API You should become comfortable in your understanding of: - basic values (strings, numbers, etc) and persistent collections (list, vector, map, set) - binding names to values and their scope (def, defn, let) - calling functions, defining functions, arity options for functions - Higher order functions and basics of functional composition (map, reduce, filter, etc) - Designing with data, Extensible Data Notation (EDN), data manipulation Activities to help practice Clojure include: - 4Clojure.org - aim to complete the first 50 exercises, the first 10 are relatively easy - Coding Kata exercises - Awesome Kata collection - Alice In Wonderland inspired Katas - Attend coding dojo events - e.g. London Clojurians Solidify some of the basics you have learned so far \u03bb\ufe0e Work on a relatively small project that you care about enough to work on - eg. a tool to help you at work Learn more tools to help you think functionally \u03bb\ufe0e mostly using immutable values and pure functions functional composition, sequences and transducers atoms for managing mutable state changes (with immutable values) Get a broader view of Clojure and learn some common practices \u03bb\ufe0e Start reading a book which is aimed at intermediate - Clojure CookBook Watch Video's about Clojure on subjects that are relevant to work or projects you want to work on. - ClojureTV on YouTube Follow tutorials on Clojure, especially those that introduce the amazing libraries available in Clojure - Lambda Island - PurelyFunctional.tv - Practical.li Work with some of the most common libraries in Clojure - Ring / Compojure for web development (server side) - ClojureScript for web UI or native mobile apps (client side) - Reagent - reactjs style single page apps - Reagent deep dive - excellent tutorial - core.async - for asynchronous programming - clojure.string - specific functions for string manipulation - tools.logging - java.jdbc - database access - data.zip - manipulating trees of data, e.g. XML","title":"Learning Clojure"},{"location":"introduction/learning-clojure/#learning-clojure","text":"Learning the syntax of Clojure is really quick (its very small and simple). Learning to think functionally and discovering the 700+ functions in the Clojure API can take a little longer. I recommend you find someone with a bit of Clojure experience to guide you. Here is my suggested path to learning Clojure and thinking functionally. Many of the tasks can be done in parallel.","title":"Learning Clojure"},{"location":"introduction/learning-clojure/#simple-rather-than-complex-the-foundation-of-clojure","text":"Gaining an appreciation that systems should be simple is a crucial step truly understanding Clojure. So early in your journey into Clojure, spend an hour watching Rich Hickey talk about Simple made Easy - ( transcript of talk ).","title":"Simple rather than complex - the foundation of Clojure"},{"location":"introduction/learning-clojure/#experience-the-clojure-syntax","text":"Take a quick look at the Syntax of Clojure. The syntax is very small, so this will take about 15 minutes to 1 hour (dependent on your own experiences with coding). Don't try to remember all the syntax, it will come through practise. - eg. Clojure in 15 minutes","title":"Experience the Clojure syntax"},{"location":"introduction/learning-clojure/#set-up-an-enjoyable-environment-to-work-in","text":"Find how to use Clojure with your favourite editor or IDE. Configure this tool so you can easily run a REPL and evaluate some expressions. - repl.it - web based repl you can share / fork - Spacemacs - for the ultimate Emacs & Vim experience - IntelliJ and Cursive - Leiningen & any editor you like","title":"Set up an enjoyable environment to work in"},{"location":"introduction/learning-clojure/#building-a-frame-of-reference-for-functional-programming","text":"Find an introductory book that you like which provides lots of example code to help you feel more comfortable with the syntax and more importantly the major concepts of functional programming with Clojure. Type in the exercises as you read and don't be afraid to play around with code examples Clojure for the Brave and the True Living Clojure - includes a training guide Practicalli Clojure - you are already here :) ClojureBridge London workshop - aimed at those new to coding PurelyFunctional - Introduction to Clojure","title":"Building a frame of reference for functional programming"},{"location":"introduction/learning-clojure/#practice-clojure-standard-library-clojurecore","text":"Practice Clojure. Write lots of small and relatively simple examples in Clojure and experiment with the code in the REPL and try break things. This will start helping you learn the Clojure API You should become comfortable in your understanding of: - basic values (strings, numbers, etc) and persistent collections (list, vector, map, set) - binding names to values and their scope (def, defn, let) - calling functions, defining functions, arity options for functions - Higher order functions and basics of functional composition (map, reduce, filter, etc) - Designing with data, Extensible Data Notation (EDN), data manipulation Activities to help practice Clojure include: - 4Clojure.org - aim to complete the first 50 exercises, the first 10 are relatively easy - Coding Kata exercises - Awesome Kata collection - Alice In Wonderland inspired Katas - Attend coding dojo events - e.g. London Clojurians","title":"Practice Clojure standard library (clojure.core)"},{"location":"introduction/learning-clojure/#solidify-some-of-the-basics-you-have-learned-so-far","text":"Work on a relatively small project that you care about enough to work on - eg. a tool to help you at work","title":"Solidify some of the basics you have learned so far"},{"location":"introduction/learning-clojure/#learn-more-tools-to-help-you-think-functionally","text":"mostly using immutable values and pure functions functional composition, sequences and transducers atoms for managing mutable state changes (with immutable values)","title":"Learn more tools to help you think functionally"},{"location":"introduction/learning-clojure/#get-a-broader-view-of-clojure-and-learn-some-common-practices","text":"Start reading a book which is aimed at intermediate - Clojure CookBook Watch Video's about Clojure on subjects that are relevant to work or projects you want to work on. - ClojureTV on YouTube Follow tutorials on Clojure, especially those that introduce the amazing libraries available in Clojure - Lambda Island - PurelyFunctional.tv - Practical.li Work with some of the most common libraries in Clojure - Ring / Compojure for web development (server side) - ClojureScript for web UI or native mobile apps (client side) - Reagent - reactjs style single page apps - Reagent deep dive - excellent tutorial - core.async - for asynchronous programming - clojure.string - specific functions for string manipulation - tools.logging - java.jdbc - database access - data.zip - manipulating trees of data, e.g. XML","title":"Get a broader view of Clojure and learn some common practices"},{"location":"introduction/repl-workflow/","text":"REPL Driven Development \u03bb\ufe0e Always be REPL'ing Coding without a REPL feels limiting. The REPL provides fast feedback from code as its crafted, testing assumptions and design choices every step of the journey to a solution - John Stevenson, Practical.li REPL driven development is the foundation of working with Clojure effectively An effective Clojure workflow begins by running a REPL process. Clojure expressions are written and evaluated immediately to provide instant feedback as design decisions are coded. The REPL feedback tests the assumptions driving design choices. Important design choices provide data which can be codified into unit tests, optionally using spec and generative testing. Read - code is read by the Clojure reader, passing any macros to the macro reader which converts those macros into Clojure code. Evaluate - code is compiled into the host language (e.g. Java bytecode) and executed Print - results of the code are displayed, either in the REPL or as part of the application. Loop - the REPL is a continuous process that evaluates code, either a single expression or the whole application. Evaluating source code \u03bb\ufe0e A REPL connected editor is the primary tool for evaluating Clojure code from source code files, displaying the results inline. Source code is automatically evaluated in its respective namespace, removing the need to change namespaces in the REPL, ( in-ns ), or use fully qualified names to call functions. Evaluate Clojure in a Terminal UI REPL Entering expressions at the REPL prompt evaluates the expression immediately, returning the result directly underneath Rich Comment blocks - living documentation \u03bb\ufe0e The (comment ,,,) function wraps code that is only run directly by the developer using a Clojure aware editor . Expressions in rich comment blocks can represent how to use the functions that make up the namespace API. For example, starting/restarting the system, updating the database, etc. Expressions provide examples of calling functions with typical arguments and make a project more accessible and easier to work with. Rich comment blocks are very useful for rapidly iterating over different design decisions by including the same function but with different implementations. Hide clj-kondo linter warnings for redefined vars ( def , defn ) when using this approach. ;; Rich comment block with redefined vars ignored # _ { :clj-kondo/ignore [ :redefined-var ]} ( comment ( defn value-added-tax [] ;; algorithm design - first try) ( defn value-added-tax [] ;; algorithm design - first try) ) ;; End of rich comment block The \"Rich\" in the name is an honourary mention to Rich Hickey, the author and benevolent dictator of Clojure design. Design Journal \u03bb\ufe0e A journal of design decisions makes the code easier to understand and maintain. Code examples of design decisions and alternative design discussions are captured, reducing the time spent revisiting those discussions. Journals simplify the developer on-boarding processes as the journey through design decisions are already documented. A Design Journal is usually created in a separate namespace, although it may start as a rich comment at the bottom of a namespace. A journal should cover the following aspects Relevant expressions use to test assumptions about design options. Examples of design choices not taken and discussions why (saves repeating the same design discussions) Expressions that can be evaluated to explain how a function or parts of a function work The design journal can be used to create meaningful documentation for the project very easily and should prevent time spent on repeating the same conversations. Example design journal Design journal for TicTacToe game using Reagent, ClojureScript and Scalable Vector Graphics Viewing data structures \u03bb\ufe0e Pretty print shows the structure of results from function calls in a human-friendly form, making it easier for a developer to parse and more likely to notice incorrect results. , e p on the Spacemacs Clojure menu has several commands to Pretty Print data structure results when evaluating code. , d v is the Cider Inspect menu for paging through very large data sets and navigate nested data structures in detail. , d is the Cider debug menu which can inspect view intermediate values and data structures during the debugging of Clojure function calls. Cider inspector is an effective way to navigate nested data and page through large data sets. External data browsers can visualise data in many different forms. Code Style and idiomatic Clojure \u03bb\ufe0e Clojure aware editors should automatically apply formatting that follows the Clojure Style guide . Live linting with clj-kondo suggests common idioms and highlights a wide range of syntax errors as code is written, minimizing bugs and therefore speeding up the development process. Clojure Style Guide The Clojure Style guide provides examples of common formatting approaches, although the development team should decide which of these to adopt. Emacs clojure-mode will automatically format code and so will Clojure LSP (via cljfmt). These tools are configurable and should be tailored to the teams standard. Test Driven Development and REPL Driven Development \u03bb\ufe0e Test Driven Development (TDD) and REPL Driven Development (RDD) complement each other as they both encourage incremental changes and continuous feedback. Test Driven Development fits well with Hammock Time, as good design comes from deep thought RDD enables rapid design experiments so different approaches can easily and quickly be evaluated . TDD focuses the results of the REPL experiments into design decisions, codified as unit tests. These tests guide the correctness of specific implementations and provide critical feedback when changes break that design. Unit tests should support the public API of each namespace in a project to help prevent regressions in the code. Its far more efficient in terms of thinking time to define unit tests as the design starts to stabilize than as an after thought. clojure.test library is part of the Clojure standard library that provides a simple way to start writing unit tests. Clojure spec can also be used for generative testing, providing far greater scope in values used when running unit tests. Specifications can be defined for values and functions. Clojure has a number of test runners available. Kaocha is a test runner that will run unit tests and function specification checks. Automate local test runner Use kaocha test runner in watch mode to run tests and specification check automatically (when changes are saved) clojure -X:test/watch Continuous Integration and Deployment \u03bb\ufe0e Add a continuous integration service to run tests and builds code on every shared commit. Spin up testable review deployments when commits pushed to a pull request branch, before pushing commits to the main deployment branch, creating an effective pipeline to gain further feedback. CircleCI provides a simple to use service that supports Clojure projects. GitHub Workflows and GitHub actions marketplace to quickly build a tailored continuous integration service, e.g. Setup Clojure GitHub Action . GitLab CI Live Coding with Data - Stuart Halloway \u03bb\ufe0e There are few novel features of programming languages, but each combination has different properties. The combination of dynamic, hosted, functional and extended Lisp in Clojure gives developers the tools for making effective programs. The ways in which Clojure's unique combination of features can yield a highly effective development process. Over more than a decade we have developed an effective approach to writing code in Clojure whose power comes from composing many of its key features. As different as Clojure programs are from e.g. Java programs, so to can and should be the development experience. You are not in Kansas anymore! This talk presents a demonstration of the leverage you can get when writing programs in Clojure, with examples, based on my experiences as a core developer of Clojure and Datomic.","title":"REPL Workflow"},{"location":"introduction/repl-workflow/#repl-driven-development","text":"Always be REPL'ing Coding without a REPL feels limiting. The REPL provides fast feedback from code as its crafted, testing assumptions and design choices every step of the journey to a solution - John Stevenson, Practical.li REPL driven development is the foundation of working with Clojure effectively An effective Clojure workflow begins by running a REPL process. Clojure expressions are written and evaluated immediately to provide instant feedback as design decisions are coded. The REPL feedback tests the assumptions driving design choices. Important design choices provide data which can be codified into unit tests, optionally using spec and generative testing. Read - code is read by the Clojure reader, passing any macros to the macro reader which converts those macros into Clojure code. Evaluate - code is compiled into the host language (e.g. Java bytecode) and executed Print - results of the code are displayed, either in the REPL or as part of the application. Loop - the REPL is a continuous process that evaluates code, either a single expression or the whole application.","title":"REPL Driven Development"},{"location":"introduction/repl-workflow/#evaluating-source-code","text":"A REPL connected editor is the primary tool for evaluating Clojure code from source code files, displaying the results inline. Source code is automatically evaluated in its respective namespace, removing the need to change namespaces in the REPL, ( in-ns ), or use fully qualified names to call functions. Evaluate Clojure in a Terminal UI REPL Entering expressions at the REPL prompt evaluates the expression immediately, returning the result directly underneath","title":"Evaluating source code"},{"location":"introduction/repl-workflow/#rich-comment-blocks-living-documentation","text":"The (comment ,,,) function wraps code that is only run directly by the developer using a Clojure aware editor . Expressions in rich comment blocks can represent how to use the functions that make up the namespace API. For example, starting/restarting the system, updating the database, etc. Expressions provide examples of calling functions with typical arguments and make a project more accessible and easier to work with. Rich comment blocks are very useful for rapidly iterating over different design decisions by including the same function but with different implementations. Hide clj-kondo linter warnings for redefined vars ( def , defn ) when using this approach. ;; Rich comment block with redefined vars ignored # _ { :clj-kondo/ignore [ :redefined-var ]} ( comment ( defn value-added-tax [] ;; algorithm design - first try) ( defn value-added-tax [] ;; algorithm design - first try) ) ;; End of rich comment block The \"Rich\" in the name is an honourary mention to Rich Hickey, the author and benevolent dictator of Clojure design.","title":"Rich Comment blocks - living documentation"},{"location":"introduction/repl-workflow/#design-journal","text":"A journal of design decisions makes the code easier to understand and maintain. Code examples of design decisions and alternative design discussions are captured, reducing the time spent revisiting those discussions. Journals simplify the developer on-boarding processes as the journey through design decisions are already documented. A Design Journal is usually created in a separate namespace, although it may start as a rich comment at the bottom of a namespace. A journal should cover the following aspects Relevant expressions use to test assumptions about design options. Examples of design choices not taken and discussions why (saves repeating the same design discussions) Expressions that can be evaluated to explain how a function or parts of a function work The design journal can be used to create meaningful documentation for the project very easily and should prevent time spent on repeating the same conversations. Example design journal Design journal for TicTacToe game using Reagent, ClojureScript and Scalable Vector Graphics","title":"Design Journal"},{"location":"introduction/repl-workflow/#viewing-data-structures","text":"Pretty print shows the structure of results from function calls in a human-friendly form, making it easier for a developer to parse and more likely to notice incorrect results. , e p on the Spacemacs Clojure menu has several commands to Pretty Print data structure results when evaluating code. , d v is the Cider Inspect menu for paging through very large data sets and navigate nested data structures in detail. , d is the Cider debug menu which can inspect view intermediate values and data structures during the debugging of Clojure function calls. Cider inspector is an effective way to navigate nested data and page through large data sets. External data browsers can visualise data in many different forms.","title":"Viewing data structures"},{"location":"introduction/repl-workflow/#code-style-and-idiomatic-clojure","text":"Clojure aware editors should automatically apply formatting that follows the Clojure Style guide . Live linting with clj-kondo suggests common idioms and highlights a wide range of syntax errors as code is written, minimizing bugs and therefore speeding up the development process. Clojure Style Guide The Clojure Style guide provides examples of common formatting approaches, although the development team should decide which of these to adopt. Emacs clojure-mode will automatically format code and so will Clojure LSP (via cljfmt). These tools are configurable and should be tailored to the teams standard.","title":"Code Style and idiomatic Clojure"},{"location":"introduction/repl-workflow/#test-driven-development-and-repl-driven-development","text":"Test Driven Development (TDD) and REPL Driven Development (RDD) complement each other as they both encourage incremental changes and continuous feedback. Test Driven Development fits well with Hammock Time, as good design comes from deep thought RDD enables rapid design experiments so different approaches can easily and quickly be evaluated . TDD focuses the results of the REPL experiments into design decisions, codified as unit tests. These tests guide the correctness of specific implementations and provide critical feedback when changes break that design. Unit tests should support the public API of each namespace in a project to help prevent regressions in the code. Its far more efficient in terms of thinking time to define unit tests as the design starts to stabilize than as an after thought. clojure.test library is part of the Clojure standard library that provides a simple way to start writing unit tests. Clojure spec can also be used for generative testing, providing far greater scope in values used when running unit tests. Specifications can be defined for values and functions. Clojure has a number of test runners available. Kaocha is a test runner that will run unit tests and function specification checks. Automate local test runner Use kaocha test runner in watch mode to run tests and specification check automatically (when changes are saved) clojure -X:test/watch","title":"Test Driven Development and REPL Driven Development"},{"location":"introduction/repl-workflow/#continuous-integration-and-deployment","text":"Add a continuous integration service to run tests and builds code on every shared commit. Spin up testable review deployments when commits pushed to a pull request branch, before pushing commits to the main deployment branch, creating an effective pipeline to gain further feedback. CircleCI provides a simple to use service that supports Clojure projects. GitHub Workflows and GitHub actions marketplace to quickly build a tailored continuous integration service, e.g. Setup Clojure GitHub Action . GitLab CI","title":"Continuous Integration and Deployment"},{"location":"introduction/repl-workflow/#live-coding-with-data-stuart-halloway","text":"There are few novel features of programming languages, but each combination has different properties. The combination of dynamic, hosted, functional and extended Lisp in Clojure gives developers the tools for making effective programs. The ways in which Clojure's unique combination of features can yield a highly effective development process. Over more than a decade we have developed an effective approach to writing code in Clojure whose power comes from composing many of its key features. As different as Clojure programs are from e.g. Java programs, so to can and should be the development experience. You are not in Kansas anymore! This talk presents a demonstration of the leverage you can get when writing programs in Clojure, with examples, based on my experiences as a core developer of Clojure and Datomic.","title":"Live Coding with Data - Stuart Halloway"},{"location":"introduction/who-uses-clojure/","text":"Who uses Clojure \u03bb\ufe0e Hundreds of companies actively advertised their Clojure adoption. Given the broad participation in user groups there are clearly many more organizations using Clojure at some level in their technology stack. A quick scan of various job sites shows Clojure positions at companies like Walmart, Facebook, Staples, Consumer Reports, Salesforce, and Amazon. It doesn't get much more mainstream than that. If you are looking for a new role using Clojure or other functional programming languages, visit Functional Works , the only Functional Recruiters in the world. Here is just a small and diverse set of example companies that I am aware of that use Clojure for development. Company Type of applications Boeing Boeing 737 MAX - onboard maintenance Puppet Labs DevOps apps & services e.g. trapperkeeper Cisco Malware analysis & threat intelligence platform (expert system with core.logic) Deuche Bank (UK) Processing event streams from Apache Storm Atlassian Collaborative editing platform for all their products Netflix Map-Reduce languages for writing apps for Hadoop / Pig USwitch (UK) Creating meaningful data from multiple sources Daily Mail Online (UK) Publishing pipeline Circle CI (USA) Front-end of CI server in ClojureScript & test suite CitiGroup Financial Trading Student Loans company (UK) Loans management system written in Clojure LinkedIn Powers the LinkedIn social graph Walmart (USA) eReceipts project to process every purchase from 5,000+ stores SwiftKey (UK) Predictive intelligence platform (possibly used with Microsoft Cortana) Roomkey.co.uk Hotel booking system to rival Expedia (with a tiny development team) Funding Circle (UK & USA) Adopting Clojure as their main language (from Ruby, etc) Braintree Payment processing pipeline with Kafka Mastodon C Data centre analysis (Incanta, Storm) Thoughtworks Agile development for Client projects world wide Vero Insurance (AUS) Rebuilt policy management system in Clojure with Thoughworks Meta-X Performance art (Overtone, Quil) Salesforce (USA) Build & deployment with Puppet & Application Routing with nginx-clojure There are many more examples of projects on the HackerNews thread: Ask HN: Who's using Clojure in Production Tech Radar \u03bb\ufe0e Clojure is also defined as a technology that can be adopted since 2014, according to the Thoughtworks technology radar. JUXT also created its own Clojure specific technology radar as there is such an encompassing ecosystem of libraries and services.","title":"Who uses Clojure"},{"location":"introduction/who-uses-clojure/#who-uses-clojure","text":"Hundreds of companies actively advertised their Clojure adoption. Given the broad participation in user groups there are clearly many more organizations using Clojure at some level in their technology stack. A quick scan of various job sites shows Clojure positions at companies like Walmart, Facebook, Staples, Consumer Reports, Salesforce, and Amazon. It doesn't get much more mainstream than that. If you are looking for a new role using Clojure or other functional programming languages, visit Functional Works , the only Functional Recruiters in the world. Here is just a small and diverse set of example companies that I am aware of that use Clojure for development. Company Type of applications Boeing Boeing 737 MAX - onboard maintenance Puppet Labs DevOps apps & services e.g. trapperkeeper Cisco Malware analysis & threat intelligence platform (expert system with core.logic) Deuche Bank (UK) Processing event streams from Apache Storm Atlassian Collaborative editing platform for all their products Netflix Map-Reduce languages for writing apps for Hadoop / Pig USwitch (UK) Creating meaningful data from multiple sources Daily Mail Online (UK) Publishing pipeline Circle CI (USA) Front-end of CI server in ClojureScript & test suite CitiGroup Financial Trading Student Loans company (UK) Loans management system written in Clojure LinkedIn Powers the LinkedIn social graph Walmart (USA) eReceipts project to process every purchase from 5,000+ stores SwiftKey (UK) Predictive intelligence platform (possibly used with Microsoft Cortana) Roomkey.co.uk Hotel booking system to rival Expedia (with a tiny development team) Funding Circle (UK & USA) Adopting Clojure as their main language (from Ruby, etc) Braintree Payment processing pipeline with Kafka Mastodon C Data centre analysis (Incanta, Storm) Thoughtworks Agile development for Client projects world wide Vero Insurance (AUS) Rebuilt policy management system in Clojure with Thoughworks Meta-X Performance art (Overtone, Quil) Salesforce (USA) Build & deployment with Puppet & Application Routing with nginx-clojure There are many more examples of projects on the HackerNews thread: Ask HN: Who's using Clojure in Production","title":"Who uses Clojure"},{"location":"introduction/who-uses-clojure/#tech-radar","text":"Clojure is also defined as a technology that can be adopted since 2014, according to the Thoughtworks technology radar. JUXT also created its own Clojure specific technology radar as there is such an encompassing ecosystem of libraries and services.","title":"Tech Radar"},{"location":"introduction/writing-tips/","text":"Writing tips for MkDocs \u03bb\ufe0e Making the docs more engaging using the mkdocs-material theme reference guide Hypertext links \u03bb\ufe0e Links open in the same browser window/tab by default. Add {target=_blank} to the end of a link to configure opening in a new tab [ link text ]( url ){target=_blank} Buttons \u03bb\ufe0e Convert any link into a button by adding {.md-button} class names to end of the markdown for a link, which uses .md-button-primary by default. Include target=_blank for buttons with links to external sites. [link text](http://practical.li/blog){.md-button target=_blank} Or specify a different class [link text](http://practical.li/blog){.md-button .md-button-primary} Add an icon to the button Practicalli Issues Practicalli Blog [ :fontawesome-brands-github: Practicalli Issues ]( http://practical.li/blog ){ .md-button .md-button-primary } [ :octicons-heart-fill-24: Practicalli Blog ]( http://practical.li/blog ){ .md-button .md-button-primary } YouTube video \u03bb\ufe0e Use an iframe element to include a YouTube video, wrapping in a paragraph tag with center alignment to place the video in a centered horizontal position < p style = \"text-align:center\" > < iframe width = \"560\" height = \"315\" src = \"https://www.youtube.com/embed/rQ802kSaip4\" title = \"YouTube video player\" frameborder = \"0\" allow = \"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen ></ iframe > </ p > mkdocs material does not have direct support for adding a YouTube video via markdown. Admonitions \u03bb\ufe0e Supported admonition types Note Use !!! followed by NOTE Adding a title Use !!! followed by NOTE and a \"title in double quotes\" Shh, no title bar just the text... Use !!! followed by NOTE and a \"\" empty double quotes Abstract Use !!! followed by ABSTRACT Info Use !!! followed by INFO Tip Use !!! followed by TIP Success Use !!! followed by SUCCESS Question Use !!! followed by QUESTION Warning Use !!! followed by WARNING Failure Use !!! followed by FAILURE Danger Use !!! followed by DANGER Bug Use !!! followed by BUG Example Use !!! followed by EXAMPLE Quote Use !!! followed by QUOTE Collapsing admonitions \u03bb\ufe0e Note Collapse those admonitions using ??? instead of !!! Replace with a title Use ??? followed by NOTE and a \"title in double quotes\" Expanded by default Use ???+ , note the + character, followed by NOTE and a \"title in double quotes\" Inline blocks \u03bb\ufe0e Inline blocks of text to make a very specific callout within text Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Adding something to then end of text is probably my favourite Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Code blocks \u03bb\ufe0e Code blocks include a copy icon automatically Syntax highlighting in code blocks ( defn my-function ; Write a simple function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ])) Give the code block a title using title=\"\" after the backtics and language name src/practicalli/gameboard.clj ( defn my-function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ])) We all like line numbers, especially when you can set the starting line src/practicalli/gameboard.clj 42 43 44 45 ( defn my-function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ])) Add linenums=42 to start line numbers from 42 onward clojure linenums=\"42\" title=\"src/practicalli/gameboard.clj\" Annotations \u03bb\ufe0e Add an annotation using # (1) where 1 is the number of the annotation ls -la $HOME /Downloads # (1) I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be written in Markdown. Code blocks with annotation, add ! after the annotation number to suppress the # character ( defn helper-function \"Doc-string with description of function purpose\" ; (1)! [ data ] ( merge { :fish 1 } data ) ) 1. Always include a doc-string in every function to describe the purpose of that function, identifying why it was added and what its value is. GitHub action example with multiple annotations name : ci # (1)! on : push : branches : - master # (2)! - main permissions : contents : write jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v3 - uses : actions/setup-python@v4 with : python-version : 3.x - run : pip install mkdocs-material # (3)! - run : mkdocs gh-deploy --force You can change the name to your liking. At some point, GitHub renamed master to main . If your default branch is named master , you can safely remove main , vice versa. This is the place to install further [MkDocs plugins] or Markdown extensions with pip to be used during the build: pip install \\ mkdocs-material \\ mkdocs-awesome-pages-plugin \\ ... Highlight lines in code blocks \u03bb\ufe0e hl_lines=\"2\" where 2 is the line number to highlight ( defn my-function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ])) Content tabs \u03bb\ufe0e Create in page tabs that can also be Setting up a project Clojure CLI Leiningen clojure -T:project/new :template app :name practicalli/gameboard lein new app practicalli/gameboard Or nest the content tabs in an admonition Run a terminal REPL Clojure CLI Leiningen clojure -T:repl/rebel lein repl Diagrams \u03bb\ufe0e Neat flow diagrams graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; UML Sequence Diagrams sequenceDiagram Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! state transition diagrams stateDiagram-v2 state fork_state <<fork>> [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state <<join>> State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] Class diagrams - but dont need them. Entity relationship diagrams are handy though erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses Other diagram types \u03bb\ufe0e Besides the diagram types listed above, [Mermaid.js] provides support for pie charts , gantt charts , user journeys , git graphs and requirement diagrams , all of which are not officially supported by Material for MkDocs. Those diagrams should still work as advertised by [Mermaid.js], but we don't consider them a good choice, mostly as they don't work well on mobile. Keyboard keys \u03bb\ufe0e Represent key bindings with Keyboard keys . Each number and alphabet character has their own key. 1 ++1++ for numbers l ++\"l\"++ for lowercase character U ++u++ for uppercase character or ++\"U\"++ for consistency Punctionation keys use their name Space ++spc++ , ++comma++ Left ++arrow-left++ For key sequences, place a space between each keyboard character Space g s ++spc++ ++\"g\"++ ++\"s\"++ For key combinations, use join they key identifies with a + Meta + X ++meta+x++ Ctrl + Alt + Del ++ctrl+alt+del++ MkDocs keyboard keys reference Grids \u03bb\ufe0e Useful for putting button links on the main page as quick links into the key parts of the book HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? Sponsor only feature Images \u03bb\ufe0e Markdown images can be appended with material tags to set the size of the image, whether to appear on light or dark theme and support lazy image loading in browsers Size Lazy Loading Align Theme Specific All Image Attributes {style=\"height:150px;width:150px\"} specifies the image size ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){style=\"height:150px;width:150px\"} {loading=lazy} specifies an image should lazily load in the browser ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png ){loading=lazy} {aligh=left} or {aligh=right} specifies the page alignment of an image. ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){align=right} ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light ){align=right} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. ![Kitty Logo](image/kitty-light.png#only-dark) or ![Kitty Logo](image/kitty-light.png#only-light) specifies the theme the image should be shown, allowing different versions of images to be shown based on the theme. ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){style=\"height:150px;width:150px\"} ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light ){style=\"height:150px;width:150px\"} Use the theme toggle in the top nav bar to see the icon change between light and dark. Requires the color pallet toggle Alight right, lazy load and set image to 150x150 ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){align=right loading=lazy style=\"height:64px;width:64px\"} ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light ){align=right loading=lazy style=\"height:64px;width:64px\"} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lists \u03bb\ufe0e Task lists Lorem ipsum dolor sit amet, consectetur adipiscing elit Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Tooltips \u03bb\ufe0e The humble tool tip Hover me with references Hover me Icon tool tip with a title Abreviations \u03bb\ufe0e The HTML specification is maintained by the W3C. [HTML]: Hyper Text Markup Language [W3C]: World Wide Web Consortium Magic links \u03bb\ufe0e MagicLink can auto-link HTML, FTP, and email links. It can auto-convert repository links (GitHub, GitLab, and Bitbucket) and display them in a more concise, shorthand format. Email Practicalli Practicalli Neovim","title":"Writing Tips"},{"location":"introduction/writing-tips/#writing-tips-for-mkdocs","text":"Making the docs more engaging using the mkdocs-material theme reference guide","title":"Writing tips for MkDocs"},{"location":"introduction/writing-tips/#hypertext-links","text":"Links open in the same browser window/tab by default. Add {target=_blank} to the end of a link to configure opening in a new tab [ link text ]( url ){target=_blank}","title":"Hypertext links"},{"location":"introduction/writing-tips/#buttons","text":"Convert any link into a button by adding {.md-button} class names to end of the markdown for a link, which uses .md-button-primary by default. Include target=_blank for buttons with links to external sites. [link text](http://practical.li/blog){.md-button target=_blank} Or specify a different class [link text](http://practical.li/blog){.md-button .md-button-primary} Add an icon to the button Practicalli Issues Practicalli Blog [ :fontawesome-brands-github: Practicalli Issues ]( http://practical.li/blog ){ .md-button .md-button-primary } [ :octicons-heart-fill-24: Practicalli Blog ]( http://practical.li/blog ){ .md-button .md-button-primary }","title":"Buttons"},{"location":"introduction/writing-tips/#youtube-video","text":"Use an iframe element to include a YouTube video, wrapping in a paragraph tag with center alignment to place the video in a centered horizontal position < p style = \"text-align:center\" > < iframe width = \"560\" height = \"315\" src = \"https://www.youtube.com/embed/rQ802kSaip4\" title = \"YouTube video player\" frameborder = \"0\" allow = \"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen ></ iframe > </ p > mkdocs material does not have direct support for adding a YouTube video via markdown.","title":"YouTube video"},{"location":"introduction/writing-tips/#admonitions","text":"Supported admonition types Note Use !!! followed by NOTE Adding a title Use !!! followed by NOTE and a \"title in double quotes\" Shh, no title bar just the text... Use !!! followed by NOTE and a \"\" empty double quotes Abstract Use !!! followed by ABSTRACT Info Use !!! followed by INFO Tip Use !!! followed by TIP Success Use !!! followed by SUCCESS Question Use !!! followed by QUESTION Warning Use !!! followed by WARNING Failure Use !!! followed by FAILURE Danger Use !!! followed by DANGER Bug Use !!! followed by BUG Example Use !!! followed by EXAMPLE Quote Use !!! followed by QUOTE","title":"Admonitions"},{"location":"introduction/writing-tips/#collapsing-admonitions","text":"Note Collapse those admonitions using ??? instead of !!! Replace with a title Use ??? followed by NOTE and a \"title in double quotes\" Expanded by default Use ???+ , note the + character, followed by NOTE and a \"title in double quotes\"","title":"Collapsing admonitions"},{"location":"introduction/writing-tips/#inline-blocks","text":"Inline blocks of text to make a very specific callout within text Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Adding something to then end of text is probably my favourite Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Inline blocks"},{"location":"introduction/writing-tips/#code-blocks","text":"Code blocks include a copy icon automatically Syntax highlighting in code blocks ( defn my-function ; Write a simple function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ])) Give the code block a title using title=\"\" after the backtics and language name src/practicalli/gameboard.clj ( defn my-function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ])) We all like line numbers, especially when you can set the starting line src/practicalli/gameboard.clj 42 43 44 45 ( defn my-function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ])) Add linenums=42 to start line numbers from 42 onward clojure linenums=\"42\" title=\"src/practicalli/gameboard.clj\"","title":"Code blocks"},{"location":"introduction/writing-tips/#annotations","text":"Add an annotation using # (1) where 1 is the number of the annotation ls -la $HOME /Downloads # (1) I'm a code annotation! I can contain code , formatted text , images, ... basically anything that can be written in Markdown. Code blocks with annotation, add ! after the annotation number to suppress the # character ( defn helper-function \"Doc-string with description of function purpose\" ; (1)! [ data ] ( merge { :fish 1 } data ) ) 1. Always include a doc-string in every function to describe the purpose of that function, identifying why it was added and what its value is. GitHub action example with multiple annotations name : ci # (1)! on : push : branches : - master # (2)! - main permissions : contents : write jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v3 - uses : actions/setup-python@v4 with : python-version : 3.x - run : pip install mkdocs-material # (3)! - run : mkdocs gh-deploy --force You can change the name to your liking. At some point, GitHub renamed master to main . If your default branch is named master , you can safely remove main , vice versa. This is the place to install further [MkDocs plugins] or Markdown extensions with pip to be used during the build: pip install \\ mkdocs-material \\ mkdocs-awesome-pages-plugin \\ ...","title":"Annotations"},{"location":"introduction/writing-tips/#highlight-lines-in-code-blocks","text":"hl_lines=\"2\" where 2 is the line number to highlight ( defn my-function \"With a lovely doc-string\" [ arguments ] ( map inc [ 1 2 3 ]))","title":"Highlight lines in code blocks"},{"location":"introduction/writing-tips/#content-tabs","text":"Create in page tabs that can also be Setting up a project Clojure CLI Leiningen clojure -T:project/new :template app :name practicalli/gameboard lein new app practicalli/gameboard Or nest the content tabs in an admonition Run a terminal REPL Clojure CLI Leiningen clojure -T:repl/rebel lein repl","title":"Content tabs"},{"location":"introduction/writing-tips/#diagrams","text":"Neat flow diagrams graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; UML Sequence Diagrams sequenceDiagram Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! state transition diagrams stateDiagram-v2 state fork_state <<fork>> [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state <<join>> State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] Class diagrams - but dont need them. Entity relationship diagrams are handy though erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses","title":"Diagrams"},{"location":"introduction/writing-tips/#other-diagram-types","text":"Besides the diagram types listed above, [Mermaid.js] provides support for pie charts , gantt charts , user journeys , git graphs and requirement diagrams , all of which are not officially supported by Material for MkDocs. Those diagrams should still work as advertised by [Mermaid.js], but we don't consider them a good choice, mostly as they don't work well on mobile.","title":"Other diagram types"},{"location":"introduction/writing-tips/#keyboard-keys","text":"Represent key bindings with Keyboard keys . Each number and alphabet character has their own key. 1 ++1++ for numbers l ++\"l\"++ for lowercase character U ++u++ for uppercase character or ++\"U\"++ for consistency Punctionation keys use their name Space ++spc++ , ++comma++ Left ++arrow-left++ For key sequences, place a space between each keyboard character Space g s ++spc++ ++\"g\"++ ++\"s\"++ For key combinations, use join they key identifies with a + Meta + X ++meta+x++ Ctrl + Alt + Del ++ctrl+alt+del++ MkDocs keyboard keys reference","title":"Keyboard keys"},{"location":"introduction/writing-tips/#grids","text":"Useful for putting button links on the main page as quick links into the key parts of the book HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? Sponsor only feature","title":"Grids"},{"location":"introduction/writing-tips/#images","text":"Markdown images can be appended with material tags to set the size of the image, whether to appear on light or dark theme and support lazy image loading in browsers Size Lazy Loading Align Theme Specific All Image Attributes {style=\"height:150px;width:150px\"} specifies the image size ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){style=\"height:150px;width:150px\"} {loading=lazy} specifies an image should lazily load in the browser ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png ){loading=lazy} {aligh=left} or {aligh=right} specifies the page alignment of an image. ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){align=right} ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light ){align=right} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. ![Kitty Logo](image/kitty-light.png#only-dark) or ![Kitty Logo](image/kitty-light.png#only-light) specifies the theme the image should be shown, allowing different versions of images to be shown based on the theme. ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){style=\"height:150px;width:150px\"} ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light ){style=\"height:150px;width:150px\"} Use the theme toggle in the top nav bar to see the icon change between light and dark. Requires the color pallet toggle Alight right, lazy load and set image to 150x150 ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-light.png#only-dark ){align=right loading=lazy style=\"height:64px;width:64px\"} ![ Kitty Logo ]( https://raw.githubusercontent.com/practicalli/graphic-design/live/icons/kitty-dark.png#only-light ){align=right loading=lazy style=\"height:64px;width:64px\"} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Images"},{"location":"introduction/writing-tips/#lists","text":"Task lists Lorem ipsum dolor sit amet, consectetur adipiscing elit Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque","title":"Lists"},{"location":"introduction/writing-tips/#tooltips","text":"The humble tool tip Hover me with references Hover me Icon tool tip with a title","title":"Tooltips"},{"location":"introduction/writing-tips/#abreviations","text":"The HTML specification is maintained by the W3C. [HTML]: Hyper Text Markup Language [W3C]: World Wide Web Consortium","title":"Abreviations"},{"location":"introduction/writing-tips/#magic-links","text":"MagicLink can auto-link HTML, FTP, and email links. It can auto-convert repository links (GitHub, GitLab, and Bitbucket) and display them in a more concise, shorthand format. Email Practicalli Practicalli Neovim","title":"Magic links"},{"location":"introduction/concepts/","text":"Clojure concepts \u03bb\ufe0e Clojure is an elegant language for a more civilized development experience. Clojure supports the creation of simple software systems using immutable values and encouraging a pragmatic approach to pure functional design. A simple syntax means Clojure is quick to learn and a wide range of open source libraries provides a rapid way to build any kind of software. Designed as a hosted language, Clojure runs on many platforms including the Java Virtual Machine, GraalVM, Microsoft.Net, JavaScript engines. Simple host language interoperability provides access to libraries from a wide range of programming languages, further extending the reach of Clojure. Experiment with the Clojure language to help understand concepts Spend some time eevaluating code in the REPL and then revisit this section to get a deeper understanding of the design and philosophy of the Clojure approach to functional programming. Clojure concepts are easier to relate to whist practicing with Clojure and building Clojure software solutions. Ten Big Ideas plus one \u03bb\ufe0e The key to understanding Clojure is ideas, not language constructs but the concepts that shape the language. Each of these ideas is valuable by itself, not only in Clojure. Taken together, however, they Begin to fill in the picture of why Clojure is changing the way many programmers think about software development. Extensible Data Notation Persistent Data Structures Sequences Transducers Specification Dynamic Development Async Programming Protocols ClojureScript Logic query / Logic Programming Atomic Succession Model Stuart Halloway presents Clojure in 10 big ideas (plus one) in the following video, also see presentation Content 2013 RuPy slides 2017 Chicago JUG slides Antithesis of Clojure and simple software design \u03bb\ufe0e In Narcissistic Design by Stuart Halloway, the antithesis of the Clojure view of software development is presented as a description of how unproductive and valueless much of the software industry has been in the past. Its essentially a guide on what to avoid if you are a responsible and professional software developer.","title":"Clojure concepts"},{"location":"introduction/concepts/#clojure-concepts","text":"Clojure is an elegant language for a more civilized development experience. Clojure supports the creation of simple software systems using immutable values and encouraging a pragmatic approach to pure functional design. A simple syntax means Clojure is quick to learn and a wide range of open source libraries provides a rapid way to build any kind of software. Designed as a hosted language, Clojure runs on many platforms including the Java Virtual Machine, GraalVM, Microsoft.Net, JavaScript engines. Simple host language interoperability provides access to libraries from a wide range of programming languages, further extending the reach of Clojure. Experiment with the Clojure language to help understand concepts Spend some time eevaluating code in the REPL and then revisit this section to get a deeper understanding of the design and philosophy of the Clojure approach to functional programming. Clojure concepts are easier to relate to whist practicing with Clojure and building Clojure software solutions.","title":"Clojure concepts"},{"location":"introduction/concepts/#ten-big-ideas-plus-one","text":"The key to understanding Clojure is ideas, not language constructs but the concepts that shape the language. Each of these ideas is valuable by itself, not only in Clojure. Taken together, however, they Begin to fill in the picture of why Clojure is changing the way many programmers think about software development. Extensible Data Notation Persistent Data Structures Sequences Transducers Specification Dynamic Development Async Programming Protocols ClojureScript Logic query / Logic Programming Atomic Succession Model Stuart Halloway presents Clojure in 10 big ideas (plus one) in the following video, also see presentation Content 2013 RuPy slides 2017 Chicago JUG slides","title":"Ten Big Ideas plus one"},{"location":"introduction/concepts/#antithesis-of-clojure-and-simple-software-design","text":"In Narcissistic Design by Stuart Halloway, the antithesis of the Clojure view of software development is presented as a description of how unproductive and valueless much of the software industry has been in the past. Its essentially a guide on what to avoid if you are a responsible and professional software developer.","title":"Antithesis of Clojure and simple software design"},{"location":"introduction/concepts/all-bytecode-in-the-end/","text":"Its all Bytecode in the end \u03bb\ufe0e The REPL is your compiler As soon as you evaluate your code in the REPL it is also being compiled in the background into Java Bytecode. So there is no need for a seperate build and run phase. Injecting code into the running environment provides the means for fast iterative development of code.","title":"Its all Bytecode in the end"},{"location":"introduction/concepts/all-bytecode-in-the-end/#its-all-bytecode-in-the-end","text":"The REPL is your compiler As soon as you evaluate your code in the REPL it is also being compiled in the background into Java Bytecode. So there is no need for a seperate build and run phase. Injecting code into the running environment provides the means for fast iterative development of code.","title":"Its all Bytecode in the end"},{"location":"introduction/concepts/clojure-made-simple/","text":"Clojure from the Author \u03bb\ufe0e A series of important videos from Rich Hickey, the author of Clojure who spent over 2 years designing core of Clojure around the concept of simplicity. Since then Rich has stewarded the continued design and development of Clojure, ensuring it stays true to is founding principles. You do not need to watch these videos to start coding in Clojure, but they are very useful to adopt the approach and design idioms that make Clojure a highly effective language for software development. Expert to Expert: Rich Hickey and Brian Beckman - Inside Clojure \u03bb\ufe0e Discussing some of the key characteristics of the Clojure language and why those decisions were taken Clojure made simple \u03bb\ufe0e Covers the major problems with software development and the challenges most programming languages fail to tackle completely. Discusses a simple approach to software development and the big picture view of how Clojure solves these problems Simplicity Matters \u03bb\ufe0e !!! QUOTE Rich Hickey, Clojure Benevolent Dictator for Life As we move forward we have to take what we already have and make that [software] do more, make it do things differently, make it do things better, and as we try to take on manipulating software we are going to be challenged to understand it in order to make that happen. And I'll contend that you will completely be dominated by complexity. I don't care what processes you are using, I don't care how well you test or anything else. Complexity will dominate what you do. Discussing Design \u03bb\ufe0e The value of values \u03bb\ufe0e Rich Hickey provides analysis of the changing way we think about values (not the philosophical kind) in light of the increasing complexity of information technology and the advent of Big Data Also see the related video: Database as a value by Rich Hickey Understanding Clojure as a programming language \u03bb\ufe0e","title":"From The Author"},{"location":"introduction/concepts/clojure-made-simple/#clojure-from-the-author","text":"A series of important videos from Rich Hickey, the author of Clojure who spent over 2 years designing core of Clojure around the concept of simplicity. Since then Rich has stewarded the continued design and development of Clojure, ensuring it stays true to is founding principles. You do not need to watch these videos to start coding in Clojure, but they are very useful to adopt the approach and design idioms that make Clojure a highly effective language for software development.","title":"Clojure from the Author"},{"location":"introduction/concepts/clojure-made-simple/#expert-to-expert-rich-hickey-and-brian-beckman-inside-clojure","text":"Discussing some of the key characteristics of the Clojure language and why those decisions were taken","title":"Expert to Expert: Rich Hickey and Brian Beckman - Inside Clojure"},{"location":"introduction/concepts/clojure-made-simple/#clojure-made-simple","text":"Covers the major problems with software development and the challenges most programming languages fail to tackle completely. Discusses a simple approach to software development and the big picture view of how Clojure solves these problems","title":"Clojure made simple"},{"location":"introduction/concepts/clojure-made-simple/#simplicity-matters","text":"!!! QUOTE Rich Hickey, Clojure Benevolent Dictator for Life As we move forward we have to take what we already have and make that [software] do more, make it do things differently, make it do things better, and as we try to take on manipulating software we are going to be challenged to understand it in order to make that happen. And I'll contend that you will completely be dominated by complexity. I don't care what processes you are using, I don't care how well you test or anything else. Complexity will dominate what you do.","title":"Simplicity Matters"},{"location":"introduction/concepts/clojure-made-simple/#discussing-design","text":"","title":"Discussing Design"},{"location":"introduction/concepts/clojure-made-simple/#the-value-of-values","text":"Rich Hickey provides analysis of the changing way we think about values (not the philosophical kind) in light of the increasing complexity of information technology and the advent of Big Data Also see the related video: Database as a value by Rich Hickey","title":"The value of values"},{"location":"introduction/concepts/clojure-made-simple/#understanding-clojure-as-a-programming-language","text":"","title":"Understanding Clojure as a programming language"},{"location":"introduction/concepts/design/","text":"Clojure Design \u03bb\ufe0e Clojure leads to a very component based approach to development. There are no huge and bloated frameworks in Clojure. The core is very small. Hundreds of focused libraries to use in collaboration. Boiled down to the most simplest structure, Clojure applications you write typically look like this: ;; define a namespace ( ns name-space.name ) ;; define one or more immutable data structures - the fewer the better typically ( def my-data-structure [[{}{}]]) ;; define behaviour that acts on data structures inside one or more functions ( defn my-function [ parameter ] ( my-behaviour parameter )) ;; Call those functions to make your application do something ( my-behaviour data ) Hint As functions always evaluate to a value, a function can be used as an argument to another function (or itself if you get recursive !!) Data focused design - Maps & Vectors \u03bb\ufe0e Maps (hash-map) and vectors are two more built-in persistent data structures that are more commonly used to represent data within a Clojure application. A vector is similar to an array in that its an indexed collection and so has fast random access. Vectors are a catch all data structure that can hold any type of information, including other data structures and function calls. A hash-map is an associative data structure with key value pairs. The keys are most commonly represented with Clojure keywords, although keys can be strings, numbers, collections or functions so long as all the keys are unique. Hash-maps are a collection of key / value pairs that provide an easy way to reference data by keys. Its common to use a Clojure keyword type as the keys as keywords are self-referential (they point to themselves). Using keywords in a map means you can use a specific keyword as a function call on the map that returns its associated value. Some examples of using these data structures this are: ;; A map of maps of maps with occasional vectors { :star-wars { :characters { :jedi [ \"Luke Skywalker\" \"Obiwan Kenobi\" ] :sith [ \"Darth Vader\" \"Darth Sideous\" ] :droids [ \"C3P0\" \"R2D2\" ]} :ships { :rebel-alliance [ \"Millennium Falcon\" \"X-wing fighter\" ] :imperial-empire [ \"Intergalactic Cruiser\" \"Destroyer\" \"Im just making these up now\" ]}}} Hint::Basic design principle \u03bb\ufe0e \u201cIt is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.\u201d \u2014Alan Perlis Extensibility via Macros \u03bb\ufe0e You can extend the language and define your own constructs using Macros. The first example of this you see is from Leiningen. The defproject function is a macro that helps you easily define the configuration of a Clojure project. An example of a macro that is part of the core Clojure language is defn . When you define a function with defn it is syntactic sugar for defining a thing that is a function. ( defn my-function [ argument ] ( my-behaviour argument ) ) ( def my-function ( fn [ argument ] ( my-behaviour argument ))) Special forms - the building blocks of Clojure \u03bb\ufe0e The following are the building blocks of Clojure, everything else is either a macro or a function The Clojure / LISP special forms def, do, if, let, loop, fn, quote, recur, set!, var The forms added for Interoperability with the host platform (mainly Java / JVM) monitor-enter, monitor-exit, catch, dot ('.'), finally, new, throw, try","title":"Clojure Design"},{"location":"introduction/concepts/design/#clojure-design","text":"Clojure leads to a very component based approach to development. There are no huge and bloated frameworks in Clojure. The core is very small. Hundreds of focused libraries to use in collaboration. Boiled down to the most simplest structure, Clojure applications you write typically look like this: ;; define a namespace ( ns name-space.name ) ;; define one or more immutable data structures - the fewer the better typically ( def my-data-structure [[{}{}]]) ;; define behaviour that acts on data structures inside one or more functions ( defn my-function [ parameter ] ( my-behaviour parameter )) ;; Call those functions to make your application do something ( my-behaviour data ) Hint As functions always evaluate to a value, a function can be used as an argument to another function (or itself if you get recursive !!)","title":"Clojure Design"},{"location":"introduction/concepts/design/#data-focused-design-maps-vectors","text":"Maps (hash-map) and vectors are two more built-in persistent data structures that are more commonly used to represent data within a Clojure application. A vector is similar to an array in that its an indexed collection and so has fast random access. Vectors are a catch all data structure that can hold any type of information, including other data structures and function calls. A hash-map is an associative data structure with key value pairs. The keys are most commonly represented with Clojure keywords, although keys can be strings, numbers, collections or functions so long as all the keys are unique. Hash-maps are a collection of key / value pairs that provide an easy way to reference data by keys. Its common to use a Clojure keyword type as the keys as keywords are self-referential (they point to themselves). Using keywords in a map means you can use a specific keyword as a function call on the map that returns its associated value. Some examples of using these data structures this are: ;; A map of maps of maps with occasional vectors { :star-wars { :characters { :jedi [ \"Luke Skywalker\" \"Obiwan Kenobi\" ] :sith [ \"Darth Vader\" \"Darth Sideous\" ] :droids [ \"C3P0\" \"R2D2\" ]} :ships { :rebel-alliance [ \"Millennium Falcon\" \"X-wing fighter\" ] :imperial-empire [ \"Intergalactic Cruiser\" \"Destroyer\" \"Im just making these up now\" ]}}}","title":"Data focused design - Maps &amp; Vectors"},{"location":"introduction/concepts/design/#hintbasic-design-principle","text":"\u201cIt is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.\u201d \u2014Alan Perlis","title":"Hint::Basic design principle"},{"location":"introduction/concepts/design/#extensibility-via-macros","text":"You can extend the language and define your own constructs using Macros. The first example of this you see is from Leiningen. The defproject function is a macro that helps you easily define the configuration of a Clojure project. An example of a macro that is part of the core Clojure language is defn . When you define a function with defn it is syntactic sugar for defining a thing that is a function. ( defn my-function [ argument ] ( my-behaviour argument ) ) ( def my-function ( fn [ argument ] ( my-behaviour argument )))","title":"Extensibility via Macros"},{"location":"introduction/concepts/design/#special-forms-the-building-blocks-of-clojure","text":"The following are the building blocks of Clojure, everything else is either a macro or a function The Clojure / LISP special forms def, do, if, let, loop, fn, quote, recur, set!, var The forms added for Interoperability with the host platform (mainly Java / JVM) monitor-enter, monitor-exit, catch, dot ('.'), finally, new, throw, try","title":"Special forms - the building blocks of Clojure"},{"location":"introduction/concepts/features/","text":"Features of Clojure \u03bb\ufe0e Dynamic language \u03bb\ufe0e A problem space can quickly be explored through code to test your assumptions. The design of code is easy to change as you are not managing type changes, Clojure is very good at managing data that would otherwise lead to exceptions. As a dynamic language the code is quite terse and developers are encouraged to write very modular code, therefore it is easy to refactor. Dynamic Development - REPL \u03bb\ufe0e Clojure has a REPL (Read Evaluate Print Loop), this is the Clojure run-time environment. You can define functions and data structures, then evaluate them to run either all your code or just a single expression. You can even change code and re-evaluate it whilst your application is still running and immediately see the effect that change has. So the REPL is a very fast way to explore your problem domain with code You could even connect to the REPL of a live system and change its behaviour without any down time (unless of course you write code that crashes). 'Pure' Functional Programming \u03bb\ufe0e Functions return a value (even if that value is nil) and you can therefore use a function as an argument to another function. This is termed as first order functions. Clojure encourages a relatively pure approach to functional programming and Clojure can be considered immutable by default Immutability \u03bb\ufe0e immutable data structures at its core, everything is immutable by default in imperative programming, we change state where ever we like in functional programming we avoid changing state as much as possible if a function does not change state it is referentially transparent, always returning the same result when given the same input (arguments) - often returned as a pure function impure functions can affect other functions and therefore has to be very mindful of the changes it makes and when it makes them pure functions are truly modular as they do not affect any other part of the system Persistent Data Structures \u03bb\ufe0e List, Map, Vector and Set are all built in data structures that are immutable. If you run a function that seems to change a data structure, its actually returning a new data structure. Via a shared-memory model, new data structures are created cheaply as they share the common data elements from the original data structure and only include additional elements. Homoiconicity \u03bb\ufe0e One thing that keeps Clojure a small language is the fact that the same syntax is used to represent data and behaviour. For example, a function call is defined using a list, data structures and functions are defined using a list. In fact everything is a list, although we use a little syntactic sugar here and there to make the code quicker for a human to parse. Clojure is an implementation of Lisp \u03bb\ufe0e Lisp stands for LISt Processing, so its no surprise that all Clojure code is defined in a list. The open Parenthesis ( denotes the start of a list, the first element of that list is evaluated as a function call, everything else in the list is data. The evaluation of the first element of a list can be behaviour of ( can be over-ridden using quote or its short form the quote character, ' , so the list elements are all treated as data. Runtime Polymorphism \u03bb\ufe0e See Clojure arity and multi-methods for more information Concurrent Programming & Parallelism \u03bb\ufe0e Concurrent code is much safer when you data does not change state (eg. immutable values). Clojure encourages an immutable approach with its built in persistent data structures (list, Map, Vector, Set). Using Pure Functions that are not affected by or cause side effects also make writing concurrent code trivial. Clojure helps you scale your applications by with a parallel processing approach, as you can run functions over immutable data-structures without conflict. Hosted on the JVM \u03bb\ufe0e Clojure is compiled to bytecode that runs on the Java Virtual Machine. This helps Clojure run at a very high performance (close to Java, C++, etc.) Clojure has a concise and easy to use Java Interoperability, enabling you to use any libraries that run on the JVM (Java, Groovy, Scala, Jruby, Jython, etc). many parts of the Clojure standard library, Clojure.core defer to the Java Standard library, for example for I/O (reading,writing files) Clojure makes invoking Java very convenient and provides special primitive constructs in the Clojure language to do so (new .javaMethodName javaClassName. etc) ClojureScript generated JavaScript that will run in a browser. ClojureCLR will compile to bytecode that runs on the Microsoft .Net platform. Managed State Changes \u03bb\ufe0e Using atoms or refs in clojure you can have mutable data. Changes are done safely within Software Transactional Memory (STM), like having an in-memory ACID database managing access Extend the language with Macros \u03bb\ufe0e Clojure uses macros Fixme Review the following content to see if its relevant ? ** Input & output with functional programming - other fp languages like haskel & Scala use monads to encapsulate data changes whilst appearing stateless to the rest of the program - monads allow us to sneak in impure code into the context of pure code. - Clojure doesn't try and enforce functional purity, so any function can include impure code - most functions should be pure though or you loose the benefits of functional programming - Clojure encourages minimal state changes / mutable state - so its up to the developer to keep the ratio of mutable data small - Clojure uses reference types to manage threads and mutable state. References provide synchronisation of threads without using locks (notoriously cumbersome). See STM Supporting concurrency atoms etc automatic management of state changes via Software transactional memory - like having an ACID database in memory, managing requests to change values over time. by having immutable data structures - if your values do not change then its trivial to have massive parallelism. A modern LISP leaner syntax and not as many brackets as LISP clean data structure syntax at the core of the language LiSP was the first language to introduce first class functions, garbage collection and dynamic typing, which are common in languages used today Macros - a function that takes in source code and returns source code, replacing the macro code - use macros to take out repetition / boilerplate code - as LISP syntax is extremely simple it is much easier to write macros that work compared to non-LISP languages Clojure emphasizes safety in its type system and approach to parallelism, making it easier to write correct multi-threaded programs. Clojure is very concise, requiring very little code to express complex operations. Data centric design - a well constructed data structure helps define and clarify the purpose of the code Modularity - Clojure and its community build things in modules / components that work together (in a similar design approach to the Unix file system, for example). It offers a REPL and dynamic type system: ideal for beginners to experiment with, and well-suited for manipulating complex data structures. A consistently designed standard library and full-featured set of core data types rounds out the Clojure toolbox. Clojure is close to the speed of Java Constraints \u03bb\ufe0e Clojure relies on the JVM so there can be a longer boot time than a scripting language like Javascript. However, as you can connect to the Clojure runtime (the REPL) of a live system and because Clojure is dynamic, you can make changes to that live system without any downtime. If you require more performance from Clojure, you can specify ahead of time compilation.","title":"Features of Clojure"},{"location":"introduction/concepts/features/#features-of-clojure","text":"","title":"Features of Clojure"},{"location":"introduction/concepts/features/#dynamic-language","text":"A problem space can quickly be explored through code to test your assumptions. The design of code is easy to change as you are not managing type changes, Clojure is very good at managing data that would otherwise lead to exceptions. As a dynamic language the code is quite terse and developers are encouraged to write very modular code, therefore it is easy to refactor.","title":"Dynamic language"},{"location":"introduction/concepts/features/#dynamic-development-repl","text":"Clojure has a REPL (Read Evaluate Print Loop), this is the Clojure run-time environment. You can define functions and data structures, then evaluate them to run either all your code or just a single expression. You can even change code and re-evaluate it whilst your application is still running and immediately see the effect that change has. So the REPL is a very fast way to explore your problem domain with code You could even connect to the REPL of a live system and change its behaviour without any down time (unless of course you write code that crashes).","title":"Dynamic Development - REPL"},{"location":"introduction/concepts/features/#pure-functional-programming","text":"Functions return a value (even if that value is nil) and you can therefore use a function as an argument to another function. This is termed as first order functions. Clojure encourages a relatively pure approach to functional programming and Clojure can be considered immutable by default","title":"'Pure' Functional Programming"},{"location":"introduction/concepts/features/#immutability","text":"immutable data structures at its core, everything is immutable by default in imperative programming, we change state where ever we like in functional programming we avoid changing state as much as possible if a function does not change state it is referentially transparent, always returning the same result when given the same input (arguments) - often returned as a pure function impure functions can affect other functions and therefore has to be very mindful of the changes it makes and when it makes them pure functions are truly modular as they do not affect any other part of the system","title":"Immutability"},{"location":"introduction/concepts/features/#persistent-data-structures","text":"List, Map, Vector and Set are all built in data structures that are immutable. If you run a function that seems to change a data structure, its actually returning a new data structure. Via a shared-memory model, new data structures are created cheaply as they share the common data elements from the original data structure and only include additional elements.","title":"Persistent Data Structures"},{"location":"introduction/concepts/features/#homoiconicity","text":"One thing that keeps Clojure a small language is the fact that the same syntax is used to represent data and behaviour. For example, a function call is defined using a list, data structures and functions are defined using a list. In fact everything is a list, although we use a little syntactic sugar here and there to make the code quicker for a human to parse.","title":"Homoiconicity"},{"location":"introduction/concepts/features/#clojure-is-an-implementation-of-lisp","text":"Lisp stands for LISt Processing, so its no surprise that all Clojure code is defined in a list. The open Parenthesis ( denotes the start of a list, the first element of that list is evaluated as a function call, everything else in the list is data. The evaluation of the first element of a list can be behaviour of ( can be over-ridden using quote or its short form the quote character, ' , so the list elements are all treated as data.","title":"Clojure is an implementation of Lisp"},{"location":"introduction/concepts/features/#runtime-polymorphism","text":"See Clojure arity and multi-methods for more information","title":"Runtime Polymorphism"},{"location":"introduction/concepts/features/#concurrent-programming-parallelism","text":"Concurrent code is much safer when you data does not change state (eg. immutable values). Clojure encourages an immutable approach with its built in persistent data structures (list, Map, Vector, Set). Using Pure Functions that are not affected by or cause side effects also make writing concurrent code trivial. Clojure helps you scale your applications by with a parallel processing approach, as you can run functions over immutable data-structures without conflict.","title":"Concurrent Programming &amp; Parallelism"},{"location":"introduction/concepts/features/#hosted-on-the-jvm","text":"Clojure is compiled to bytecode that runs on the Java Virtual Machine. This helps Clojure run at a very high performance (close to Java, C++, etc.) Clojure has a concise and easy to use Java Interoperability, enabling you to use any libraries that run on the JVM (Java, Groovy, Scala, Jruby, Jython, etc). many parts of the Clojure standard library, Clojure.core defer to the Java Standard library, for example for I/O (reading,writing files) Clojure makes invoking Java very convenient and provides special primitive constructs in the Clojure language to do so (new .javaMethodName javaClassName. etc) ClojureScript generated JavaScript that will run in a browser. ClojureCLR will compile to bytecode that runs on the Microsoft .Net platform.","title":"Hosted on the JVM"},{"location":"introduction/concepts/features/#managed-state-changes","text":"Using atoms or refs in clojure you can have mutable data. Changes are done safely within Software Transactional Memory (STM), like having an in-memory ACID database managing access","title":"Managed State Changes"},{"location":"introduction/concepts/features/#extend-the-language-with-macros","text":"Clojure uses macros Fixme Review the following content to see if its relevant ? ** Input & output with functional programming - other fp languages like haskel & Scala use monads to encapsulate data changes whilst appearing stateless to the rest of the program - monads allow us to sneak in impure code into the context of pure code. - Clojure doesn't try and enforce functional purity, so any function can include impure code - most functions should be pure though or you loose the benefits of functional programming - Clojure encourages minimal state changes / mutable state - so its up to the developer to keep the ratio of mutable data small - Clojure uses reference types to manage threads and mutable state. References provide synchronisation of threads without using locks (notoriously cumbersome). See STM Supporting concurrency atoms etc automatic management of state changes via Software transactional memory - like having an ACID database in memory, managing requests to change values over time. by having immutable data structures - if your values do not change then its trivial to have massive parallelism. A modern LISP leaner syntax and not as many brackets as LISP clean data structure syntax at the core of the language LiSP was the first language to introduce first class functions, garbage collection and dynamic typing, which are common in languages used today Macros - a function that takes in source code and returns source code, replacing the macro code - use macros to take out repetition / boilerplate code - as LISP syntax is extremely simple it is much easier to write macros that work compared to non-LISP languages Clojure emphasizes safety in its type system and approach to parallelism, making it easier to write correct multi-threaded programs. Clojure is very concise, requiring very little code to express complex operations. Data centric design - a well constructed data structure helps define and clarify the purpose of the code Modularity - Clojure and its community build things in modules / components that work together (in a similar design approach to the Unix file system, for example). It offers a REPL and dynamic type system: ideal for beginners to experiment with, and well-suited for manipulating complex data structures. A consistently designed standard library and full-featured set of core data types rounds out the Clojure toolbox. Clojure is close to the speed of Java","title":"Extend the language with Macros"},{"location":"introduction/concepts/features/#constraints","text":"Clojure relies on the JVM so there can be a longer boot time than a scripting language like Javascript. However, as you can connect to the Clojure runtime (the REPL) of a live system and because Clojure is dynamic, you can make changes to that live system without any downtime. If you require more performance from Clojure, you can specify ahead of time compilation.","title":"Constraints"},{"location":"introduction/concepts/functional-reactive-programming/","text":"Functional Reactive Programming \u03bb\ufe0e Functional Reactive programming is used in ClojureScript with libraries including reagent, re-frame, rum, etc. Functional Reactive Programming is an elegant means of modeling state over time in an easily composable way. Approaching the problem conceptually and developing a formal semantics first can lead to better optimization potential and simpler implementation. Taking a functional reactive programming approach results in systems that are: * Easier to reason about * Simpler to implement * Easier to optimize Functional Reactive Programming (FRP) is a specific formalism of a model of behaviors that change in response to events, created by Conal Elliot. That's a pretty abstract statement, but FRP is abstract itself. It does not denote a particular implementation, but rather a formal semantics. It is not a style of programming or a paradigm. It's simply a formalism. Functional Reactive Programming (and Denotational Design, also by Conal Elliott) has a lot to teach us about how to design functional programs. Conal Elliott on FRP Audio Interview \u03bb\ufe0e If you're looking for an explanation of the Functional Reactive Programming from the man who invented it, along with an idea of the intriguing process he used to invent it, this HaskellCast episode is for you. Functional Reactive Animation \u03bb\ufe0e A great paper from 1997 that spells out an early form of Functional Reactive Programming. It specifies behaviors (functions of time to a value) that change when events occur. Conal Elliot's home page \u03bb\ufe0e Conal Elliot created FRP while he was researching graphics and animation. Be sure to check out his FRP papers section. Push-pull functional reactive programming \u03bb\ufe0e A more advanced formulation of Functional Reactive Programming that formalizes the types and operations using Haskell's common type classes (Functor, ApplicativeFunctor, Monoid, etc). This one also includes a video of the paper presentation given at ICFP. The main breakthrough of this paper is to model the notion of a future value for events that have not yet happened. But if they have not happened, how can future values be compared? For instance, how does one ask if event a happens before event b if neither of them has happened yet? The paper develops a cool and inspiring formalism which resolves this problem. And one is left with a value that represents the entire behavior of a system past, present, and future. Elm Thesis - PDF \u03bb\ufe0e Elm is a different take on FRP (and it is potentially not FRP, according to some). Instead of behaviors (functions of time to a value), Elm uses discreet signals which are transformed to other signals using functional map-like operations. It also solves a real issue with computationally expensive operations blocking the propagation of signals by making some signals asynchronous. All-in-all, the thesis is a pleasure to read. It is very clear and a decent introduction to the myriad implementations of FRP out there. See the bibliography.","title":"Functional Reactive Programming"},{"location":"introduction/concepts/functional-reactive-programming/#functional-reactive-programming","text":"Functional Reactive programming is used in ClojureScript with libraries including reagent, re-frame, rum, etc. Functional Reactive Programming is an elegant means of modeling state over time in an easily composable way. Approaching the problem conceptually and developing a formal semantics first can lead to better optimization potential and simpler implementation. Taking a functional reactive programming approach results in systems that are: * Easier to reason about * Simpler to implement * Easier to optimize Functional Reactive Programming (FRP) is a specific formalism of a model of behaviors that change in response to events, created by Conal Elliot. That's a pretty abstract statement, but FRP is abstract itself. It does not denote a particular implementation, but rather a formal semantics. It is not a style of programming or a paradigm. It's simply a formalism. Functional Reactive Programming (and Denotational Design, also by Conal Elliott) has a lot to teach us about how to design functional programs.","title":"Functional Reactive Programming"},{"location":"introduction/concepts/functional-reactive-programming/#conal-elliott-on-frp-audio-interview","text":"If you're looking for an explanation of the Functional Reactive Programming from the man who invented it, along with an idea of the intriguing process he used to invent it, this HaskellCast episode is for you.","title":"Conal Elliott on FRP Audio Interview"},{"location":"introduction/concepts/functional-reactive-programming/#functional-reactive-animation","text":"A great paper from 1997 that spells out an early form of Functional Reactive Programming. It specifies behaviors (functions of time to a value) that change when events occur.","title":"Functional Reactive Animation"},{"location":"introduction/concepts/functional-reactive-programming/#conal-elliots-home-page","text":"Conal Elliot created FRP while he was researching graphics and animation. Be sure to check out his FRP papers section.","title":"Conal Elliot's home page"},{"location":"introduction/concepts/functional-reactive-programming/#push-pull-functional-reactive-programming","text":"A more advanced formulation of Functional Reactive Programming that formalizes the types and operations using Haskell's common type classes (Functor, ApplicativeFunctor, Monoid, etc). This one also includes a video of the paper presentation given at ICFP. The main breakthrough of this paper is to model the notion of a future value for events that have not yet happened. But if they have not happened, how can future values be compared? For instance, how does one ask if event a happens before event b if neither of them has happened yet? The paper develops a cool and inspiring formalism which resolves this problem. And one is left with a value that represents the entire behavior of a system past, present, and future.","title":"Push-pull functional reactive programming"},{"location":"introduction/concepts/functional-reactive-programming/#elm-thesis-pdf","text":"Elm is a different take on FRP (and it is potentially not FRP, according to some). Instead of behaviors (functions of time to a value), Elm uses discreet signals which are transformed to other signals using functional map-like operations. It also solves a real issue with computationally expensive operations blocking the propagation of signals by making some signals asynchronous. All-in-all, the thesis is a pleasure to read. It is very clear and a decent introduction to the myriad implementations of FRP out there. See the bibliography.","title":"Elm Thesis - PDF"},{"location":"introduction/concepts/misc/","text":"Characteristics \u03bb\ufe0e Dynamic typed - like Python, Ruby or Groovy because its a LISP - you can redefine running code by redefining functions and re-evaluating REPL - a fast way to explore your problem domain with code Functional programming in contrast to imperative programing immutable data structures at its core, everything is immutable by default if any piece of data can be changed, that is mutable state in imperative programming, we change state where ever we like in functional programming we avoid changing state as much as possible if a function does not change state it is referentially transparent, always returning the same result when given the same input (arguments) - often returned as a pure function impure functions can affect other functions and therefore has to be very mindful of the changes it makes and when it makes them pure functions are truely modular as they do not affect any other part of the system ** Changing state rather than changing a data structure, fp instead creates a new data structure that contains the changes and copies of the existing data. to manage the potential overhead of copying data structures, Clojure uses Persistent collections (Lists, Vectors, Maps) which are immutable but provide an efficient way to mutate by sharing common elements (data) ** Input & output with functional programming other fp languages like haskel & Scala use monads to encapsulate data changes whilst appearing stateless to the rest of the program - monads allow us to sneak in impure code into the context of pure code. Clojure doesn't try and enforce functional purity, so any function can include impure code most functions should be pure though or you loose the benefits of functional programming Clojure encourages minimal state changes / mutable state - so its up to the developer to keep the ratio of mutable data small Clojure uses reference types to manage threads and mutable state. References provide synchronisation of threads without using locks (notoriously cumbersome). See STM Hosted on the Java Virtual Machine written for the JVM & heavily integrated, giving beautiful integration Clojure is compiled to Java byte code many parts of the Clojure standard library, Clojure.core defer to the Java Standard library, for example for I/O (reading,writing files) Clojure makes invoking Java very convenient and provides special primitive constructs in the Clojure language to do so (new .javaMethodName javaClassName. etc) Supporting concurrency atoms etc automatic management of state changes via Software transactional memory - like having an ACID database in memory, managing requests to change values over time. by having immutable data structures - if your values do not change then its trivial to have massive parallelism. A modern LISP leaner syntax and not as many brackets as LISP clean data structure syntax at the core of the language LiSP was the first language to introduce first class functions, garbage collection and dynamic typing, which are common in languages used today Macros - a function that takes in source code and returns source code, replacing the macro code - use macros to take out repetition / boilerplate code - as LISP syntax is extremely simple it is much easier to write macros that work compared to non-LISP languages fixme assuming you need more, I'll add to this page, but Clojure is a very powerful language, incredibly flexible and tonnes of fun. What more do you need ? fixme concepts to explore Clojure emphasizes safety in its type system and approach to parallelism, making it easier to write correct multi-threaded programs. Clojure is very concise, requiring very little code to express complex operations. Data centric design - a well constructed data structure helps define and clarify the purpose of the code Modularity - Clojure and its community build things in modules / components that work together (in a similar design approach to the Unix file system, for example). It offers a REPL and dynamic type system: ideal for beginners to experiment with, and well-suited for manipulating complex data structures. A consistently designed standard library and full-featured set of core data types rounds out the Clojure toolbox. Clojure is close to the speed of Java Constraints \u03bb\ufe0e Clojure relies on the JVM so there can be a longer boot time than a scripting language like Javascript. However, as you can connect to the Clojure runtime (the REPL) of a live system and because Clojure is dynamic, you can make changes to that live system without any downtime. If you require more performance from Clojure, you can specify ahead of time compilation.","title":"Misc"},{"location":"introduction/concepts/misc/#characteristics","text":"Dynamic typed - like Python, Ruby or Groovy because its a LISP - you can redefine running code by redefining functions and re-evaluating REPL - a fast way to explore your problem domain with code Functional programming in contrast to imperative programing immutable data structures at its core, everything is immutable by default if any piece of data can be changed, that is mutable state in imperative programming, we change state where ever we like in functional programming we avoid changing state as much as possible if a function does not change state it is referentially transparent, always returning the same result when given the same input (arguments) - often returned as a pure function impure functions can affect other functions and therefore has to be very mindful of the changes it makes and when it makes them pure functions are truely modular as they do not affect any other part of the system ** Changing state rather than changing a data structure, fp instead creates a new data structure that contains the changes and copies of the existing data. to manage the potential overhead of copying data structures, Clojure uses Persistent collections (Lists, Vectors, Maps) which are immutable but provide an efficient way to mutate by sharing common elements (data) ** Input & output with functional programming other fp languages like haskel & Scala use monads to encapsulate data changes whilst appearing stateless to the rest of the program - monads allow us to sneak in impure code into the context of pure code. Clojure doesn't try and enforce functional purity, so any function can include impure code most functions should be pure though or you loose the benefits of functional programming Clojure encourages minimal state changes / mutable state - so its up to the developer to keep the ratio of mutable data small Clojure uses reference types to manage threads and mutable state. References provide synchronisation of threads without using locks (notoriously cumbersome). See STM Hosted on the Java Virtual Machine written for the JVM & heavily integrated, giving beautiful integration Clojure is compiled to Java byte code many parts of the Clojure standard library, Clojure.core defer to the Java Standard library, for example for I/O (reading,writing files) Clojure makes invoking Java very convenient and provides special primitive constructs in the Clojure language to do so (new .javaMethodName javaClassName. etc) Supporting concurrency atoms etc automatic management of state changes via Software transactional memory - like having an ACID database in memory, managing requests to change values over time. by having immutable data structures - if your values do not change then its trivial to have massive parallelism. A modern LISP leaner syntax and not as many brackets as LISP clean data structure syntax at the core of the language LiSP was the first language to introduce first class functions, garbage collection and dynamic typing, which are common in languages used today Macros - a function that takes in source code and returns source code, replacing the macro code - use macros to take out repetition / boilerplate code - as LISP syntax is extremely simple it is much easier to write macros that work compared to non-LISP languages fixme assuming you need more, I'll add to this page, but Clojure is a very powerful language, incredibly flexible and tonnes of fun. What more do you need ? fixme concepts to explore Clojure emphasizes safety in its type system and approach to parallelism, making it easier to write correct multi-threaded programs. Clojure is very concise, requiring very little code to express complex operations. Data centric design - a well constructed data structure helps define and clarify the purpose of the code Modularity - Clojure and its community build things in modules / components that work together (in a similar design approach to the Unix file system, for example). It offers a REPL and dynamic type system: ideal for beginners to experiment with, and well-suited for manipulating complex data structures. A consistently designed standard library and full-featured set of core data types rounds out the Clojure toolbox. Clojure is close to the speed of Java","title":"Characteristics"},{"location":"introduction/concepts/misc/#constraints","text":"Clojure relies on the JVM so there can be a longer boot time than a scripting language like Javascript. However, as you can connect to the Clojure runtime (the REPL) of a live system and because Clojure is dynamic, you can make changes to that live system without any downtime. If you require more performance from Clojure, you can specify ahead of time compilation.","title":"Constraints"},{"location":"introduction/concepts/naming-local/","text":"Naming - local scope \u03bb\ufe0e Local names in functions \u03bb\ufe0e You can define names for things within the scope of a function using the let function. Example \u03bb\ufe0e You can use the let function to define a simple expression, for which everything will go out of scope once it has been evaluated (let [local-name \"some value\"]) (let [minutes-in-a-day (* 60 60 24)]) You can also use let inside a function to do something with the arguments passed to that function. Here we calculate the hourly-rate from a yearly salary, returning the calculated-rate. (defn hourly-rate [yearly-salary weeks-in-year days-in-week] (let [calculated-rate (/ yearly-salary weeks-in-year days-in-week)] calculated-rate)) (hourly-rate 60000 48 5) ## Local names in data structures When defining a map you are creating a series of key value pairs. The key is essentially a name that represents the value it is paired with. Keys are often defined using a `:keyword`. ```clojure {:radius 10, :pi 22/7 :colour purple} (def my-circle {:radius 10, :pi 22/7 :colour purple}) Fixme This is incorrect, as a Clojure keyword type (a name starting with :) have global scope within a namespace. If the keys were strings, then they would have the scope of just the collection.","title":"Naming - local scope"},{"location":"introduction/concepts/naming-local/#naming-local-scope","text":"","title":"Naming - local scope"},{"location":"introduction/concepts/naming-local/#local-names-in-functions","text":"You can define names for things within the scope of a function using the let function.","title":"Local names in functions"},{"location":"introduction/concepts/naming-local/#example","text":"You can use the let function to define a simple expression, for which everything will go out of scope once it has been evaluated (let [local-name \"some value\"]) (let [minutes-in-a-day (* 60 60 24)]) You can also use let inside a function to do something with the arguments passed to that function. Here we calculate the hourly-rate from a yearly salary, returning the calculated-rate. (defn hourly-rate [yearly-salary weeks-in-year days-in-week] (let [calculated-rate (/ yearly-salary weeks-in-year days-in-week)] calculated-rate)) (hourly-rate 60000 48 5) ## Local names in data structures When defining a map you are creating a series of key value pairs. The key is essentially a name that represents the value it is paired with. Keys are often defined using a `:keyword`. ```clojure {:radius 10, :pi 22/7 :colour purple} (def my-circle {:radius 10, :pi 22/7 :colour purple}) Fixme This is incorrect, as a Clojure keyword type (a name starting with :) have global scope within a namespace. If the keys were strings, then they would have the scope of just the collection.","title":"Example"},{"location":"introduction/concepts/naming-things/","text":"Naming things - data structures and functions \u03bb\ufe0e The def function is used to name data structures in Clojure. You can also use def to name functions, however it is more common to use defn (which is a macro around def) to give a function a name. Keeping things private \u03bb\ufe0e There is less emphasis on keeping functions and data structures private (compared to Java, C++, C#). If you want to define a function name so that it is only accessible by other functions of the same namespace, you can use the defn- function. There is no private equivalent for def (as of Clojure 1.6) however you can use metadata to specify this (def ^:private name data) TODO: check if there is anything new around this or other common practices Misc - writing a private def macro \u03bb\ufe0e You could write your own macro to create a private def called def- ( defmacro def- [ item value ] ` ( def ^ { :private true } ~ item ~ value ) ) There are no naming conventions for a private symbol name. As its defined an used within the scope of that one namespace (file), then there is no real need to make a special convention. Private functions will just be called as normal within the namespace and it will be quite clear from the function definition that it is private. Clojure community style guide example \u03bb\ufe0e Learning Clojure #4: private functions http://tech.puredanger.com/2010/02/09/clojure-4-private-functions/ Sometimes in a Clojure file you just want some helper functions that shouldn\u2019t be exposed outside the namespace. You can create a private function using the special defn- macro instead of defn. For instance, create a file foo/bar.clj with a public and a private function: (ns foo.bar) (defn- sq [x] (* x x)) (defn sum-squares [a b] (+ (sq a) (sq b))) Then use it from the REPL: user=> (use 'foo.bar) nil user=> (sum-squares 3 4) 25 user=> (sq 5) java.lang.Exception: Unable to resolve symbol: sq in this context (NO_SOURCE_FILE:6)","title":"Naming things - data structures and functions"},{"location":"introduction/concepts/naming-things/#naming-things-data-structures-and-functions","text":"The def function is used to name data structures in Clojure. You can also use def to name functions, however it is more common to use defn (which is a macro around def) to give a function a name.","title":"Naming things - data structures and functions"},{"location":"introduction/concepts/naming-things/#keeping-things-private","text":"There is less emphasis on keeping functions and data structures private (compared to Java, C++, C#). If you want to define a function name so that it is only accessible by other functions of the same namespace, you can use the defn- function. There is no private equivalent for def (as of Clojure 1.6) however you can use metadata to specify this (def ^:private name data) TODO: check if there is anything new around this or other common practices","title":"Keeping things private"},{"location":"introduction/concepts/naming-things/#misc-writing-a-private-def-macro","text":"You could write your own macro to create a private def called def- ( defmacro def- [ item value ] ` ( def ^ { :private true } ~ item ~ value ) ) There are no naming conventions for a private symbol name. As its defined an used within the scope of that one namespace (file), then there is no real need to make a special convention. Private functions will just be called as normal within the namespace and it will be quite clear from the function definition that it is private. Clojure community style guide","title":"Misc - writing a private def macro"},{"location":"introduction/concepts/naming-things/#example","text":"Learning Clojure #4: private functions http://tech.puredanger.com/2010/02/09/clojure-4-private-functions/ Sometimes in a Clojure file you just want some helper functions that shouldn\u2019t be exposed outside the namespace. You can create a private function using the special defn- macro instead of defn. For instance, create a file foo/bar.clj with a public and a private function: (ns foo.bar) (defn- sq [x] (* x x)) (defn sum-squares [a b] (+ (sq a) (sq b))) Then use it from the REPL: user=> (use 'foo.bar) nil user=> (sum-squares 3 4) 25 user=> (sq 5) java.lang.Exception: Unable to resolve symbol: sq in this context (NO_SOURCE_FILE:6)","title":"example"},{"location":"introduction/concepts/purpose/","text":"When to use Clojure \u03bb\ufe0e Clojure is a general purpose language suitable for any kind of application or service. As Clojure implementations run across multiple technology platforms and operating systems, there are very few barriers to its use. So Clojure is great for webapps, data science, big data, finance industry (banking, trading, insurance, etc), devops tools (log analysis, etc) and anything else really. There are areas where Clojure obviously excels. Effective Data Manipulation \u03bb\ufe0e Fundamentally all software systems take in data (in the form of values or events), process or react to that data and return as a result. The persistent data structures in Clojure (list, vector, hash-map and set) provide an efficient way to use immutable collections of data. The clojure.core library contains a vast number of data processing functions in Clojure so data is easily transformed Highly Scalable \u03bb\ufe0e Clojure code is encouraged to be immutable and functions to be pure, you can run millions of parallel instances of your application or service for massive processing power. These features also vastly simplify concurrent programming. Reducing Complexity \u03bb\ufe0e Clojure encourages a component design through functional composition, breaking down problems into components Clojure and its libraries are all great examples of well designed components and the community strongly encourages this approach. Hint::Functional Reactive Programming \u03bb\ufe0e You can also use ClojureScript for Functional Reactive programming of client-side apps for browsers and mobile device.","title":"When to use Clojure"},{"location":"introduction/concepts/purpose/#when-to-use-clojure","text":"Clojure is a general purpose language suitable for any kind of application or service. As Clojure implementations run across multiple technology platforms and operating systems, there are very few barriers to its use. So Clojure is great for webapps, data science, big data, finance industry (banking, trading, insurance, etc), devops tools (log analysis, etc) and anything else really. There are areas where Clojure obviously excels.","title":"When to use Clojure"},{"location":"introduction/concepts/purpose/#effective-data-manipulation","text":"Fundamentally all software systems take in data (in the form of values or events), process or react to that data and return as a result. The persistent data structures in Clojure (list, vector, hash-map and set) provide an efficient way to use immutable collections of data. The clojure.core library contains a vast number of data processing functions in Clojure so data is easily transformed","title":"Effective Data Manipulation"},{"location":"introduction/concepts/purpose/#highly-scalable","text":"Clojure code is encouraged to be immutable and functions to be pure, you can run millions of parallel instances of your application or service for massive processing power. These features also vastly simplify concurrent programming.","title":"Highly Scalable"},{"location":"introduction/concepts/purpose/#reducing-complexity","text":"Clojure encourages a component design through functional composition, breaking down problems into components Clojure and its libraries are all great examples of well designed components and the community strongly encourages this approach.","title":"Reducing Complexity"},{"location":"introduction/concepts/purpose/#hintfunctional-reactive-programming","text":"You can also use ClojureScript for Functional Reactive programming of client-side apps for browsers and mobile device.","title":"Hint::Functional Reactive Programming"},{"location":"introduction/concepts/rationale/","text":"The rationale for Clojure \u03bb\ufe0e At the time Clojure was created there were no LISP based languages that ran on a widely adopted platform, that also made concurrency easier for the developer to manage. Developers and the companies that hire them are comfortable with the performance, security and stability of the Java Virtual Machine. While Java developers may envy the succinctness, flexibility and productivity of dynamic languages, they have concerns about running on customer-approved infrastructure, access to their existing code base and libraries, and performance. In addition, they face ongoing problems dealing with concurrency using native threads and locking. Clojure is an effort in pragmatic dynamic language design in this context. It endeavors to be a general-purpose language suitable in those areas where Java is suitable. It reflects the reality that, for the concurrent programming future, pervasive, uncontrolled mutation simply has to go. Clojure meets its goals by: embracing an industry-standard, open platform - the JVM; modernizing a venerable language - Lisp; fostering functional programming with immutable persistent data structures; and providing built-in concurrency support via software transactional memory and asynchronous agents. The result is robust, practical, and fast. Clojure has a distinctive approach to state and identity . Why Clojure? Motivating ideas behind Clojure. \u03bb\ufe0e A LISP base language design is very effecitve Lambda calculus yields an extremely small core with very little syntax required Core advantage still code-as-data and syntactic abstraction Standard Lisps (Common Lisp, Scheme) have not evolved over time, since standardisation. Their core data structures are mutable and not extensible and therefore no mechanisms for effectively dealing with concurrency. Clojure is a Lisp not constrained by backwards compatibility, allowing modernisation of the language that otherwise deters developers from adoption. Clojure extends the code-as-data paradigm to maps and vectors All data structures default to immutability Core data structures are extensible abstractions Embraces a platform (JVM) Functional programming is a good thing - Immutable data + first-class functions - Could always be done in Lisp, by discipline/convention But if a data structure can be mutated, dangerous to presume it won't be In traditional Lisp, only the list data structure is structurally recursive Pure functional languages tend to strongly static types Not for everyone, or every task Clojure is a functional language with a dynamic emphasis All data structures immutable & persistent, supporting recursion Heterogeneous collections, return types Dynamic polymorphism Languages and Platforms VMs, not OSes, are the platforms of the future, providing: Type system Dynamic enforcement and safety Libraries Abstract away OSes Huge set of facilities Built-in and 3rd-party Memory and other resource management GC is platform, not language, facility Bytecode + JIT compilation Abstracts away hardware Language as platform vs. language + platform Old way - each language defines its own runtime GC, bytecode, type system, libraries etc New way (JVM, .Net) Common runtime independent of language Language built for platform vs language ported-to platform Many new languages still take 'Language as platform' approach When ported, have platform-on-platform issues Memory management, type-system, threading issues Library duplication If original language based on C, some extension libraries written in C don't come over Platforms are dictated by clients 'Must run on JVM' or .Net vs 'must run on Unix' or Windows JVM has established track record and trust level Now also open source Interop with other code required C linkage insufficient these days Java/JVM is a language and platform Not the original story, but other languages for JVM always existed, now embraced by Sun Java can be tedious, insufficiently expressive Lack of first-class functions, no type inference, etc Ability to call/consume Java is critical Clojure is the language, JVM the platform Object Orientation is overrated Born of simulation, now used for everything, even when inappropriate Encouraged by Java/C# in all situations, due to their lack of (idiomatic) support for anything else Mutable stateful objects are the new spaghetti code Hard to understand, test, reason about Concurrency disaster Inheritance is not the only way to do polymorphism \"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.\" - Alan J. Perlis Clojure models its data structures as immutable objects represented by interfaces, and otherwise does not offer its own class system. Many functions defined on few primary data structures (seq, map, vector, set). Write Java in Java, consume and extend Java from Clojure. Polymorphism is a good thing Switch statements, structural matching etc yield brittle systems Polymorphism yields extensible, flexible systems Clojure multi-methods decouple polymorphism from OO and types Supports multiple taxonomies Dispatches via static, dynamic or external properties, metadata, etc Concurrency and the multi-core future Immutability makes much of the problem go away Share freely between threads But changing state a reality for simulations and for in-program proxies to the outside world Locking is too hard to get right over and over again Clojure's software transactional memory and agent systems do the hard part In short, I think Clojure occupies a unique niche as a functional Lisp for the JVM with strong concurrency support. Check out some of the features.","title":"The rationale for Clojure"},{"location":"introduction/concepts/rationale/#the-rationale-for-clojure","text":"At the time Clojure was created there were no LISP based languages that ran on a widely adopted platform, that also made concurrency easier for the developer to manage. Developers and the companies that hire them are comfortable with the performance, security and stability of the Java Virtual Machine. While Java developers may envy the succinctness, flexibility and productivity of dynamic languages, they have concerns about running on customer-approved infrastructure, access to their existing code base and libraries, and performance. In addition, they face ongoing problems dealing with concurrency using native threads and locking. Clojure is an effort in pragmatic dynamic language design in this context. It endeavors to be a general-purpose language suitable in those areas where Java is suitable. It reflects the reality that, for the concurrent programming future, pervasive, uncontrolled mutation simply has to go. Clojure meets its goals by: embracing an industry-standard, open platform - the JVM; modernizing a venerable language - Lisp; fostering functional programming with immutable persistent data structures; and providing built-in concurrency support via software transactional memory and asynchronous agents. The result is robust, practical, and fast. Clojure has a distinctive approach to state and identity . Why Clojure?","title":"The rationale for Clojure"},{"location":"introduction/concepts/rationale/#motivating-ideas-behind-clojure","text":"A LISP base language design is very effecitve Lambda calculus yields an extremely small core with very little syntax required Core advantage still code-as-data and syntactic abstraction Standard Lisps (Common Lisp, Scheme) have not evolved over time, since standardisation. Their core data structures are mutable and not extensible and therefore no mechanisms for effectively dealing with concurrency. Clojure is a Lisp not constrained by backwards compatibility, allowing modernisation of the language that otherwise deters developers from adoption. Clojure extends the code-as-data paradigm to maps and vectors All data structures default to immutability Core data structures are extensible abstractions Embraces a platform (JVM) Functional programming is a good thing - Immutable data + first-class functions - Could always be done in Lisp, by discipline/convention But if a data structure can be mutated, dangerous to presume it won't be In traditional Lisp, only the list data structure is structurally recursive Pure functional languages tend to strongly static types Not for everyone, or every task Clojure is a functional language with a dynamic emphasis All data structures immutable & persistent, supporting recursion Heterogeneous collections, return types Dynamic polymorphism Languages and Platforms VMs, not OSes, are the platforms of the future, providing: Type system Dynamic enforcement and safety Libraries Abstract away OSes Huge set of facilities Built-in and 3rd-party Memory and other resource management GC is platform, not language, facility Bytecode + JIT compilation Abstracts away hardware Language as platform vs. language + platform Old way - each language defines its own runtime GC, bytecode, type system, libraries etc New way (JVM, .Net) Common runtime independent of language Language built for platform vs language ported-to platform Many new languages still take 'Language as platform' approach When ported, have platform-on-platform issues Memory management, type-system, threading issues Library duplication If original language based on C, some extension libraries written in C don't come over Platforms are dictated by clients 'Must run on JVM' or .Net vs 'must run on Unix' or Windows JVM has established track record and trust level Now also open source Interop with other code required C linkage insufficient these days Java/JVM is a language and platform Not the original story, but other languages for JVM always existed, now embraced by Sun Java can be tedious, insufficiently expressive Lack of first-class functions, no type inference, etc Ability to call/consume Java is critical Clojure is the language, JVM the platform Object Orientation is overrated Born of simulation, now used for everything, even when inappropriate Encouraged by Java/C# in all situations, due to their lack of (idiomatic) support for anything else Mutable stateful objects are the new spaghetti code Hard to understand, test, reason about Concurrency disaster Inheritance is not the only way to do polymorphism \"It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.\" - Alan J. Perlis Clojure models its data structures as immutable objects represented by interfaces, and otherwise does not offer its own class system. Many functions defined on few primary data structures (seq, map, vector, set). Write Java in Java, consume and extend Java from Clojure. Polymorphism is a good thing Switch statements, structural matching etc yield brittle systems Polymorphism yields extensible, flexible systems Clojure multi-methods decouple polymorphism from OO and types Supports multiple taxonomies Dispatches via static, dynamic or external properties, metadata, etc Concurrency and the multi-core future Immutability makes much of the problem go away Share freely between threads But changing state a reality for simulations and for in-program proxies to the outside world Locking is too hard to get right over and over again Clojure's software transactional memory and agent systems do the hard part In short, I think Clojure occupies a unique niche as a functional Lisp for the JVM with strong concurrency support. Check out some of the features.","title":"Motivating ideas behind Clojure."},{"location":"introduction/concepts/what-is-functional-programming/","text":"What is Functional Programming \u03bb\ufe0e Functional programming can seem quite different from imperative programming used in languages like C, C++ and Java. Imperative languages may seem easier initially, as defining one step after another is familiar approach to many things in live. As the scale of a system grows, so does complexity. Imperative languages applied object oriented design to manage complexity with varied rates of success. When shared mutable state is common in an OO design, then a system quickly becomes complex and very difficult to reason about. Functional programming is actually simpler that the OO approach, although initially it may be unfamiliar and not considered as easy. As systems grow in complexity, the building blocks are still simple and deterministic, creating a system that is far easier to reason about. Imperative programming languages \u03bb\ufe0e In Imperative languages code is written that specifies a sequential of instructions that complete a task. These instructions typically modifies program state until the desired result is achieved. Variables typically represent memory addresses that are mutable (can be changed) by default. Functional programming languages \u03bb\ufe0e Individual tasks are small and achieved by passing data to a function which returns a result. Functions are composed together to form more complex tasks and satisfy larger business logic. These composed functions pass the result of their evaluation to the next function, until all functions in the composition have been evaluated. The entire functional program can be thought of as a single function defined in terms of smaller ones. Program execution is an evaluation of expressions , with the nesting structure of function composition determining program flow. Data is immutable and cannot be change once created. Changes are expressed as new values, with complex values sharing common values for efficiency.","title":"Functional vs Imperative"},{"location":"introduction/concepts/what-is-functional-programming/#what-is-functional-programming","text":"Functional programming can seem quite different from imperative programming used in languages like C, C++ and Java. Imperative languages may seem easier initially, as defining one step after another is familiar approach to many things in live. As the scale of a system grows, so does complexity. Imperative languages applied object oriented design to manage complexity with varied rates of success. When shared mutable state is common in an OO design, then a system quickly becomes complex and very difficult to reason about. Functional programming is actually simpler that the OO approach, although initially it may be unfamiliar and not considered as easy. As systems grow in complexity, the building blocks are still simple and deterministic, creating a system that is far easier to reason about.","title":"What is Functional Programming"},{"location":"introduction/concepts/what-is-functional-programming/#imperative-programming-languages","text":"In Imperative languages code is written that specifies a sequential of instructions that complete a task. These instructions typically modifies program state until the desired result is achieved. Variables typically represent memory addresses that are mutable (can be changed) by default.","title":"Imperative programming languages"},{"location":"introduction/concepts/what-is-functional-programming/#functional-programming-languages","text":"Individual tasks are small and achieved by passing data to a function which returns a result. Functions are composed together to form more complex tasks and satisfy larger business logic. These composed functions pass the result of their evaluation to the next function, until all functions in the composition have been evaluated. The entire functional program can be thought of as a single function defined in terms of smaller ones. Program execution is an evaluation of expressions , with the nesting structure of function composition determining program flow. Data is immutable and cannot be change once created. Changes are expressed as new values, with complex values sharing common values for efficiency.","title":"Functional programming languages"},{"location":"iterate-over-data/","text":"Iterate over data \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Clojure data is typically within one or more of the built in collection types (vector, map, list, set). We can use some functions in Clojure core directly on these collection types. Other clojure core functions need a little help. map \u03bb\ufe0e Used to create a new collection by applying a given function to each element of the collection in turn. ( map inc [ 1 2 3 ]) If there are multiple collections, map returns a new collection with values created by calling the function with a value from each of the collections. Once map reaches the end of one collection it stops and returns the result. ( map + [ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ]) apply \u03bb\ufe0e Used to remove all the values from a collection so they are treated as individual arguemnts to the function given to apply. ( = ( apply + [ 1 2 3 ]) ( + 1 2 3 )) reduce \u03bb\ufe0e reduce can be used in a similar way as apply, to transform a collection into a different value. reduce can also take an argument referred to as an accumulator, used to keep local state as reduce iterates through the values in the collection. A function used with reduce is called a reducing function and is a more abstract approach to loop/recur although its possible to give your reducing function a name so is more reusable. threading macros \u03bb\ufe0e Write code that reads as a sequential series of function calls, rather that the nested function calls typical in lisp. A threading macro is often used to thread a collection through a number of function calls and expressions. comp \u03bb\ufe0e Compose functions together that work over a collection. It can be seen as a more abstract approach to a threading macro or nested function calls. transduce \u03bb\ufe0e Used like comp to create a pipeline of function calls, however, each function call or expression must return a transducer (transforming reduction). Many clojure.core functions return a transducer if you do not provide the collection argument.","title":"Iterate over data"},{"location":"iterate-over-data/#iterate-over-data","text":"","title":"Iterate over data"},{"location":"iterate-over-data/#todowork-in-progress-sorry","text":"Clojure data is typically within one or more of the built in collection types (vector, map, list, set). We can use some functions in Clojure core directly on these collection types. Other clojure core functions need a little help.","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/#map","text":"Used to create a new collection by applying a given function to each element of the collection in turn. ( map inc [ 1 2 3 ]) If there are multiple collections, map returns a new collection with values created by calling the function with a value from each of the collections. Once map reaches the end of one collection it stops and returns the result. ( map + [ 1 2 3 ] [ 4 5 6 ] [ 7 8 9 ])","title":"map"},{"location":"iterate-over-data/#apply","text":"Used to remove all the values from a collection so they are treated as individual arguemnts to the function given to apply. ( = ( apply + [ 1 2 3 ]) ( + 1 2 3 ))","title":"apply"},{"location":"iterate-over-data/#reduce","text":"reduce can be used in a similar way as apply, to transform a collection into a different value. reduce can also take an argument referred to as an accumulator, used to keep local state as reduce iterates through the values in the collection. A function used with reduce is called a reducing function and is a more abstract approach to loop/recur although its possible to give your reducing function a name so is more reusable.","title":"reduce"},{"location":"iterate-over-data/#threading-macros","text":"Write code that reads as a sequential series of function calls, rather that the nested function calls typical in lisp. A threading macro is often used to thread a collection through a number of function calls and expressions.","title":"threading macros"},{"location":"iterate-over-data/#comp","text":"Compose functions together that work over a collection. It can be seen as a more abstract approach to a threading macro or nested function calls.","title":"comp"},{"location":"iterate-over-data/#transduce","text":"Used like comp to create a pipeline of function calls, however, each function call or expression must return a transducer (transforming reduction). Many clojure.core functions return a transducer if you do not provide the collection argument.","title":"transduce"},{"location":"iterate-over-data/apply/","text":"apply \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e","title":"apply"},{"location":"iterate-over-data/apply/#apply","text":"","title":"apply"},{"location":"iterate-over-data/apply/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/comp/","text":"comp - composing functions \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e","title":"comp - composing functions"},{"location":"iterate-over-data/comp/#comp-composing-functions","text":"","title":"comp - composing functions"},{"location":"iterate-over-data/comp/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/filter-remove/","text":"filter and remove \u03bb\ufe0e Use filter and remove with predicate functions, those returning true or false, to create a sub-set of the data. filter creates a new collection that contains all the matching values from the predicate function (true). remove creates a new collection with contains all the values that didn't match the predicate function (false). TODO::work in progress, sorry \u03bb\ufe0e ( filter odd? [ 1 2 3 4 5 6 7 8 9 ])","title":"filter and remove"},{"location":"iterate-over-data/filter-remove/#filter-and-remove","text":"Use filter and remove with predicate functions, those returning true or false, to create a sub-set of the data. filter creates a new collection that contains all the matching values from the predicate function (true). remove creates a new collection with contains all the values that didn't match the predicate function (false).","title":"filter and remove"},{"location":"iterate-over-data/filter-remove/#todowork-in-progress-sorry","text":"( filter odd? [ 1 2 3 4 5 6 7 8 9 ])","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/map-fn/","text":"map with fn - anonymous function \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e ( map ( fn [ arg ] ( + arg 5 )) [ 1 2 3 4 5 ]) There is a syntactic short-cut for the anonymous function that does not require a name for the arguments #(+ %1 5) Adding this into our previous expression we can see that its still quite readable and helps keep the code clean. ( map # ( + arg 5 ) [ 1 2 3 4 5 ]) Hint::Anonymous function name \u03bb\ufe0e Anonymous functions do not have an externally referable name, so must be used in-line with an expression. The fn function can be defined with a name, however, this is only available in the scope of that function definition, the name cannot be used to refer to that function outside of its definition. Including a name within a fn definition enables the function to call itself, therefore creating an anonymous recursive function.","title":"map with fn - anonymous function"},{"location":"iterate-over-data/map-fn/#map-with-fn-anonymous-function","text":"","title":"map with fn - anonymous function"},{"location":"iterate-over-data/map-fn/#todowork-in-progress-sorry","text":"( map ( fn [ arg ] ( + arg 5 )) [ 1 2 3 4 5 ]) There is a syntactic short-cut for the anonymous function that does not require a name for the arguments #(+ %1 5) Adding this into our previous expression we can see that its still quite readable and helps keep the code clean. ( map # ( + arg 5 ) [ 1 2 3 4 5 ])","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/map-fn/#hintanonymous-function-name","text":"Anonymous functions do not have an externally referable name, so must be used in-line with an expression. The fn function can be defined with a name, however, this is only available in the scope of that function definition, the name cannot be used to refer to that function outside of its definition. Including a name within a fn definition enables the function to call itself, therefore creating an anonymous recursive function.","title":"Hint::Anonymous function name"},{"location":"iterate-over-data/map-partial/","text":"map with partial \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e","title":"map with partial"},{"location":"iterate-over-data/map-partial/#map-with-partial","text":"","title":"map with partial"},{"location":"iterate-over-data/map-partial/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/map/","text":"map function \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Add examples of using the map function with data","title":"map function"},{"location":"iterate-over-data/map/#map-function","text":"","title":"map function"},{"location":"iterate-over-data/map/#todowork-in-progress-sorry","text":"Add examples of using the map function with data","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/reduce/","text":"reduce \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e","title":"reduce"},{"location":"iterate-over-data/reduce/#reduce","text":"","title":"reduce"},{"location":"iterate-over-data/reduce/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"iterate-over-data/transduce/","text":"transduce and transforming reducers \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e","title":"transduce and transforming reducers"},{"location":"iterate-over-data/transduce/#transduce-and-transforming-reducers","text":"","title":"transduce and transforming reducers"},{"location":"iterate-over-data/transduce/#todowork-in-progress-sorry","text":"","title":"TODO::work in progress, sorry"},{"location":"leiningen/","text":"Projects with Leiningen \u03bb\ufe0e Leiningen is the build automation tool for Clojure and is very simple to work with. This section will guide you through the common tasks you will use Leiningen for when working with Clojure.","title":"Projects with Leiningen"},{"location":"leiningen/#projects-with-leiningen","text":"Leiningen is the build automation tool for Clojure and is very simple to work with. This section will guide you through the common tasks you will use Leiningen for when working with Clojure.","title":"Projects with Leiningen"},{"location":"leiningen/adding-a-dev-profile/","text":"Adding a dev profile \u03bb\ufe0e","title":"Adding a dev profile"},{"location":"leiningen/adding-a-dev-profile/#adding-a-dev-profile","text":"","title":"Adding a dev profile"},{"location":"leiningen/create-a-template/","text":"Create a custom template \u03bb\ufe0e fixme The following instructions currently result in a broken template, missing version, so this section is under investigation. Note Create a template that customises the REPL prompt that changes the welcome message you see when the REPL first starts, as well as changing the prompt to output a message followed by the current namespace Create a new project as a base for the template \u03bb\ufe0e Create a new project with leiningen lein new app lein-app-custom-prompt Edit the project.clj file in the root of the new project and add the :repl-options customisation. :repl-options { prompt ( fn [ ns ] ( str \"You are hacking in \" ns \"=> \" )) :welcome ( println \"Its REPL time!\" )} When you run lein repl inside the project, the prompt should now look like: Create a new template \u03bb\ufe0e Add the Leining plugin called lein-create-template to your user-wide profile by adding the following line to the file ~/.lein/profiles.clj {:user {:plugins [[lein-create-template \"0.1.1\"]]}} The file should look similar to the following, depending on which other plugins are already added: Inside the new project you created as a base for you template, run the command lein create-template hack-prompt lein install lein new hack-prompt my-new-project fixme something has gone wrong with the creation of the template, missing a version number. Check the files created in the original project and in the ~/.m2 directory. I wonder if it is because the original project had a snapshot for the version. Hint I created further customisation's to the prompt in the article add colour to your clojure repl","title":"Create a custom template"},{"location":"leiningen/create-a-template/#create-a-custom-template","text":"fixme The following instructions currently result in a broken template, missing version, so this section is under investigation. Note Create a template that customises the REPL prompt that changes the welcome message you see when the REPL first starts, as well as changing the prompt to output a message followed by the current namespace","title":"Create a custom template"},{"location":"leiningen/create-a-template/#create-a-new-project-as-a-base-for-the-template","text":"Create a new project with leiningen lein new app lein-app-custom-prompt Edit the project.clj file in the root of the new project and add the :repl-options customisation. :repl-options { prompt ( fn [ ns ] ( str \"You are hacking in \" ns \"=> \" )) :welcome ( println \"Its REPL time!\" )} When you run lein repl inside the project, the prompt should now look like:","title":"Create a new project as a base for the template"},{"location":"leiningen/create-a-template/#create-a-new-template","text":"Add the Leining plugin called lein-create-template to your user-wide profile by adding the following line to the file ~/.lein/profiles.clj {:user {:plugins [[lein-create-template \"0.1.1\"]]}} The file should look similar to the following, depending on which other plugins are already added: Inside the new project you created as a base for you template, run the command lein create-template hack-prompt lein install lein new hack-prompt my-new-project fixme something has gone wrong with the creation of the template, missing a version number. Check the files created in the original project and in the ~/.m2 directory. I wonder if it is because the original project had a snapshot for the version. Hint I created further customisation's to the prompt in the article add colour to your clojure repl","title":"Create a new template"},{"location":"leiningen/plugins/","text":"Common Leiningen Plugins \u03bb\ufe0e To do more with the Leiningen build automation tool you can install a wide range of plugins Some interesting plugins to look at include: lein-ancient - check your project for outdated dependencies lein-annotations - display TODO's and other notes added to your code lein-auto - automatically runs a task on file system change lein-heroku-deploy - use maintenance mode whilst deploying to Heroku Alembic \u03bb\ufe0e Alembic is an easy way to reload your project in the REPL, useful when you need to add a new dependency. This saves time stopping and starting a REPL and avoids loosing any REPL state (?) Reload your project.clj with the following expressions in the REPL ( use 'alembic.still ) ( load-project ) Use Alembic to load a library without adding it to your project.clj, if you just want to try a library. In this example wed add the cheshire library by running these expressions in the REPL ( use 'alembic.still ) ( distill ' [ cheshire \"5.5.0\" ]) Add Alembic to your Leiningen configuration \u03bb\ufe0e Edit ~/.lein/profiles.clj and add Alembic to the :repl :dependencies {:repl {:dependencies [[alembic \"0.3.2\"]]}} Lein Ancient \u03bb\ufe0e Ancient tells you which project dependencies have newer versions and will update them to the latest. This saves you manually searching for each dependency in [Clojars)[ https://clojars.org/ ] and finding the latest version. lein ancient will produce a report similar to: [org.webjars/font-awesome \"4.6.2\"] is available but we use \"4.6.1\" [org.webjars.bower/tether \"1.3.2\"] is available but we use \"1.3.1\" [org.clojure/tools.cli \"0.3.5\"] is available but we use \"0.3.4\" [clj-http \"3.0.1\"] is available but we use \"2.1.0\" [lein-figwheel \"0.5.3-1\"] is available but we use \"0.5.2\" Hint::Test dependency updates \u03bb\ufe0e Extensively test dependency changing and check the logs for any messages about conflicts of functions and namespaces. Add Lein Ancient to every project \u03bb\ufe0e Edit ~/.lein/profiles.clj and include the following plugin in the :user :plugins configuration {:user {:plugins [[lein-ancient \"0.6.10\"]]}} Eastwood \u03bb\ufe0e Eastwood is a linter that will help you maintain code quality and ensure you are following Clojure style rules lein eastwood {:linters [:all]} produces a list of violations found. An Eastwood report looks similar to: == Eastwood 0.2.3 Clojure 1.8.0 JVM 1.8.0_77 Directories scanned for source files: env/dev/clj test/clj src/clj src/cljc test Entering directory `/Users/name/programming/daily-cider' src/cljc/daily_cider/validation.cljc:1:1: non-clojure-file: Non-Clojure file 'src/cljc/daily_cider/validation.cljc'. It will not be linted. test/cljs/daily_cider/core_test.cljs:1:1: non-clojure-file: Non-Clojure file 'test/cljs/daily_cider/core_test.cljs'. It will not be linted. test/cljs/daily_cider/doo_runner.cljs:1:1: non-clojure-file: Non-Clojure file 'test/cljs/daily_cider/doo_runner.cljs'. It will not be linted. == Linting daily-cider.dev-middleware == == Linting daily-cider.env == == Linting daily-cider.config == == Linting daily-cider.layout == src/clj/daily_cider/layout.clj:10:1: non-dynamic-earmuffs: #'daily-cider.layout/*app-context* should be marked dynamic == Linting daily-cider.middleware == == Linting daily-cider.routes.home == src/clj/daily_cider/routes/home.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used src/clj/daily_cider/routes/home.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used == Linting daily-cider.processor == src/clj/daily_cider/processor.clj:1:1: unused-namespaces: Namespace clojure.java.shell is never used in daily-cider.processor src/clj/daily_cider/processor.clj:1:1: unused-namespaces: Namespace luminus.logger is never used in daily-cider.processor src/clj/daily_cider/processor.clj:1:1: unused-namespaces: Namespace clojure.java.io is never used in daily-cider.processor == Linting daily-cider.routes.cider == src/clj/daily_cider/routes/cider.clj:1:1: unused-namespaces: Namespace clojure.java.io is never used in daily-cider.routes.cider src/clj/daily_cider/routes/cider.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used src/clj/daily_cider/routes/cider.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used == Linting daily-cider.handler == == Linting daily-cider.figwheel == == Linting daily-cider.core == src/clj/daily_cider/core.clj:1:1: unused-namespaces: Namespace daily-cider.processor is never used in daily-cider.core == Linting user == env/dev/clj/user.clj:1:1: unused-namespaces: Namespace daily-cider.figwheel is never used in user == Linting daily-cider.test.handler == == Linting daily-cider.test.processor == test/daily_cider/test/processor.clj:1:1: unused-namespaces: Namespace clojure.string is never used in daily-cider.test.processor == Warnings: 15 (not including reflection warnings) Exceptions thrown: 0 Subprocess failed Add Eastwood to your Leiningen configuration \u03bb\ufe0e Edit ~/.lein/profiles.clj and add Eastwood to :user :plugins {:user {:plugins [[jonase/eastwood \"0.2.3\"]]}}","title":"Common Leiningen Plugins"},{"location":"leiningen/plugins/#common-leiningen-plugins","text":"To do more with the Leiningen build automation tool you can install a wide range of plugins Some interesting plugins to look at include: lein-ancient - check your project for outdated dependencies lein-annotations - display TODO's and other notes added to your code lein-auto - automatically runs a task on file system change lein-heroku-deploy - use maintenance mode whilst deploying to Heroku","title":"Common Leiningen Plugins"},{"location":"leiningen/plugins/#alembic","text":"Alembic is an easy way to reload your project in the REPL, useful when you need to add a new dependency. This saves time stopping and starting a REPL and avoids loosing any REPL state (?) Reload your project.clj with the following expressions in the REPL ( use 'alembic.still ) ( load-project ) Use Alembic to load a library without adding it to your project.clj, if you just want to try a library. In this example wed add the cheshire library by running these expressions in the REPL ( use 'alembic.still ) ( distill ' [ cheshire \"5.5.0\" ])","title":"Alembic"},{"location":"leiningen/plugins/#add-alembic-to-your-leiningen-configuration","text":"Edit ~/.lein/profiles.clj and add Alembic to the :repl :dependencies {:repl {:dependencies [[alembic \"0.3.2\"]]}}","title":"Add Alembic to your Leiningen configuration"},{"location":"leiningen/plugins/#lein-ancient","text":"Ancient tells you which project dependencies have newer versions and will update them to the latest. This saves you manually searching for each dependency in [Clojars)[ https://clojars.org/ ] and finding the latest version. lein ancient will produce a report similar to: [org.webjars/font-awesome \"4.6.2\"] is available but we use \"4.6.1\" [org.webjars.bower/tether \"1.3.2\"] is available but we use \"1.3.1\" [org.clojure/tools.cli \"0.3.5\"] is available but we use \"0.3.4\" [clj-http \"3.0.1\"] is available but we use \"2.1.0\" [lein-figwheel \"0.5.3-1\"] is available but we use \"0.5.2\"","title":"Lein Ancient"},{"location":"leiningen/plugins/#hinttest-dependency-updates","text":"Extensively test dependency changing and check the logs for any messages about conflicts of functions and namespaces.","title":"Hint::Test dependency updates"},{"location":"leiningen/plugins/#add-lein-ancient-to-every-project","text":"Edit ~/.lein/profiles.clj and include the following plugin in the :user :plugins configuration {:user {:plugins [[lein-ancient \"0.6.10\"]]}}","title":"Add Lein Ancient to every project"},{"location":"leiningen/plugins/#eastwood","text":"Eastwood is a linter that will help you maintain code quality and ensure you are following Clojure style rules lein eastwood {:linters [:all]} produces a list of violations found. An Eastwood report looks similar to: == Eastwood 0.2.3 Clojure 1.8.0 JVM 1.8.0_77 Directories scanned for source files: env/dev/clj test/clj src/clj src/cljc test Entering directory `/Users/name/programming/daily-cider' src/cljc/daily_cider/validation.cljc:1:1: non-clojure-file: Non-Clojure file 'src/cljc/daily_cider/validation.cljc'. It will not be linted. test/cljs/daily_cider/core_test.cljs:1:1: non-clojure-file: Non-Clojure file 'test/cljs/daily_cider/core_test.cljs'. It will not be linted. test/cljs/daily_cider/doo_runner.cljs:1:1: non-clojure-file: Non-Clojure file 'test/cljs/daily_cider/doo_runner.cljs'. It will not be linted. == Linting daily-cider.dev-middleware == == Linting daily-cider.env == == Linting daily-cider.config == == Linting daily-cider.layout == src/clj/daily_cider/layout.clj:10:1: non-dynamic-earmuffs: #'daily-cider.layout/*app-context* should be marked dynamic == Linting daily-cider.middleware == == Linting daily-cider.routes.home == src/clj/daily_cider/routes/home.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used src/clj/daily_cider/routes/home.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used == Linting daily-cider.processor == src/clj/daily_cider/processor.clj:1:1: unused-namespaces: Namespace clojure.java.shell is never used in daily-cider.processor src/clj/daily_cider/processor.clj:1:1: unused-namespaces: Namespace luminus.logger is never used in daily-cider.processor src/clj/daily_cider/processor.clj:1:1: unused-namespaces: Namespace clojure.java.io is never used in daily-cider.processor == Linting daily-cider.routes.cider == src/clj/daily_cider/routes/cider.clj:1:1: unused-namespaces: Namespace clojure.java.io is never used in daily-cider.routes.cider src/clj/daily_cider/routes/cider.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used src/clj/daily_cider/routes/cider.clj:1:1: unused-fn-args: Function arg request__16360__auto__ never used == Linting daily-cider.handler == == Linting daily-cider.figwheel == == Linting daily-cider.core == src/clj/daily_cider/core.clj:1:1: unused-namespaces: Namespace daily-cider.processor is never used in daily-cider.core == Linting user == env/dev/clj/user.clj:1:1: unused-namespaces: Namespace daily-cider.figwheel is never used in user == Linting daily-cider.test.handler == == Linting daily-cider.test.processor == test/daily_cider/test/processor.clj:1:1: unused-namespaces: Namespace clojure.string is never used in daily-cider.test.processor == Warnings: 15 (not including reflection warnings) Exceptions thrown: 0 Subprocess failed","title":"Eastwood"},{"location":"leiningen/plugins/#add-eastwood-to-your-leiningen-configuration","text":"Edit ~/.lein/profiles.clj and add Eastwood to :user :plugins {:user {:plugins [[jonase/eastwood \"0.2.3\"]]}}","title":"Add Eastwood to your Leiningen configuration"},{"location":"leiningen/profile/","text":"Profiles \u03bb\ufe0e You can run your Clojure project with different profiles, establishing a different set of configuration options when run with Leiningen. Profiles can be created in one of the following places: Profile name Filename Description Project project.clj project specific profiles used by all developers on the project. User profiles.clj add or override individual configuration for the project, not typically shared as part of the project. User-wide ~/.lein/profiles.clj common configuration a developer uses across all their Clojure projects. Profiles defined with the same name in any of the above files are either merged or over-written in the following order of precedence to form a single configuration map: fixme refactor the rest of the text on profiles to just cover the essentials and link to the official documentation for further details. probably just need a few examples typically added to the different profile files Project profiles \u03bb\ufe0e Define one or more profiles specific to the project. Typically done to seperate configuration for different parts of the development lifecycle, eg. dev, test, production The example below adds a \"dummy-data\" resources directory during development and a dependency upon \"expectations\" that's only used for tests/development. (defproject myproject \"0.5.0-SNAPSHOT\" :description \"A project for doing things.\" :dependencies [[org.clojure/clojure \"1.4.0\"]] :profiles {:dev {:resource-paths [\"dummy-data\"] :dependencies [[expectations \"1.4.41\"]]}}) Use the lein show-profiles task to list the project's profiles. User profiles \u03bb\ufe0e User specific configuration Create / edit the file profiles.clj in the root of the specific Clojure project (the same directory as project.clj ) Use the lein show-profiles task to list the project's profiles. User-wide profiles \u03bb\ufe0e Add have common configuration you want in all your Clojure projects without having to modify the project.clj file each time. Create / edit the file ~/.lein/profiles.clj Typical things are added to your profile include common development tools (lein-ancient, slamhound , etc) additional directories on the classpath (ie. classes used during testing that are not in any jar file yet) Declaring Profiles \u03bb\ufe0e Profiles specified in ~/.lein/profiles.clj override profiles in a specific project configuration file, project.clj . Override project configuration without having to change the project.clj file or adding those changes to version control. User-wide profiles can also be specified in ~/.lein/profiles.clj. These will be available in all projects managed by Leiningen, though those profiles will be overridden by profiles of the same name specified in the project. System-wide profiles can be placed in /etc/leiningen/profiles.clj. They are treated the same as user profiles, but with lower precedence. You can also define user-wide profiles within clj-files inside ~/.lein/profiles.d. The semantics within such files differ slightly from other profile files: rather than a map of maps, the profile map is the top-level within the file, and the name of the profile comes from the file itself (without the .clj part). Defining the same user-wide profile in both ~/.lein/profiles.clj and in ~/.lein/profiles.d is considered an error. Default Profiles \u03bb\ufe0e Certain profiles are active by default unless you specify another set of profiles using the with-profiles task. Each of the default profiles have different semantics: If you want to access dependencies or plugins during development time for any project place them in your :user profile. Your ~/.lein/profiles.clj file could look something like this: { :user { :plugins [[ lein-pprint \"1.1.1\" ]] :dependencies [[ slamhound \"1.3.1\" ]]}} The :dev profile is used to specify project specific development tooling. Put things here if they are required for builds or tests, rather than just convenience tooling. The :user profile is separate from :dev; the latter is intended to be specified in the project itself. In order to avoid collisions, the project should never define a :user profile, nor should a user-wide :dev profile be defined. Likewise, system profiles should use the :system profile, and define neither :user nor :dev profiles. The :system profile is similar to :user, except it applies system-wide instead of merely to a single user. The :base profile provides dependencies necessary for basic repl functionality, adds dev-resources to the :resources-path, and sets defaults for :jvm-opts, :checkout-deps-share and :test-selectors. It is part of Leiningen itself; you shouldn't need to change it. The profiles listed above are active during development, but they are unmerged before the jar and pom files are created, making them invisible to code that depends upon your project. The :provided profile is used to specify dependencies that should be available during jar creation, but not propagated to other code that depends on your project. These are dependencies that the project assumes will be provided by whatever environment the jar is used in, but are needed during the development of the project. This is often used for frameworks like Hadoop that provide their own copies of certain libraries. The :default profile specifies the profiles that are active by default when running lein tasks. If not overridden, this is set to :leiningen/default, which is a composite profile with [:base :system :user :provided :dev]. Task Specific Profiles \u03bb\ufe0e Some tasks automatically merge a profile if specified. Examples of these are the :test profile, when running the test task, and the :repl profile, when running the repl task. Profile Metadata \u03bb\ufe0e If you mark your profile with ^:leaky metadata, then the profile will not be stripped out when the pom and jar files are created. If you mark a profile with ^{:pom-scope :test} metadata, then the profile's :dependencies will be added with a test scope in the generated pom and jar when active. The :dev, :test, and :base profiles have this set automatically. If you mark a profile with ^{:pom-scope :provided} metadata, then the profile's :dependencies will be added with a provided scope in the generated pom and jar when active. The :provided profile has this set automatically. Merging \u03bb\ufe0e Profiles are merged by taking each key in the project map or profile map, combining the value if it's a collection and replacing it if it's not. Profiles specified later take precedence when replacing, just like the clojure.core/merge function. The dev profile takes precedence over user by default. Maps are merged recursively, sets are combined with clojure.set/union, and lists/vectors are concatenated. You can add hints via metadata that a given value should take precedence (:replace) or defer to values from a different profile (:displace) if you want to override this logic: { :profiles { :dev { :prep-tasks ^ :replace [ \"clean\" \"compile\" ] :aliases ^ :displace { \"launch\" \"run\" }}}} The exception to this merge logic is that :plugins and :dependencies have custom de-duplication logic since they must be specified as vectors even though they behave like maps (because it only makes sense to have a single version of a given dependency present at once). The replace/displace metadata hints still apply though. Remember that if a profile with the same name is specified in multiple locations, only the profile with the highest \"priority\" is picked \u2013 no merging is done. The \"priority\" is \u2013 from highest to lowest \u2013 project.clj, profiles.clj, user-wide profiles, and finally system-wide profiles. If you need to enable personal overrides of parts of a profile, you can use a composite profile with common and personal parts - something like :dev [:dev-common :dev-overrides]; you would then have just :dev-overrides {} in project.clj and override it in profiles.clj. Another use of profiles is to test against various sets of dependencies: ( defproject swank-clojure \"1.5.0-SNAPSHOT\" :description \"Swank server connecting Clojure to Emacs SLIME\" :dependencies [[ org.clojure/clojure \"1.2.1\" ] [ clj-stacktrace \"0.2.4\" ] [ cdt \"1.2.6.2\" ]] :profiles { :1.3 { :dependencies [[ org.clojure/clojure \"1.3.0\" ]]} :1.4 { :dependencies [[ org.clojure/clojure \"1.4.0-beta1\" ]]}}) Activating Profiles \u03bb\ufe0e To activate a different set of profiles for a given task, use the with-profile higher-order task: $ lein with-profile 1.3 test :database Multiple profiles may be combined with commas: $ lein with-profile qa,user test :database Multiple profiles may be executed in series with colons: $ lein with-profile 1.3:1.4 test :database The above invocations activate the given profiles in place of the defaults. To activate a profile in addition to the defaults, prepend it with a + : $ lein with-profile +server run You can also use - to deactivate a profile. By default all profiles will share the same :target-path, which can cause problems if settings from one profile leak over into another. It's recommended to set :target-path to \"target/%s\", which will isolate each profile set and prevent anything from bleeding over. Composite Profiles \u03bb\ufe0e Sometimes it is useful to define a profile as a combination of other profiles. To do this, just use a vector instead of a map as the profile value. This can be used to avoid duplication: { :shared { :port 9229 , :protocol \"https\" } :qa [ :shared { :servers [ \"qa.my-corp.com\" ]}] :stage [ :shared { :servers [ \"stage.my-corp.com\" ]}] :production [ :shared { :servers [ \"prod1.my-corp.com\" , \"prod1.my-corp.com\" ]}]} Dynamic Eval \u03bb\ufe0e Often you want to read an environment variable or execute a function to capture a value to use in your profiles. In order to do such a thing with the profiles.clj you'll need to use the read-eval syntax. Here is an example of such a case: { :user { :compile-path # = ( eval ( System/getenv \"ci.compile-path\" )) , :target-path # = ( eval ( System/getenv \"ci.target-path\" ))}} Debugging \u03bb\ufe0e To see how a given profile affects your project map, use the lein-pprint plugin: $ lein with-profile 1 .4 pprint { :compile-path \"/home/phil/src/leiningen/lein-pprint/classes\" , :group \"lein-pprint\" , :source-path ( \"/home/phil/src/leiningen/lein-pprint/src\" ) , :dependencies ([ org.clojure/tools.nrepl \"0.0.5\" :exclusions [ org.clojure/clojure ]] [ clojure-complete \"0.1.4\" :exclusions [ org.clojure/clojure ]] [ org.thnetos/cd-client \"0.3.3\" :exclusions [ org.clojure/clojure ]]) , :target-path \"/home/phil/src/leiningen/lein-pprint/target\" , :name \"lein-pprint\" , [ ... ] :description \"Pretty-print a representation of the project map.\" } In order to prevent profile settings from being propagated to other projects that depend upon yours, the :default profiles are removed from your project when generating the pom, jar, and uberjar, and an :uberjar profile, if present, is included when creating uberjars. (This can be useful if you want to specify a :main namespace for uberjar use without triggering AOT during regular development.) Profiles activated through an explicit with-profile invocation will be preserved. Production \u03bb\ufe0e Leiningen 2.1.0 onward get a speed boost by disabling optimized compilation (which only benefits long-running processes). This can negatively affect performance in the long run, or lead to inaccurate benchmarking results. If want the JVM to fully optimize, you can you can switch profiles with lein with-profiles production run","title":"Profiles"},{"location":"leiningen/profile/#profiles","text":"You can run your Clojure project with different profiles, establishing a different set of configuration options when run with Leiningen. Profiles can be created in one of the following places: Profile name Filename Description Project project.clj project specific profiles used by all developers on the project. User profiles.clj add or override individual configuration for the project, not typically shared as part of the project. User-wide ~/.lein/profiles.clj common configuration a developer uses across all their Clojure projects. Profiles defined with the same name in any of the above files are either merged or over-written in the following order of precedence to form a single configuration map: fixme refactor the rest of the text on profiles to just cover the essentials and link to the official documentation for further details. probably just need a few examples typically added to the different profile files","title":"Profiles"},{"location":"leiningen/profile/#project-profiles","text":"Define one or more profiles specific to the project. Typically done to seperate configuration for different parts of the development lifecycle, eg. dev, test, production The example below adds a \"dummy-data\" resources directory during development and a dependency upon \"expectations\" that's only used for tests/development. (defproject myproject \"0.5.0-SNAPSHOT\" :description \"A project for doing things.\" :dependencies [[org.clojure/clojure \"1.4.0\"]] :profiles {:dev {:resource-paths [\"dummy-data\"] :dependencies [[expectations \"1.4.41\"]]}}) Use the lein show-profiles task to list the project's profiles.","title":"Project profiles"},{"location":"leiningen/profile/#user-profiles","text":"User specific configuration Create / edit the file profiles.clj in the root of the specific Clojure project (the same directory as project.clj ) Use the lein show-profiles task to list the project's profiles.","title":"User profiles"},{"location":"leiningen/profile/#user-wide-profiles","text":"Add have common configuration you want in all your Clojure projects without having to modify the project.clj file each time. Create / edit the file ~/.lein/profiles.clj Typical things are added to your profile include common development tools (lein-ancient, slamhound , etc) additional directories on the classpath (ie. classes used during testing that are not in any jar file yet)","title":"User-wide profiles"},{"location":"leiningen/profile/#declaring-profiles","text":"Profiles specified in ~/.lein/profiles.clj override profiles in a specific project configuration file, project.clj . Override project configuration without having to change the project.clj file or adding those changes to version control. User-wide profiles can also be specified in ~/.lein/profiles.clj. These will be available in all projects managed by Leiningen, though those profiles will be overridden by profiles of the same name specified in the project. System-wide profiles can be placed in /etc/leiningen/profiles.clj. They are treated the same as user profiles, but with lower precedence. You can also define user-wide profiles within clj-files inside ~/.lein/profiles.d. The semantics within such files differ slightly from other profile files: rather than a map of maps, the profile map is the top-level within the file, and the name of the profile comes from the file itself (without the .clj part). Defining the same user-wide profile in both ~/.lein/profiles.clj and in ~/.lein/profiles.d is considered an error.","title":"Declaring Profiles"},{"location":"leiningen/profile/#default-profiles","text":"Certain profiles are active by default unless you specify another set of profiles using the with-profiles task. Each of the default profiles have different semantics: If you want to access dependencies or plugins during development time for any project place them in your :user profile. Your ~/.lein/profiles.clj file could look something like this: { :user { :plugins [[ lein-pprint \"1.1.1\" ]] :dependencies [[ slamhound \"1.3.1\" ]]}} The :dev profile is used to specify project specific development tooling. Put things here if they are required for builds or tests, rather than just convenience tooling. The :user profile is separate from :dev; the latter is intended to be specified in the project itself. In order to avoid collisions, the project should never define a :user profile, nor should a user-wide :dev profile be defined. Likewise, system profiles should use the :system profile, and define neither :user nor :dev profiles. The :system profile is similar to :user, except it applies system-wide instead of merely to a single user. The :base profile provides dependencies necessary for basic repl functionality, adds dev-resources to the :resources-path, and sets defaults for :jvm-opts, :checkout-deps-share and :test-selectors. It is part of Leiningen itself; you shouldn't need to change it. The profiles listed above are active during development, but they are unmerged before the jar and pom files are created, making them invisible to code that depends upon your project. The :provided profile is used to specify dependencies that should be available during jar creation, but not propagated to other code that depends on your project. These are dependencies that the project assumes will be provided by whatever environment the jar is used in, but are needed during the development of the project. This is often used for frameworks like Hadoop that provide their own copies of certain libraries. The :default profile specifies the profiles that are active by default when running lein tasks. If not overridden, this is set to :leiningen/default, which is a composite profile with [:base :system :user :provided :dev].","title":"Default Profiles"},{"location":"leiningen/profile/#task-specific-profiles","text":"Some tasks automatically merge a profile if specified. Examples of these are the :test profile, when running the test task, and the :repl profile, when running the repl task.","title":"Task Specific Profiles"},{"location":"leiningen/profile/#profile-metadata","text":"If you mark your profile with ^:leaky metadata, then the profile will not be stripped out when the pom and jar files are created. If you mark a profile with ^{:pom-scope :test} metadata, then the profile's :dependencies will be added with a test scope in the generated pom and jar when active. The :dev, :test, and :base profiles have this set automatically. If you mark a profile with ^{:pom-scope :provided} metadata, then the profile's :dependencies will be added with a provided scope in the generated pom and jar when active. The :provided profile has this set automatically.","title":"Profile Metadata"},{"location":"leiningen/profile/#merging","text":"Profiles are merged by taking each key in the project map or profile map, combining the value if it's a collection and replacing it if it's not. Profiles specified later take precedence when replacing, just like the clojure.core/merge function. The dev profile takes precedence over user by default. Maps are merged recursively, sets are combined with clojure.set/union, and lists/vectors are concatenated. You can add hints via metadata that a given value should take precedence (:replace) or defer to values from a different profile (:displace) if you want to override this logic: { :profiles { :dev { :prep-tasks ^ :replace [ \"clean\" \"compile\" ] :aliases ^ :displace { \"launch\" \"run\" }}}} The exception to this merge logic is that :plugins and :dependencies have custom de-duplication logic since they must be specified as vectors even though they behave like maps (because it only makes sense to have a single version of a given dependency present at once). The replace/displace metadata hints still apply though. Remember that if a profile with the same name is specified in multiple locations, only the profile with the highest \"priority\" is picked \u2013 no merging is done. The \"priority\" is \u2013 from highest to lowest \u2013 project.clj, profiles.clj, user-wide profiles, and finally system-wide profiles. If you need to enable personal overrides of parts of a profile, you can use a composite profile with common and personal parts - something like :dev [:dev-common :dev-overrides]; you would then have just :dev-overrides {} in project.clj and override it in profiles.clj. Another use of profiles is to test against various sets of dependencies: ( defproject swank-clojure \"1.5.0-SNAPSHOT\" :description \"Swank server connecting Clojure to Emacs SLIME\" :dependencies [[ org.clojure/clojure \"1.2.1\" ] [ clj-stacktrace \"0.2.4\" ] [ cdt \"1.2.6.2\" ]] :profiles { :1.3 { :dependencies [[ org.clojure/clojure \"1.3.0\" ]]} :1.4 { :dependencies [[ org.clojure/clojure \"1.4.0-beta1\" ]]}})","title":"Merging"},{"location":"leiningen/profile/#activating-profiles","text":"To activate a different set of profiles for a given task, use the with-profile higher-order task: $ lein with-profile 1.3 test :database Multiple profiles may be combined with commas: $ lein with-profile qa,user test :database Multiple profiles may be executed in series with colons: $ lein with-profile 1.3:1.4 test :database The above invocations activate the given profiles in place of the defaults. To activate a profile in addition to the defaults, prepend it with a + : $ lein with-profile +server run You can also use - to deactivate a profile. By default all profiles will share the same :target-path, which can cause problems if settings from one profile leak over into another. It's recommended to set :target-path to \"target/%s\", which will isolate each profile set and prevent anything from bleeding over.","title":"Activating Profiles"},{"location":"leiningen/profile/#composite-profiles","text":"Sometimes it is useful to define a profile as a combination of other profiles. To do this, just use a vector instead of a map as the profile value. This can be used to avoid duplication: { :shared { :port 9229 , :protocol \"https\" } :qa [ :shared { :servers [ \"qa.my-corp.com\" ]}] :stage [ :shared { :servers [ \"stage.my-corp.com\" ]}] :production [ :shared { :servers [ \"prod1.my-corp.com\" , \"prod1.my-corp.com\" ]}]}","title":"Composite Profiles"},{"location":"leiningen/profile/#dynamic-eval","text":"Often you want to read an environment variable or execute a function to capture a value to use in your profiles. In order to do such a thing with the profiles.clj you'll need to use the read-eval syntax. Here is an example of such a case: { :user { :compile-path # = ( eval ( System/getenv \"ci.compile-path\" )) , :target-path # = ( eval ( System/getenv \"ci.target-path\" ))}}","title":"Dynamic Eval"},{"location":"leiningen/profile/#debugging","text":"To see how a given profile affects your project map, use the lein-pprint plugin: $ lein with-profile 1 .4 pprint { :compile-path \"/home/phil/src/leiningen/lein-pprint/classes\" , :group \"lein-pprint\" , :source-path ( \"/home/phil/src/leiningen/lein-pprint/src\" ) , :dependencies ([ org.clojure/tools.nrepl \"0.0.5\" :exclusions [ org.clojure/clojure ]] [ clojure-complete \"0.1.4\" :exclusions [ org.clojure/clojure ]] [ org.thnetos/cd-client \"0.3.3\" :exclusions [ org.clojure/clojure ]]) , :target-path \"/home/phil/src/leiningen/lein-pprint/target\" , :name \"lein-pprint\" , [ ... ] :description \"Pretty-print a representation of the project map.\" } In order to prevent profile settings from being propagated to other projects that depend upon yours, the :default profiles are removed from your project when generating the pom, jar, and uberjar, and an :uberjar profile, if present, is included when creating uberjars. (This can be useful if you want to specify a :main namespace for uberjar use without triggering AOT during regular development.) Profiles activated through an explicit with-profile invocation will be preserved.","title":"Debugging"},{"location":"leiningen/profile/#production","text":"Leiningen 2.1.0 onward get a speed boost by disabling optimized compilation (which only benefits long-running processes). This can negatively affect performance in the long run, or lead to inaccurate benchmarking results. If want the JVM to fully optimize, you can you can switch profiles with lein with-profiles production run","title":"Production"},{"location":"leiningen/run-the-repl/","text":"Run the REPL \u03bb\ufe0e You can try out your new project in Clojure's run time environment, the REPL. Inside your project directory, practicalli run the following command: lein repl You will see a REPL prompt, where you can enter Clojure expressions for evaluation. Lets try some simple Clojure: (+ 1 2) (str \"Hello\" \" \" \"Clojure world\") (def author \"John Stevenson\") author fixme add some extra examples to try Reload changes from file \u03bb\ufe0e If you do not have your editor connected to the REPL you can still reload changes made to files by reloading the changed namespace in the REPL. Enter the following into the REPL, specifying your namespace ( use 'your.namespace :reload ) You can also use https://github.com/clojure/tools.namespace , however, as refresh throws away the current namespace you have to enter both lines of code each time ( use ' [ clojure.tools.namespace.repl :only ( refresh )]) ( refresh )","title":"Run the REPL"},{"location":"leiningen/run-the-repl/#run-the-repl","text":"You can try out your new project in Clojure's run time environment, the REPL. Inside your project directory, practicalli run the following command: lein repl You will see a REPL prompt, where you can enter Clojure expressions for evaluation. Lets try some simple Clojure: (+ 1 2) (str \"Hello\" \" \" \"Clojure world\") (def author \"John Stevenson\") author fixme add some extra examples to try","title":"Run the REPL"},{"location":"leiningen/run-the-repl/#reload-changes-from-file","text":"If you do not have your editor connected to the REPL you can still reload changes made to files by reloading the changed namespace in the REPL. Enter the following into the REPL, specifying your namespace ( use 'your.namespace :reload ) You can also use https://github.com/clojure/tools.namespace , however, as refresh throws away the current namespace you have to enter both lines of code each time ( use ' [ clojure.tools.namespace.repl :only ( refresh )]) ( refresh )","title":"Reload changes from file"},{"location":"leiningen/templates/","text":"Leiningen Templates \u03bb\ufe0e Leiningen has several built in templates and there are many community templates published on Clojars. Built in templates \u03bb\ufe0e default - use when no template is specified. Useful for libraries. app - creating standalone applications compojure luminus Note Search Clojars to see what additional templates are available: https://clojars.org/search?q=lein-template","title":"Leiningen Templates"},{"location":"leiningen/templates/#leiningen-templates","text":"Leiningen has several built in templates and there are many community templates published on Clojars.","title":"Leiningen Templates"},{"location":"leiningen/templates/#built-in-templates","text":"default - use when no template is specified. Useful for libraries. app - creating standalone applications compojure luminus Note Search Clojars to see what additional templates are available: https://clojars.org/search?q=lein-template","title":"Built in templates"},{"location":"libraries/","text":"Libraries \u03bb\ufe0e","title":"Libraries"},{"location":"libraries/#libraries","text":"","title":"Libraries"},{"location":"libraries/clojars/","text":"Clojars \u03bb\ufe0e","title":"Clojars"},{"location":"libraries/clojars/#clojars","text":"","title":"Clojars"},{"location":"libraries/clojure-core-lisp-comprehension/","text":"Libraries: clojure.core lisp comprehension \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e discuss functions for list comprehension for","title":"Libraries: `clojure.core` lisp comprehension"},{"location":"libraries/clojure-core-lisp-comprehension/#libraries-clojurecore-lisp-comprehension","text":"","title":"Libraries: clojure.core lisp comprehension"},{"location":"libraries/clojure-core-lisp-comprehension/#todowork-in-progress-sorry","text":"discuss functions for list comprehension for","title":"TODO::work in progress, sorry"},{"location":"libraries/clojure-core/","text":"Understanding Clojure Libraries: clojure.core \u03bb\ufe0e Warning::Very rough draft of an idea \u03bb\ufe0e Experimenting with the value of grouping functions in clojure.core to help ensure you are exposed to most of the concepts in Clojure Families of functions \u03bb\ufe0e List Comprehension (for, while, ) used to process multiple collections Transformations (map, filter, apply, reduce ) transform the contents of a collection","title":"Understanding Clojure Libraries: `clojure.core`"},{"location":"libraries/clojure-core/#understanding-clojure-libraries-clojurecore","text":"","title":"Understanding Clojure Libraries: clojure.core"},{"location":"libraries/clojure-core/#warningvery-rough-draft-of-an-idea","text":"Experimenting with the value of grouping functions in clojure.core to help ensure you are exposed to most of the concepts in Clojure","title":"Warning::Very rough draft of an idea"},{"location":"libraries/clojure-core/#families-of-functions","text":"List Comprehension (for, while, ) used to process multiple collections Transformations (map, filter, apply, reduce ) transform the contents of a collection","title":"Families of functions"},{"location":"libraries/edn/","text":"edn \u03bb\ufe0e","title":"edn"},{"location":"libraries/edn/#edn","text":"","title":"edn"},{"location":"libraries/om/","text":"om \u03bb\ufe0e","title":"om"},{"location":"libraries/om/#om","text":"","title":"om"},{"location":"lighttable/","text":"Lighttable \u03bb\ufe0e","title":"Lighttable"},{"location":"lighttable/#lighttable","text":"","title":"Lighttable"},{"location":"lighttable/configure-keyboard-mappings/","text":"Configure Lighttable keyboard mappings \u03bb\ufe0e LightTable/User/user.keymap Emacs \u03bb\ufe0e Add a keybinding to kill a line Suggested configuration [ :editor \"ctrl-k\" ( :editor.line-start ) ( :editor.kill-line ) ( :editor.delete-char-left )] need to test this","title":"Configure Lighttable keyboard mappings"},{"location":"lighttable/configure-keyboard-mappings/#configure-lighttable-keyboard-mappings","text":"LightTable/User/user.keymap","title":"Configure Lighttable keyboard mappings"},{"location":"lighttable/configure-keyboard-mappings/#emacs","text":"Add a keybinding to kill a line Suggested configuration [ :editor \"ctrl-k\" ( :editor.line-start ) ( :editor.kill-line ) ( :editor.delete-char-left )] need to test this","title":"Emacs"},{"location":"modifying-data-structures/","text":"Modifying data structures \u03bb\ufe0e Wait, I thought you said that data structures were immutable! So how can we change them then? Yes, lists, vectors, maps and sets are all immutable. However, you can get a new data structure that has the changes you want. To make this approach efficient, the new data structure contains only the new data and links back to the existing data structure for shared data elements. We will see some of the most common functions that work with data structures in this section. In actuality, everything can be considered a function that works on a data structure though, as that is the language design of clojure.","title":"Modifying data structures"},{"location":"modifying-data-structures/#modifying-data-structures","text":"Wait, I thought you said that data structures were immutable! So how can we change them then? Yes, lists, vectors, maps and sets are all immutable. However, you can get a new data structure that has the changes you want. To make this approach efficient, the new data structure contains only the new data and links back to the existing data structure for shared data elements. We will see some of the most common functions that work with data structures in this section. In actuality, everything can be considered a function that works on a data structure though, as that is the language design of clojure.","title":"Modifying data structures"},{"location":"modifying-data-structures/lists/","text":"Lists \u03bb\ufe0e You can change lists with the cons function, see (doc cons) for details (cons 5 '(1 2 3 4)) You will see that cons does not change the existing list, it create a new list that contains the number 5 and a link to all the elements of the existing list. You can also use cons on vectors (cons 5 [1 2 3 4]) (cons \"fish\" '(\"and\" \"chips\")) (conj '(1 2 3 4) 5) (conj [1 2 3 4] 5) ;; Lets define a simple list and give it a name (def list-one '(1 2 3)) ;; the name evaluates to what we expect list-one ;; If we add the number 4 using the cons function, then we ;; get a new list in return, with 4 added to the front (because thats how lists work with cons) (cons 4 list-one) ;; If we want to keep the result of adding to the list, we can assign it a different name (def list-two (cons 4 list-one)) ;; and we get the result we want list-two ;; we can also pass the original name we used for the list to the new list (def list-one (cons 4 list-one)) ;; If we re-evaluate the definition above, then each time we will get an extra ;; number 4 added to the list. list-one ;; Again, this is not changing the original list, we have just moved the name ;; of the list to point to the new list. ;; Any other function working with this data structure before reassigning the name ;; will not be affected by the re-assignment and will use the unchanged list.","title":"Lists"},{"location":"modifying-data-structures/lists/#lists","text":"You can change lists with the cons function, see (doc cons) for details (cons 5 '(1 2 3 4)) You will see that cons does not change the existing list, it create a new list that contains the number 5 and a link to all the elements of the existing list. You can also use cons on vectors (cons 5 [1 2 3 4]) (cons \"fish\" '(\"and\" \"chips\")) (conj '(1 2 3 4) 5) (conj [1 2 3 4] 5) ;; Lets define a simple list and give it a name (def list-one '(1 2 3)) ;; the name evaluates to what we expect list-one ;; If we add the number 4 using the cons function, then we ;; get a new list in return, with 4 added to the front (because thats how lists work with cons) (cons 4 list-one) ;; If we want to keep the result of adding to the list, we can assign it a different name (def list-two (cons 4 list-one)) ;; and we get the result we want list-two ;; we can also pass the original name we used for the list to the new list (def list-one (cons 4 list-one)) ;; If we re-evaluate the definition above, then each time we will get an extra ;; number 4 added to the list. list-one ;; Again, this is not changing the original list, we have just moved the name ;; of the list to point to the new list. ;; Any other function working with this data structure before reassigning the name ;; will not be affected by the re-assignment and will use the unchanged list.","title":"Lists"},{"location":"modifying-data-structures/maps/","text":"Maps \u03bb\ufe0e The conj function works on all of the Clojure collections. The map collection also has functions that affect the evaluation of a map and the value of map returned. Adding new values with conj \u03bb\ufe0e If you have a collection of maps, you can add another map to that collection with the conj function. ( conj [{ :map1 1 }] { :map2 2 }) ;; => [{:map1 1} {:map2 2}] Changing values with assoc \u03bb\ufe0e The assoc function is used to update a value in a map without necessary being concerned about the current value. assoc returns a complete new map with the specified value. ( assoc { :food \"Fish\" } :food \"Fish&Chips\" ) ;; => {:food \"Fish&Chips\"} It does not matter how many keys are in the map, as keys are unique, then assoc will look up the specific key and change its value to that specified in the third argument. If a key is not in the map, assoc will add both the key and the value. ( def alphabet-soup { :a 1 :b 2 :c 3 }) ( assoc alphabet-soup :d 4 ) ;; => {:a 1, :b 2, :c 3, :d 4} If there are multiple levels to the structure of your map, ie. the value of a key in the map is also a map For example, the value of :luke in the star-wars-characters map is represented as a map too {:fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\"} ( def star-wars-characters { :luke { :fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :fullname \"Darth Vader\" :skill \"Crank phone calls\" } :jarjar { :fullname \"JarJar Binks\" :skill \"Upsetting a generation of fans\" }}) To update the skill of one of the characters we can use assoc-in to update the correct value by traversing the map via the given keys. ( assoc-in star-wars-characters [ :vader :skill ] \"The Dark Side of the Force\" ) ;; => {:luke {:fullname \"Luke Skywalker\", :skill \"Targeting Swamp Rats\"}, :vader { :fullname \"Darth Vader\" , :skill \"The Dark Side of the Force\" } , :jarjar { :fullname \"JarJar Binks\" , :skill \"Upsetting a generation of fans\" }} Update values in a map with update \u03bb\ufe0e Rather than replace the current value with one specified, update applies a function to the existing value in order to update that value. ( def alphabet-soup { :a 1 :b 2 :c 3 }) ( update alphabet-soup :a inc ) ;; => {:a 2, :b 2, :c 3} Hint As with assoc you can also use update on nested maps using the update-in function.","title":"Maps"},{"location":"modifying-data-structures/maps/#maps","text":"The conj function works on all of the Clojure collections. The map collection also has functions that affect the evaluation of a map and the value of map returned.","title":"Maps"},{"location":"modifying-data-structures/maps/#adding-new-values-with-conj","text":"If you have a collection of maps, you can add another map to that collection with the conj function. ( conj [{ :map1 1 }] { :map2 2 }) ;; => [{:map1 1} {:map2 2}]","title":"Adding new values with conj"},{"location":"modifying-data-structures/maps/#changing-values-with-assoc","text":"The assoc function is used to update a value in a map without necessary being concerned about the current value. assoc returns a complete new map with the specified value. ( assoc { :food \"Fish\" } :food \"Fish&Chips\" ) ;; => {:food \"Fish&Chips\"} It does not matter how many keys are in the map, as keys are unique, then assoc will look up the specific key and change its value to that specified in the third argument. If a key is not in the map, assoc will add both the key and the value. ( def alphabet-soup { :a 1 :b 2 :c 3 }) ( assoc alphabet-soup :d 4 ) ;; => {:a 1, :b 2, :c 3, :d 4} If there are multiple levels to the structure of your map, ie. the value of a key in the map is also a map For example, the value of :luke in the star-wars-characters map is represented as a map too {:fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\"} ( def star-wars-characters { :luke { :fullname \"Luke Skywalker\" :skill \"Targeting Swamp Rats\" } :vader { :fullname \"Darth Vader\" :skill \"Crank phone calls\" } :jarjar { :fullname \"JarJar Binks\" :skill \"Upsetting a generation of fans\" }}) To update the skill of one of the characters we can use assoc-in to update the correct value by traversing the map via the given keys. ( assoc-in star-wars-characters [ :vader :skill ] \"The Dark Side of the Force\" ) ;; => {:luke {:fullname \"Luke Skywalker\", :skill \"Targeting Swamp Rats\"}, :vader { :fullname \"Darth Vader\" , :skill \"The Dark Side of the Force\" } , :jarjar { :fullname \"JarJar Binks\" , :skill \"Upsetting a generation of fans\" }}","title":"Changing values with assoc"},{"location":"modifying-data-structures/maps/#update-values-in-a-map-with-update","text":"Rather than replace the current value with one specified, update applies a function to the existing value in order to update that value. ( def alphabet-soup { :a 1 :b 2 :c 3 }) ( update alphabet-soup :a inc ) ;; => {:a 2, :b 2, :c 3} Hint As with assoc you can also use update on nested maps using the update-in function.","title":"Update values in a map with update"},{"location":"modifying-data-structures/sets/","text":"Sets \u03bb\ufe0e","title":"Sets"},{"location":"modifying-data-structures/sets/#sets","text":"","title":"Sets"},{"location":"modifying-data-structures/vectors/","text":"Vectors \u03bb\ufe0e","title":"Vectors"},{"location":"modifying-data-structures/vectors/#vectors","text":"","title":"Vectors"},{"location":"performance/","text":"Clojure Performance and benchmarks \u03bb\ufe0e There are several aspects to performance testing time taken by individual functions / expressions time through a specific path in your application response times under different loads The purpose of performance testing and bench-marking is to understand the expected behaviour of your application under various usage patterns. This kind of testing can also suggest areas of the application that might benefit from optimisation Performance tools for Clojure \u03bb\ufe0e Criterium - benchmarks for Clojure expressions Gatling Gatling \u03bb\ufe0e The Gatling Project is a free and open source performance testing tool. Gatling has a basic GUI that's limited to test recorder only. However, the tests can be developed in easily readable/writable domain-specific language (DSL). Key Features of Gatling: HTTP Recorder An expressive self-explanatory DSL for test development Scala-based Production of higher load using an asynchronous non-blocking approach Full support of HTTP(S) protocols and can also be used for JDBC and JMS load testing Multiple input sources for data-driven tests Powerful and flexible validation and assertions system Comprehensive informative load reports Reference: Other performance tools \u03bb\ufe0e Other notable performance tools include: The Grinder Apache JMeter (Java desktop app) Tsung (required Erlang) Locust (python) Key Features of The Grinder: TCP proxy to record network activity into the Grinder test script Distributed testing that scales with an the increasing number of agent instances Power of Python or Closure, combined with any Java API, for test script creation or modification Flexible parameterization, which includes creating test data on the fly and the ability to use external data sources like files and databases Post-processing and assertion with full access to test results for correlation and content verification Support of multiple protocols Key Features of JMeter: Desktop GUI tool Cross-platform. JMeter can run on any operating system with Java Scalable. When you need a higher load than a single machine can create, JMeter can execute in a distributed mode, meaning one master JMeter machine controls a number of remote hosts. Multi-protocol support. The following protocols are all supported out-of-the-box: HTTP, SMTP, POP3, LDAP, JDBC, FTP, JMS, SOAP, TCP Multiple implementations of pre- and post-processors around sampler. This provides advanced setup, teardo* wn parametrization, and correlation capabilities Various assertions to define criteria Multiple built-in and external listeners to visualize and analyze performance test results Integration with major build and continuous integration systems, making JMeter performance tests part of the full software development life cycle Extensions via plugins Resources \u03bb\ufe0e Open source load testing tools - which one should you use","title":"Clojure Performance and benchmarks"},{"location":"performance/#clojure-performance-and-benchmarks","text":"There are several aspects to performance testing time taken by individual functions / expressions time through a specific path in your application response times under different loads The purpose of performance testing and bench-marking is to understand the expected behaviour of your application under various usage patterns. This kind of testing can also suggest areas of the application that might benefit from optimisation","title":"Clojure Performance and benchmarks"},{"location":"performance/#performance-tools-for-clojure","text":"Criterium - benchmarks for Clojure expressions Gatling","title":"Performance tools for Clojure"},{"location":"performance/#gatling","text":"The Gatling Project is a free and open source performance testing tool. Gatling has a basic GUI that's limited to test recorder only. However, the tests can be developed in easily readable/writable domain-specific language (DSL). Key Features of Gatling: HTTP Recorder An expressive self-explanatory DSL for test development Scala-based Production of higher load using an asynchronous non-blocking approach Full support of HTTP(S) protocols and can also be used for JDBC and JMS load testing Multiple input sources for data-driven tests Powerful and flexible validation and assertions system Comprehensive informative load reports","title":"Gatling"},{"location":"performance/#reference-other-performance-tools","text":"Other notable performance tools include: The Grinder Apache JMeter (Java desktop app) Tsung (required Erlang) Locust (python) Key Features of The Grinder: TCP proxy to record network activity into the Grinder test script Distributed testing that scales with an the increasing number of agent instances Power of Python or Closure, combined with any Java API, for test script creation or modification Flexible parameterization, which includes creating test data on the fly and the ability to use external data sources like files and databases Post-processing and assertion with full access to test results for correlation and content verification Support of multiple protocols Key Features of JMeter: Desktop GUI tool Cross-platform. JMeter can run on any operating system with Java Scalable. When you need a higher load than a single machine can create, JMeter can execute in a distributed mode, meaning one master JMeter machine controls a number of remote hosts. Multi-protocol support. The following protocols are all supported out-of-the-box: HTTP, SMTP, POP3, LDAP, JDBC, FTP, JMS, SOAP, TCP Multiple implementations of pre- and post-processors around sampler. This provides advanced setup, teardo* wn parametrization, and correlation capabilities Various assertions to define criteria Multiple built-in and external listeners to visualize and analyze performance test results Integration with major build and continuous integration systems, making JMeter performance tests part of the full software development life cycle Extensions via plugins","title":"Reference: Other performance tools"},{"location":"performance/#resources","text":"Open source load testing tools - which one should you use","title":"Resources"},{"location":"performance/load-testing/","text":"Load Testing \u03bb\ufe0e The Gatling project can be used to create and run load tests using Clojure (and get fancy reports). Add the following to your project.clj :dependencies [clj-gatling \"0.11.0\"] Describe a Load Test \u03bb\ufe0e This is how we would write a simple load test which performs 50 GET requests against a server running at test.com: class SimpleSimulation extends Simulation { //declare a scenario with a simple get request performed 5 times val scn = scenario(\"myScenario\") .exec(http(\"myRequest\").get(\"http://test.com/page.html\")) .repeat(5) //run the scenario with 10 concurrent users setUp(scn.users(10)) } Gatling refers to load tests as Simulations which have one or more Scenarios. In the one above we are saying we will have 10 users execute 5 requests each in parallel. We could provide a Content-Type header with the request and check for a 200 response code like this: http(\"myRequest\") .get(\"http://test.com/page.html\") .header(\"Content-Type\", \"text/html\") .check(status.is(200)) If we wanted to do a POST request with a JSON body and basic authentication, as well as verify something in the response: http(\"myRequest\") .post(\"http://test.com/someresource\")) .body(StringBody(\"\"\"{ \"myContent\": \"myValue\" }\"\"\")) .asJSON .basicAuth(\"username\", \"password\") .check(jsonPath(\"$..someField\").is(\"some value\")) The expression used to extract someField from the response is passed to jsonPath() and is based on Goessner\u2019s JsonPath syntax. We use is() to verify the expected value is equal to some value. We can also do other forms of verification on the response json like: not(expectedValue): not equal to expectedValue in(sequence): to check that a value belongs to the given sequence exists(), notExists(): to check for the presence/absence of a field For a multipart request with 2 parts and gzip compression: http(\"myRequest\") .post(\"http://test.com/someresource\")) .bodyPart(StringBodyPart(\"\"\"{ \"myContent\": \"myValue\" }\"\"\")) .bodyPart(RawFileBodyPart(\"file\", \"test.txt\") .processRequestBody(gzipBody) We can also create scenarios with multiple requests and use the result from previous requests in subsequent requests like this: scenario(\"myScenario\") .exec(http(\"request1\") .post(\"http://test.com/resource1\") .body(StringBody\"\"\"{ \"myContent\": \"\"}\"\"\") .check(jsonPath(\"$..myResponse.guid\").saveAs(\"guid\"))) .exec(http(\"request2\") .put(\"http://test.com/resource2/${guid}\") .body(StringBody\"\"\"{ \"someOtherField\": \"\"}\"\"\")) guid is extracted from the response of the first call using saveAs(\"guid\") and used in the path to the PUT call. Scenarios can also be run with a ramp up. If we wanted to run the scenario above with 1000 users with a ramp up of 20 seconds we would do: setUp(scn.users(1000).ramp(20)) Run a Simulation \u03bb\ufe0e There are a number of ways to run Gatling simulations. You can download the bundle, place your simulations under the user-files/simulations directory and then run bin/gatling.sh. If you prefer integration with your build system there are plugins for Maven, Gradle and SBT. For example, for Maven we just add the dependencies in the pom.xml: <dependencies> <dependency> <groupId>io.gatling.highcharts</groupId> <artifactId>gatling-charts-highcharts</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>io.gatling</groupId> <artifactId>gatling-maven-plugin</artifactId> </plugin> </plugins> </build> Place simulations under src/test/scala/com/company/service and then in the terminal: mvn gatling:execute -Dgatling.simulationClass=com.company.service.YourSimulation","title":"Load Testing"},{"location":"performance/load-testing/#load-testing","text":"The Gatling project can be used to create and run load tests using Clojure (and get fancy reports). Add the following to your project.clj :dependencies [clj-gatling \"0.11.0\"]","title":"Load Testing"},{"location":"performance/load-testing/#describe-a-load-test","text":"This is how we would write a simple load test which performs 50 GET requests against a server running at test.com: class SimpleSimulation extends Simulation { //declare a scenario with a simple get request performed 5 times val scn = scenario(\"myScenario\") .exec(http(\"myRequest\").get(\"http://test.com/page.html\")) .repeat(5) //run the scenario with 10 concurrent users setUp(scn.users(10)) } Gatling refers to load tests as Simulations which have one or more Scenarios. In the one above we are saying we will have 10 users execute 5 requests each in parallel. We could provide a Content-Type header with the request and check for a 200 response code like this: http(\"myRequest\") .get(\"http://test.com/page.html\") .header(\"Content-Type\", \"text/html\") .check(status.is(200)) If we wanted to do a POST request with a JSON body and basic authentication, as well as verify something in the response: http(\"myRequest\") .post(\"http://test.com/someresource\")) .body(StringBody(\"\"\"{ \"myContent\": \"myValue\" }\"\"\")) .asJSON .basicAuth(\"username\", \"password\") .check(jsonPath(\"$..someField\").is(\"some value\")) The expression used to extract someField from the response is passed to jsonPath() and is based on Goessner\u2019s JsonPath syntax. We use is() to verify the expected value is equal to some value. We can also do other forms of verification on the response json like: not(expectedValue): not equal to expectedValue in(sequence): to check that a value belongs to the given sequence exists(), notExists(): to check for the presence/absence of a field For a multipart request with 2 parts and gzip compression: http(\"myRequest\") .post(\"http://test.com/someresource\")) .bodyPart(StringBodyPart(\"\"\"{ \"myContent\": \"myValue\" }\"\"\")) .bodyPart(RawFileBodyPart(\"file\", \"test.txt\") .processRequestBody(gzipBody) We can also create scenarios with multiple requests and use the result from previous requests in subsequent requests like this: scenario(\"myScenario\") .exec(http(\"request1\") .post(\"http://test.com/resource1\") .body(StringBody\"\"\"{ \"myContent\": \"\"}\"\"\") .check(jsonPath(\"$..myResponse.guid\").saveAs(\"guid\"))) .exec(http(\"request2\") .put(\"http://test.com/resource2/${guid}\") .body(StringBody\"\"\"{ \"someOtherField\": \"\"}\"\"\")) guid is extracted from the response of the first call using saveAs(\"guid\") and used in the path to the PUT call. Scenarios can also be run with a ramp up. If we wanted to run the scenario above with 1000 users with a ramp up of 20 seconds we would do: setUp(scn.users(1000).ramp(20))","title":"Describe a Load Test"},{"location":"performance/load-testing/#run-a-simulation","text":"There are a number of ways to run Gatling simulations. You can download the bundle, place your simulations under the user-files/simulations directory and then run bin/gatling.sh. If you prefer integration with your build system there are plugins for Maven, Gradle and SBT. For example, for Maven we just add the dependencies in the pom.xml: <dependencies> <dependency> <groupId>io.gatling.highcharts</groupId> <artifactId>gatling-charts-highcharts</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>io.gatling</groupId> <artifactId>gatling-maven-plugin</artifactId> </plugin> </plugins> </build> Place simulations under src/test/scala/com/company/service and then in the terminal: mvn gatling:execute -Dgatling.simulationClass=com.company.service.YourSimulation","title":"Run a Simulation"},{"location":"performance/testing-functions/","text":"Testing Functions \u03bb\ufe0e Adding the Criterium library \u03bb\ufe0e Add [criterium \"0.4.4\"] to you project.clj file. Add criterium to the namespace were you run your tests ( ns ,,, :require [ criterium.core ] :refer [ quick-bench ]) Or simply require criterium in the REPL ( require ' [ criterium.core ] :refer [ quick-bench ]) Using Criterium to test code \u03bb\ufe0e Lets try a few similar Clojure functions to see the Criterium benchmark in action ( let [ number 5 ] ( quick-bench ( cond = 5 1 1 2 2 3 3 4 4 5 5 ))) Benchmark output is sent to the REPL Evaluation count : 50788488 in 6 samples of 8464748 calls. Execution time mean : 2.535916 ns Execution time std-deviation : 0.096838 ns Execution time lower quantile : 2.435814 ns ( 2.5%) Execution time upper quantile : 2.686146 ns (97.5%) Overhead used : 9.431514 ns Found 1 outliers in 6 samples (16.6667 %) low-severe 1 (16.6667 %) Variance from outliers : 13.8889 % Variance is moderately inflated by outliers Running the benchmark again for the same expression, we get pretty consistent results Evaluation count : 50408712 in 6 samples of 8401452 calls. Execution time mean : 2.571379 ns Execution time std-deviation : 0.163071 ns Execution time lower quantile : 2.366952 ns ( 2.5%) Execution time upper quantile : 2.721099 ns (97.5%) Overhead used : 9.431514 ns There is a parallized version of cond called condp . ( let [ number 5 ] ( quick-bench ( condp = 5 1 1 2 2 3 3 4 4 5 5 ))) Evaluation count : 3625284 in 6 samples of 604214 calls. Execution time mean : 156.813816 ns Execution time std-deviation : 2.560629 ns Execution time lower quantile : 154.222522 ns ( 2.5%) Execution time upper quantile : 160.425030 ns (97.5%) Overhead used : 9.431514 ns Found 1 outliers in 6 samples (16.6667 %) low-severe 1 (16.6667 %) Variance from outliers : 13.8889 % Variance is moderately inflated by outliers That figure is quite high, lets run that again. Evaluation count : 3707922 in 6 samples of 617987 calls. Execution time mean : 154.219102 ns Execution time std-deviation : 3.427811 ns Execution time lower quantile : 149.777377 ns ( 2.5%) Execution time upper quantile : 159.225180 ns (97.5%) Overhead used : 9.431514 ns So using a parallized version of a function adds a significant exectution time. I believe the extra time is due to setting up a thread. If so, then when using condp you only get a more effective throughput when running multiple parallel threads, which should be fairly obvious. Now lets benchmark a similar function called case . This function is nicely optimised on the JVM especially when the values are sequential, so we should see faster results ( let [ number 5 ] ( quick-bench ( case 5 1 1 2 2 3 3 4 4 5 5 ))) Benchmark output is sent to the REPL Evaluation count : 56533626 in 6 samples of 9422271 calls. Execution time mean : 1.158650 ns Execution time std-deviation : 0.187322 ns Execution time lower quantile : 1.021431 ns ( 2.5%) Execution time upper quantile : 1.471115 ns (97.5%) Overhead used : 9.431514 ns Found 1 outliers in 6 samples (16.6667 %) low-severe 1 (16.6667 %) Variance from outliers : 47.5092 % Variance is moderately inflated by outliers","title":"Testing Functions"},{"location":"performance/testing-functions/#testing-functions","text":"","title":"Testing Functions"},{"location":"performance/testing-functions/#adding-the-criterium-library","text":"Add [criterium \"0.4.4\"] to you project.clj file. Add criterium to the namespace were you run your tests ( ns ,,, :require [ criterium.core ] :refer [ quick-bench ]) Or simply require criterium in the REPL ( require ' [ criterium.core ] :refer [ quick-bench ])","title":"Adding the Criterium library"},{"location":"performance/testing-functions/#using-criterium-to-test-code","text":"Lets try a few similar Clojure functions to see the Criterium benchmark in action ( let [ number 5 ] ( quick-bench ( cond = 5 1 1 2 2 3 3 4 4 5 5 ))) Benchmark output is sent to the REPL Evaluation count : 50788488 in 6 samples of 8464748 calls. Execution time mean : 2.535916 ns Execution time std-deviation : 0.096838 ns Execution time lower quantile : 2.435814 ns ( 2.5%) Execution time upper quantile : 2.686146 ns (97.5%) Overhead used : 9.431514 ns Found 1 outliers in 6 samples (16.6667 %) low-severe 1 (16.6667 %) Variance from outliers : 13.8889 % Variance is moderately inflated by outliers Running the benchmark again for the same expression, we get pretty consistent results Evaluation count : 50408712 in 6 samples of 8401452 calls. Execution time mean : 2.571379 ns Execution time std-deviation : 0.163071 ns Execution time lower quantile : 2.366952 ns ( 2.5%) Execution time upper quantile : 2.721099 ns (97.5%) Overhead used : 9.431514 ns There is a parallized version of cond called condp . ( let [ number 5 ] ( quick-bench ( condp = 5 1 1 2 2 3 3 4 4 5 5 ))) Evaluation count : 3625284 in 6 samples of 604214 calls. Execution time mean : 156.813816 ns Execution time std-deviation : 2.560629 ns Execution time lower quantile : 154.222522 ns ( 2.5%) Execution time upper quantile : 160.425030 ns (97.5%) Overhead used : 9.431514 ns Found 1 outliers in 6 samples (16.6667 %) low-severe 1 (16.6667 %) Variance from outliers : 13.8889 % Variance is moderately inflated by outliers That figure is quite high, lets run that again. Evaluation count : 3707922 in 6 samples of 617987 calls. Execution time mean : 154.219102 ns Execution time std-deviation : 3.427811 ns Execution time lower quantile : 149.777377 ns ( 2.5%) Execution time upper quantile : 159.225180 ns (97.5%) Overhead used : 9.431514 ns So using a parallized version of a function adds a significant exectution time. I believe the extra time is due to setting up a thread. If so, then when using condp you only get a more effective throughput when running multiple parallel threads, which should be fairly obvious. Now lets benchmark a similar function called case . This function is nicely optimised on the JVM especially when the values are sequential, so we should see faster results ( let [ number 5 ] ( quick-bench ( case 5 1 1 2 2 3 3 4 4 5 5 ))) Benchmark output is sent to the REPL Evaluation count : 56533626 in 6 samples of 9422271 calls. Execution time mean : 1.158650 ns Execution time std-deviation : 0.187322 ns Execution time lower quantile : 1.021431 ns ( 2.5%) Execution time upper quantile : 1.471115 ns (97.5%) Overhead used : 9.431514 ns Found 1 outliers in 6 samples (16.6667 %) low-severe 1 (16.6667 %) Variance from outliers : 47.5092 % Variance is moderately inflated by outliers","title":"Using Criterium to test code"},{"location":"project-palindrome/","text":"Project Palindrome \u03bb\ufe0e In this section we will create a simple Clojure project using Leiningen and build up a palindrome checker step by step. We will start with the simplest possible thing we can create and steadily add What is a Palindrome \u03bb\ufe0e For this project it is assumed that a palindrome is a string of characters from the English alphabet and not any other language or an alphanumeric sequence. It is assumed that a palindrome is at least 3 characters long, meaning a single character cannot be a palindrome. If a single character was a palindrome, then any valid sequence would contain at least as many palindromes as characters in that sequence. Task set \u03bb\ufe0e Write an algorithm to find the 3 longest unique palindromes in a string. For the 3 longest palindromes, report the palindrome, start index and length in descending order of length. Any tests should be included with the submission. For example, the output for string, \"sqrrqabccbatudefggfedvwhijkllkjihxymnnmzpop\" should be: Text: hijkllkjih, Index: 23, Length: 10 Text: defggfed, Index: 13, Length: 8 Text: abccba, Index: 5 Length: 6 Check for a palindrome Generate a series of palindromes","title":"Project Palindrome"},{"location":"project-palindrome/#project-palindrome","text":"In this section we will create a simple Clojure project using Leiningen and build up a palindrome checker step by step. We will start with the simplest possible thing we can create and steadily add","title":"Project Palindrome"},{"location":"project-palindrome/#what-is-a-palindrome","text":"For this project it is assumed that a palindrome is a string of characters from the English alphabet and not any other language or an alphanumeric sequence. It is assumed that a palindrome is at least 3 characters long, meaning a single character cannot be a palindrome. If a single character was a palindrome, then any valid sequence would contain at least as many palindromes as characters in that sequence.","title":"What is a Palindrome"},{"location":"project-palindrome/#task-set","text":"Write an algorithm to find the 3 longest unique palindromes in a string. For the 3 longest palindromes, report the palindrome, start index and length in descending order of length. Any tests should be included with the submission. For example, the output for string, \"sqrrqabccbatudefggfedvwhijkllkjihxymnnmzpop\" should be: Text: hijkllkjih, Index: 23, Length: 10 Text: defggfed, Index: 13, Length: 8 Text: abccba, Index: 5 Length: 6 Check for a palindrome Generate a series of palindromes","title":"Task set"},{"location":"project-palindrome/simple-palindrome-test/","text":"Simple palindrome test \u03bb\ufe0e","title":"Simple palindrome test"},{"location":"project-palindrome/simple-palindrome-test/#simple-palindrome-test","text":"","title":"Simple palindrome test"},{"location":"puzzles/","text":"Puzzles \u03bb\ufe0e Simple puzzles to help you start thinking functionally","title":"Puzzles"},{"location":"puzzles/#puzzles","text":"Simple puzzles to help you start thinking functionally","title":"Puzzles"},{"location":"puzzles/random-seat-assignment/","text":"Random Seat assignment \u03bb\ufe0e https://github.com/practicalli/clojure-practicalli-content/issues/4 Take a functional / data oriented approach to solving this problem Description \u03bb\ufe0e You want to randomly assign seating to a number of people for a fixed number of seats. Each seat is represented by an integer number between 1 and 30. How do you randomly assign seats without choosing the same seat twice. Loop / recur approach \u03bb\ufe0e Bad... recursive function \u03bb\ufe0e","title":"Random Seat assignment"},{"location":"puzzles/random-seat-assignment/#random-seat-assignment","text":"https://github.com/practicalli/clojure-practicalli-content/issues/4 Take a functional / data oriented approach to solving this problem","title":"Random Seat assignment"},{"location":"puzzles/random-seat-assignment/#description","text":"You want to randomly assign seating to a number of people for a fixed number of seats. Each seat is represented by an integer number between 1 and 30. How do you randomly assign seats without choosing the same seat twice.","title":"Description"},{"location":"puzzles/random-seat-assignment/#loop-recur-approach","text":"Bad...","title":"Loop / recur approach"},{"location":"puzzles/random-seat-assignment/#recursive-function","text":"","title":"recursive function"},{"location":"quickstart/","text":"Clojure quick start \u03bb\ufe0e Clojure in 15 minutes is an online Clojure environment with example code for the Clojure syntax and some common functions. If you have a GitHub account, you can fork the code and continue to experiment","title":"Clojure quick start"},{"location":"quickstart/#clojure-quick-start","text":"Clojure in 15 minutes is an online Clojure environment with example code for the Clojure syntax and some common functions. If you have a GitHub account, you can fork the code and continue to experiment","title":"Clojure quick start"},{"location":"quickstart/quick-reference/","text":"Clojure Quick Reference \u03bb\ufe0e The basic Clojure syntax and a few common functions you should probably learn first. Also see the Clojure.org cheat-sheet Calling functions \u03bb\ufe0e The first element in a list, () , is treated as a call to a function. This is known as prefix notation which greatly simplifies Clojure syntax and makes mathematical expressions completely deterministic, eliminating the need for operator precedence . fs ( + 2 3 5 8 13 ( * 3 7 )) ( + 3 ( * 2 ( - 7 2 ) 4 ) ( / 16 4 )) ( clojure-version ) Functions contain doc-strings and you can ask for a functions documentation, or show the source code. ( doc doc ) ( source doc ) Clojure is a dynamically typed language, it is also strongly typed (everything is a type, but you dont have to express the type in your code). The type of anything in Clojure can be returned. ( type 42 ) ( type { :hash \"data\" :map \"more data\" }) Modeling data with Collection types \u03bb\ufe0e Clojure has 4 main collection types, all immutable (cannot change once created) and can contain any Clojure types. ( str \"lists used mainly\" ( * 2 2 ) :code ) [ 0 \"indexed array\" ] { :key \"value\" :pairs \"hash-map\" :aka \"dictionary\" } # { 1 2 3 4 \"unique\" \"set\" \"of\" \"values\" \"unordered\" ( * 3 9 )} Defining names for values (vars) \u03bb\ufe0e Names can be bound to any values, simple values like numbers, collections or functions. A convenient way to refer to value in your code. ( def public-health-data ({ :date \"2020-01-01\" :confirmed-cases 23014 :recovery-percent 15 } { :date \"2020-01-02\" :confirmed-cases 23014 :recovery-percent 15 } { :date \"2020-01-03\" :confirmed-cases 23014 :recovery-percent 15 })) ( def add-hundred ( partial + 100 )) map reduce filter \u03bb\ufe0e Common functions for iterating through a collection / sequence of values (map * [1 3 5 8 13 21] [3 5 8 13 21 34]) (filter even? [1 3 5 8 13 21 34]) (reduce + [31 28 30 31 30 31]) Using data structures \u03bb\ufe0e Using the map and inc function, increment all the numbers in a vector (map inc [1 2 3 4 5]) The above map function is roughly equivalent to the following expression (conj [] (inc 1) (inc 2) (inc 3) (inc 4) (inc 5)) The conj function creates a new collection by combining a collection and one or more values. Defining custom functions \u03bb\ufe0e ( defn square-of \"Calculates the square of a given number\" [ number ] ( * number number )) Function definitions can also be used within other expressions, useful for mapping custom functions over a collection ( fn [ x ] ( * x x )) ( map ( fn [ x ] ( * x x )) [ 1 2 3 4 5 ]) Ratio Type \u03bb\ufe0e ; Using the division function (/ ) shows another interesting characteristic of Clojure, the fact that it is lazy. This is not lazy in a bad way, but lazy evaluation of data structures. This actually helps to make clojure more efficient at dealing with data, especially very large data sets. ( / 22 7 ) 22/7 ( / 22 7.0 ) 3.142857142857143 ( type ( / 22 7 )) ;; Using a Ratio means that the mathematical division is not evaluated when using whole numbers (Integers) that would produce a decimal number. If you do return a decimal number then what precision of decimal are you expecting. By specifying one or more of the numbers as a decimal value you are giving Clojure a precision to infer and can therefore provide a specific decimal result. Java interoperability \u03bb\ufe0e . and new are Clojure functions that create a Java object. This allows you to use values from Java constants, i.e. PI is a static double from the java.lang.Math object ( . Math PI ) 3.141592653589793 Also call static and instance methods from Java objects. ( Math/cos 3 ) ( javax.swing.JOptionPane/showMessageDialog nil \"Hello Java Developers\" ) Recursion \u03bb\ufe0e Recursive function ( defn recursive-counter [ value ] ( if ( < value 1000 ) ( recur ( + value 25 )))) ( recursive-counter 100 ) TODO: loop-recur TODO: reduce and reducing function","title":"Clojure Quick Reference"},{"location":"quickstart/quick-reference/#clojure-quick-reference","text":"The basic Clojure syntax and a few common functions you should probably learn first. Also see the Clojure.org cheat-sheet","title":"Clojure Quick Reference"},{"location":"quickstart/quick-reference/#calling-functions","text":"The first element in a list, () , is treated as a call to a function. This is known as prefix notation which greatly simplifies Clojure syntax and makes mathematical expressions completely deterministic, eliminating the need for operator precedence . fs ( + 2 3 5 8 13 ( * 3 7 )) ( + 3 ( * 2 ( - 7 2 ) 4 ) ( / 16 4 )) ( clojure-version ) Functions contain doc-strings and you can ask for a functions documentation, or show the source code. ( doc doc ) ( source doc ) Clojure is a dynamically typed language, it is also strongly typed (everything is a type, but you dont have to express the type in your code). The type of anything in Clojure can be returned. ( type 42 ) ( type { :hash \"data\" :map \"more data\" })","title":"Calling functions"},{"location":"quickstart/quick-reference/#modeling-data-with-collection-types","text":"Clojure has 4 main collection types, all immutable (cannot change once created) and can contain any Clojure types. ( str \"lists used mainly\" ( * 2 2 ) :code ) [ 0 \"indexed array\" ] { :key \"value\" :pairs \"hash-map\" :aka \"dictionary\" } # { 1 2 3 4 \"unique\" \"set\" \"of\" \"values\" \"unordered\" ( * 3 9 )}","title":"Modeling data with Collection types"},{"location":"quickstart/quick-reference/#defining-names-for-values-vars","text":"Names can be bound to any values, simple values like numbers, collections or functions. A convenient way to refer to value in your code. ( def public-health-data ({ :date \"2020-01-01\" :confirmed-cases 23014 :recovery-percent 15 } { :date \"2020-01-02\" :confirmed-cases 23014 :recovery-percent 15 } { :date \"2020-01-03\" :confirmed-cases 23014 :recovery-percent 15 })) ( def add-hundred ( partial + 100 ))","title":"Defining names for values (vars)"},{"location":"quickstart/quick-reference/#map-reduce-filter","text":"Common functions for iterating through a collection / sequence of values (map * [1 3 5 8 13 21] [3 5 8 13 21 34]) (filter even? [1 3 5 8 13 21 34]) (reduce + [31 28 30 31 30 31])","title":"map reduce filter"},{"location":"quickstart/quick-reference/#using-data-structures","text":"Using the map and inc function, increment all the numbers in a vector (map inc [1 2 3 4 5]) The above map function is roughly equivalent to the following expression (conj [] (inc 1) (inc 2) (inc 3) (inc 4) (inc 5)) The conj function creates a new collection by combining a collection and one or more values.","title":"Using data structures"},{"location":"quickstart/quick-reference/#defining-custom-functions","text":"( defn square-of \"Calculates the square of a given number\" [ number ] ( * number number )) Function definitions can also be used within other expressions, useful for mapping custom functions over a collection ( fn [ x ] ( * x x )) ( map ( fn [ x ] ( * x x )) [ 1 2 3 4 5 ])","title":"Defining custom functions"},{"location":"quickstart/quick-reference/#ratio-type","text":"; Using the division function (/ ) shows another interesting characteristic of Clojure, the fact that it is lazy. This is not lazy in a bad way, but lazy evaluation of data structures. This actually helps to make clojure more efficient at dealing with data, especially very large data sets. ( / 22 7 ) 22/7 ( / 22 7.0 ) 3.142857142857143 ( type ( / 22 7 )) ;; Using a Ratio means that the mathematical division is not evaluated when using whole numbers (Integers) that would produce a decimal number. If you do return a decimal number then what precision of decimal are you expecting. By specifying one or more of the numbers as a decimal value you are giving Clojure a precision to infer and can therefore provide a specific decimal result.","title":"Ratio Type"},{"location":"quickstart/quick-reference/#java-interoperability","text":". and new are Clojure functions that create a Java object. This allows you to use values from Java constants, i.e. PI is a static double from the java.lang.Math object ( . Math PI ) 3.141592653589793 Also call static and instance methods from Java objects. ( Math/cos 3 ) ( javax.swing.JOptionPane/showMessageDialog nil \"Hello Java Developers\" )","title":"Java interoperability"},{"location":"quickstart/quick-reference/#recursion","text":"Recursive function ( defn recursive-counter [ value ] ( if ( < value 1000 ) ( recur ( + value 25 )))) ( recursive-counter 100 ) TODO: loop-recur TODO: reduce and reducing function","title":"Recursion"},{"location":"reference/","text":"Reference \u03bb\ufe0e","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/basic-syntax/","text":"Reference: Basic Syntax \u03bb\ufe0e Notes from Aphyr \u03bb\ufe0e Let\u2019s write a simple program. The simplest, in fact. Type \u201cnil\u201d, and hit enter. user=> nil nil nil is the most basic value in Clojure. It represents emptiness, nothing-doing, not-a-thing. The absence of information. user=> true true user=> false false true and false are a pair of special values called Booleans. They mean exactly what you think: whether a statement is true or false. true, false, and nil form the three poles of the Lisp logical system. user=> 0 0 This is the number zero. Its numeric friends are 1, -47, 1.2e-4, 1/3, and so on. We might also talk about strings, which are chunks of text surrounded by double quotes: user=> \"hi there!\" \"hi there!\" nil, true, 0, and \"hi there!\" are all different types of values; the nouns of programming. Just as one could say \u201cHouse.\u201d in English, we can write a program like \"hello, world\" and it evaluates to itself: the string \"hello world\". But most sentences aren\u2019t just about stating the existence of a thing; they involve action. We need verbs. user=> inc \u03bb\ufe0e This is a verb called inc\u2013short for \u201cincrement\u201d. Specifically, inc is a symbol which points to a verb: # \u2013 just like the word \u201crun\u201d is a name for the concept of running. There\u2019s a key distinction here\u2013that a signifier, a reference, a label, is not the same as the signified, the referent, the concept itself. If you write the word \u201crun\u201d on paper, the ink means nothing by itself. It\u2019s just a symbol. But in the mind of a reader, that symbol takes on meaning; the idea of running. Unlike the number 0, or the string \u201chi\u201d, symbols are references to other values. when Clojure evaluates a symbol, it looks up that symbol\u2019s meaning. Look up inc, and you get # . Can we refer to the symbol itself, without looking up its meaning? user=> 'inc inc Yes. The single quote ' escapes a sentence. In programming languages, we call sentences expressions or statements. A quote says \u201cRather than evaluating this expression\u2019s text, simply return the text itself, unchanged.\u201d Quote a symbol, get a symbol. Quote a number, get a number. Quote anything, and get it back exactly as it came in. user=> '123 123 user=> '\"foo\" \"foo\" user=> '(1 2 3) (1 2 3) A new kind of value, surrounded by parentheses: the list. LISP originally stood for LISt Processing, and lists are still at the core of the language. In fact, they form the most basic way to compose expressions, or sentences. A list is a single expression which has multiple parts. For instance, this list contains three elements: the numbers 1, 2, and 3. Lists can contain anything: numbers, strings, even other lists: user=> '(nil \"hi\") (nil \"hi\") A list containing two elements: the number 1, and a second list. That list contains two elements: the number 2, and another list. That list contains two elements: 3, and an empty list. user=> '(1 (2 (3 ()))) (1 (2 (3 ()))) You could think of this structure as a tree\u2013which is a provocative idea, because languages are like trees too: sentences are comprised of clauses, which can be nested, and each clause may have subjects modified by adjectives, and verbs modified by adverbs, and so on. \u201cLindsay, my best friend, took the dog which we found together at the pound on fourth street, for a walk with her mother Michelle.\u201d Took Lindsay my best friend the dog which we found together at the pound on fourth street for a walk with her mother Michelle But let\u2019s try something simpler. Something we know how to talk about. \u201cIncrement the number zero.\u201d As a tree: Increment the number zero We have a symbol for incrementing, and we know how to write the number zero. Let\u2019s combine them in a list: clj=> '(inc 0) (inc 0) A basic sentence. Remember, since it\u2019s quoted, we\u2019re talking about the tree, the text, the expression, by itself. Absent interpretation. If we remove the single-quote, Clojure will interpret the expression: user=> (inc 0) 1 Incrementing zero yields one. And if we wanted to increment that value? Increment increment the number zero user=> (inc (inc 0)) 2 A sentence in Lisp is a list. It starts with a verb, and is followed by zero or more objects for that verb to act on. Each part of the list can itself be another list, in which case that nested list is evaluated first, just like a nested clause in a sentence. When we type (inc (inc 0)) Clojure first looks up the meanings for the symbols in the code: (# (# 0)) Then evaluates the innermost list (inc 0), which becomes the number 1: (# 1) Finally, it evaluates the outer list, incrementing the number 1: 2 Every list starts with a verb. Parts of a list are evaluated from left to right. Innermost lists are evaluated before outer lists. (+ 1 (- 5 2) (+ 3 4)) (+ 1 3 (+ 3 4)) (+ 1 3 7) 11 That\u2019s it. The entire grammar of Lisp: the structure for every expression in the language. We transform expressions by substituting meanings for symbols, and obtain some result. This is the core of the Lambda Calculus, and it is the theoretical basis for almost all computer languages. Ruby, Javascript, C, Haskell; all languages express the text of their programs in different ways, but internally all construct a tree of expressions. Lisp simply makes it explicit.","title":"Reference: Basic Syntax"},{"location":"reference/basic-syntax/#reference-basic-syntax","text":"","title":"Reference: Basic Syntax"},{"location":"reference/basic-syntax/#notes-from-aphyr","text":"Let\u2019s write a simple program. The simplest, in fact. Type \u201cnil\u201d, and hit enter. user=> nil nil nil is the most basic value in Clojure. It represents emptiness, nothing-doing, not-a-thing. The absence of information. user=> true true user=> false false true and false are a pair of special values called Booleans. They mean exactly what you think: whether a statement is true or false. true, false, and nil form the three poles of the Lisp logical system. user=> 0 0 This is the number zero. Its numeric friends are 1, -47, 1.2e-4, 1/3, and so on. We might also talk about strings, which are chunks of text surrounded by double quotes: user=> \"hi there!\" \"hi there!\" nil, true, 0, and \"hi there!\" are all different types of values; the nouns of programming. Just as one could say \u201cHouse.\u201d in English, we can write a program like \"hello, world\" and it evaluates to itself: the string \"hello world\". But most sentences aren\u2019t just about stating the existence of a thing; they involve action. We need verbs. user=> inc","title":"Notes from Aphyr"},{"location":"reference/basic-syntax/#_1","text":"This is a verb called inc\u2013short for \u201cincrement\u201d. Specifically, inc is a symbol which points to a verb: # \u2013 just like the word \u201crun\u201d is a name for the concept of running. There\u2019s a key distinction here\u2013that a signifier, a reference, a label, is not the same as the signified, the referent, the concept itself. If you write the word \u201crun\u201d on paper, the ink means nothing by itself. It\u2019s just a symbol. But in the mind of a reader, that symbol takes on meaning; the idea of running. Unlike the number 0, or the string \u201chi\u201d, symbols are references to other values. when Clojure evaluates a symbol, it looks up that symbol\u2019s meaning. Look up inc, and you get # . Can we refer to the symbol itself, without looking up its meaning? user=> 'inc inc Yes. The single quote ' escapes a sentence. In programming languages, we call sentences expressions or statements. A quote says \u201cRather than evaluating this expression\u2019s text, simply return the text itself, unchanged.\u201d Quote a symbol, get a symbol. Quote a number, get a number. Quote anything, and get it back exactly as it came in. user=> '123 123 user=> '\"foo\" \"foo\" user=> '(1 2 3) (1 2 3) A new kind of value, surrounded by parentheses: the list. LISP originally stood for LISt Processing, and lists are still at the core of the language. In fact, they form the most basic way to compose expressions, or sentences. A list is a single expression which has multiple parts. For instance, this list contains three elements: the numbers 1, 2, and 3. Lists can contain anything: numbers, strings, even other lists: user=> '(nil \"hi\") (nil \"hi\") A list containing two elements: the number 1, and a second list. That list contains two elements: the number 2, and another list. That list contains two elements: 3, and an empty list. user=> '(1 (2 (3 ()))) (1 (2 (3 ()))) You could think of this structure as a tree\u2013which is a provocative idea, because languages are like trees too: sentences are comprised of clauses, which can be nested, and each clause may have subjects modified by adjectives, and verbs modified by adverbs, and so on. \u201cLindsay, my best friend, took the dog which we found together at the pound on fourth street, for a walk with her mother Michelle.\u201d Took Lindsay my best friend the dog which we found together at the pound on fourth street for a walk with her mother Michelle But let\u2019s try something simpler. Something we know how to talk about. \u201cIncrement the number zero.\u201d As a tree: Increment the number zero We have a symbol for incrementing, and we know how to write the number zero. Let\u2019s combine them in a list: clj=> '(inc 0) (inc 0) A basic sentence. Remember, since it\u2019s quoted, we\u2019re talking about the tree, the text, the expression, by itself. Absent interpretation. If we remove the single-quote, Clojure will interpret the expression: user=> (inc 0) 1 Incrementing zero yields one. And if we wanted to increment that value? Increment increment the number zero user=> (inc (inc 0)) 2 A sentence in Lisp is a list. It starts with a verb, and is followed by zero or more objects for that verb to act on. Each part of the list can itself be another list, in which case that nested list is evaluated first, just like a nested clause in a sentence. When we type (inc (inc 0)) Clojure first looks up the meanings for the symbols in the code: (# (# 0)) Then evaluates the innermost list (inc 0), which becomes the number 1: (# 1) Finally, it evaluates the outer list, incrementing the number 1: 2 Every list starts with a verb. Parts of a list are evaluated from left to right. Innermost lists are evaluated before outer lists. (+ 1 (- 5 2) (+ 3 4)) (+ 1 3 (+ 3 4)) (+ 1 3 7) 11 That\u2019s it. The entire grammar of Lisp: the structure for every expression in the language. We transform expressions by substituting meanings for symbols, and obtain some result. This is the core of the Lambda Calculus, and it is the theoretical basis for almost all computer languages. Ruby, Javascript, C, Haskell; all languages express the text of their programs in different ways, but internally all construct a tree of expressions. Lisp simply makes it explicit.","title":""},{"location":"reference/books/","text":"Books & Tutorials on Clojure \u03bb\ufe0e Here is a list of Clojure books, grouped by skill level. There is also a book list on Clojure.org or via a search for Clojure on o'Reilly lists most of these books. For Clojure beginners \u03bb\ufe0e Living Clojure , O'Reilly April 2015 Clojure for the Brave and the True , NoStartch Press September 2015 Clojurescript Unraveled - June 2016 Clojure from the ground up Practicalli Clojure Practicalli Clojure WebApps Reference \u03bb\ufe0e Clojure Programming Cookbook , Packt August 2016 Clojure Cookbook , O'Reilly March 2014 - hundreds of real-world problems and solutions, ranging from basic utilities to rich web services to heavy data processing Intermediate level \u03bb\ufe0e Web Development with Clojure , Pragmatic July 2016 Mastering Clojure , Packt March 2016 Clojure in Action , Manning December 2015 Programming Clojure , Pragmatic October 2015 Clojure Applied: From Practice to Practitioner , Pragmatic September 2015 Joy of Clojure , Manning May 2014 Clojure Programming , O'Reilly March 2012 Other books \u03bb\ufe0e Learning Clojurescript , Packt June 2016 Professional Clojure , Wiley/Wrox May 2016 Clojure for Java Developers , Packt February 2016 Clojure for Finance , January 2016 Clojure Recipes , Addison-Wesley October 2015 Clojure for Data Science , Packt September 2015 Clojure High Performance Programming , Packt September 2015 Clojure Data Structures & Algorithms , Packt August 2015 Mastering Clojure Data Analysis , Packt Clojure Reactive Programming , Packt March 2015 Clojure Web Development Essentials , Packt February 2015 Clojure Data Analysis Cookbook , Packt January 2015 Mastering Clojure Macros , Pragmatic August 2014 Clojure for Machine Learning , Packt April 2014 Clojure for Domain-specific Languages , Packt December 2013 Clojurescript: Up and Running , O'Reilly October 2012 Building Web Applications with Clojure , Packt April 2012 Functional Programming Patterns in Scala and Clojure , Pragmatic August 2014","title":"Books & Tutorials on Clojure"},{"location":"reference/books/#books-tutorials-on-clojure","text":"Here is a list of Clojure books, grouped by skill level. There is also a book list on Clojure.org or via a search for Clojure on o'Reilly lists most of these books.","title":"Books &amp; Tutorials on Clojure"},{"location":"reference/books/#for-clojure-beginners","text":"Living Clojure , O'Reilly April 2015 Clojure for the Brave and the True , NoStartch Press September 2015 Clojurescript Unraveled - June 2016 Clojure from the ground up Practicalli Clojure Practicalli Clojure WebApps","title":"For Clojure beginners"},{"location":"reference/books/#reference","text":"Clojure Programming Cookbook , Packt August 2016 Clojure Cookbook , O'Reilly March 2014 - hundreds of real-world problems and solutions, ranging from basic utilities to rich web services to heavy data processing","title":"Reference"},{"location":"reference/books/#intermediate-level","text":"Web Development with Clojure , Pragmatic July 2016 Mastering Clojure , Packt March 2016 Clojure in Action , Manning December 2015 Programming Clojure , Pragmatic October 2015 Clojure Applied: From Practice to Practitioner , Pragmatic September 2015 Joy of Clojure , Manning May 2014 Clojure Programming , O'Reilly March 2012","title":"Intermediate level"},{"location":"reference/books/#other-books","text":"Learning Clojurescript , Packt June 2016 Professional Clojure , Wiley/Wrox May 2016 Clojure for Java Developers , Packt February 2016 Clojure for Finance , January 2016 Clojure Recipes , Addison-Wesley October 2015 Clojure for Data Science , Packt September 2015 Clojure High Performance Programming , Packt September 2015 Clojure Data Structures & Algorithms , Packt August 2015 Mastering Clojure Data Analysis , Packt Clojure Reactive Programming , Packt March 2015 Clojure Web Development Essentials , Packt February 2015 Clojure Data Analysis Cookbook , Packt January 2015 Mastering Clojure Macros , Pragmatic August 2014 Clojure for Machine Learning , Packt April 2014 Clojure for Domain-specific Languages , Packt December 2013 Clojurescript: Up and Running , O'Reilly October 2012 Building Web Applications with Clojure , Packt April 2012 Functional Programming Patterns in Scala and Clojure , Pragmatic August 2014","title":"Other books"},{"location":"reference/changing-state/","text":"Changing State \u03bb\ufe0e","title":"Changing State"},{"location":"reference/changing-state/#changing-state","text":"","title":"Changing State"},{"location":"reference/control-flow/","text":"Control Flow \u03bb\ufe0e","title":"Control Flow"},{"location":"reference/control-flow/#control-flow","text":"","title":"Control Flow"},{"location":"reference/core-async/","text":"Core.async \u03bb\ufe0e","title":"Core.async"},{"location":"reference/core-async/#coreasync","text":"","title":"Core.async"},{"location":"reference/doc-and-source-functions/","text":"The doc & source functions \u03bb\ufe0e If you are not using a Clojure aware editor or spend a lot of time in the REPL you can also view the documentation of a function by calling the doc function and see the source by calling the source function. To use the doc & source functions in the REPL you should be in the user namespace. Note On the command line, start a REPL with the command lein repl and then view the documentation for three common functions used in clojure Make sure you are in the user namespace before calling the doc function. If you are in another namespace, either change back using (ns 'user) or see the next section on using these functions in another namespace. ( doc doc ) ( doc map ) ( doc filter ) ( doc cons ) ( source doc ) ( source map ) Here is the doc string for doc Here is the source code for the source function Hint As the documentation for a function is part of its definition, by looking at the source of a function you also get the documentation. Using doc & source function from another namespace \u03bb\ufe0e The doc and source functions are only included in the user namespace. If you switch to another namespace or your editor places you in the current namespace of your project, these functions will not be available unless you including core.repl in the current namespace. From the REPL, evaluate the expression: (use 'clojure.repl) You could also require the clojure.repl library in your own code, however if you have a good editor it should provide these features without including this library. Therefore the following code is shown only as an example and not a recommended approach. (ns foobar (:require [clojure.repl :refer :all]))","title":"Doc and source functions"},{"location":"reference/doc-and-source-functions/#the-doc-source-functions","text":"If you are not using a Clojure aware editor or spend a lot of time in the REPL you can also view the documentation of a function by calling the doc function and see the source by calling the source function. To use the doc & source functions in the REPL you should be in the user namespace. Note On the command line, start a REPL with the command lein repl and then view the documentation for three common functions used in clojure Make sure you are in the user namespace before calling the doc function. If you are in another namespace, either change back using (ns 'user) or see the next section on using these functions in another namespace. ( doc doc ) ( doc map ) ( doc filter ) ( doc cons ) ( source doc ) ( source map ) Here is the doc string for doc Here is the source code for the source function Hint As the documentation for a function is part of its definition, by looking at the source of a function you also get the documentation.","title":"The doc &amp; source functions"},{"location":"reference/doc-and-source-functions/#using-doc-source-function-from-another-namespace","text":"The doc and source functions are only included in the user namespace. If you switch to another namespace or your editor places you in the current namespace of your project, these functions will not be available unless you including core.repl in the current namespace. From the REPL, evaluate the expression: (use 'clojure.repl) You could also require the clojure.repl library in your own code, however if you have a good editor it should provide these features without including this library. Therefore the following code is shown only as an example and not a recommended approach. (ns foobar (:require [clojure.repl :refer :all]))","title":"Using doc &amp; source function from another namespace"},{"location":"reference/functions/","text":"Reference: Functions \u03bb\ufe0e We left off last chapter with a question: what are verbs, anyway? When you evaluate (type :mary-poppins), what really happens? user=> (type :mary-poppins) clojure.lang.Keyword To understand how type works, we\u2019ll need several new ideas. First, we\u2019ll expand on the notion of symbols as references to other values. Then we\u2019ll learn about functions: Clojure\u2019s verbs. Finally, we\u2019ll use the Var system to explore and change the definitions of those functions. Let bindings We know that symbols are names for things, and that when evaluated, Clojure replaces those symbols with their corresponding values. +, for instance, is a symbol which points to the verb # . user=> + \u03bb\ufe0e When you try to use a symbol which has no defined meaning, Clojure refuses: user=> cats CompilerException java.lang.RuntimeException: Unable to resolve symbol: cats in this context, compiling:(NO_SOURCE_PATH:0:0) But we can define a meaning for a symbol within a specific expression, using let. user=> (let [cats 5] (str \"I have \" cats \" cats.\")) \"I have 5 cats.\" The let expression first takes a vector of bindings: alternating symbols and values that those symbols are bound to, within the remainder of the expression. \u201cLet the symbol cats be 5, and construct a string composed of \"I have \", cats, and \" cats\". Let bindings apply only within the let expression itself. They also override any existing definitions for symbols at that point in the program. For instance, we can redefine addition to mean subtraction, for the duration of a let: user=> (let [+ -] (+ 2 3)) -1 But that definition doesn\u2019t apply outside the let: user=> (+ 2 3) 5 We can also provide multiple bindings. Since Clojure doesn\u2019t care about spacing, alignment, or newlines, I\u2019ll write this on multiple lines for clarity. user=> (let [person \"joseph\" num-cats 186] (str person \" has \" num-cats \" cats!\")) \"joseph has 186 cats!\" When multiple bindings are given, they are evaluated in order. Later bindings can use previous bindings. user=> (let [cats 3 legs (* 4 cats)] (str legs \" legs all together\")) \"12 legs all together\" So fundamentally, let defines the meaning of symbols within an expression. When Clojure evaluates a let, it replaces all occurrences of those symbols in the rest of the let expression with their corresponding values, then evaluates the rest of the expression. Functions We saw in chapter one that Clojure evaluates lists by substituting some other value in their place: user=> (inc 1) 2 inc takes any number, and is replaced by that number plus one. That sounds an awful lot like a let: user=> (let [x 1] (+ x 1)) 2 If we bound x to 5 instead of 1, this expression would evaluate to 6. We can think about inc like a let expression, but without particular values provided for the symbols. (let [x] (+ x 1)) We can\u2019t actually evaluate this program, because there\u2019s no value for x yet. It could be 1, or 4, or 1453. We say that x is unbound, because it has no binding to a particular value. This is the nature of the function: an expression with unbound symbols. user=> (fn [x] (+ x 1)) \u03bb\ufe0e Does the name of that function remind you of anything? user=> inc \u03bb\ufe0e Almost all verbs in Clojure are functions. Functions represent unrealized computation: expressions which are not yet evaluated, or incomplete. This particular function works just like inc: it\u2019s an expression which has a single unbound symbol, x. When we invoke the function with a particular value, the expressions in the function are evaluated with x bound to that value. user=> (inc 2) 3 user=> ((fn [x] (+ x 1)) 2) 3 We say that x is this functions argument, or parameter. When Clojure evaluates (inc 2), we say that inc is called with 2, or that 2 is passed to inc. The result of that function invocation is the function\u2019s return value. We say that (inc 2) returns 3. Fundamentally, functions describe the relationship between arguments and return values: given 1, return 2. Given 2, return 3, and so on. Let bindings describe a similar relationship, but with a specific set of values for those arguments. let is evaluated immediately, whereas fn is evaluated later, when bindings are provided. There\u2019s a shorthand for writing functions, too: #(+ % 1) is equivalent to (fn [x] (+ x 1)). % takes the place of the first argument to the function. You\u2019ll sometime see %1, %2, etc. used for the first argument, second argument, and so on. user=> (let [burrito #(list \"beans\" % \"cheese\")] (burrito \"carnitas\")) (\"beans\" \"carnitas\" \"cheese\") Since functions exist to defer evaluation, there\u2019s no sense in creating and invoking them in the same expression as we\u2019ve done here. What we want is to give names to our functions, so they can be recombined in different ways. user=> (let [twice (fn [x] (* 2 x))] (+ (twice 1) (twice 3))) 8 Compare that expression to an equivalent, expanded form: user=> (+ ( 2 1) ( 2 3)) The name twice is gone, and in its place is the same sort of computation\u2013(* 2 something)\u2013written twice. While we could represent our programs as a single massive expression, it\u2019d be impossible to reason about. Instead, we use functions to compact redundant expressions, by isolating common patterns of computation. Symbols help us re-use those functions (and other values) in more than one place. By giving the symbols meaningful names, we make it easier to reason about the structure of the program as a whole; breaking it up into smaller, understandable parts. This is core pursuit of software engineering: organizing expressions. Almost every programming language is in search of the right tools to break apart, name, and recombine expressions to solve large problems. In Clojure we\u2019ll see one particular set of tools for composing programs, but the underlying ideas will transfer to many other languages. Vars We\u2019ve used let to define a symbol within an expression, but what about the default meanings of +, conj, and type? Are they also let bindings? Is the whole universe one giant let? Well, not exactly. That\u2019s one way to think about default bindings, but it\u2019s brittle. We\u2019d need to wrap our whole program in a new let expression every time we wanted to change the meaning of a symbol. And moreover, once a let is defined, there\u2019s no way to change it. If we want to redefine symbols for everyone\u2013even code that we didn\u2019t write\u2013we need a new construct: a mutable variable. user=> (def cats 5) 'user/cats \u03bb\ufe0e user=> (type #'user/cats) clojure.lang.Var def defines a type of value we haven\u2019t seen before: a var. Vars, like symbols, are references to other values. When evaluated, a symbol pointing to a var is replaced by the var\u2019s corresponding value: user=> user/cats 5 def also binds the symbol cats (and its globally qualified equivalent user/cats) to that var. user=> user/cats 5 user=> cats 5 When we said in chapter one that inc, list, and friends were symbols that pointed to functions, that wasn\u2019t the whole story. The symbol inc points to the var #'inc, which in turn points to the function # . We can see the intermediate var with resolve: user=> 'inc inc ; the symbol user=> (resolve 'inc) 'clojure.core/inc ; the var \u03bb\ufe0e user=> (eval 'inc) ; the value \u03bb\ufe0e Why two layers of indirection? Because unlike the symbol, we can change the meaning of a Var for everyone, globally, at any time. user=> (def astronauts []) 'user/astronauts \u03bb\ufe0e user=> (count astronauts) 0 user=> (def astronauts [\"Sally Ride\" \"Guy Bluford\"]) 'user/astronauts \u03bb\ufe0e user=> (count astronauts) 2 Notice that astronauts had two distinct meanings, depending on when we evaluated it. After the first def, astronauts was an empty vector. After the second def, it had one entry. If this seems dangerous, you\u2019re a smart cookie. Redefining names in this way changes the meaning of expressions everywhere in a program, without warning. Expressions which relied on the value of a Var could suddenly take on new, possibly incorrect, meanings. It\u2019s a powerful tool for experimenting at the REPL, and for updating a running program, but it can have unexpected consequences. Good Clojurists use def to set up a program initially, and only change those definitions with careful thought. Totally redefining a Var isn\u2019t the only option. There are safer, controlled ways to change the meaning of a Var within a particular part of a program, which we\u2019ll explore later. Defining functions Armed with def, we\u2019re ready to create our own named functions in Clojure. user=> (def half (fn [number] (/ number 2))) 'user/half \u03bb\ufe0e user=> (half 6) 3 Creating a function and binding it to a var is so common that it has its own form: defn, short for def fn. user=> (defn half [number] (/ number 2)) 'user/half \u03bb\ufe0e Functions don\u2019t have to take an argument. We\u2019ve seen functions which take zero arguments, like (+). user=> (defn half [] 1/2) 'user/half \u03bb\ufe0e user=> (half) 1/2 But if we try to use our earlier form with one argument, Clojure complains that the arity\u2013the number of arguments to the function\u2013is incorrect. user=> (half 10) ArityException Wrong number of args (1) passed to: user$half clojure.lang.AFn.throwArity (AFn.java:437) To handle multiple arities, functions have an alternate form. Instead of an argument vector and a body, one provides a series of lists, each of which starts with an argument vector, followed by the body. user=> (defn half ([] 1/2) ([x] (/ x 2))) user=> (half) 1/2 user=> (half 10) 5 Multiple arguments work just like you expect. Just specify an argument vector of two, or three, or however many arguments the function takes. user=> (defn add [x y] (+ x y)) 'user/add \u03bb\ufe0e user=> (add 1 2) 3 Some functions can take any number of arguments. For that, Clojure provides &, which slurps up all remaining arguments as a list: user=> (defn variable-arguments [x y & more-args] {:x x :y y :more more-args}) 'user/variable-arguments \u03bb\ufe0e user=> (variable-arguments 1) ArityException Wrong number of args (1) passed to: user$variable-arguments clojure.lang.AFn.throwArity (AFn.java:437) user=> (variable-arguments 1 2) {:x 1, :y 2, :more nil} user=> (variable-arguments 1 2 3 4 5) {:x 1, :y 2, :more (3 4 5)} Note that x and y are mandatory, though there don\u2019t have to be any remaining arguments. To keep track of what arguments a function takes, why the function exists, and what it does, we usually include a docstring. Docstrings help fill in the missing context around functions, to explain their assumptions, context, and purpose to the world. (defn launch \"Launches a spacecraft into the given orbit by initiating a controlled on-axis burn. Does not automatically stage, but does vector thrust, if the craft supports it.\" [craft target-orbit] \"OK, we don't know how to control spacecraft yet.\") Docstrings are used to automatically generate documentation for Clojure programs, but you can also access them from the REPL. user=> (doc launch) \u03bb\ufe0e user/launch ([craft target-orbit]) Launches a spacecraft into the given orbit by initiating a controlled on-axis burn. Does not automatically stage, but does vector thrust, if the craft supports it. nil doc tells us the full name of the function, the arguments it accepts, and its docstring. This information comes from the #'launch var\u2019s metadata, and is saved there by defn. We can inspect metadata directly with the meta function: (meta #'launch) {:arglists ([craft target-orbit]), :ns # , :name launch!, :column 1, :doc \"Launches a spacecraft into the given orbit.\", :line 1, :file \"NO_SOURCE_PATH\"} There\u2019s some other juicy information in there, like the file the function was defined in and which line and column it started at, but that\u2019s not particularly useful since we\u2019re in the REPL, not a file. However, this does hint at a way to answer our motivating question: how does the type function work? How does type work? We know that type returns the type of an object: user=> (type 2) java.lang.long And that type, like all functions, is a kind of object with its own unique type: user=> type \u03bb\ufe0e user=> (type type) clojure.core$type This tells us that type is a particular instance, at memory address 39bda9b9, of the type clojure.core$type. clojure.core is a namespace which defines the fundamentals of the Clojure language, and $type tells us that it\u2019s named type in that namespace. None of this is particularly helpful, though. Maybe we can find out more about the clojure.core$type by asking what its super types are: user=> (supers (type type)) {clojure.lang.AFunction clojure.lang.IMeta java.util.concurrent.Callable clojure.lang.Fn clojure.lang.AFn java.util.Comparator java.lang.Object clojure.lang.RestFn clojure.lang.IObj java.lang.Runnable java.io.Serializable clojure.lang.IFn} \u03bb\ufe0e This is a set of all the types that include type. We say that type is an instance of clojure.lang.AFunction, or that it implements or extends java.util.concurrent.Callable, and so on. Since it\u2019s a member of clojure.lang.IMeta it has metadata, and since it\u2019s a member of clojure.lang.AFn, it\u2019s a function. Just to double check, let\u2019s confirm that type is indeed a function: user=> (fn? type) true What about its documentation? user=> (doc type) \u03bb\ufe0e clojure.core/type ([x]) Returns the :type metadata of x, or its Class if none nil Ah, that\u2019s helpful. type can take a single argument, which it calls x. If it has :type metadata, that\u2019s what it returns. Otherwise, it returns the class of x. Let\u2019s take a deeper look at type\u2019s metadata for more clues. user=> (meta #'type) {:ns # , :name type, :arglists ([x]), :column 1, :added \"1.0\", :static true, :doc \"Returns the :type metadata of x, or its Class if none\", :line 3109, :file \"clojure/core.clj\"} Look at that! This function was first added to Clojure in version 1.0, and is defined in the file clojure/core.clj, on line 3109. We could go dig up the Clojure source code and read its definition there\u2013or we could ask Clojure to do it for us: user=> (source type) (defn type \"Returns the :type metadata of x, or its Class if none\" {:added \"1.0\" :static true} [x] (or (get (meta x) :type) (class x))) nil Aha! Here, at last, is how type works. It\u2019s a function which takes a single argument x, and returns either :type from its metadata, or (class x). We can delve into any function in Clojure using these tools: user=> (source +) (defn + \"Returns the sum of numbers. (+) returns 0. Does not auto-promote longs, will throw on overflow. See also: +'\" {:inline (nary-inline 'add 'unchecked_add) :inline-arities >1? :added \"1.2\"} ([] 0) ([x] (cast Number x)) ([x y] (. clojure.lang.Numbers (add x y))) ([x y & more] (reduce1 + (+ x y) more))) nil Almost every function in a programming language is made up of other, simpler functions. +, for instance, is defined in terms of cast, add, and reduce1. Sometimes functions are defined in terms of themselves. + uses itself twice in this definition; a technique called recursion. At the bottom, though, are certain fundamental constructs below which you can go no further. Core axioms of the language. Lisp calls these \"special forms\u201d. def and let are special forms (well\u2013almost: let is a thin wrapper around let*, which is a special form) in Clojure. These forms are defined by the core implementation of the language, and are not reducible to other Clojure expressions. user=> (source def) Source not found Some Lisps are written entirely in terms of a few special forms, but Clojure is much less pure. Many functions bottom out in Java functions and types, or, for CLJS, in terms of Javascript. Any time you see an expression like (. clojure.lang.Numbers (add x y)), there\u2019s Java code underneath. Below Java lies the JVM, which might be written in C or C++, depending on which one you use. And underneath C and C++ lie more libraries, the operating system, assembler, microcode, registers, and ultimately, electrons flowing through silicon. A well-designed language isolates you from details you don\u2019t need to worry about, like which logic gates or registers to use, and lets you focus on the task at hand. Good languages also need to allow escape hatches for performance or access to dangerous functionality, as we saw with Vars. You can write entire programs entirely in terms of Clojure, but sometimes, for performance or to use tools from other languages, you\u2019ll rely on Java. The Clojure code is easy to explore with doc and source, but Java can be more opaque\u2013I usually rely on the java source files and online documentation. Review We\u2019ve seen how let associates names with values in a particular expression, and how Vars allow for mutable bindings which apply universally. and whose definitions can change over time. We learned that Clojure verbs are functions, which express the general shape of an expression but with certain values unbound. Invoking a function binds those variables to specific values, allowing evaluation of the function to proceed. Functions decompose programs into simpler pieces, expressed in terms of one another. Short, meaningful names help us understand what those functions (and other values) mean. Finally, we learned how to introspect Clojure functions with doc and source, and saw the definition of some basic Clojure functions. The Clojure cheatsheet gives a comprehensive list of the core functions in the language, and is a great starting point when you have to solve a problem but don\u2019t know what functions to use. We\u2019ll see a broad swath of those functions in Chapter 4: Sequences.","title":"Reference: Functions"},{"location":"reference/functions/#reference-functions","text":"We left off last chapter with a question: what are verbs, anyway? When you evaluate (type :mary-poppins), what really happens? user=> (type :mary-poppins) clojure.lang.Keyword To understand how type works, we\u2019ll need several new ideas. First, we\u2019ll expand on the notion of symbols as references to other values. Then we\u2019ll learn about functions: Clojure\u2019s verbs. Finally, we\u2019ll use the Var system to explore and change the definitions of those functions. Let bindings We know that symbols are names for things, and that when evaluated, Clojure replaces those symbols with their corresponding values. +, for instance, is a symbol which points to the verb # . user=> +","title":"Reference: Functions"},{"location":"reference/functions/#_1","text":"When you try to use a symbol which has no defined meaning, Clojure refuses: user=> cats CompilerException java.lang.RuntimeException: Unable to resolve symbol: cats in this context, compiling:(NO_SOURCE_PATH:0:0) But we can define a meaning for a symbol within a specific expression, using let. user=> (let [cats 5] (str \"I have \" cats \" cats.\")) \"I have 5 cats.\" The let expression first takes a vector of bindings: alternating symbols and values that those symbols are bound to, within the remainder of the expression. \u201cLet the symbol cats be 5, and construct a string composed of \"I have \", cats, and \" cats\". Let bindings apply only within the let expression itself. They also override any existing definitions for symbols at that point in the program. For instance, we can redefine addition to mean subtraction, for the duration of a let: user=> (let [+ -] (+ 2 3)) -1 But that definition doesn\u2019t apply outside the let: user=> (+ 2 3) 5 We can also provide multiple bindings. Since Clojure doesn\u2019t care about spacing, alignment, or newlines, I\u2019ll write this on multiple lines for clarity. user=> (let [person \"joseph\" num-cats 186] (str person \" has \" num-cats \" cats!\")) \"joseph has 186 cats!\" When multiple bindings are given, they are evaluated in order. Later bindings can use previous bindings. user=> (let [cats 3 legs (* 4 cats)] (str legs \" legs all together\")) \"12 legs all together\" So fundamentally, let defines the meaning of symbols within an expression. When Clojure evaluates a let, it replaces all occurrences of those symbols in the rest of the let expression with their corresponding values, then evaluates the rest of the expression. Functions We saw in chapter one that Clojure evaluates lists by substituting some other value in their place: user=> (inc 1) 2 inc takes any number, and is replaced by that number plus one. That sounds an awful lot like a let: user=> (let [x 1] (+ x 1)) 2 If we bound x to 5 instead of 1, this expression would evaluate to 6. We can think about inc like a let expression, but without particular values provided for the symbols. (let [x] (+ x 1)) We can\u2019t actually evaluate this program, because there\u2019s no value for x yet. It could be 1, or 4, or 1453. We say that x is unbound, because it has no binding to a particular value. This is the nature of the function: an expression with unbound symbols. user=> (fn [x] (+ x 1))","title":""},{"location":"reference/functions/#_2","text":"Does the name of that function remind you of anything? user=> inc","title":""},{"location":"reference/functions/#_3","text":"Almost all verbs in Clojure are functions. Functions represent unrealized computation: expressions which are not yet evaluated, or incomplete. This particular function works just like inc: it\u2019s an expression which has a single unbound symbol, x. When we invoke the function with a particular value, the expressions in the function are evaluated with x bound to that value. user=> (inc 2) 3 user=> ((fn [x] (+ x 1)) 2) 3 We say that x is this functions argument, or parameter. When Clojure evaluates (inc 2), we say that inc is called with 2, or that 2 is passed to inc. The result of that function invocation is the function\u2019s return value. We say that (inc 2) returns 3. Fundamentally, functions describe the relationship between arguments and return values: given 1, return 2. Given 2, return 3, and so on. Let bindings describe a similar relationship, but with a specific set of values for those arguments. let is evaluated immediately, whereas fn is evaluated later, when bindings are provided. There\u2019s a shorthand for writing functions, too: #(+ % 1) is equivalent to (fn [x] (+ x 1)). % takes the place of the first argument to the function. You\u2019ll sometime see %1, %2, etc. used for the first argument, second argument, and so on. user=> (let [burrito #(list \"beans\" % \"cheese\")] (burrito \"carnitas\")) (\"beans\" \"carnitas\" \"cheese\") Since functions exist to defer evaluation, there\u2019s no sense in creating and invoking them in the same expression as we\u2019ve done here. What we want is to give names to our functions, so they can be recombined in different ways. user=> (let [twice (fn [x] (* 2 x))] (+ (twice 1) (twice 3))) 8 Compare that expression to an equivalent, expanded form: user=> (+ ( 2 1) ( 2 3)) The name twice is gone, and in its place is the same sort of computation\u2013(* 2 something)\u2013written twice. While we could represent our programs as a single massive expression, it\u2019d be impossible to reason about. Instead, we use functions to compact redundant expressions, by isolating common patterns of computation. Symbols help us re-use those functions (and other values) in more than one place. By giving the symbols meaningful names, we make it easier to reason about the structure of the program as a whole; breaking it up into smaller, understandable parts. This is core pursuit of software engineering: organizing expressions. Almost every programming language is in search of the right tools to break apart, name, and recombine expressions to solve large problems. In Clojure we\u2019ll see one particular set of tools for composing programs, but the underlying ideas will transfer to many other languages. Vars We\u2019ve used let to define a symbol within an expression, but what about the default meanings of +, conj, and type? Are they also let bindings? Is the whole universe one giant let? Well, not exactly. That\u2019s one way to think about default bindings, but it\u2019s brittle. We\u2019d need to wrap our whole program in a new let expression every time we wanted to change the meaning of a symbol. And moreover, once a let is defined, there\u2019s no way to change it. If we want to redefine symbols for everyone\u2013even code that we didn\u2019t write\u2013we need a new construct: a mutable variable. user=> (def cats 5)","title":""},{"location":"reference/functions/#usercats","text":"user=> (type #'user/cats) clojure.lang.Var def defines a type of value we haven\u2019t seen before: a var. Vars, like symbols, are references to other values. When evaluated, a symbol pointing to a var is replaced by the var\u2019s corresponding value: user=> user/cats 5 def also binds the symbol cats (and its globally qualified equivalent user/cats) to that var. user=> user/cats 5 user=> cats 5 When we said in chapter one that inc, list, and friends were symbols that pointed to functions, that wasn\u2019t the whole story. The symbol inc points to the var #'inc, which in turn points to the function # . We can see the intermediate var with resolve: user=> 'inc inc ; the symbol user=> (resolve 'inc)","title":"'user/cats"},{"location":"reference/functions/#clojurecoreinc-the-var","text":"user=> (eval 'inc)","title":"'clojure.core/inc ; the var"},{"location":"reference/functions/#the-value","text":"Why two layers of indirection? Because unlike the symbol, we can change the meaning of a Var for everyone, globally, at any time. user=> (def astronauts [])","title":" ; the value"},{"location":"reference/functions/#userastronauts","text":"user=> (count astronauts) 0 user=> (def astronauts [\"Sally Ride\" \"Guy Bluford\"])","title":"'user/astronauts"},{"location":"reference/functions/#userastronauts_1","text":"user=> (count astronauts) 2 Notice that astronauts had two distinct meanings, depending on when we evaluated it. After the first def, astronauts was an empty vector. After the second def, it had one entry. If this seems dangerous, you\u2019re a smart cookie. Redefining names in this way changes the meaning of expressions everywhere in a program, without warning. Expressions which relied on the value of a Var could suddenly take on new, possibly incorrect, meanings. It\u2019s a powerful tool for experimenting at the REPL, and for updating a running program, but it can have unexpected consequences. Good Clojurists use def to set up a program initially, and only change those definitions with careful thought. Totally redefining a Var isn\u2019t the only option. There are safer, controlled ways to change the meaning of a Var within a particular part of a program, which we\u2019ll explore later. Defining functions Armed with def, we\u2019re ready to create our own named functions in Clojure. user=> (def half (fn [number] (/ number 2)))","title":"'user/astronauts"},{"location":"reference/functions/#userhalf","text":"user=> (half 6) 3 Creating a function and binding it to a var is so common that it has its own form: defn, short for def fn. user=> (defn half [number] (/ number 2))","title":"'user/half"},{"location":"reference/functions/#userhalf_1","text":"Functions don\u2019t have to take an argument. We\u2019ve seen functions which take zero arguments, like (+). user=> (defn half [] 1/2)","title":"'user/half"},{"location":"reference/functions/#userhalf_2","text":"user=> (half) 1/2 But if we try to use our earlier form with one argument, Clojure complains that the arity\u2013the number of arguments to the function\u2013is incorrect. user=> (half 10) ArityException Wrong number of args (1) passed to: user$half clojure.lang.AFn.throwArity (AFn.java:437) To handle multiple arities, functions have an alternate form. Instead of an argument vector and a body, one provides a series of lists, each of which starts with an argument vector, followed by the body. user=> (defn half ([] 1/2) ([x] (/ x 2))) user=> (half) 1/2 user=> (half 10) 5 Multiple arguments work just like you expect. Just specify an argument vector of two, or three, or however many arguments the function takes. user=> (defn add [x y] (+ x y))","title":"'user/half"},{"location":"reference/functions/#useradd","text":"user=> (add 1 2) 3 Some functions can take any number of arguments. For that, Clojure provides &, which slurps up all remaining arguments as a list: user=> (defn variable-arguments [x y & more-args] {:x x :y y :more more-args})","title":"'user/add"},{"location":"reference/functions/#uservariable-arguments","text":"user=> (variable-arguments 1) ArityException Wrong number of args (1) passed to: user$variable-arguments clojure.lang.AFn.throwArity (AFn.java:437) user=> (variable-arguments 1 2) {:x 1, :y 2, :more nil} user=> (variable-arguments 1 2 3 4 5) {:x 1, :y 2, :more (3 4 5)} Note that x and y are mandatory, though there don\u2019t have to be any remaining arguments. To keep track of what arguments a function takes, why the function exists, and what it does, we usually include a docstring. Docstrings help fill in the missing context around functions, to explain their assumptions, context, and purpose to the world. (defn launch \"Launches a spacecraft into the given orbit by initiating a controlled on-axis burn. Does not automatically stage, but does vector thrust, if the craft supports it.\" [craft target-orbit] \"OK, we don't know how to control spacecraft yet.\") Docstrings are used to automatically generate documentation for Clojure programs, but you can also access them from the REPL.","title":"'user/variable-arguments"},{"location":"reference/functions/#user-doc-launch","text":"user/launch ([craft target-orbit]) Launches a spacecraft into the given orbit by initiating a controlled on-axis burn. Does not automatically stage, but does vector thrust, if the craft supports it. nil doc tells us the full name of the function, the arguments it accepts, and its docstring. This information comes from the #'launch var\u2019s metadata, and is saved there by defn. We can inspect metadata directly with the meta function: (meta #'launch) {:arglists ([craft target-orbit]), :ns # , :name launch!, :column 1, :doc \"Launches a spacecraft into the given orbit.\", :line 1, :file \"NO_SOURCE_PATH\"} There\u2019s some other juicy information in there, like the file the function was defined in and which line and column it started at, but that\u2019s not particularly useful since we\u2019re in the REPL, not a file. However, this does hint at a way to answer our motivating question: how does the type function work? How does type work? We know that type returns the type of an object: user=> (type 2) java.lang.long And that type, like all functions, is a kind of object with its own unique type: user=> type","title":"user=&gt; (doc launch)"},{"location":"reference/functions/#_4","text":"user=> (type type) clojure.core$type This tells us that type is a particular instance, at memory address 39bda9b9, of the type clojure.core$type. clojure.core is a namespace which defines the fundamentals of the Clojure language, and $type tells us that it\u2019s named type in that namespace. None of this is particularly helpful, though. Maybe we can find out more about the clojure.core$type by asking what its super types are: user=> (supers (type type))","title":""},{"location":"reference/functions/#clojurelangafunction-clojurelangimeta-javautilconcurrentcallable-clojurelangfn-clojurelangafn-javautilcomparator-javalangobject-clojurelangrestfn-clojurelangiobj-javalangrunnable-javaioserializable-clojurelangifn","text":"This is a set of all the types that include type. We say that type is an instance of clojure.lang.AFunction, or that it implements or extends java.util.concurrent.Callable, and so on. Since it\u2019s a member of clojure.lang.IMeta it has metadata, and since it\u2019s a member of clojure.lang.AFn, it\u2019s a function. Just to double check, let\u2019s confirm that type is indeed a function: user=> (fn? type) true What about its documentation?","title":"{clojure.lang.AFunction clojure.lang.IMeta java.util.concurrent.Callable clojure.lang.Fn clojure.lang.AFn java.util.Comparator java.lang.Object clojure.lang.RestFn clojure.lang.IObj java.lang.Runnable java.io.Serializable clojure.lang.IFn}"},{"location":"reference/functions/#user-doc-type","text":"clojure.core/type ([x]) Returns the :type metadata of x, or its Class if none nil Ah, that\u2019s helpful. type can take a single argument, which it calls x. If it has :type metadata, that\u2019s what it returns. Otherwise, it returns the class of x. Let\u2019s take a deeper look at type\u2019s metadata for more clues. user=> (meta #'type) {:ns # , :name type, :arglists ([x]), :column 1, :added \"1.0\", :static true, :doc \"Returns the :type metadata of x, or its Class if none\", :line 3109, :file \"clojure/core.clj\"} Look at that! This function was first added to Clojure in version 1.0, and is defined in the file clojure/core.clj, on line 3109. We could go dig up the Clojure source code and read its definition there\u2013or we could ask Clojure to do it for us: user=> (source type) (defn type \"Returns the :type metadata of x, or its Class if none\" {:added \"1.0\" :static true} [x] (or (get (meta x) :type) (class x))) nil Aha! Here, at last, is how type works. It\u2019s a function which takes a single argument x, and returns either :type from its metadata, or (class x). We can delve into any function in Clojure using these tools: user=> (source +) (defn + \"Returns the sum of numbers. (+) returns 0. Does not auto-promote longs, will throw on overflow. See also: +'\" {:inline (nary-inline 'add 'unchecked_add) :inline-arities >1? :added \"1.2\"} ([] 0) ([x] (cast Number x)) ([x y] (. clojure.lang.Numbers (add x y))) ([x y & more] (reduce1 + (+ x y) more))) nil Almost every function in a programming language is made up of other, simpler functions. +, for instance, is defined in terms of cast, add, and reduce1. Sometimes functions are defined in terms of themselves. + uses itself twice in this definition; a technique called recursion. At the bottom, though, are certain fundamental constructs below which you can go no further. Core axioms of the language. Lisp calls these \"special forms\u201d. def and let are special forms (well\u2013almost: let is a thin wrapper around let*, which is a special form) in Clojure. These forms are defined by the core implementation of the language, and are not reducible to other Clojure expressions. user=> (source def) Source not found Some Lisps are written entirely in terms of a few special forms, but Clojure is much less pure. Many functions bottom out in Java functions and types, or, for CLJS, in terms of Javascript. Any time you see an expression like (. clojure.lang.Numbers (add x y)), there\u2019s Java code underneath. Below Java lies the JVM, which might be written in C or C++, depending on which one you use. And underneath C and C++ lie more libraries, the operating system, assembler, microcode, registers, and ultimately, electrons flowing through silicon. A well-designed language isolates you from details you don\u2019t need to worry about, like which logic gates or registers to use, and lets you focus on the task at hand. Good languages also need to allow escape hatches for performance or access to dangerous functionality, as we saw with Vars. You can write entire programs entirely in terms of Clojure, but sometimes, for performance or to use tools from other languages, you\u2019ll rely on Java. The Clojure code is easy to explore with doc and source, but Java can be more opaque\u2013I usually rely on the java source files and online documentation. Review We\u2019ve seen how let associates names with values in a particular expression, and how Vars allow for mutable bindings which apply universally. and whose definitions can change over time. We learned that Clojure verbs are functions, which express the general shape of an expression but with certain values unbound. Invoking a function binds those variables to specific values, allowing evaluation of the function to proceed. Functions decompose programs into simpler pieces, expressed in terms of one another. Short, meaningful names help us understand what those functions (and other values) mean. Finally, we learned how to introspect Clojure functions with doc and source, and saw the definition of some basic Clojure functions. The Clojure cheatsheet gives a comprehensive list of the core functions in the language, and is a great starting point when you have to solve a problem but don\u2019t know what functions to use. We\u2019ll see a broad swath of those functions in Chapter 4: Sequences.","title":"user=&gt; (doc type)"},{"location":"reference/kebab-case/","text":"Clojure names use kebab-case \u03bb\ufe0e kebab-case is a clean, human-readable way to combine the words that would otherwise have spaces. Cloure uses kebab-case to combines words with a dash, - , rather than a space. e.g. rock-paper-scissors , tic-tac-toe or (def db-spec-development {:db-type \"h2\" :db-name \"banking-on-clojure\"}) kebab-case is used throughout Clojure, including * Var names with def and function names with defn * Local names with let * Clojure spec names kebab-case is used in lisp languages including Clojure. The style is also used in website URLs, e.g. practicalli.github.io/clojure-webapps Using meaningful names \u03bb\ufe0e To provide greater clarity to human developers, words may be combined for the names used when writing the code. Using multiple words can give greater context in to the purpose of that code. Using a combination of meaningful names makes understanding and debugging code far easier. Spaces characters have special meaning \u03bb\ufe0e Programming languages remove spaces between words because the space character is used as a separator when parsing the code. If spaces were not used as a separator for the some other character would be required, adding complexity to the language syntax. Other Styles \u03bb\ufe0e camelCase - used in Java and C-style programming languages PascalCase - used in the Pascal programming language snake_case - used for ENVIRONMENT_VARIABLES and database_table_names_and_columns","title":"Clojure names use kebab-case"},{"location":"reference/kebab-case/#clojure-names-use-kebab-case","text":"kebab-case is a clean, human-readable way to combine the words that would otherwise have spaces. Cloure uses kebab-case to combines words with a dash, - , rather than a space. e.g. rock-paper-scissors , tic-tac-toe or (def db-spec-development {:db-type \"h2\" :db-name \"banking-on-clojure\"}) kebab-case is used throughout Clojure, including * Var names with def and function names with defn * Local names with let * Clojure spec names kebab-case is used in lisp languages including Clojure. The style is also used in website URLs, e.g. practicalli.github.io/clojure-webapps","title":"Clojure names use kebab-case"},{"location":"reference/kebab-case/#using-meaningful-names","text":"To provide greater clarity to human developers, words may be combined for the names used when writing the code. Using multiple words can give greater context in to the purpose of that code. Using a combination of meaningful names makes understanding and debugging code far easier.","title":"Using meaningful names"},{"location":"reference/kebab-case/#spaces-characters-have-special-meaning","text":"Programming languages remove spaces between words because the space character is used as a separator when parsing the code. If spaces were not used as a separator for the some other character would be required, adding complexity to the language syntax.","title":"Spaces characters have special meaning"},{"location":"reference/kebab-case/#other-styles","text":"camelCase - used in Java and C-style programming languages PascalCase - used in the Pascal programming language snake_case - used for ENVIRONMENT_VARIABLES and database_table_names_and_columns","title":"Other Styles"},{"location":"reference/naming-conventions/","text":"Naming Conventions \u03bb\ufe0e Kebab-case \u03bb\ufe0e Kebab-case is the naming convention for all Clojure function names than contain more than one word. Its name comes from the Shish Kebab style of cooking, where the words are the tofu and vegetables and the dashes are the skewers. clj-time string-parser display-name Predicates \u03bb\ufe0e Examples of predicate naming conventions from clojure.core contains? empty? every? not-empty? null? Namespace requires and aliases \u03bb\ufe0e Required libraries should be given a contextually meaningful name as an alias, helping to identify the purpose of functions defined outside of the namespace. Giving meaningful context helps code to be understood by any person reading the code. It is also easier to search for usage of functions from that context in the current project. Aliases are rarely typed more than once in full as Clojure editors have auto-complete, so there is no benefit to short of single character aliases. ( ns status-monitor.handler ( :require [ hiccup.page :refer :as web-page ] [ hiccup.form :refer :as web-form ])) In very commonly used libraries or very highly used functions through out the code, refer those functions explicitly ( ns naming.is.hard ( :require [ compojure.core :refer [ defroutes GET POST ]] [ ring.middleware.defaults :refer [ wrap-defaults site-defaults ]])) Converting functions \u03bb\ufe0e When a function takes values in one format or type and converts them to another Examples md->html map->Record-name ; map factory function of a record -- creates a new record from a map ->Record-name ; positional factory function of a record -- creates a new record from a list of values","title":"Naming Conventions"},{"location":"reference/naming-conventions/#naming-conventions","text":"","title":"Naming Conventions"},{"location":"reference/naming-conventions/#kebab-case","text":"Kebab-case is the naming convention for all Clojure function names than contain more than one word. Its name comes from the Shish Kebab style of cooking, where the words are the tofu and vegetables and the dashes are the skewers. clj-time string-parser display-name","title":"Kebab-case"},{"location":"reference/naming-conventions/#predicates","text":"Examples of predicate naming conventions from clojure.core contains? empty? every? not-empty? null?","title":"Predicates"},{"location":"reference/naming-conventions/#namespace-requires-and-aliases","text":"Required libraries should be given a contextually meaningful name as an alias, helping to identify the purpose of functions defined outside of the namespace. Giving meaningful context helps code to be understood by any person reading the code. It is also easier to search for usage of functions from that context in the current project. Aliases are rarely typed more than once in full as Clojure editors have auto-complete, so there is no benefit to short of single character aliases. ( ns status-monitor.handler ( :require [ hiccup.page :refer :as web-page ] [ hiccup.form :refer :as web-form ])) In very commonly used libraries or very highly used functions through out the code, refer those functions explicitly ( ns naming.is.hard ( :require [ compojure.core :refer [ defroutes GET POST ]] [ ring.middleware.defaults :refer [ wrap-defaults site-defaults ]]))","title":"Namespace requires and aliases"},{"location":"reference/naming-conventions/#converting-functions","text":"When a function takes values in one format or type and converts them to another Examples md->html map->Record-name ; map factory function of a record -- creates a new record from a map ->Record-name ; positional factory function of a record -- creates a new record from a list of values","title":"Converting functions"},{"location":"reference/naming/","text":"Naming \u03bb\ufe0e","title":"Naming"},{"location":"reference/naming/#naming","text":"","title":"Naming"},{"location":"reference/persistent-data-structures/","text":"Persistent Data Structures \u03bb\ufe0e","title":"Persistent Data Structures"},{"location":"reference/persistent-data-structures/#persistent-data-structures","text":"","title":"Persistent Data Structures"},{"location":"reference/prasmatic-schema/","text":"Prasmatic Schema \u03bb\ufe0e","title":"Prasmatic Schema"},{"location":"reference/prasmatic-schema/#prasmatic-schema","text":"","title":"Prasmatic Schema"},{"location":"reference/reader-macros/","text":"Reader Macros \u03bb\ufe0e Todo::Re-write \u03bb\ufe0e This is a collection of reader macros (think syntactic sugar) that are valid in Clojure. These macros are useful for commenting out expressions, defining sets, ... Many reader macros start with the character # , which is in fact the Dispatch macro that tells the Clojure reader (the thing that takes a file of Clojure text and parses it for consumption in the compiler) to go and look at another read table for the definition of the next character - in essence this allows extending default reader behaviour. #_ - Discard macro - ignore the next expression. Often used to comment out code, especially when nested inside other expressions #' - Var macro - returns the reference to the var. Used to pass the definition of something rather than the result of evaluating it. There is a nice list of reader macros in the article: The weird and wonderful characters of Clojure by @kouphax . Hint Reader macros are part of the Clojure language specification, so are different to macros, which can be defined by anyone.","title":"Reader Macros"},{"location":"reference/reader-macros/#reader-macros","text":"","title":"Reader Macros"},{"location":"reference/reader-macros/#todore-write","text":"This is a collection of reader macros (think syntactic sugar) that are valid in Clojure. These macros are useful for commenting out expressions, defining sets, ... Many reader macros start with the character # , which is in fact the Dispatch macro that tells the Clojure reader (the thing that takes a file of Clojure text and parses it for consumption in the compiler) to go and look at another read table for the definition of the next character - in essence this allows extending default reader behaviour. #_ - Discard macro - ignore the next expression. Often used to comment out code, especially when nested inside other expressions #' - Var macro - returns the reference to the var. Used to pass the definition of something rather than the result of evaluating it. There is a nice list of reader macros in the article: The weird and wonderful characters of Clojure by @kouphax . Hint Reader macros are part of the Clojure language specification, so are different to macros, which can be defined by anyone.","title":"Todo::Re-write"},{"location":"reference/recursion/","text":"Recursion \u03bb\ufe0e Recursion is a highly valuable tool in functional programming as it provides an idiomatic way of processing collections of data. normal recursion is more idiomatic \u03bb\ufe0e On average it tends to give you clearer, more functional code whereas loop/recur tens to push you more towards an imperative, iterative style. Recursive functions \u03bb\ufe0e Warning::Recursion can hit the limit of your heap/stack and cause a ... exception \u03bb\ufe0e Tail-call Optimisation with recur \u03bb\ufe0e Tail-call optimisation is where a part of memory is over-written by additional calls during recursive calls. By using the same memory segment each time, then the memory footprint of your code does not increase. Info:: \u03bb\ufe0e Using the recur function as the last line of a loop or function will enable tail call optimisation. Therefore recur is good choice for deeply nested recursion or when manipulating larger (non-lazy) data structures. Without tail-call optimisation the code may otherwise cause a StackOverflow / Heap out of memory Error Fast \u03bb\ufe0e Using loop and recur it's one of the most efficient constructs in Clojure, match the speed of an equivalent for loop in Java code. Restrictions \u03bb\ufe0e you can only recur in tail position, you can't do mutual recursion between two different function etc. Sometime it simply isn't possible to use loop/recur or it may require the contort of code to something very unmanageable to do so. Hint::Use recur once you have created a new recursive function \u03bb\ufe0e By calling a recursive function by name rather than using recur can prevent your code from remaining in an infinite loop if you get a terminating condition wrong. Without recur you memory space will be eaten up and your code will stop. Once your function is working correctly, then you can replace the call to itself with recur . Examples \u03bb\ufe0e Here are two examples using two different recursion approaches. What are the guidelines of usage of one over another? This example recursively calls itself ( defn take-while \"Returns a lazy sequence of successive items from coll while (pred item) returns true. pred must be free of side-effects.\" { :added \"1.0\" :static true } [ pred coll ] ( lazy-seq ( when-let [ s ( seq coll )] ( when ( pred ( first s )) ( cons ( first s ) ( take-while pred ( rest s ))))))) Hint:: \u03bb\ufe0e The above example could not use recur instead of the recursive call to take-while as that call is not in the last position. The cons function is in the last position of this function. This example uses loop and recur for recursively processing the collection. ( defn take-last \"Returns a seq of the last n items in coll. Depending on the type of coll may be no better than linear time. For vectors, see also subvec.\" { :added \"1.1\" :static true } [ n coll ] ( loop [ s ( seq coll ) , lead ( seq ( drop n coll ))] ( if lead ( recur ( next s ) ( next lead )) s ))) Misc \u03bb\ufe0e The only one reason to use lazy-seq/lazy-cons mechanism is generating lazy sequences. If you don't need them then loop/recur should undoubtedly be used.","title":"Recursion"},{"location":"reference/recursion/#recursion","text":"Recursion is a highly valuable tool in functional programming as it provides an idiomatic way of processing collections of data.","title":"Recursion"},{"location":"reference/recursion/#normal-recursion-is-more-idiomatic","text":"On average it tends to give you clearer, more functional code whereas loop/recur tens to push you more towards an imperative, iterative style.","title":"normal recursion is more idiomatic"},{"location":"reference/recursion/#recursive-functions","text":"","title":"Recursive functions"},{"location":"reference/recursion/#warningrecursion-can-hit-the-limit-of-your-heapstack-and-cause-a-exception","text":"","title":"Warning::Recursion can hit the limit of your heap/stack and cause a ... exception"},{"location":"reference/recursion/#tail-call-optimisation-with-recur","text":"Tail-call optimisation is where a part of memory is over-written by additional calls during recursive calls. By using the same memory segment each time, then the memory footprint of your code does not increase.","title":"Tail-call Optimisation with recur"},{"location":"reference/recursion/#info","text":"Using the recur function as the last line of a loop or function will enable tail call optimisation. Therefore recur is good choice for deeply nested recursion or when manipulating larger (non-lazy) data structures. Without tail-call optimisation the code may otherwise cause a StackOverflow / Heap out of memory Error","title":"Info::"},{"location":"reference/recursion/#fast","text":"Using loop and recur it's one of the most efficient constructs in Clojure, match the speed of an equivalent for loop in Java code.","title":"Fast"},{"location":"reference/recursion/#restrictions","text":"you can only recur in tail position, you can't do mutual recursion between two different function etc. Sometime it simply isn't possible to use loop/recur or it may require the contort of code to something very unmanageable to do so.","title":"Restrictions"},{"location":"reference/recursion/#hintuse-recur-once-you-have-created-a-new-recursive-function","text":"By calling a recursive function by name rather than using recur can prevent your code from remaining in an infinite loop if you get a terminating condition wrong. Without recur you memory space will be eaten up and your code will stop. Once your function is working correctly, then you can replace the call to itself with recur .","title":"Hint::Use recur once you have created a new recursive function"},{"location":"reference/recursion/#examples","text":"Here are two examples using two different recursion approaches. What are the guidelines of usage of one over another? This example recursively calls itself ( defn take-while \"Returns a lazy sequence of successive items from coll while (pred item) returns true. pred must be free of side-effects.\" { :added \"1.0\" :static true } [ pred coll ] ( lazy-seq ( when-let [ s ( seq coll )] ( when ( pred ( first s )) ( cons ( first s ) ( take-while pred ( rest s )))))))","title":"Examples"},{"location":"reference/recursion/#hint","text":"The above example could not use recur instead of the recursive call to take-while as that call is not in the last position. The cons function is in the last position of this function. This example uses loop and recur for recursively processing the collection. ( defn take-last \"Returns a seq of the last n items in coll. Depending on the type of coll may be no better than linear time. For vectors, see also subvec.\" { :added \"1.1\" :static true } [ n coll ] ( loop [ s ( seq coll ) , lead ( seq ( drop n coll ))] ( if lead ( recur ( next s ) ( next lead )) s )))","title":"Hint::"},{"location":"reference/recursion/#misc","text":"The only one reason to use lazy-seq/lazy-cons mechanism is generating lazy sequences. If you don't need them then loop/recur should undoubtedly be used.","title":"Misc"},{"location":"reference/sequences/","text":"Reference: Clojure from the ground up: sequences \u03bb\ufe0e In Chapter 3, we discovered functions as a way to abstract expressions; to rephrase a particular computation with some parts missing. We used functions to transform a single value. But what if we want to apply a function to more than one value at once? What about sequences? For example, we know that (inc 2) increments the number 2. What if we wanted to increment every number in the vector [1 2 3], producing [2 3 4]? user=> (inc [1 2 3]) ClassCastException clojure.lang.PersistentVector cannot be cast to java.lang.Number clojure.lang.Numbers.inc (Numbers.java:110) Clearly inc can only work on numbers, not on vectors. We need a different kind of tool. A direct approach Let\u2019s think about the problem in concrete terms. We want to increment each of three elements: the first, second, and third. We know how to get an element from a sequence by using nth, so let\u2019s start with the first number, at index 0: user=> (def numbers [1 2 3]) 'user/numbers \u03bb\ufe0e user=> (nth numbers 0) 1 user=> (inc (nth numbers 0)) 2 So there\u2019s the first element incremented. Now we can do the second: user=> (inc (nth numbers 1)) 3 user=> (inc (nth numbers 2)) 4 And it should be straightforward to combine these into a vector\u2026 user=> [(inc (nth numbers 0)) (inc (nth numbers 1)) (inc (nth numbers 2))] [2 3 4] Success! We\u2019ve incremented each of the numbers in the list! How about a list with only two elements? user=> (def numbers [1 2]) 'user/numbers \u03bb\ufe0e user=> [(inc (nth numbers 0)) (inc (nth numbers 1)) (inc (nth numbers 2))] IndexOutOfBoundsException clojure.lang.PersistentVector.arrayFor (PersistentVector.java:107) Shoot. We tried to get the element at index 2, but couldn\u2019t, because numbers only has indices 0 and 1. Clojure calls that \u201cindex out of bounds\u201d. We could just leave off the third expression in the vector; taking only elements 0 and 1. But the problem actually gets much worse, because we\u2019d need to make this change every time we wanted to use a different sized vector. And what of a vector with 1000 elements? We\u2019d need 1000 (inc (nth numbers ...)) expressions! Down this path lies madness. Let\u2019s back up a bit, and try a slightly smaller problem. Recursion What if we just incremented the first number in the vector? How would that work? We know that first finds the first element in a sequence, and rest finds all the remaining ones. user=> (first [1 2 3]) 1 user=> (rest [1 2 3]) (2 3) So there\u2019s the pieces we\u2019d need. To glue them back together, we can use a function called cons, which says \u201cmake a list beginning with the first argument, followed by all the elements in the second argument\u201d. user=> (cons 1 [2]) (1 2) user=> (cons 1 [2 3]) (1 2 3) user=> (cons 1 [2 3 4]) (1 2 3 4) OK so we can split up a sequence, increment the first part, and join them back together. Not so hard, right? (defn inc-first [numbers] (cons (inc (first numbers)) (rest numbers))) user=> (inc-first [1 2 3 4]) (2 2 3 4) Hey, there we go! First element changed. Will it work with any length list? user=> (inc-first [5]) (6) user=> (inc-first []) NullPointerException clojure.lang.Numbers.ops (Numbers.java:942) Shoot. We can\u2019t increment the first element of this empty vector, because it doesn\u2019t have a first element. user=> (first []) nil user=> (inc nil) NullPointerException clojure.lang.Numbers.ops (Numbers.java:942) So there are really two cases for this function. If there is a first element in numbers, we\u2019ll increment it as normal. If there\u2019s no such element, we\u2019ll return an empty list. To express this kind of conditional behavior, we\u2019ll use a Clojure special form called if: user=> (doc if) \u03bb\ufe0e if (if test then else?) Special Form Evaluates test. If not the singular values nil or false, evaluates and yields then, otherwise, evaluates and yields else. If else is not supplied it defaults to nil. Please see http://clojure.org/special_forms#if To confirm our intuition: user=> (if true :a :b) :a user=> (if false :a :b) :b Seems straightforward enough. (defn inc-first [numbers] (if (first numbers) ; If there's a first number, build a new list with cons (cons (inc (first numbers)) (rest numbers)) ; If there's no first number, just return an empty list (list))) user=> (inc-first []) () user=> (inc-first [1 2 3]) (2 2 3) Success! Now we can handle both cases: empty sequences, and sequences with things in them. Now how about incrementing that second number? Let\u2019s stare at that code for a bit. (rest numbers) Hang on. That list\u2013(rest numbers)\u2013that\u2019s a list of numbers too. What if we\u2026 used our inc-first function on that list, to increment its first number? Then we\u2019d have incremented both the first and the second element. (defn inc-more [numbers] (if (first numbers) (cons (inc (first numbers)) (inc-more (rest numbers))) (list))) user=> (inc-more [1 2 3 4]) (2 3 4 5) Odd. That didn\u2019t just increment the first two numbers. It incremented all the numbers. We fell into the complete solution entirely by accident. What happened here? Well first we\u2026 yes, we got the number one, and incremented it. Then we stuck that onto (inc-first [2 3 4]), which got two, and incremented it. Then we stuck that two onto (inc-first [3 4]), which got three, and then we did the same for four. Only that time around, at the very end of the list, (rest [4]) would have been empty. So when we went to get the first number of the empty list, we took the second branch of the if, and returned the empty list. Having reached the bottom of the function calls, so to speak, we zip back up the chain. We can imagine this function turning into a long string of cons calls, like so: (cons 2 (cons 3 (cons 4 (cons 5 '())))) (cons 2 (cons 3 (cons 4 '(5)))) (cons 2 (cons 3 '(4 5))) (cons 2 '(3 4 5)) '(2 3 4 5) This technique is called recursion, and it is a fundamental principle in working with collections, sequences, trees, or graphs\u2026 any problem which has small parts linked together. There are two key elements in a recursive program: Some part of the problem which has a known solution A relationship which connects one part of the problem to the next Incrementing the elements of an empty list returns the empty list. This is our base case: the ground to build on. Our inductive case, also called the recurrence relation, is how we broke the problem up into incrementing the first number in the sequence, and incrementing all the numbers in the rest of the sequence. The if expression bound these two cases together into a single function; a function defined in terms of itself. Once the initial step has been taken, every step can be taken. user=> (inc-more [1 2 3 4 5 6 7 8 9 10 11 12]) (2 3 4 5 6 7 8 9 10 11 12 13) This is the beauty of a recursive function; folding an unbounded stream of computation over and over, onto itself, until only a single step remains. Generalizing from inc We set out to increment every number in a vector, but nothing in our solution actually depended on inc. It just as well could have been dec, or str, or keyword. Let\u2019s parameterize our inc-more function to use any transformation of its elements: (defn transform-all [f xs] (if (first xs) (cons (f (first xs)) (transform-all f (rest xs))) (list))) Because we could be talking about any kind of sequence, not just numbers, we\u2019ve named the sequence xs, and its first element x. We also take a function f as an argument, and that function will be applied to each x in turn. So not only can we increment numbers\u2026 user=> (transform-all inc [1 2 3 4]) (2 3 4 5) \u2026but we can turn strings to keywords\u2026 user=> (transform-all keyword [\"bell\" \"hooks\"]) (:bell :hooks) \u2026or wrap every element in a list: user=> (transform-all list [:codex :book :manuscript]) ((:codex) (:book) (:manuscript)) In short, this function expresses a sequence in which each element is some function applied to the corresponding element in the underlying sequence. This idea is so important that it has its own name, in mathematics, Clojure, and other languages. We call it map. user=> (map inc [1 2 3 4]) (2 3 4 5) You might remember maps as a datatype in Clojure, too\u2013they\u2019re dictionaries that relate keys to values. {:year 1969 :event \"moon landing\"} The function map relates one sequence to another. The type map relates keys to values. There is a deep symmetry between the two: maps are usually sparse, and the relationships between keys and values may be arbitrarily complex. The map function, on the other hand, usually expresses the same type of relationship, applied to a series of elements in fixed order. Building sequences Recursion can do more than just map. We can use it to expand a single value into a sequence of values, each related by some function. For instance: (defn expand [f x count] (if (pos? count) (cons x (expand f (f x) (dec count))))) Our base case is x itself, followed by the sequence beginning with (f x). That sequence in turn expands to (f (f x)), and then (f (f (f x))), and so on. Each time we call expand, we count down by one using dec. Once the count is zero, the if returns nil, and evaluation stops. If we start with the number 0 and use inc as our function: user=> user=> (expand inc 0 10) (0 1 2 3 4 5 6 7 8 9) Clojure has a more general form of this function, called iterate. user=> (take 10 (iterate inc 0)) (0 1 2 3 4 5 6 7 8 9) Since this sequence is infinitely long, we\u2019re using take to select only the first 10 elements. We can construct more complex sequences by using more complex functions: user=> (take 10 (iterate (fn [x] (if (odd? x) (+ 1 x) (/ x 2))) 10)) (10 5 6 3 4 2 1 2 1 2) Or build up strings: user=> (take 5 (iterate (fn [x] (str x \"o\")) \"y\")) (\"y\" \"yo\" \"yoo\" \"yooo\" \"yoooo\") iterate is extremely handy for working with infinite sequences, and has some partners in crime. repeat, for instance, constructs a sequence where every element is the same. user=> (take 10 (repeat :hi)) (:hi :hi :hi :hi :hi :hi :hi :hi :hi :hi) user=> (repeat 3 :echo) (:echo :echo :echo) And its close relative repeatedly simply calls a function (f) to generate an infinite sequence of values, over and over again, without any relationship between elements. For an infinite sequence of random numbers: user=> (rand) 0.9002678382322784 user=> (rand) 0.12375594203332863 user=> (take 3 (repeatedly rand)) (0.44442397843046755 0.33668691162169784 0.18244875487846746) Notice that calling (rand) returns a different number each time. We say that rand is an impure function, because it cannot simply be replaced by the same value every time. It does something different each time it\u2019s called. There\u2019s another very handy sequence function specifically for numbers: range, which generates a sequence of numbers between two points. (range n) gives n successive integers starting at 0. (range n m) returns integers from n to m-1. (range n m step) returns integers from n to m, but separated by step. user=> (range 5) (0 1 2 3 4) user=> (range 2 10) (2 3 4 5 6 7 8 9) user=> (range 0 100 5) (0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95) To extend a sequence by repeating it forever, use cycle: user=> (take 10 (cycle [1 2 3])) (1 2 3 1 2 3 1 2 3 1) Transforming sequences Given a sequence, we often want to find a related sequence. map, for instance, applies a function to each element\u2013but has a few more tricks up its sleeve. user=> (map (fn [n vehicle] (str \"I've got \" n \" \" vehicle \"s\")) [0 200 9] [\"car\" \"train\" \"kiteboard\"]) (\"I've got 0 cars\" \"I've got 200 trains\" \"I've got 9 kiteboards\") If given multiple sequences, map calls its function with one element from each sequence in turn. So the first value will be (f 0 \"car\"), the second (f 200 \"train\"), and so on. Like a zipper, map folds together corresponding elements from multiple collections. To sum three vectors, column-wise: user=> (map + [1 2 3] [4 5 6] [7 8 9]) (12 15 18) If one sequence is bigger than another, map stops at the end of the smaller one. We can exploit this to combine finite and infinite sequences. For example, to number the elements in a vector: user=> (map (fn [index element] (str index \". \" element)) (iterate inc 0) [\"erlang\" \"ruby\" \"haskell\"]) (\"0. erlang\" \"1. ruby\" \"2. haskell\") Transforming elements together with their indices is so common that Clojure has a special function for it: map-indexed: user=> (map-indexed (fn [index element] (str index \". \" element)) [\"erlang\" \"ruby\" \"haskell\"]) (\"0. erlang\" \"1. ruby\" \"2. haskell\") You can also tack one sequence onto the end of another, like so: user=> (concat [1 2 3] [:a :b :c] [4 5 6]) (1 2 3 :a :b :c 4 5 6) Another way to combine two sequences is to riffle them together, using interleave. user=> (interleave [:a :b :c] [1 2 3]) (:a 1 :b 2 :c 3) And if you want to insert a specific element between each successive pair in a sequence, try interpose: user=> (interpose :and [1 2 3 4]) (1 :and 2 :and 3 :and 4) To reverse a sequence, use reverse. user=> (reverse [1 2 3]) (3 2 1) user=> (reverse \"woolf\") (\\f \\l \\o \\o \\w) Strings are sequences too! Each element of a string is a character, written \\f. You can rejoin those characters into a string with apply str: user=> (apply str (reverse \"woolf\")) \"floow\" \u2026and break strings up into sequences of chars with seq. user=> (seq \"sato\") (\\s \\a \\t \\o) To randomize the order of a sequence, use shuffle. user=> (shuffle [1 2 3 4]) [3 1 2 4] user=> (apply str (shuffle (seq \"abracadabra\"))) \"acaadabrrab\" Subsequences We\u2019ve already seen take, which selects the first n elements. There\u2019s also drop, which removes the first n elements. user=> (range 10) (0 1 2 3 4 5 6 7 8 9) user=> (take 3 (range 10)) (0 1 2) user=> (drop 3 (range 10)) (3 4 5 6 7 8 9) And for slicing apart the other end of the sequence, we have take-last and drop-last: user=> (take-last 3 (range 10)) (7 8 9) user=> (drop-last 3 (range 10)) (0 1 2 3 4 5 6) take-while and drop-while work just like take and drop, but use a function to decide when to cut. user=> (take-while pos? [3 2 1 0 -1 -2 10]) (3 2 1) In general, one can cut a sequence in twain by using split-at, and giving it a particular index. There\u2019s also split-with, which uses a function to decide when to cut. (split-at 4 (range 10)) [(0 1 2 3) (4 5 6 7 8 9)] user=> (split-with number? [1 2 3 :mark 4 5 6 :mark 7]) [(1 2 3) (:mark 4 5 6 :mark 7)] Notice that because indexes start at zero, sequence functions tend to have predictable numbers of elements. (split-at 4) yields four elements in the first collection, and ensures the second collection begins at index four. (range 10) has ten elements, corresponding to the first ten indices in a sequence. (range 3 5) has two (since 5 - 3 is two) elements. These choices simplify the definition of recursive functions as well. We can select particular elements from a sequence by applying a function. To find all positive numbers in a list, use filter: user=> (filter pos? [1 5 -4 -7 3 0]) (1 5 3) filter looks at each element in turn, and includes it in the resulting sequence only if (f element) returns a truthy value. Its complement is remove, which only includes those elements where (f element) is false or nil. user=> (remove string? [1 \"turing\" :apple]) (1 :apple) Finally, one can group a sequence into chunks using partition, partition-all, or partition-by. For instance, one might group alternating values into pairs: user=> (partition 2 [:cats 5 :bats 27 :crocodiles 0]) ((:cats 5) (:bats 27) (:crocodiles 0)) Or separate a series of numbers into negative and positive runs: (user=> (partition-by neg? [1 2 3 2 1 -1 -2 -3 -2 -1 1 2]) ((1 2 3 2 1) (-1 -2 -3 -2 -1) (1 2)) Collapsing sequences After transforming a sequence, we often want to collapse it in some way; to derive some smaller value. For instance, we might want the number of times each element appears in a sequence: user=> (frequencies [:meow :mrrrow :meow :meow]) {:meow 3, :mrrrow 1} Or to group elements by some function: user=> (pprint (group-by :first [{:first \"Li\" :last \"Zhou\"} {:first \"Sarah\" :last \"Lee\"} {:first \"Sarah\" :last \"Dunn\"} {:first \"Li\" :last \"O'Toole\"}])) {\"Li\" [{:last \"Zhou\", :first \"Li\"} {:last \"O'Toole\", :first \"Li\"}], \"Sarah\" [{:last \"Lee\", :first \"Sarah\"} {:last \"Dunn\", :first \"Sarah\"}]} Here we\u2019ve taken a sequence of people with first and last names, and used the :first keyword (which can act as a function!) to look up those first names. group-by used that function to produce a map of first names to lists of people\u2013kind of like an index. In general, we want to combine elements together in some way, using a function. Where map treated each element independently, reducing a sequence requires that we bring some information along. The most general way to collapse a sequence is reduce. user=> (doc reduce) \u03bb\ufe0e clojure.core/reduce ([f coll] [f val coll]) f should be a function of 2 arguments. If val is not supplied, returns the result of applying f to the first 2 items in coll, then applying f to that result and the 3rd item, etc. If coll contains no items, f must accept no arguments as well, and reduce returns the result of calling f with no arguments. If coll has only 1 item, it is returned and f is not called. If val is supplied, returns the result of applying f to val and the first item in coll, then applying f to that result and the 2nd item, etc. If coll contains no items, returns val and f is not called. That\u2019s a little complicated, so we\u2019ll start small. We need a function, f, which combines successive elements of the sequence. (f state element) will return the state for the next invocation of f. As f moves along the sequence, it carries some changing state with it. The final state is the return value of reduce. user=> (reduce + [1 2 3 4]) 10 reduce begins by calling (+ 1 2), which yields the state 3. Then it calls (+ 3 3), which yields 6. Then (+ 6 4), which returns 10. We\u2019ve taken a function over two elements, and used it to combine all the elements. Mathematically, we could write: 1 + 2 + 3 + 4 3 + 3 + 4 6 + 4 10 So another way to look at reduce is like sticking a function between each pair of elements. To see the reducing process in action, we can use reductions, which returns a sequence of all the intermediate states. user=> (reductions + [1 2 3 4]) (1 3 6 10) Oftentimes we include a default state to start with. For instance, we could start with an empty set, and add each element to it as we go along: user=> (reduce conj #{} [:a :b :b :b :a :a]) {:a :b} \u03bb\ufe0e Reducing elements into a collection has its own name: into. We can conj [key value] vectors into a map, for instance, or build up a list: user=> (into {} [[:a 2] [:b 3]]) {:a 2, :b 3} user=> (into (list) [1 2 3 4]) (4 3 2 1) Because elements added to a list appear at the beginning, not the end, this expression reverses the sequence. Vectors conj onto the end, so to emit the elements in order, using reduce, we might try: user=> (reduce conj [] [1 2 3 4 5]) (reduce conj [] [1 2 3 4 5]) [1 2 3 4 5] Which brings up an interesting thought: this looks an awful lot like map. All that\u2019s missing is some kind of transformation applied to each element. (defn my-map [f coll] (reduce (fn [output element] (conj output (f element))) [] coll)) user=> (my-map inc [1 2 3 4]) [2 3 4 5] Huh. map is just a special kind of reduce. What about, say, take-while? (defn my-take-while [f coll] (reduce (fn [out elem] (if (f elem) (conj out elem) (reduced out))) [] coll)) We\u2019re using a special function here, reduced, to indicate that we\u2019ve completed our reduction early and can skip the rest of the sequence. user=> (my-take-while pos? [2 1 0 -1 0 1 2]) [2 1] reduce really is the uber function over sequences. Almost any operation on a sequence can be expressed in terms of a reduce\u2013though for various reasons, many of the Clojure sequence functions are not written this way. For instance, take-while is actually defined like so: user=> (source take-while) (defn take-while \"Returns a lazy sequence of successive items from coll while (pred item) returns true. pred must be free of side-effects.\" {:added \"1.0\" :static true} [pred coll] (lazy-seq (when-let [s (seq coll)] (when (pred (first s)) (cons (first s) (take-while pred (rest s))))))) There\u2019s a few new pieces here, but the structure is essentially the same as our initial attempt at writing map. When the predicate matches the first element, cons the first element onto take-while, applied to the rest of the sequence. That lazy-seq construct allows Clojure to compute this sequence as required, instead of right away. It defers execution to a later time. Most of Clojure\u2019s sequence functions are lazy. They don\u2019t do anything until needed. For instance, we can increment every number from zero to infinity: user=> (def infinite-sequence (map inc (iterate inc 0))) 'user/infinite-sequence \u03bb\ufe0e user=> (realized? infinite-sequence) false That function returned immediately. Because it hasn\u2019t done any work yet, we say the sequence is unrealized. It doesn\u2019t increment any numbers at all until we ask for them: user=> (take 10 infinite-sequence) (1 2 3 4 5 6 7 8 9 10) user=> (realized? infinite-sequence) true Lazy sequences also remember their contents, once evaluated, for faster access. Putting it all together We\u2019ve seen how recursion generalizes a function over one thing into a function over many things, and discovered a rich landscape of recursive functions over sequences. Now let\u2019s use our knowledge of sequences to solve a more complex problem: find the sum of the products of consecutive pairs of the first 1000 odd integers. First, we\u2019ll need the integers. We can start with 0, and work our way up to infinity. To save time printing an infinite number of integers, we\u2019ll start with just the first 10. user=> (take 10 (iterate inc 0)) (0 1 2 3 4 5 6 7 8 9) Now we need to find only the ones which are odd. Remember, filter pares down a sequence to only those elements which pass a test. user=> (take 10 (filter odd? (iterate inc 0))) (1 3 5 7 9 11 13 15 17 19) For consecutive pairs, we want to take [1 3 5 7 ...] and find a sequence like ([1 3] [3 5] [5 7] ...). That sounds like a job for partition: user=> (take 3 (partition 2 (filter odd? (iterate inc 0)))) ((1 3) (5 7) (9 11)) Not quite right\u2013this gave us non-overlapping pairs, but we wanted overlapping ones too. A quick check of (doc partition) reveals the step parameter: user=> (take 3 (partition 2 1 (filter odd? (iterate inc 0)))) ((1 3) (3 5) (5 7)) Now we need to find the product for each pair. Given a pair, multiply the two pieces together\u2026 yes, that sounds like map: user=> (take 3 (map (fn [pair] (* (first pair) (second pair))) (partition 2 1 (filter odd? (iterate inc 0))))) (3 15 35) Getting a bit unwieldy, isn\u2019t it? Only one final step: sum all those products. We\u2019ll adjust the take to include the first 1000, not the first 3, elements. user=> (reduce + (take 1000 (map (fn [pair] (* (first pair) (second pair))) (partition 2 1 (filter odd? (iterate inc 0))))) 1335333000 The sum of the first thousand products of consecutive pairs of the odd integers starting at 0. See how each part leads to the next? This expression looks a lot like the way we phrased the problem in English\u2013but both English and Lisp expressions are sort of backwards, in a way. The part that happens first appears deepest, last, in the expression. In a chain of reasoning like this, it\u2019d be nicer to write it in order. user=> (->> 0 (iterate inc) (filter odd?) (partition 2 1) (map (fn [pair] (* (first pair) (second pair)))) (take 1000) (reduce +)) 1335333000 Much easier to read: now everything flows in order, from top to bottom, and we\u2019ve flattened out the deeply nested expressions into a single level. This is how object-oriented languages structure their expressions: as a chain of function invocations, each acting on the previous value. But how is this possible? Which expression gets evaluated first? (take 1000) isn\u2019t even a valid call\u2013where\u2019s its second argument? How are any of these forms evaluated? What kind of arcane function is ->>? All these mysteries, and more, in Chapter 5: Macros. Problems Write a function to find out if a string is a palindrome\u2013that is, if it looks the same forwards and backwards. Find the number of \u2018c\u2019s in \u201cabracadabra\u201d. Write your own version of filter. Find the first 100 prime numbers: 2, 3, 5, 7, 11, 13, 17, \u2026.","title":"Reference: Clojure from the ground up: sequences"},{"location":"reference/sequences/#reference-clojure-from-the-ground-up-sequences","text":"In Chapter 3, we discovered functions as a way to abstract expressions; to rephrase a particular computation with some parts missing. We used functions to transform a single value. But what if we want to apply a function to more than one value at once? What about sequences? For example, we know that (inc 2) increments the number 2. What if we wanted to increment every number in the vector [1 2 3], producing [2 3 4]? user=> (inc [1 2 3]) ClassCastException clojure.lang.PersistentVector cannot be cast to java.lang.Number clojure.lang.Numbers.inc (Numbers.java:110) Clearly inc can only work on numbers, not on vectors. We need a different kind of tool. A direct approach Let\u2019s think about the problem in concrete terms. We want to increment each of three elements: the first, second, and third. We know how to get an element from a sequence by using nth, so let\u2019s start with the first number, at index 0: user=> (def numbers [1 2 3])","title":"Reference: Clojure from the ground up: sequences"},{"location":"reference/sequences/#usernumbers","text":"user=> (nth numbers 0) 1 user=> (inc (nth numbers 0)) 2 So there\u2019s the first element incremented. Now we can do the second: user=> (inc (nth numbers 1)) 3 user=> (inc (nth numbers 2)) 4 And it should be straightforward to combine these into a vector\u2026 user=> [(inc (nth numbers 0)) (inc (nth numbers 1)) (inc (nth numbers 2))] [2 3 4] Success! We\u2019ve incremented each of the numbers in the list! How about a list with only two elements? user=> (def numbers [1 2])","title":"'user/numbers"},{"location":"reference/sequences/#usernumbers_1","text":"user=> [(inc (nth numbers 0)) (inc (nth numbers 1)) (inc (nth numbers 2))] IndexOutOfBoundsException clojure.lang.PersistentVector.arrayFor (PersistentVector.java:107) Shoot. We tried to get the element at index 2, but couldn\u2019t, because numbers only has indices 0 and 1. Clojure calls that \u201cindex out of bounds\u201d. We could just leave off the third expression in the vector; taking only elements 0 and 1. But the problem actually gets much worse, because we\u2019d need to make this change every time we wanted to use a different sized vector. And what of a vector with 1000 elements? We\u2019d need 1000 (inc (nth numbers ...)) expressions! Down this path lies madness. Let\u2019s back up a bit, and try a slightly smaller problem. Recursion What if we just incremented the first number in the vector? How would that work? We know that first finds the first element in a sequence, and rest finds all the remaining ones. user=> (first [1 2 3]) 1 user=> (rest [1 2 3]) (2 3) So there\u2019s the pieces we\u2019d need. To glue them back together, we can use a function called cons, which says \u201cmake a list beginning with the first argument, followed by all the elements in the second argument\u201d. user=> (cons 1 [2]) (1 2) user=> (cons 1 [2 3]) (1 2 3) user=> (cons 1 [2 3 4]) (1 2 3 4) OK so we can split up a sequence, increment the first part, and join them back together. Not so hard, right? (defn inc-first [numbers] (cons (inc (first numbers)) (rest numbers))) user=> (inc-first [1 2 3 4]) (2 2 3 4) Hey, there we go! First element changed. Will it work with any length list? user=> (inc-first [5]) (6) user=> (inc-first []) NullPointerException clojure.lang.Numbers.ops (Numbers.java:942) Shoot. We can\u2019t increment the first element of this empty vector, because it doesn\u2019t have a first element. user=> (first []) nil user=> (inc nil) NullPointerException clojure.lang.Numbers.ops (Numbers.java:942) So there are really two cases for this function. If there is a first element in numbers, we\u2019ll increment it as normal. If there\u2019s no such element, we\u2019ll return an empty list. To express this kind of conditional behavior, we\u2019ll use a Clojure special form called if:","title":"'user/numbers"},{"location":"reference/sequences/#user-doc-if","text":"if (if test then else?) Special Form Evaluates test. If not the singular values nil or false, evaluates and yields then, otherwise, evaluates and yields else. If else is not supplied it defaults to nil. Please see http://clojure.org/special_forms#if To confirm our intuition: user=> (if true :a :b) :a user=> (if false :a :b) :b Seems straightforward enough. (defn inc-first [numbers] (if (first numbers) ; If there's a first number, build a new list with cons (cons (inc (first numbers)) (rest numbers)) ; If there's no first number, just return an empty list (list))) user=> (inc-first []) () user=> (inc-first [1 2 3]) (2 2 3) Success! Now we can handle both cases: empty sequences, and sequences with things in them. Now how about incrementing that second number? Let\u2019s stare at that code for a bit. (rest numbers) Hang on. That list\u2013(rest numbers)\u2013that\u2019s a list of numbers too. What if we\u2026 used our inc-first function on that list, to increment its first number? Then we\u2019d have incremented both the first and the second element. (defn inc-more [numbers] (if (first numbers) (cons (inc (first numbers)) (inc-more (rest numbers))) (list))) user=> (inc-more [1 2 3 4]) (2 3 4 5) Odd. That didn\u2019t just increment the first two numbers. It incremented all the numbers. We fell into the complete solution entirely by accident. What happened here? Well first we\u2026 yes, we got the number one, and incremented it. Then we stuck that onto (inc-first [2 3 4]), which got two, and incremented it. Then we stuck that two onto (inc-first [3 4]), which got three, and then we did the same for four. Only that time around, at the very end of the list, (rest [4]) would have been empty. So when we went to get the first number of the empty list, we took the second branch of the if, and returned the empty list. Having reached the bottom of the function calls, so to speak, we zip back up the chain. We can imagine this function turning into a long string of cons calls, like so: (cons 2 (cons 3 (cons 4 (cons 5 '())))) (cons 2 (cons 3 (cons 4 '(5)))) (cons 2 (cons 3 '(4 5))) (cons 2 '(3 4 5)) '(2 3 4 5) This technique is called recursion, and it is a fundamental principle in working with collections, sequences, trees, or graphs\u2026 any problem which has small parts linked together. There are two key elements in a recursive program: Some part of the problem which has a known solution A relationship which connects one part of the problem to the next Incrementing the elements of an empty list returns the empty list. This is our base case: the ground to build on. Our inductive case, also called the recurrence relation, is how we broke the problem up into incrementing the first number in the sequence, and incrementing all the numbers in the rest of the sequence. The if expression bound these two cases together into a single function; a function defined in terms of itself. Once the initial step has been taken, every step can be taken. user=> (inc-more [1 2 3 4 5 6 7 8 9 10 11 12]) (2 3 4 5 6 7 8 9 10 11 12 13) This is the beauty of a recursive function; folding an unbounded stream of computation over and over, onto itself, until only a single step remains. Generalizing from inc We set out to increment every number in a vector, but nothing in our solution actually depended on inc. It just as well could have been dec, or str, or keyword. Let\u2019s parameterize our inc-more function to use any transformation of its elements: (defn transform-all [f xs] (if (first xs) (cons (f (first xs)) (transform-all f (rest xs))) (list))) Because we could be talking about any kind of sequence, not just numbers, we\u2019ve named the sequence xs, and its first element x. We also take a function f as an argument, and that function will be applied to each x in turn. So not only can we increment numbers\u2026 user=> (transform-all inc [1 2 3 4]) (2 3 4 5) \u2026but we can turn strings to keywords\u2026 user=> (transform-all keyword [\"bell\" \"hooks\"]) (:bell :hooks) \u2026or wrap every element in a list: user=> (transform-all list [:codex :book :manuscript]) ((:codex) (:book) (:manuscript)) In short, this function expresses a sequence in which each element is some function applied to the corresponding element in the underlying sequence. This idea is so important that it has its own name, in mathematics, Clojure, and other languages. We call it map. user=> (map inc [1 2 3 4]) (2 3 4 5) You might remember maps as a datatype in Clojure, too\u2013they\u2019re dictionaries that relate keys to values. {:year 1969 :event \"moon landing\"} The function map relates one sequence to another. The type map relates keys to values. There is a deep symmetry between the two: maps are usually sparse, and the relationships between keys and values may be arbitrarily complex. The map function, on the other hand, usually expresses the same type of relationship, applied to a series of elements in fixed order. Building sequences Recursion can do more than just map. We can use it to expand a single value into a sequence of values, each related by some function. For instance: (defn expand [f x count] (if (pos? count) (cons x (expand f (f x) (dec count))))) Our base case is x itself, followed by the sequence beginning with (f x). That sequence in turn expands to (f (f x)), and then (f (f (f x))), and so on. Each time we call expand, we count down by one using dec. Once the count is zero, the if returns nil, and evaluation stops. If we start with the number 0 and use inc as our function: user=> user=> (expand inc 0 10) (0 1 2 3 4 5 6 7 8 9) Clojure has a more general form of this function, called iterate. user=> (take 10 (iterate inc 0)) (0 1 2 3 4 5 6 7 8 9) Since this sequence is infinitely long, we\u2019re using take to select only the first 10 elements. We can construct more complex sequences by using more complex functions: user=> (take 10 (iterate (fn [x] (if (odd? x) (+ 1 x) (/ x 2))) 10)) (10 5 6 3 4 2 1 2 1 2) Or build up strings: user=> (take 5 (iterate (fn [x] (str x \"o\")) \"y\")) (\"y\" \"yo\" \"yoo\" \"yooo\" \"yoooo\") iterate is extremely handy for working with infinite sequences, and has some partners in crime. repeat, for instance, constructs a sequence where every element is the same. user=> (take 10 (repeat :hi)) (:hi :hi :hi :hi :hi :hi :hi :hi :hi :hi) user=> (repeat 3 :echo) (:echo :echo :echo) And its close relative repeatedly simply calls a function (f) to generate an infinite sequence of values, over and over again, without any relationship between elements. For an infinite sequence of random numbers: user=> (rand) 0.9002678382322784 user=> (rand) 0.12375594203332863 user=> (take 3 (repeatedly rand)) (0.44442397843046755 0.33668691162169784 0.18244875487846746) Notice that calling (rand) returns a different number each time. We say that rand is an impure function, because it cannot simply be replaced by the same value every time. It does something different each time it\u2019s called. There\u2019s another very handy sequence function specifically for numbers: range, which generates a sequence of numbers between two points. (range n) gives n successive integers starting at 0. (range n m) returns integers from n to m-1. (range n m step) returns integers from n to m, but separated by step. user=> (range 5) (0 1 2 3 4) user=> (range 2 10) (2 3 4 5 6 7 8 9) user=> (range 0 100 5) (0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95) To extend a sequence by repeating it forever, use cycle: user=> (take 10 (cycle [1 2 3])) (1 2 3 1 2 3 1 2 3 1) Transforming sequences Given a sequence, we often want to find a related sequence. map, for instance, applies a function to each element\u2013but has a few more tricks up its sleeve. user=> (map (fn [n vehicle] (str \"I've got \" n \" \" vehicle \"s\")) [0 200 9] [\"car\" \"train\" \"kiteboard\"]) (\"I've got 0 cars\" \"I've got 200 trains\" \"I've got 9 kiteboards\") If given multiple sequences, map calls its function with one element from each sequence in turn. So the first value will be (f 0 \"car\"), the second (f 200 \"train\"), and so on. Like a zipper, map folds together corresponding elements from multiple collections. To sum three vectors, column-wise: user=> (map + [1 2 3] [4 5 6] [7 8 9]) (12 15 18) If one sequence is bigger than another, map stops at the end of the smaller one. We can exploit this to combine finite and infinite sequences. For example, to number the elements in a vector: user=> (map (fn [index element] (str index \". \" element)) (iterate inc 0) [\"erlang\" \"ruby\" \"haskell\"]) (\"0. erlang\" \"1. ruby\" \"2. haskell\") Transforming elements together with their indices is so common that Clojure has a special function for it: map-indexed: user=> (map-indexed (fn [index element] (str index \". \" element)) [\"erlang\" \"ruby\" \"haskell\"]) (\"0. erlang\" \"1. ruby\" \"2. haskell\") You can also tack one sequence onto the end of another, like so: user=> (concat [1 2 3] [:a :b :c] [4 5 6]) (1 2 3 :a :b :c 4 5 6) Another way to combine two sequences is to riffle them together, using interleave. user=> (interleave [:a :b :c] [1 2 3]) (:a 1 :b 2 :c 3) And if you want to insert a specific element between each successive pair in a sequence, try interpose: user=> (interpose :and [1 2 3 4]) (1 :and 2 :and 3 :and 4) To reverse a sequence, use reverse. user=> (reverse [1 2 3]) (3 2 1) user=> (reverse \"woolf\") (\\f \\l \\o \\o \\w) Strings are sequences too! Each element of a string is a character, written \\f. You can rejoin those characters into a string with apply str: user=> (apply str (reverse \"woolf\")) \"floow\" \u2026and break strings up into sequences of chars with seq. user=> (seq \"sato\") (\\s \\a \\t \\o) To randomize the order of a sequence, use shuffle. user=> (shuffle [1 2 3 4]) [3 1 2 4] user=> (apply str (shuffle (seq \"abracadabra\"))) \"acaadabrrab\" Subsequences We\u2019ve already seen take, which selects the first n elements. There\u2019s also drop, which removes the first n elements. user=> (range 10) (0 1 2 3 4 5 6 7 8 9) user=> (take 3 (range 10)) (0 1 2) user=> (drop 3 (range 10)) (3 4 5 6 7 8 9) And for slicing apart the other end of the sequence, we have take-last and drop-last: user=> (take-last 3 (range 10)) (7 8 9) user=> (drop-last 3 (range 10)) (0 1 2 3 4 5 6) take-while and drop-while work just like take and drop, but use a function to decide when to cut. user=> (take-while pos? [3 2 1 0 -1 -2 10]) (3 2 1) In general, one can cut a sequence in twain by using split-at, and giving it a particular index. There\u2019s also split-with, which uses a function to decide when to cut. (split-at 4 (range 10)) [(0 1 2 3) (4 5 6 7 8 9)] user=> (split-with number? [1 2 3 :mark 4 5 6 :mark 7]) [(1 2 3) (:mark 4 5 6 :mark 7)] Notice that because indexes start at zero, sequence functions tend to have predictable numbers of elements. (split-at 4) yields four elements in the first collection, and ensures the second collection begins at index four. (range 10) has ten elements, corresponding to the first ten indices in a sequence. (range 3 5) has two (since 5 - 3 is two) elements. These choices simplify the definition of recursive functions as well. We can select particular elements from a sequence by applying a function. To find all positive numbers in a list, use filter: user=> (filter pos? [1 5 -4 -7 3 0]) (1 5 3) filter looks at each element in turn, and includes it in the resulting sequence only if (f element) returns a truthy value. Its complement is remove, which only includes those elements where (f element) is false or nil. user=> (remove string? [1 \"turing\" :apple]) (1 :apple) Finally, one can group a sequence into chunks using partition, partition-all, or partition-by. For instance, one might group alternating values into pairs: user=> (partition 2 [:cats 5 :bats 27 :crocodiles 0]) ((:cats 5) (:bats 27) (:crocodiles 0)) Or separate a series of numbers into negative and positive runs: (user=> (partition-by neg? [1 2 3 2 1 -1 -2 -3 -2 -1 1 2]) ((1 2 3 2 1) (-1 -2 -3 -2 -1) (1 2)) Collapsing sequences After transforming a sequence, we often want to collapse it in some way; to derive some smaller value. For instance, we might want the number of times each element appears in a sequence: user=> (frequencies [:meow :mrrrow :meow :meow]) {:meow 3, :mrrrow 1} Or to group elements by some function: user=> (pprint (group-by :first [{:first \"Li\" :last \"Zhou\"} {:first \"Sarah\" :last \"Lee\"} {:first \"Sarah\" :last \"Dunn\"} {:first \"Li\" :last \"O'Toole\"}])) {\"Li\" [{:last \"Zhou\", :first \"Li\"} {:last \"O'Toole\", :first \"Li\"}], \"Sarah\" [{:last \"Lee\", :first \"Sarah\"} {:last \"Dunn\", :first \"Sarah\"}]} Here we\u2019ve taken a sequence of people with first and last names, and used the :first keyword (which can act as a function!) to look up those first names. group-by used that function to produce a map of first names to lists of people\u2013kind of like an index. In general, we want to combine elements together in some way, using a function. Where map treated each element independently, reducing a sequence requires that we bring some information along. The most general way to collapse a sequence is reduce.","title":"user=&gt; (doc if)"},{"location":"reference/sequences/#user-doc-reduce","text":"clojure.core/reduce ([f coll] [f val coll]) f should be a function of 2 arguments. If val is not supplied, returns the result of applying f to the first 2 items in coll, then applying f to that result and the 3rd item, etc. If coll contains no items, f must accept no arguments as well, and reduce returns the result of calling f with no arguments. If coll has only 1 item, it is returned and f is not called. If val is supplied, returns the result of applying f to val and the first item in coll, then applying f to that result and the 2nd item, etc. If coll contains no items, returns val and f is not called. That\u2019s a little complicated, so we\u2019ll start small. We need a function, f, which combines successive elements of the sequence. (f state element) will return the state for the next invocation of f. As f moves along the sequence, it carries some changing state with it. The final state is the return value of reduce. user=> (reduce + [1 2 3 4]) 10 reduce begins by calling (+ 1 2), which yields the state 3. Then it calls (+ 3 3), which yields 6. Then (+ 6 4), which returns 10. We\u2019ve taken a function over two elements, and used it to combine all the elements. Mathematically, we could write: 1 + 2 + 3 + 4 3 + 3 + 4 6 + 4 10 So another way to look at reduce is like sticking a function between each pair of elements. To see the reducing process in action, we can use reductions, which returns a sequence of all the intermediate states. user=> (reductions + [1 2 3 4]) (1 3 6 10) Oftentimes we include a default state to start with. For instance, we could start with an empty set, and add each element to it as we go along: user=> (reduce conj #{} [:a :b :b :b :a :a])","title":"user=&gt; (doc reduce)"},{"location":"reference/sequences/#a-b","text":"Reducing elements into a collection has its own name: into. We can conj [key value] vectors into a map, for instance, or build up a list: user=> (into {} [[:a 2] [:b 3]]) {:a 2, :b 3} user=> (into (list) [1 2 3 4]) (4 3 2 1) Because elements added to a list appear at the beginning, not the end, this expression reverses the sequence. Vectors conj onto the end, so to emit the elements in order, using reduce, we might try: user=> (reduce conj [] [1 2 3 4 5]) (reduce conj [] [1 2 3 4 5]) [1 2 3 4 5] Which brings up an interesting thought: this looks an awful lot like map. All that\u2019s missing is some kind of transformation applied to each element. (defn my-map [f coll] (reduce (fn [output element] (conj output (f element))) [] coll)) user=> (my-map inc [1 2 3 4]) [2 3 4 5] Huh. map is just a special kind of reduce. What about, say, take-while? (defn my-take-while [f coll] (reduce (fn [out elem] (if (f elem) (conj out elem) (reduced out))) [] coll)) We\u2019re using a special function here, reduced, to indicate that we\u2019ve completed our reduction early and can skip the rest of the sequence. user=> (my-take-while pos? [2 1 0 -1 0 1 2]) [2 1] reduce really is the uber function over sequences. Almost any operation on a sequence can be expressed in terms of a reduce\u2013though for various reasons, many of the Clojure sequence functions are not written this way. For instance, take-while is actually defined like so: user=> (source take-while) (defn take-while \"Returns a lazy sequence of successive items from coll while (pred item) returns true. pred must be free of side-effects.\" {:added \"1.0\" :static true} [pred coll] (lazy-seq (when-let [s (seq coll)] (when (pred (first s)) (cons (first s) (take-while pred (rest s))))))) There\u2019s a few new pieces here, but the structure is essentially the same as our initial attempt at writing map. When the predicate matches the first element, cons the first element onto take-while, applied to the rest of the sequence. That lazy-seq construct allows Clojure to compute this sequence as required, instead of right away. It defers execution to a later time. Most of Clojure\u2019s sequence functions are lazy. They don\u2019t do anything until needed. For instance, we can increment every number from zero to infinity: user=> (def infinite-sequence (map inc (iterate inc 0)))","title":"{:a :b}"},{"location":"reference/sequences/#userinfinite-sequence","text":"user=> (realized? infinite-sequence) false That function returned immediately. Because it hasn\u2019t done any work yet, we say the sequence is unrealized. It doesn\u2019t increment any numbers at all until we ask for them: user=> (take 10 infinite-sequence) (1 2 3 4 5 6 7 8 9 10) user=> (realized? infinite-sequence) true Lazy sequences also remember their contents, once evaluated, for faster access. Putting it all together We\u2019ve seen how recursion generalizes a function over one thing into a function over many things, and discovered a rich landscape of recursive functions over sequences. Now let\u2019s use our knowledge of sequences to solve a more complex problem: find the sum of the products of consecutive pairs of the first 1000 odd integers. First, we\u2019ll need the integers. We can start with 0, and work our way up to infinity. To save time printing an infinite number of integers, we\u2019ll start with just the first 10. user=> (take 10 (iterate inc 0)) (0 1 2 3 4 5 6 7 8 9) Now we need to find only the ones which are odd. Remember, filter pares down a sequence to only those elements which pass a test. user=> (take 10 (filter odd? (iterate inc 0))) (1 3 5 7 9 11 13 15 17 19) For consecutive pairs, we want to take [1 3 5 7 ...] and find a sequence like ([1 3] [3 5] [5 7] ...). That sounds like a job for partition: user=> (take 3 (partition 2 (filter odd? (iterate inc 0)))) ((1 3) (5 7) (9 11)) Not quite right\u2013this gave us non-overlapping pairs, but we wanted overlapping ones too. A quick check of (doc partition) reveals the step parameter: user=> (take 3 (partition 2 1 (filter odd? (iterate inc 0)))) ((1 3) (3 5) (5 7)) Now we need to find the product for each pair. Given a pair, multiply the two pieces together\u2026 yes, that sounds like map: user=> (take 3 (map (fn [pair] (* (first pair) (second pair))) (partition 2 1 (filter odd? (iterate inc 0))))) (3 15 35) Getting a bit unwieldy, isn\u2019t it? Only one final step: sum all those products. We\u2019ll adjust the take to include the first 1000, not the first 3, elements. user=> (reduce + (take 1000 (map (fn [pair] (* (first pair) (second pair))) (partition 2 1 (filter odd? (iterate inc 0))))) 1335333000 The sum of the first thousand products of consecutive pairs of the odd integers starting at 0. See how each part leads to the next? This expression looks a lot like the way we phrased the problem in English\u2013but both English and Lisp expressions are sort of backwards, in a way. The part that happens first appears deepest, last, in the expression. In a chain of reasoning like this, it\u2019d be nicer to write it in order. user=> (->> 0 (iterate inc) (filter odd?) (partition 2 1) (map (fn [pair] (* (first pair) (second pair)))) (take 1000) (reduce +)) 1335333000 Much easier to read: now everything flows in order, from top to bottom, and we\u2019ve flattened out the deeply nested expressions into a single level. This is how object-oriented languages structure their expressions: as a chain of function invocations, each acting on the previous value. But how is this possible? Which expression gets evaluated first? (take 1000) isn\u2019t even a valid call\u2013where\u2019s its second argument? How are any of these forms evaluated? What kind of arcane function is ->>? All these mysteries, and more, in Chapter 5: Macros. Problems Write a function to find out if a string is a palindrome\u2013that is, if it looks the same forwards and backwards. Find the number of \u2018c\u2019s in \u201cabracadabra\u201d. Write your own version of filter. Find the first 100 prime numbers: 2, 3, 5, 7, 11, 13, 17, \u2026.","title":"'user/infinite-sequence"},{"location":"reference/threading-macros/","text":"Reference: Threading macros \u03bb\ufe0e Using the threading macro, the result of every function is passed onto the next function in the list. This can be seen very clearly using ,,, to denote where the value is passed to the next function ( -> \"project.clj\" slurp ,,, read-string ,,, ( nth ,,, 2 )) Hint::Commas in clojure are whitespace \u03bb\ufe0e Commas are simply ignored when the Clojure Reader parses code. Commas are rarely used and only to help human readability of the code To make this really simple lets create a contrived example of the threading macro. Here we use the str function to join strings together. Each individual str function joins its own strings together, passing the resulting string as the first argument to the next function. ( -> ( str \"This\" \" \" \"is\" \" \" ) ( str \"the\" \" \" \"threading\" \" \" \"macro\" ) ( str \"in\" \" \" \"action.\" )) Output ;; => \"This is the threading macro in action\" Thread-last macro \u03bb\ufe0e Using the thread-last macro, ->> , the result of a function is passed as the last argument of the next function call. So in another simple series of str function calls, our text comes out backwards. (->> \" this\" (str \" is\") (str \" backwards\"))","title":"Reference: Threading macros"},{"location":"reference/threading-macros/#reference-threading-macros","text":"Using the threading macro, the result of every function is passed onto the next function in the list. This can be seen very clearly using ,,, to denote where the value is passed to the next function ( -> \"project.clj\" slurp ,,, read-string ,,, ( nth ,,, 2 ))","title":"Reference: Threading macros"},{"location":"reference/threading-macros/#hintcommas-in-clojure-are-whitespace","text":"Commas are simply ignored when the Clojure Reader parses code. Commas are rarely used and only to help human readability of the code To make this really simple lets create a contrived example of the threading macro. Here we use the str function to join strings together. Each individual str function joins its own strings together, passing the resulting string as the first argument to the next function. ( -> ( str \"This\" \" \" \"is\" \" \" ) ( str \"the\" \" \" \"threading\" \" \" \"macro\" ) ( str \"in\" \" \" \"action.\" )) Output ;; => \"This is the threading macro in action\"","title":"Hint::Commas in clojure are whitespace"},{"location":"reference/threading-macros/#thread-last-macro","text":"Using the thread-last macro, ->> , the result of a function is passed as the last argument of the next function call. So in another simple series of str function calls, our text comes out backwards. (->> \" this\" (str \" is\") (str \" backwards\"))","title":"Thread-last macro"},{"location":"reference/clojure-cli/","text":"Reference: Clojure CLI \u03bb\ufe0e A reference on using Clojure CLI and using community tools effectively. structure of the deps.edn configuration execution options Java Virtual Machine options defining custom aliases common aliases from practicalli/clojure-deps-edn project","title":"Reference: Clojure CLI"},{"location":"reference/clojure-cli/#reference-clojure-cli","text":"A reference on using Clojure CLI and using community tools effectively. structure of the deps.edn configuration execution options Java Virtual Machine options defining custom aliases common aliases from practicalli/clojure-deps-edn project","title":"Reference: Clojure CLI"},{"location":"reference/clojure-cli/defining-aliases/","text":"Clojure CLI: Defining aliases \u03bb\ufe0e Clojure CLI tools provide a very flexible way to run Clojure, using aliases to include community libraries and tools to enhance clojure projects and provide independent tools. Understand the execution options (exec-opts) on the command line options ensures an effective use of Clojure CLI tools. Aliases are used to add (or remove) configuration from the Aliases are used with Clojure tools to provide additional configuration when explicitly added to the clojure command. Aliases can be used to modify: the classpath and dependencies included, by adding or removing dependencies and paths providing a simple way to configure community tools, such as rebel readline, clj-new, depstar, etc. Aliases can be defined in a project deps.edn or be available to all projects via the ~/.clojure/deps.edn configuration file. Hint::practicalli/clojure-deps-edn user level aliases and tools \u03bb\ufe0e practicalli/clojure-deps-edn is a configuration designed to work across all Clojure projects, containing unique and meaningful alias names for ease of understanding. Clojure CLI tool options \u03bb\ufe0e Clojure CLI tool has several options that determine how aliases and other configuration is used add or remove dependencies add or remove directories on the class path define a function or main namespace to run, along with arguments Clojure CLI main flag options \u03bb\ufe0e Flag Purpose -A add paths and dependencies when running a REPL (do not include :main-opts in alias) -M Run -main function from a specified namespace with clojure.main -P Prepare / dry run (CI servers, Containers) -X Execute a qualified function, optional default arguments -T Install / Run a tool by name (or use alias) -J Java Virtual Machine specific options (memory size, etc) deps = :deps , :extra-deps , replace-deps path = :path , :extra-paths , replace-paths -A to configure paths and dependencies when running the Clojure CLI tools REPL -M using clojure.main to run the -main function of a Clojure project or tool, using the -m flag to specify the namespace containing -main (clojure.main has other features too) -X for running any fully qualified function from a Clojure project or tool -P a dry run, downloading all dependencies (must use flag in first position) -T running a tool separate from a Clojure project (class path) Using an alias \u03bb\ufe0e An alias is used via the -M option to the clojure command: clojure -M :qualified/alias-name Multiple aliases can be used together clojure -M :env/test:test/runner Hint::Only one main namespace \u03bb\ufe0e If multiple aliases set a main namespace, only the last alias in the chain has its main namespace called, e.g. clojure -M:middleware/cider-nrepl:inspect/cognitect-rebl:middleware/nrebl will call the main namespace of :middleware/nrebl . An alias for a community tool \u03bb\ufe0e Use the rebel community tool by including its alias. clojure -M :repl/rebel This alias adds the library dependency for the rebel readline project and defines the main namespace. The namespace is where the -main function is located that will start rebel readline. { :aliases :rebel { :extra-deps { com.bhauman/rebel-readline { :mvn/version \"0.1.4\" }} :main-opts [ \"-m\" \"rebel-readline.main\" ]} } ;; End of aliases Including paths, deps and main-opts \u03bb\ufe0e The Cognitect Lab test runner included the test directory in the class path, so test code will be included when run with this alias. The test runner dependency is pulled from a specific commit shared on GitHub (defined as a Git SHA). The main namespace is set to that library and the -main function is called when using this alias. { :aliases :test-runner/cognitect { :extra-paths [ \"test\" ] :extra-deps { com.cognitect/test-runner { :git/url \"https://github.com/cognitect-labs/test-runner.git\" :sha \"f7ef16dc3b8332b0d77bc0274578ad5270fbfedd\" }} :main-opts [ \"-m\" \"cognitect.test-runner\" ]} } Stand-alone tools \u03bb\ufe0e When a community tool does not require any of the project paths or dependencies to operate, :replace-paths and :replace-deps should be used when defining an alias. These configurations only used paths and dependencies defined within the alias itself, minimizing the resources used to run the tool, improving the speed of using these tools. :project/new { :replace-deps { seancorfield/clj-new { :mvn/version \"1.1.226\" }} :main-opts [ \"-m\" \"clj-new.create\" ]} Clojure Exec \u03bb\ufe0e With Clojure CLI tools version 1.10.1.697 the -X flag was introduced using aliases with Clojure exec . The configuration should define a fully qualified function that runs the tool. The function should take arguments as key/value pairs as with an Edn hash-map, rather than relying on positional arguments as strings. In this example, :exec-fn defines the fully qualified function name that will be called. :exec-args is a hash-map of the default key values pairs that are passed to the function as an argument. :project/new { :replace-deps { seancorfield/clj-new { :mvn/version \"1.1.23\" }} :main-opts [ \"-m\" \"clj-new.create\" ] ;; deprecated :exec-fn clj-new/create :exec-args { :template lib :name practicalli/playground } } Default arguments can be over-ridden in the command, e.g. clojure -X:project/new :template app :name practicalli/simple-application uses a different template Additional arguments can be sent when running the command, e.g. clojure -X:project/new :template figwheel-main :name practicalli/landing-page :args '[\"--reagent\"]' uses the figwheel-main template, specifies a name and :args arguments sent to :ns-default can also be used to qualify the function that will be executed in an alias. :ns-default is especially useful when there are several functions that could be called from the specific namespace. The command line can over-ride the :exec-fn function configuration, allowing for a default configuration that can be easily over-ridden. :project/new { :replace-deps { seancorfield/clj-new { :mvn/version \"1.1.226\" }} :main-opts [ \"-m\" \"clj-new.create\" ] ;; deprecated :ns-default clj-new :exec-fn create :exec-args { :template lib :name practicalli/playground } } Hint::Keyword naming \u03bb\ufe0e Any legal Clojure keyword name can be used for an alias. Multiple aliases can be chained together with the clojure command. For example in this command we are combining three aliases: clojure -M:task/path:task/deps:build/options Resources \u03bb\ufe0e clj-exec - insideclojure.org clj-exec update - insideclojure.org","title":"Clojure CLI: Defining aliases"},{"location":"reference/clojure-cli/defining-aliases/#clojure-cli-defining-aliases","text":"Clojure CLI tools provide a very flexible way to run Clojure, using aliases to include community libraries and tools to enhance clojure projects and provide independent tools. Understand the execution options (exec-opts) on the command line options ensures an effective use of Clojure CLI tools. Aliases are used to add (or remove) configuration from the Aliases are used with Clojure tools to provide additional configuration when explicitly added to the clojure command. Aliases can be used to modify: the classpath and dependencies included, by adding or removing dependencies and paths providing a simple way to configure community tools, such as rebel readline, clj-new, depstar, etc. Aliases can be defined in a project deps.edn or be available to all projects via the ~/.clojure/deps.edn configuration file.","title":"Clojure CLI: Defining aliases"},{"location":"reference/clojure-cli/defining-aliases/#hintpracticalliclojure-deps-edn-user-level-aliases-and-tools","text":"practicalli/clojure-deps-edn is a configuration designed to work across all Clojure projects, containing unique and meaningful alias names for ease of understanding.","title":"Hint::practicalli/clojure-deps-edn user level aliases and tools"},{"location":"reference/clojure-cli/defining-aliases/#clojure-cli-tool-options","text":"Clojure CLI tool has several options that determine how aliases and other configuration is used add or remove dependencies add or remove directories on the class path define a function or main namespace to run, along with arguments","title":"Clojure CLI tool options"},{"location":"reference/clojure-cli/defining-aliases/#clojure-cli-main-flag-options","text":"Flag Purpose -A add paths and dependencies when running a REPL (do not include :main-opts in alias) -M Run -main function from a specified namespace with clojure.main -P Prepare / dry run (CI servers, Containers) -X Execute a qualified function, optional default arguments -T Install / Run a tool by name (or use alias) -J Java Virtual Machine specific options (memory size, etc) deps = :deps , :extra-deps , replace-deps path = :path , :extra-paths , replace-paths -A to configure paths and dependencies when running the Clojure CLI tools REPL -M using clojure.main to run the -main function of a Clojure project or tool, using the -m flag to specify the namespace containing -main (clojure.main has other features too) -X for running any fully qualified function from a Clojure project or tool -P a dry run, downloading all dependencies (must use flag in first position) -T running a tool separate from a Clojure project (class path)","title":"Clojure CLI main flag options"},{"location":"reference/clojure-cli/defining-aliases/#using-an-alias","text":"An alias is used via the -M option to the clojure command: clojure -M :qualified/alias-name Multiple aliases can be used together clojure -M :env/test:test/runner","title":"Using an alias"},{"location":"reference/clojure-cli/defining-aliases/#hintonly-one-main-namespace","text":"If multiple aliases set a main namespace, only the last alias in the chain has its main namespace called, e.g. clojure -M:middleware/cider-nrepl:inspect/cognitect-rebl:middleware/nrebl will call the main namespace of :middleware/nrebl .","title":"Hint::Only one main namespace"},{"location":"reference/clojure-cli/defining-aliases/#an-alias-for-a-community-tool","text":"Use the rebel community tool by including its alias. clojure -M :repl/rebel This alias adds the library dependency for the rebel readline project and defines the main namespace. The namespace is where the -main function is located that will start rebel readline. { :aliases :rebel { :extra-deps { com.bhauman/rebel-readline { :mvn/version \"0.1.4\" }} :main-opts [ \"-m\" \"rebel-readline.main\" ]} } ;; End of aliases","title":"An alias for a community tool"},{"location":"reference/clojure-cli/defining-aliases/#including-paths-deps-and-main-opts","text":"The Cognitect Lab test runner included the test directory in the class path, so test code will be included when run with this alias. The test runner dependency is pulled from a specific commit shared on GitHub (defined as a Git SHA). The main namespace is set to that library and the -main function is called when using this alias. { :aliases :test-runner/cognitect { :extra-paths [ \"test\" ] :extra-deps { com.cognitect/test-runner { :git/url \"https://github.com/cognitect-labs/test-runner.git\" :sha \"f7ef16dc3b8332b0d77bc0274578ad5270fbfedd\" }} :main-opts [ \"-m\" \"cognitect.test-runner\" ]} }","title":"Including paths, deps and main-opts"},{"location":"reference/clojure-cli/defining-aliases/#stand-alone-tools","text":"When a community tool does not require any of the project paths or dependencies to operate, :replace-paths and :replace-deps should be used when defining an alias. These configurations only used paths and dependencies defined within the alias itself, minimizing the resources used to run the tool, improving the speed of using these tools. :project/new { :replace-deps { seancorfield/clj-new { :mvn/version \"1.1.226\" }} :main-opts [ \"-m\" \"clj-new.create\" ]}","title":"Stand-alone tools"},{"location":"reference/clojure-cli/defining-aliases/#clojure-exec","text":"With Clojure CLI tools version 1.10.1.697 the -X flag was introduced using aliases with Clojure exec . The configuration should define a fully qualified function that runs the tool. The function should take arguments as key/value pairs as with an Edn hash-map, rather than relying on positional arguments as strings. In this example, :exec-fn defines the fully qualified function name that will be called. :exec-args is a hash-map of the default key values pairs that are passed to the function as an argument. :project/new { :replace-deps { seancorfield/clj-new { :mvn/version \"1.1.23\" }} :main-opts [ \"-m\" \"clj-new.create\" ] ;; deprecated :exec-fn clj-new/create :exec-args { :template lib :name practicalli/playground } } Default arguments can be over-ridden in the command, e.g. clojure -X:project/new :template app :name practicalli/simple-application uses a different template Additional arguments can be sent when running the command, e.g. clojure -X:project/new :template figwheel-main :name practicalli/landing-page :args '[\"--reagent\"]' uses the figwheel-main template, specifies a name and :args arguments sent to :ns-default can also be used to qualify the function that will be executed in an alias. :ns-default is especially useful when there are several functions that could be called from the specific namespace. The command line can over-ride the :exec-fn function configuration, allowing for a default configuration that can be easily over-ridden. :project/new { :replace-deps { seancorfield/clj-new { :mvn/version \"1.1.226\" }} :main-opts [ \"-m\" \"clj-new.create\" ] ;; deprecated :ns-default clj-new :exec-fn create :exec-args { :template lib :name practicalli/playground } }","title":"Clojure Exec"},{"location":"reference/clojure-cli/defining-aliases/#hintkeyword-naming","text":"Any legal Clojure keyword name can be used for an alias. Multiple aliases can be chained together with the clojure command. For example in this command we are combining three aliases: clojure -M:task/path:task/deps:build/options","title":"Hint::Keyword naming"},{"location":"reference/clojure-cli/defining-aliases/#resources","text":"clj-exec - insideclojure.org clj-exec update - insideclojure.org","title":"Resources"},{"location":"reference/clojure-cli/example-alias-definitions/","text":"Clojure Tools - Common alias definitions \u03bb\ufe0e Task: Run a simple terminal REPL \u03bb\ufe0e clojure and clj (requires rlwrap) will run a REPL if given no other arguments. Running either command from the root directory of a project will merge the deps.edn configuration with ~/.clojure/deps.edn . Task: Run a REPL with additional dependencies and paths \u03bb\ufe0e clojure -M:alias will run a repl if the alias does not contain a main namespace defined in :main-opts , e.g. :main-opts [\"-m\" \"namespace.main\"] . The deps and path values are included from the alias. If the following alias is defined in the project deps.edn file :env/dev { :extra-paths [ \"resources\" ] :extra-deps { com.h2database/h2 { :mvn/version \"1.4.200\" }}} clojure -M:env/dev will add resources directory to the path and the h2 database library to the dependencies, then runs a REPL. Including the -r option in the command line forces a REPL to run, even if a main namespace is provided via :main-opts or the command line. clojure -r -M :alias1:alias2 The dependencies and paths will be merged from the alias from left to right, with each successive alias over-riding the value of any matching keys in the dependencies. Task: Create a new project from template \u03bb\ufe0e The clj-new community tool can be used to create a Clojure / ClojureScript project, using a template to provide a project structure and example source code and tests. Using the :main-opts approach, an alias for clj-new would be defined as follows :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.0.215\" }} :main-opts [ \"-m\" \"clj-new.create\" ]} The clj-new tool can be run using the -M flag, passing the template and project names as arguments. clojure -M:project/new template-name project-domain/application-name To create a project as an application (to be run via the command line) for the practicalli domain with the application called banking-on-clojure clojure -M:new app practicalli/banking-on-clojure The latest version of the clj-new project also supports using the -X flag and default arguments. Adding the :exec-fn to the clj-new alias, the -X flag can be used instead of the -M . Arguments are supplied as key/value pairs :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.1.215\" }} :exec-fn clj-new/create } Use this alias with the -X flag clojure -X:project/new :template template-name :name practicalli/banking-on-clojure Default values can be added using the :exec-args key to the alias :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.1.215\" }} :exec-fn clj-new.create :exec-args { :template lib :name practicalli/playground }} clojure -M:project/new :name practicalli/awesome-webapp will create a new project using the {:template lib :name practicalli/awesome-webapp} argument. Task: Executing a specific function \u03bb\ufe0e Clojure can run a specific function, useful for one off tasks or timed batch processing (via cron or similar tool) as well as complete applications. Arguments to the function are passed as a hash-map, defined in either an aliases :exec-args key or as key value pairs on the command line. Command line key value pairs are merged with the :exec-arg hash-map, replacing the values from the command line if there are matching keys. Scenarios clojure -X namespace/fn runs the function specified on the command line, passing an empty hash-map as an argument clojure -X:alias fn runs the function if the :ns-default is set to the namespace that contains the function, otherwise \"Unqualified function can't be resolved: fn-name\" error is returned. clojure -X:alias runs the function specified by :exec-fn in the alias. The function must include its namespace or have that namespace defined in :ns-default . If :exec-args is defined in the alias, its value is passed to the function, otherwise an empty hash-map is passed to the function as an argument. clojure -X:alias namespace/fn will run the function specified on the command line, over-riding :exec-fn if it is defined in the alias. :exec-args will be passed to the command line function if defined in the alias. Dependencies and paths will be used from the alias. Assumption: the command line namespace also overrides the :ns-default value if set. clojure -X:alias :key1 val1 :key2 val2 will execute the function defined in :exec-fn and pass it the key value pairs from the command line as a hash map. If the alias has :exec-args defined, command line args are merged into the :exec-fn hash-map, replacing the default values in :exec-args where keys match. Assuming there is an alias called database/migrate defined in the project deps.edn :database/migrate { :exec-fn practicalli.banking-on-clojure.database/migrate :exec-args { :db-type \"h2\" :database \"banking-on-clojure\" }} clojure -X:database/migrate :database \"specs-repository\" would merge the command line args with :exec-args to create the hash-map {:db-type \"h2\" :database \"specs-repository\"} which is passed to the practicalli.banking-on-clojure.database/migrate function as an argument. Task: Executing a range of functions \u03bb\ufe0e :ns-default in an alias defines the namespace that contains the functions that could be executed. { :aliases { :project/run { :ns-default practicalli/banking-on-clojure }}} Specific functions from the namespace can be called via the command line clojure -X:project/run migrate-db :db-type h2 :database banking-on-clojure clojure -X:project/run server-start :port 8080 Task: Dry Run or Prepare for CI / Containers \u03bb\ufe0e clojure -P will download the libraries defined in :deps in the project deps.edn and do nothing else. Standard out shows downloading of dependencies not already cached locally, including name and versions and repository downloaded from. Hint::Qualified namespaces required \u03bb\ufe0e If an unqualified library name is used, e.g. compojure , then a warning is sent to the standard out. Change the name of the library to be fully qualified e.g. weavejester/compojure In a future version of the Clojure CLI tools unqualified namespaces will not be downloaded. The -P flag can be used to modify an existing command to ensure no execution takes place, ensuring a prepare only (dry run) action. clojure -P -M:alias-name downloads the dependencies for the specific aliases and multiple aliases can be chained together, e.g. clojure -P -M:env/dev:test-runner/kaocha The -P flag uses everything from an alias not related to execution. The classic way to download deps was to run clojure -A:aliases -Spath , where -Spath prevented execution of repl or main. Run a Clojure application \u03bb\ufe0e clojure -m full.namespace.to.dash-main calls the -main function from the given namespace. Arguments to the function are simply added to the end of the command line and passed to the -main function in the given namespace. The -m flag in the CLI tools pre-release returns a warning that -M should be used. Using -M and -m works, but seems redundant. Using -M by itself runs the REPL. clojure -M -m full.namespace.to.dash-main -M seems useful when including an alias with extra configuration (eg. :extra-deps , :extra-paths , :main-opts ). As :main-opts is no different to the -m option, creating an alias just to avoid the warning seems excessive. Task: Executing a project - using Edn style args \u03bb\ufe0e Clojure CLI tools is encouraging a move to functions that take a hash-map for their arguments. Passing arguments in as an edn data structure has more rigor than options and strings on the command line. The simplest form is to define an alias to run the project, specifying just the function to execute using :exec-fn :aliases { :project/run { :exec-fn practicalli.banking-on-clojure/server-start } } ;; End of Aliases Then the project can be run using this alias. clojure -X:project/run Arguments can be passed to the function as key/value pairs on the command line. clojure -X:project/run :port 8080 :host \"localhost\" :exec-args provides a way to define default arguments for the function, regardless of if it is defined in ;:exec-fn or passed via the command line. :exec-args defines a hash-map of arguments so the function must support taking a hash-map as an argument. A function may take variable args, especially if it is supporting both hash-maps and strings as options. :aliases { :project/run { :exec-fn fully.qualified/namespace :exec-args { :default \"arguments\" :can-be-over-ridden-by \"command-line-args\" } } } ;; End of Aliases Adding :exec-args to the :run-project :aliases { :project/run { :exec-fn practicalli.banking-on-clojure/server-start :exec-args { :port 8888 :host \"localhost\" }} } ;; End of Aliases Example of running a Clojure project - hello-world \u03bb\ufe0e In this example I use the hello-world example from https://clojure.org/guides/deps_and_cli#_writing_a_program A project deps.edn file was created containing the dependency for clojure.java-time and the source code from that page copied into src/hello.clj clojure -m hello runs the project and returns the time from running the -main function. However this gives a warning: WARNING: When invoking clojure.main, use -M clojure -M runs a REPL clojure -M -m hello runs the project and returns the time. But then I ask myself what is the purpose of -M Creating an alias to run the project seems an interesting idea, as I could also set default arguments. Adding an :project-run alias to the project deps.edn works when calling with clojure -M:project-run :aliases { :project-run { :main-opts [ \"-m\" \"hello\" ]}} Changing the :project-run alias to use :exec-fn and a fully qualified function (-main by default) should work when calling with clojure -X:project-run . :aliases {:run-project {:exec-fn hello]}} However, the hello-world project has an unqualified function and cannot be resolved. Moving the source code to src/practicalli/hello.clj and calling clojure -X:run-project gives an execution error, (ArityException) as the -main function does not take any arguments, (defn -main [] ,,,) . Changing the -main function to (defn -main [& args] ,,,) fixes the arity exception and calling clojure -X:run-project works. Local Maven install \u03bb\ufe0e Install a jar into the local Maven cache, typically ~/.m2/repository/ directory, organised by groupId clojure -M :deps mvn-install :jar ' \"/path/to.jar\" ' edn strings must be in double quotes, and then single-quoted for the shell mvn-install uses the .pom file contained in the jar (if it exists) to determine the groupId , artifactId , and version coordinates to use when the jar is installed. The .pom file can also be specified using the :pom argument. The install argmap takes the following options: key Required Description :jar required path to the jar file to install :pom optional path to .pom file (if .jar file does not contain .pom) :lib optional qualified symbol e.g my.org/lib :version optional Version number of library (string type) :classifier optional (string type) :local-repo optional path to local repo (default = ~/.m2/repository) mvn-install - define default configuration - using in templates for example Rather than pass details via the command line, use an alias to pass in default arguments. This is especially useful when the project deps.edn is generated from a template. TODO: Is it possible to define :exec-args with the built-in -X:deps mvn-install command? An alias can be defined in the project deps.edn file including default arguments via :exec-args { :aliases { :deploy/local-install { :exec-fn clojure.tools.deps.alpha.tools.install/install :exec-args { :jar \"./project-name.jar\" :pom \"./project-name.pom\" } }}} Install the jar using the default arguments using the command: clojure -X:deploy/local-install How it works clojure.tools.deps.alpha.tools.install/install is a function to install a jar into the local Maven cache, i.e. ~/.m2/repository . An alias called :deps is built into Clojure CLI tools and includes the tools.deps.alpha library on the classpath, :exec-args optionally includes a hash-map of key/values options that can also be passed on command line","title":"Clojure Tools - Common alias definitions"},{"location":"reference/clojure-cli/example-alias-definitions/#clojure-tools-common-alias-definitions","text":"","title":"Clojure Tools - Common alias definitions"},{"location":"reference/clojure-cli/example-alias-definitions/#task-run-a-simple-terminal-repl","text":"clojure and clj (requires rlwrap) will run a REPL if given no other arguments. Running either command from the root directory of a project will merge the deps.edn configuration with ~/.clojure/deps.edn .","title":"Task: Run a simple terminal REPL"},{"location":"reference/clojure-cli/example-alias-definitions/#task-run-a-repl-with-additional-dependencies-and-paths","text":"clojure -M:alias will run a repl if the alias does not contain a main namespace defined in :main-opts , e.g. :main-opts [\"-m\" \"namespace.main\"] . The deps and path values are included from the alias. If the following alias is defined in the project deps.edn file :env/dev { :extra-paths [ \"resources\" ] :extra-deps { com.h2database/h2 { :mvn/version \"1.4.200\" }}} clojure -M:env/dev will add resources directory to the path and the h2 database library to the dependencies, then runs a REPL. Including the -r option in the command line forces a REPL to run, even if a main namespace is provided via :main-opts or the command line. clojure -r -M :alias1:alias2 The dependencies and paths will be merged from the alias from left to right, with each successive alias over-riding the value of any matching keys in the dependencies.","title":"Task: Run a REPL with additional dependencies and paths"},{"location":"reference/clojure-cli/example-alias-definitions/#task-create-a-new-project-from-template","text":"The clj-new community tool can be used to create a Clojure / ClojureScript project, using a template to provide a project structure and example source code and tests. Using the :main-opts approach, an alias for clj-new would be defined as follows :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.0.215\" }} :main-opts [ \"-m\" \"clj-new.create\" ]} The clj-new tool can be run using the -M flag, passing the template and project names as arguments. clojure -M:project/new template-name project-domain/application-name To create a project as an application (to be run via the command line) for the practicalli domain with the application called banking-on-clojure clojure -M:new app practicalli/banking-on-clojure The latest version of the clj-new project also supports using the -X flag and default arguments. Adding the :exec-fn to the clj-new alias, the -X flag can be used instead of the -M . Arguments are supplied as key/value pairs :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.1.215\" }} :exec-fn clj-new/create } Use this alias with the -X flag clojure -X:project/new :template template-name :name practicalli/banking-on-clojure Default values can be added using the :exec-args key to the alias :project/new { :extra-deps { seancorfield/clj-new { :mvn/version \"1.1.215\" }} :exec-fn clj-new.create :exec-args { :template lib :name practicalli/playground }} clojure -M:project/new :name practicalli/awesome-webapp will create a new project using the {:template lib :name practicalli/awesome-webapp} argument.","title":"Task: Create a new project from template"},{"location":"reference/clojure-cli/example-alias-definitions/#task-executing-a-specific-function","text":"Clojure can run a specific function, useful for one off tasks or timed batch processing (via cron or similar tool) as well as complete applications. Arguments to the function are passed as a hash-map, defined in either an aliases :exec-args key or as key value pairs on the command line. Command line key value pairs are merged with the :exec-arg hash-map, replacing the values from the command line if there are matching keys. Scenarios clojure -X namespace/fn runs the function specified on the command line, passing an empty hash-map as an argument clojure -X:alias fn runs the function if the :ns-default is set to the namespace that contains the function, otherwise \"Unqualified function can't be resolved: fn-name\" error is returned. clojure -X:alias runs the function specified by :exec-fn in the alias. The function must include its namespace or have that namespace defined in :ns-default . If :exec-args is defined in the alias, its value is passed to the function, otherwise an empty hash-map is passed to the function as an argument. clojure -X:alias namespace/fn will run the function specified on the command line, over-riding :exec-fn if it is defined in the alias. :exec-args will be passed to the command line function if defined in the alias. Dependencies and paths will be used from the alias. Assumption: the command line namespace also overrides the :ns-default value if set. clojure -X:alias :key1 val1 :key2 val2 will execute the function defined in :exec-fn and pass it the key value pairs from the command line as a hash map. If the alias has :exec-args defined, command line args are merged into the :exec-fn hash-map, replacing the default values in :exec-args where keys match. Assuming there is an alias called database/migrate defined in the project deps.edn :database/migrate { :exec-fn practicalli.banking-on-clojure.database/migrate :exec-args { :db-type \"h2\" :database \"banking-on-clojure\" }} clojure -X:database/migrate :database \"specs-repository\" would merge the command line args with :exec-args to create the hash-map {:db-type \"h2\" :database \"specs-repository\"} which is passed to the practicalli.banking-on-clojure.database/migrate function as an argument.","title":"Task: Executing a specific function"},{"location":"reference/clojure-cli/example-alias-definitions/#task-executing-a-range-of-functions","text":":ns-default in an alias defines the namespace that contains the functions that could be executed. { :aliases { :project/run { :ns-default practicalli/banking-on-clojure }}} Specific functions from the namespace can be called via the command line clojure -X:project/run migrate-db :db-type h2 :database banking-on-clojure clojure -X:project/run server-start :port 8080","title":"Task: Executing a range of functions"},{"location":"reference/clojure-cli/example-alias-definitions/#task-dry-run-or-prepare-for-ci-containers","text":"clojure -P will download the libraries defined in :deps in the project deps.edn and do nothing else. Standard out shows downloading of dependencies not already cached locally, including name and versions and repository downloaded from.","title":"Task: Dry Run or Prepare for CI / Containers"},{"location":"reference/clojure-cli/example-alias-definitions/#hintqualified-namespaces-required","text":"If an unqualified library name is used, e.g. compojure , then a warning is sent to the standard out. Change the name of the library to be fully qualified e.g. weavejester/compojure In a future version of the Clojure CLI tools unqualified namespaces will not be downloaded. The -P flag can be used to modify an existing command to ensure no execution takes place, ensuring a prepare only (dry run) action. clojure -P -M:alias-name downloads the dependencies for the specific aliases and multiple aliases can be chained together, e.g. clojure -P -M:env/dev:test-runner/kaocha The -P flag uses everything from an alias not related to execution. The classic way to download deps was to run clojure -A:aliases -Spath , where -Spath prevented execution of repl or main.","title":"Hint::Qualified namespaces required"},{"location":"reference/clojure-cli/example-alias-definitions/#run-a-clojure-application","text":"clojure -m full.namespace.to.dash-main calls the -main function from the given namespace. Arguments to the function are simply added to the end of the command line and passed to the -main function in the given namespace. The -m flag in the CLI tools pre-release returns a warning that -M should be used. Using -M and -m works, but seems redundant. Using -M by itself runs the REPL. clojure -M -m full.namespace.to.dash-main -M seems useful when including an alias with extra configuration (eg. :extra-deps , :extra-paths , :main-opts ). As :main-opts is no different to the -m option, creating an alias just to avoid the warning seems excessive.","title":"Run a Clojure application"},{"location":"reference/clojure-cli/example-alias-definitions/#task-executing-a-project-using-edn-style-args","text":"Clojure CLI tools is encouraging a move to functions that take a hash-map for their arguments. Passing arguments in as an edn data structure has more rigor than options and strings on the command line. The simplest form is to define an alias to run the project, specifying just the function to execute using :exec-fn :aliases { :project/run { :exec-fn practicalli.banking-on-clojure/server-start } } ;; End of Aliases Then the project can be run using this alias. clojure -X:project/run Arguments can be passed to the function as key/value pairs on the command line. clojure -X:project/run :port 8080 :host \"localhost\" :exec-args provides a way to define default arguments for the function, regardless of if it is defined in ;:exec-fn or passed via the command line. :exec-args defines a hash-map of arguments so the function must support taking a hash-map as an argument. A function may take variable args, especially if it is supporting both hash-maps and strings as options. :aliases { :project/run { :exec-fn fully.qualified/namespace :exec-args { :default \"arguments\" :can-be-over-ridden-by \"command-line-args\" } } } ;; End of Aliases Adding :exec-args to the :run-project :aliases { :project/run { :exec-fn practicalli.banking-on-clojure/server-start :exec-args { :port 8888 :host \"localhost\" }} } ;; End of Aliases","title":"Task: Executing a project - using Edn style args"},{"location":"reference/clojure-cli/example-alias-definitions/#example-of-running-a-clojure-project-hello-world","text":"In this example I use the hello-world example from https://clojure.org/guides/deps_and_cli#_writing_a_program A project deps.edn file was created containing the dependency for clojure.java-time and the source code from that page copied into src/hello.clj clojure -m hello runs the project and returns the time from running the -main function. However this gives a warning: WARNING: When invoking clojure.main, use -M clojure -M runs a REPL clojure -M -m hello runs the project and returns the time. But then I ask myself what is the purpose of -M Creating an alias to run the project seems an interesting idea, as I could also set default arguments. Adding an :project-run alias to the project deps.edn works when calling with clojure -M:project-run :aliases { :project-run { :main-opts [ \"-m\" \"hello\" ]}} Changing the :project-run alias to use :exec-fn and a fully qualified function (-main by default) should work when calling with clojure -X:project-run . :aliases {:run-project {:exec-fn hello]}} However, the hello-world project has an unqualified function and cannot be resolved. Moving the source code to src/practicalli/hello.clj and calling clojure -X:run-project gives an execution error, (ArityException) as the -main function does not take any arguments, (defn -main [] ,,,) . Changing the -main function to (defn -main [& args] ,,,) fixes the arity exception and calling clojure -X:run-project works.","title":"Example of running a Clojure project - hello-world"},{"location":"reference/clojure-cli/example-alias-definitions/#local-maven-install","text":"Install a jar into the local Maven cache, typically ~/.m2/repository/ directory, organised by groupId clojure -M :deps mvn-install :jar ' \"/path/to.jar\" ' edn strings must be in double quotes, and then single-quoted for the shell mvn-install uses the .pom file contained in the jar (if it exists) to determine the groupId , artifactId , and version coordinates to use when the jar is installed. The .pom file can also be specified using the :pom argument. The install argmap takes the following options: key Required Description :jar required path to the jar file to install :pom optional path to .pom file (if .jar file does not contain .pom) :lib optional qualified symbol e.g my.org/lib :version optional Version number of library (string type) :classifier optional (string type) :local-repo optional path to local repo (default = ~/.m2/repository) mvn-install - define default configuration - using in templates for example Rather than pass details via the command line, use an alias to pass in default arguments. This is especially useful when the project deps.edn is generated from a template. TODO: Is it possible to define :exec-args with the built-in -X:deps mvn-install command? An alias can be defined in the project deps.edn file including default arguments via :exec-args { :aliases { :deploy/local-install { :exec-fn clojure.tools.deps.alpha.tools.install/install :exec-args { :jar \"./project-name.jar\" :pom \"./project-name.pom\" } }}} Install the jar using the default arguments using the command: clojure -X:deploy/local-install How it works clojure.tools.deps.alpha.tools.install/install is a function to install a jar into the local Maven cache, i.e. ~/.m2/repository . An alias called :deps is built into Clojure CLI tools and includes the tools.deps.alpha library on the classpath, :exec-args optionally includes a hash-map of key/values options that can also be passed on command line","title":"Local Maven install"},{"location":"reference/clojure-cli/jvm-options/","text":"Reference: Clojure CLI JVM Options \u03bb\ufe0e Hint:: JDK_JAVA_OPTIONS Environment Variable \u03bb\ufe0e JDK_JAVA_OPTIONS is the official Environment Variable for setting options when calling java , javac and other Java commands to start running a Java Virtual Machine (Java version 9 onward). Java Virtual Machine options can be passed using the Clojure CLI , either via the -J command line flag or :jvm-opts in a deps.edn alias. Hint::Java Virtual Machine configuration and reporting \u03bb\ufe0e Java Virtual Machine section covers commonly used options, reporting JVM metrics and optimisation of the JVM process. Clojure CLI command line options \u03bb\ufe0e Clojure CLI -J flag passes configuration options to the JVM. When there are multiple, each must be prefixed with -J . clojure -J-XX:+UnlockDiagnosticVMOptions -J\u2011XX:NativeMemoryTracking=summary -J\u2011XX:+PrintNMTStatistics Clojure CLI deps.edn configuration \u03bb\ufe0e :jvm-opts key in an alias adds JVM options to Clojure CLI deps.edn configuration. The :jvm-opts key has a value that is a collection of string JVM options [\"-Xms2048m\" \"-Xmx4096\"] Alias to set a large heap size :jvm/heap-max-2g { :jvm-opts [ \"-Xmx2G\" ]} Report a full breakdown of the HotSpot JVM\u2019s memory usage upon exit using the following option combination: :jvm/report { :jvm-opts [ \"-XX:+UnlockDiagnosticVMOptions\" \"\u2011XX:NativeMemoryTracking=summary\" \"\u2011XX:+PrintNMTStatistics\" ]} Add a Java module :jvm/xml-bind { :jvm-opts [ \"\u2013add-modules java.xml.bind\" ]} Ignoring unrecognised options :jvm-opts [ \"-XX:+IgnoreUnrecognizedVMOptions\" ] The aliases can be used with the Clojure CLI execution options: -A (for built-in REPL invocation), -X and -T (for clojure.exec function execution), or -M (for clojure.main execution). -J JVM options specified on the command line are concatenated after the alias options Calling A Clojure Uberjar \u03bb\ufe0e JVM options must be specified when calling an uberjar with the java command, :jvm-opts in the project deps.edn are not used with the java command java -jar project-uberjar.jar -J... Hint::Use JDK_JAVA_OPTIONS to define JVM options \u03bb\ufe0e JDK_JAVA_OPTIONS environment variable is used to define options that are used whenever the java command is called, greatly simplifying java commands. The JDK_JAVA_OPTIONS environment variable can be used with deployment systems and passed to container environments to simplify adjustment of resources used by the JVM process. Clojure related JVM options \u03bb\ufe0e Specify options or system properties to set up the Clojure service -Dclojure.compiler.disable-locals-clearing=true - make more info available to debuggers -Dclojure.main.report=stderr - print stack traces to standard error instead of saving to file, useful if process failing on startup -Dclojure.spec.skip-macros=false - skip spec checks against macro forms Memory Management \u03bb\ufe0e -XX:CompressedClassSpaceSize=3G - prevent a specific type of OOMs -XX:MaxJavaStackTraceDepth=1000000 - prevents trivial Stack Overflow errors -Xmx24G - set high maximum heap, preventing certain types of Out Of Memory errors (ideally high memory usage should be profiled if cause not known) -Xss6144k - increase stack size x6 to prevent Stack Overflow errors The current default can be found with java -XX:+PrintFlagsFinal -version 2>/dev/null | grep \"intx ThreadStackSize\" -Xms6G - Set minimum memory that is equal or greater than memory used by a running REPL, to improve performance -Xmx1G - limit maximum heap allocation so a process can never use more memory, useful for environments with limited memory resources :jvm/mem-max1g { :jvm-opts [ \"-Xmx1G\" ]} Container Memory Management \u03bb\ufe0e JDK_JAVA_OPTIONS environment variable should be used for setting JVM options within a container or in the provisioning service (e.g. Kubernettes / Argo CD) that deploys containers. Use JVM options that optimise running in a container -XshowSettings:system to output the resources the JVM believes it has access too, a very simple diagnostic tool to include -XX:+UseContainerSupport instruct the JVM that it is running in a container environment, disabling the checks the JVM would otherwise carry out to determine if it was running in a container. Can save a very small amount of start up time, though mainly used to ensure the JVM knows its in a container. -XX:MaxRAMPercentage=90 to set a relative maximum percentage of heap to use, based on the memory available from the host, e.g. -XX:MaxRAMPercentage=80 will use a heap size of 80% of the available host memory Dockerfile example with JDK_JAVA_OPTIONS environment variable \u03bb\ufe0e In this Dockerfile excerpt the JDK_JAVA_OPTIONS environment variable is used to print out the resources the JVM believes it has access to at startup. The JVM is instructed that it is running in a container environment and should use a maximum 90% heap size of the hosts memory resource. ENV JDK_JAVA_OPTIONS \"-XshowSettings:system -XX:+UseContainerSupport -XX:MaxRAMPercentage=90\" CMD [\"java\", \"-jar\", \"/opt/practicalli-service.jar\"] Low latency systems \u03bb\ufe0e For systems that require very low latency, use the Z Garbage collector \"-XX:+UnlockExperimentalVMOptions -XX:+UseZGC\" Stack traces \u03bb\ufe0e -XX:+TieredCompilation - enable tiered compilation to support accurate bench-marking (increases startup time) -XX:-OmitStackTraceInFastThrow - don't elide stack traces Startup options \u03bb\ufe0e -Xverify:none option reduces startup time of the JVM by skipping verification process \"-Xverify:none\" The verification process is a valuable check, especially for code that has not been run before. So the code should be run through the verification process before deploying to production. Benchmark options \u03bb\ufe0e Enable various optimizations, for guaranteeing accurate benchmarking (at the cost of slower startup): \"-server\" Graphical UI related options \u03bb\ufe0e -Djava.awt.headless=true - disable all UI features for disabling the clipboard for personal security: -Dapple.awt.UIElement=true - remove icon from the MacOSX Dock -Dclash.dev.expound=true - ? Garbage Collection \u03bb\ufe0e Setup GC with short STW pauses which can be relevant for very high web server workloads :jvm/g1gc { :jvm-opts [ \"-XX:+UseG1GC\" \"-XX:MaxGCPauseMillis=200\" \"-XX:ParallelGCThreads=20\" \"-XX:ConcGCThreads=5\" \"-XX:InitiatingHeapOccupancyPercent=70\" ]} Source: Tuning Garbage Collection with Oracle JDK View JVM options of a running JVM process \u03bb\ufe0e Use a JMX client, e.g. VisualVM jcmd pid VM.system_properties or jcmd pid VM.flags using jcmd -l to get the pid of the JVM process On Linux ps -ef | grep java which includes the options to run the JVM process, ps -auxww to show long arguments Getting the parameters of a running JVM References \u03bb\ufe0e JVM Options cheatsheet - JRebel","title":"Reference: Clojure CLI JVM Options"},{"location":"reference/clojure-cli/jvm-options/#reference-clojure-cli-jvm-options","text":"","title":"Reference: Clojure CLI JVM Options"},{"location":"reference/clojure-cli/jvm-options/#hintjdk_java_options-environment-variable","text":"JDK_JAVA_OPTIONS is the official Environment Variable for setting options when calling java , javac and other Java commands to start running a Java Virtual Machine (Java version 9 onward). Java Virtual Machine options can be passed using the Clojure CLI , either via the -J command line flag or :jvm-opts in a deps.edn alias.","title":"Hint::JDK_JAVA_OPTIONS Environment Variable"},{"location":"reference/clojure-cli/jvm-options/#hintjava-virtual-machine-configuration-and-reporting","text":"Java Virtual Machine section covers commonly used options, reporting JVM metrics and optimisation of the JVM process.","title":"Hint::Java Virtual Machine configuration and reporting"},{"location":"reference/clojure-cli/jvm-options/#clojure-cli-command-line-options","text":"Clojure CLI -J flag passes configuration options to the JVM. When there are multiple, each must be prefixed with -J . clojure -J-XX:+UnlockDiagnosticVMOptions -J\u2011XX:NativeMemoryTracking=summary -J\u2011XX:+PrintNMTStatistics","title":"Clojure CLI command line options"},{"location":"reference/clojure-cli/jvm-options/#clojure-cli-depsedn-configuration","text":":jvm-opts key in an alias adds JVM options to Clojure CLI deps.edn configuration. The :jvm-opts key has a value that is a collection of string JVM options [\"-Xms2048m\" \"-Xmx4096\"] Alias to set a large heap size :jvm/heap-max-2g { :jvm-opts [ \"-Xmx2G\" ]} Report a full breakdown of the HotSpot JVM\u2019s memory usage upon exit using the following option combination: :jvm/report { :jvm-opts [ \"-XX:+UnlockDiagnosticVMOptions\" \"\u2011XX:NativeMemoryTracking=summary\" \"\u2011XX:+PrintNMTStatistics\" ]} Add a Java module :jvm/xml-bind { :jvm-opts [ \"\u2013add-modules java.xml.bind\" ]} Ignoring unrecognised options :jvm-opts [ \"-XX:+IgnoreUnrecognizedVMOptions\" ] The aliases can be used with the Clojure CLI execution options: -A (for built-in REPL invocation), -X and -T (for clojure.exec function execution), or -M (for clojure.main execution). -J JVM options specified on the command line are concatenated after the alias options","title":"Clojure CLI deps.edn configuration"},{"location":"reference/clojure-cli/jvm-options/#calling-a-clojure-uberjar","text":"JVM options must be specified when calling an uberjar with the java command, :jvm-opts in the project deps.edn are not used with the java command java -jar project-uberjar.jar -J...","title":"Calling A Clojure Uberjar"},{"location":"reference/clojure-cli/jvm-options/#hintuse-jdk_java_options-to-define-jvm-options","text":"JDK_JAVA_OPTIONS environment variable is used to define options that are used whenever the java command is called, greatly simplifying java commands. The JDK_JAVA_OPTIONS environment variable can be used with deployment systems and passed to container environments to simplify adjustment of resources used by the JVM process.","title":"Hint::Use JDK_JAVA_OPTIONS to define JVM options"},{"location":"reference/clojure-cli/jvm-options/#clojure-related-jvm-options","text":"Specify options or system properties to set up the Clojure service -Dclojure.compiler.disable-locals-clearing=true - make more info available to debuggers -Dclojure.main.report=stderr - print stack traces to standard error instead of saving to file, useful if process failing on startup -Dclojure.spec.skip-macros=false - skip spec checks against macro forms","title":"Clojure related JVM options"},{"location":"reference/clojure-cli/jvm-options/#memory-management","text":"-XX:CompressedClassSpaceSize=3G - prevent a specific type of OOMs -XX:MaxJavaStackTraceDepth=1000000 - prevents trivial Stack Overflow errors -Xmx24G - set high maximum heap, preventing certain types of Out Of Memory errors (ideally high memory usage should be profiled if cause not known) -Xss6144k - increase stack size x6 to prevent Stack Overflow errors The current default can be found with java -XX:+PrintFlagsFinal -version 2>/dev/null | grep \"intx ThreadStackSize\" -Xms6G - Set minimum memory that is equal or greater than memory used by a running REPL, to improve performance -Xmx1G - limit maximum heap allocation so a process can never use more memory, useful for environments with limited memory resources :jvm/mem-max1g { :jvm-opts [ \"-Xmx1G\" ]}","title":"Memory Management"},{"location":"reference/clojure-cli/jvm-options/#container-memory-management","text":"JDK_JAVA_OPTIONS environment variable should be used for setting JVM options within a container or in the provisioning service (e.g. Kubernettes / Argo CD) that deploys containers. Use JVM options that optimise running in a container -XshowSettings:system to output the resources the JVM believes it has access too, a very simple diagnostic tool to include -XX:+UseContainerSupport instruct the JVM that it is running in a container environment, disabling the checks the JVM would otherwise carry out to determine if it was running in a container. Can save a very small amount of start up time, though mainly used to ensure the JVM knows its in a container. -XX:MaxRAMPercentage=90 to set a relative maximum percentage of heap to use, based on the memory available from the host, e.g. -XX:MaxRAMPercentage=80 will use a heap size of 80% of the available host memory","title":"Container Memory Management"},{"location":"reference/clojure-cli/jvm-options/#dockerfile-example-with-jdk_java_options-environment-variable","text":"In this Dockerfile excerpt the JDK_JAVA_OPTIONS environment variable is used to print out the resources the JVM believes it has access to at startup. The JVM is instructed that it is running in a container environment and should use a maximum 90% heap size of the hosts memory resource. ENV JDK_JAVA_OPTIONS \"-XshowSettings:system -XX:+UseContainerSupport -XX:MaxRAMPercentage=90\" CMD [\"java\", \"-jar\", \"/opt/practicalli-service.jar\"]","title":"Dockerfile example with JDK_JAVA_OPTIONS environment variable"},{"location":"reference/clojure-cli/jvm-options/#low-latency-systems","text":"For systems that require very low latency, use the Z Garbage collector \"-XX:+UnlockExperimentalVMOptions -XX:+UseZGC\"","title":"Low latency systems"},{"location":"reference/clojure-cli/jvm-options/#stack-traces","text":"-XX:+TieredCompilation - enable tiered compilation to support accurate bench-marking (increases startup time) -XX:-OmitStackTraceInFastThrow - don't elide stack traces","title":"Stack traces"},{"location":"reference/clojure-cli/jvm-options/#startup-options","text":"-Xverify:none option reduces startup time of the JVM by skipping verification process \"-Xverify:none\" The verification process is a valuable check, especially for code that has not been run before. So the code should be run through the verification process before deploying to production.","title":"Startup options"},{"location":"reference/clojure-cli/jvm-options/#benchmark-options","text":"Enable various optimizations, for guaranteeing accurate benchmarking (at the cost of slower startup): \"-server\"","title":"Benchmark options"},{"location":"reference/clojure-cli/jvm-options/#graphical-ui-related-options","text":"-Djava.awt.headless=true - disable all UI features for disabling the clipboard for personal security: -Dapple.awt.UIElement=true - remove icon from the MacOSX Dock -Dclash.dev.expound=true - ?","title":"Graphical UI related options"},{"location":"reference/clojure-cli/jvm-options/#garbage-collection","text":"Setup GC with short STW pauses which can be relevant for very high web server workloads :jvm/g1gc { :jvm-opts [ \"-XX:+UseG1GC\" \"-XX:MaxGCPauseMillis=200\" \"-XX:ParallelGCThreads=20\" \"-XX:ConcGCThreads=5\" \"-XX:InitiatingHeapOccupancyPercent=70\" ]} Source: Tuning Garbage Collection with Oracle JDK","title":"Garbage Collection"},{"location":"reference/clojure-cli/jvm-options/#view-jvm-options-of-a-running-jvm-process","text":"Use a JMX client, e.g. VisualVM jcmd pid VM.system_properties or jcmd pid VM.flags using jcmd -l to get the pid of the JVM process On Linux ps -ef | grep java which includes the options to run the JVM process, ps -auxww to show long arguments Getting the parameters of a running JVM","title":"View JVM options of a running JVM process"},{"location":"reference/clojure-cli/jvm-options/#references","text":"JVM Options cheatsheet - JRebel","title":"References"},{"location":"reference/clojure-svg/","text":"Clojure Scalable Vector Graphics - SVG \u03bb\ufe0e Scalable Vector Graphics, SVG, is an image format for two-dimensional (2D) graphics. An SVG image uses data to describe how to draw an image, ensuring that images can shrink and scale easily and retain a high quality image. As images are formed from data, shapes can easily be combined or intersected to form new shapes. Using a data format also means SVG images can be created from code and therefore animated. Raster image formats like gif, jpeg and png use a grid of squares called pixels to define an image (also known as a bitmap). Each pixel has a colour and position in an image. When zooming into an image the pixels grow larger distorting the sharpness of an image, referred to as pixelation , .Multiple versions of raster images are often created at different resolutions to reduce the loss of quality when viewed at different sizes. Hint::Work in progress \u03bb\ufe0e Concepts \u03bb\ufe0e viewbox style - border, background, width, height, stoke, fill, draw (path) shapes - circle, path Viewbox \u03bb\ufe0e A viewbox defines a co-ordinate system for the image. Defining a size for the viewbox defining a frame for the image where positions are relative to that frame, irrespective of the size of the image or how that image is scaled. A viewbox size should be selected to make the image as simple as possible to define within itself. Example: tictactoe O's and X's and the grid that represents the board . tictactoe O's and X's and the grid that represents the board Related projects \u03bb\ufe0e TicTacToe with ClojureScript, Reagent and SVG System monitoring Practicalli SVG examples library Programming SVG with Clojure (TODO) References \u03bb\ufe0e SVG: Scalable Vector Graphics - Mozilla Developer network","title":"Clojure Scalable Vector Graphics - SVG"},{"location":"reference/clojure-svg/#clojure-scalable-vector-graphics-svg","text":"Scalable Vector Graphics, SVG, is an image format for two-dimensional (2D) graphics. An SVG image uses data to describe how to draw an image, ensuring that images can shrink and scale easily and retain a high quality image. As images are formed from data, shapes can easily be combined or intersected to form new shapes. Using a data format also means SVG images can be created from code and therefore animated. Raster image formats like gif, jpeg and png use a grid of squares called pixels to define an image (also known as a bitmap). Each pixel has a colour and position in an image. When zooming into an image the pixels grow larger distorting the sharpness of an image, referred to as pixelation , .Multiple versions of raster images are often created at different resolutions to reduce the loss of quality when viewed at different sizes.","title":"Clojure Scalable Vector Graphics - SVG"},{"location":"reference/clojure-svg/#hintwork-in-progress","text":"","title":"Hint::Work in progress"},{"location":"reference/clojure-svg/#concepts","text":"viewbox style - border, background, width, height, stoke, fill, draw (path) shapes - circle, path","title":"Concepts"},{"location":"reference/clojure-svg/#viewbox","text":"A viewbox defines a co-ordinate system for the image. Defining a size for the viewbox defining a frame for the image where positions are relative to that frame, irrespective of the size of the image or how that image is scaled. A viewbox size should be selected to make the image as simple as possible to define within itself. Example: tictactoe O's and X's and the grid that represents the board . tictactoe O's and X's and the grid that represents the board","title":"Viewbox"},{"location":"reference/clojure-svg/#related-projects","text":"TicTacToe with ClojureScript, Reagent and SVG System monitoring Practicalli SVG examples library Programming SVG with Clojure (TODO)","title":"Related projects"},{"location":"reference/clojure-svg/#references","text":"SVG: Scalable Vector Graphics - Mozilla Developer network","title":"References"},{"location":"reference/clojure-syntax/assigning-names/","text":"Assigning Names \u03bb\ufe0e If we have to type the same values over and over, it would be very hard to write a program. What we need are names for values, so we can refer to them in a way we can remember. We do that using def . ( def mangoes 3 ) ( def oranges 5 ) ( + mangoes oranges ) When you assign a name to a value, that name is called a symbol . You can assign more than simple values to symbols. Try the following: ( def fruit ( + mangoes oranges )) ( def average-fruit-amount ( / fruit 2 )) average-fruit-amount Look at the last line, and see how we can use symbols by themselves to refer to a value. Note Take the Clojure syntax you have learnt to far and write a metric/imperial converter Take your height in feet and inches and convert it to inches using arithmetic in Clojure. Then convert that to centimeters. There are 2.54 centimeters in an inch. Lastly, ask two people near you for their height in centimeters. Find the average of your heights. Note Bonus: Convert that average back to feet and inches. The feet and the inches will be separate numbers. (quot x y) will give you the whole number part when dividing two numbers. (mod x y) will give you the remainder when dividing two numbers.","title":"Assigning Names"},{"location":"reference/clojure-syntax/assigning-names/#assigning-names","text":"If we have to type the same values over and over, it would be very hard to write a program. What we need are names for values, so we can refer to them in a way we can remember. We do that using def . ( def mangoes 3 ) ( def oranges 5 ) ( + mangoes oranges ) When you assign a name to a value, that name is called a symbol . You can assign more than simple values to symbols. Try the following: ( def fruit ( + mangoes oranges )) ( def average-fruit-amount ( / fruit 2 )) average-fruit-amount Look at the last line, and see how we can use symbols by themselves to refer to a value. Note Take the Clojure syntax you have learnt to far and write a metric/imperial converter Take your height in feet and inches and convert it to inches using arithmetic in Clojure. Then convert that to centimeters. There are 2.54 centimeters in an inch. Lastly, ask two people near you for their height in centimeters. Find the average of your heights. Note Bonus: Convert that average back to feet and inches. The feet and the inches will be separate numbers. (quot x y) will give you the whole number part when dividing two numbers. (mod x y) will give you the remainder when dividing two numbers.","title":"Assigning Names"},{"location":"reference/clojure-syntax/code-documentation/","text":"Code documentation \u03bb\ufe0e Clojure functions are documented by adding a string to the function definition, after the function name. This is referred to as the doc string . (defn example-function \"This is the documentation for this function, referred to as a doc string\" [arguments] (str \"some behaviour\")) def bindings can also be documented to provide context to the data the name is bound to. ( def weather-data \"Data set for weather across the major capitals of Europe\" [{ :date \"2020-05-015\" :city \"Berlin\" :temperature-max 24 :temperature-min 13 :rainfall 1 } { :date \"2020-05-015\" :city \"Amsterdam\" :temperature-max 25 :temperature-min 14 :rainfall 0 }]) Write easily understandable docstrings \u03bb\ufe0e Practically recommends including specific details of the arguments passed to a function and the expected return type. Including this at the end of the docstring makes that information very quick to find. \"Geographic visualization data set generator Arguments: - combined data set of GeoJSON and Cases - maximum integer value for scale Returns: - Oz view hash-map\" Reading source code \u03bb\ufe0e clojure.repl/source will show the source code of a given function, which can be a valuable way to understand the function. Reading function source code also provides ideas when writing custom Clojure code. Reading the source code for clojure.core functions is a good way to learn those functions, although some functions have been optimised for performance and are harder to follow. Source code for clojure.core is available online and is also linked to from the function descriptions on clojuredocs.org . Writing your own documentation \u03bb\ufe0e Writing good documentation for your own functions take practice which pays off in the long run. Note::Define your own function \u03bb\ufe0e Practice writing a meaningful documentation in the doc string () ( defn my-function \"I should practice writing clear and meaningful documentation for my functions. Arguments: brief description of arguments\" [ arguments ] ( str \"I should write pure functions where ever possible. \" \"Each function should have a specific purpose. \" \"A function should be clean and easy to read.\" ))","title":"Code documentation"},{"location":"reference/clojure-syntax/code-documentation/#code-documentation","text":"Clojure functions are documented by adding a string to the function definition, after the function name. This is referred to as the doc string . (defn example-function \"This is the documentation for this function, referred to as a doc string\" [arguments] (str \"some behaviour\")) def bindings can also be documented to provide context to the data the name is bound to. ( def weather-data \"Data set for weather across the major capitals of Europe\" [{ :date \"2020-05-015\" :city \"Berlin\" :temperature-max 24 :temperature-min 13 :rainfall 1 } { :date \"2020-05-015\" :city \"Amsterdam\" :temperature-max 25 :temperature-min 14 :rainfall 0 }])","title":"Code documentation"},{"location":"reference/clojure-syntax/code-documentation/#write-easily-understandable-docstrings","text":"Practically recommends including specific details of the arguments passed to a function and the expected return type. Including this at the end of the docstring makes that information very quick to find. \"Geographic visualization data set generator Arguments: - combined data set of GeoJSON and Cases - maximum integer value for scale Returns: - Oz view hash-map\"","title":"Write easily understandable docstrings"},{"location":"reference/clojure-syntax/code-documentation/#reading-source-code","text":"clojure.repl/source will show the source code of a given function, which can be a valuable way to understand the function. Reading function source code also provides ideas when writing custom Clojure code. Reading the source code for clojure.core functions is a good way to learn those functions, although some functions have been optimised for performance and are harder to follow. Source code for clojure.core is available online and is also linked to from the function descriptions on clojuredocs.org .","title":"Reading source code"},{"location":"reference/clojure-syntax/code-documentation/#writing-your-own-documentation","text":"Writing good documentation for your own functions take practice which pays off in the long run.","title":"Writing your own documentation"},{"location":"reference/clojure-syntax/code-documentation/#notedefine-your-own-function","text":"Practice writing a meaningful documentation in the doc string () ( defn my-function \"I should practice writing clear and meaningful documentation for my functions. Arguments: brief description of arguments\" [ arguments ] ( str \"I should write pure functions where ever possible. \" \"Each function should have a specific purpose. \" \"A function should be clean and easy to read.\" ))","title":"Note::Define your own function"},{"location":"reference/clojure-syntax/comments/","text":"Comments \u03bb\ufe0e As well as the classic line comments, Clojure also can comment specific parts of the code structure, even when it run over multiple lines. ;; to comment a whole line and ; to add a comment after the start of a line (comment ) wraps forms and returns nil when evaluated, referred to as rich comments #_ to ignore the next form as if it has not been written, commonly used for debugging Line comments \u03bb\ufe0e Add general documentation for a namespace, such as a comment header that describes the overall purpose of a namespace. Separate a namespace into logical sections to aid navigation and help identify opportunities to refactor a namespace as it grows. comment function \u03bb\ufe0e The (comment ,,,) function is used to included code that is only run by the developer directly. ( comment ( map + [ 1 2 3 ] [ 1 2 3 ])) The comment function returns nil so its advised not to use it inside another form. For example: (map + [1 2 3] (comment [1 2 3])) ; nil will be passed to map as the third argument This will fail as it tries to use the + function to add 1 to nil The #_ is the appropriate comment style for this example Rich comment \u03bb\ufe0e The comment expression is referred to a a rich comment, as it is often used to evaluate expressions it contains as part of a REPL driven development workflow . Unlike line comments, forms inside a comment block can be evaluated in a Clojure aware editor to help the developer work with a project. Rich comment are useful for rapidly iterating over different design decisions by including the same function but with different implementations. Hide clj-kondo linter](/clojure-cli/install/install-clojure.html#clj-kondo-static-analyser--linter) warnings for redefined vars ( def , defn ) when using this approach. ;; Rich comment block with redefined vars ignored # _ { :clj-kondo/ignore [ :redefined-var ]} ( comment ) ;; End of rich comment block The expressions can represent example function for using the project, such as starting/restarting the system, updating the database, etc. Expressions in rich comment blocks can also represent how to use a namespace API, providing examples of arguments to supply to further convey meaning to the code. These rich comments make a project more accessible and easier to use. The \"Rich\" in the name also refers to Rich Hickey, the author and benevolent leader of the Clojure language. Comment forms with the comment reader macro \u03bb\ufe0e #_ is the comment reader macro that instructs the Clojure reader to completely ignore the next form, as if it had never been written. No value is returned, so this comment is safe to use within an expression. You can place #_ before the start of a form and everything inside that form will be commented # _ ( def my-data [ 1 2 3 4 5 ]) #_ will comment forms that span multiple lines, for example function definitions # _ ( defn my-function [ args ] ( str \"I am an experiment, so not always needed\" )) #_ can also be put on the line(s) before the Clojure form, which can make your code more readable and keep alignment of your code consistent. debugging with comment macro \u03bb\ufe0e As the comment macro can be used without returning a value, it can safely be added to code to help with debugging. This code example finds the most common word in the text of a book. Most of the lines of code in the threading macro have been commented to discover what the non-commented code does. As each expression in the threading macros is understood, by looking at its results, comments can be removed to understand more of the code. ( defn most-common-words [ book ] ( ->> book ( re-seq # \"[a-zA-Z0-9|']+\" ,,, ) # _ ( map # ( clojure.string/lower-case % )) # _ ( remove common-english-words ) # _frequencies # _ ( sort-by val ) # _reverse )) This is an effective way to deconstruct parts of a larger Clojure expression. Watch episode #13 of Practicalli Clojure study group to see this in practice. comment nested forms \u03bb\ufe0e #_ tells the reader to ignore the next form, it is therefore never evaluated and neither is the #_ . This means that #_ can be used inside a nested form to comment just a part of the expression In this example the third vector of values is not read by the Clojure reader and therefore is not passed as an argument to + function by map (map + [1 2 3] [4 5 6] #_[7 8 9]) Stacking comments \u03bb\ufe0e The comment reader macro has the ability to stack these comments on forms, so using #_#_ will comment out two successive forms. In a let form we can comment out a name binding that is causing problems. As the name and value are both forms, then we use a stacked #_ to comment both out. We also do the same in the body of the let, so as to not include the evaluation of the string or name2 local name in the str form. (let [name1 \"value\" #_#_name2 \"another-value] (str \"First name is: \" name1 #_#_\" second name is: \" name2","title":"Comments"},{"location":"reference/clojure-syntax/comments/#comments","text":"As well as the classic line comments, Clojure also can comment specific parts of the code structure, even when it run over multiple lines. ;; to comment a whole line and ; to add a comment after the start of a line (comment ) wraps forms and returns nil when evaluated, referred to as rich comments #_ to ignore the next form as if it has not been written, commonly used for debugging","title":"Comments"},{"location":"reference/clojure-syntax/comments/#line-comments","text":"Add general documentation for a namespace, such as a comment header that describes the overall purpose of a namespace. Separate a namespace into logical sections to aid navigation and help identify opportunities to refactor a namespace as it grows.","title":"Line comments"},{"location":"reference/clojure-syntax/comments/#comment-function","text":"The (comment ,,,) function is used to included code that is only run by the developer directly. ( comment ( map + [ 1 2 3 ] [ 1 2 3 ])) The comment function returns nil so its advised not to use it inside another form. For example: (map + [1 2 3] (comment [1 2 3])) ; nil will be passed to map as the third argument This will fail as it tries to use the + function to add 1 to nil The #_ is the appropriate comment style for this example","title":"comment function"},{"location":"reference/clojure-syntax/comments/#rich-comment","text":"The comment expression is referred to a a rich comment, as it is often used to evaluate expressions it contains as part of a REPL driven development workflow . Unlike line comments, forms inside a comment block can be evaluated in a Clojure aware editor to help the developer work with a project. Rich comment are useful for rapidly iterating over different design decisions by including the same function but with different implementations. Hide clj-kondo linter](/clojure-cli/install/install-clojure.html#clj-kondo-static-analyser--linter) warnings for redefined vars ( def , defn ) when using this approach. ;; Rich comment block with redefined vars ignored # _ { :clj-kondo/ignore [ :redefined-var ]} ( comment ) ;; End of rich comment block The expressions can represent example function for using the project, such as starting/restarting the system, updating the database, etc. Expressions in rich comment blocks can also represent how to use a namespace API, providing examples of arguments to supply to further convey meaning to the code. These rich comments make a project more accessible and easier to use. The \"Rich\" in the name also refers to Rich Hickey, the author and benevolent leader of the Clojure language.","title":"Rich comment"},{"location":"reference/clojure-syntax/comments/#comment-forms-with-the-comment-reader-macro","text":"#_ is the comment reader macro that instructs the Clojure reader to completely ignore the next form, as if it had never been written. No value is returned, so this comment is safe to use within an expression. You can place #_ before the start of a form and everything inside that form will be commented # _ ( def my-data [ 1 2 3 4 5 ]) #_ will comment forms that span multiple lines, for example function definitions # _ ( defn my-function [ args ] ( str \"I am an experiment, so not always needed\" )) #_ can also be put on the line(s) before the Clojure form, which can make your code more readable and keep alignment of your code consistent.","title":"Comment forms with the comment reader macro"},{"location":"reference/clojure-syntax/comments/#debugging-with-comment-macro","text":"As the comment macro can be used without returning a value, it can safely be added to code to help with debugging. This code example finds the most common word in the text of a book. Most of the lines of code in the threading macro have been commented to discover what the non-commented code does. As each expression in the threading macros is understood, by looking at its results, comments can be removed to understand more of the code. ( defn most-common-words [ book ] ( ->> book ( re-seq # \"[a-zA-Z0-9|']+\" ,,, ) # _ ( map # ( clojure.string/lower-case % )) # _ ( remove common-english-words ) # _frequencies # _ ( sort-by val ) # _reverse )) This is an effective way to deconstruct parts of a larger Clojure expression. Watch episode #13 of Practicalli Clojure study group to see this in practice.","title":"debugging with comment macro"},{"location":"reference/clojure-syntax/comments/#comment-nested-forms","text":"#_ tells the reader to ignore the next form, it is therefore never evaluated and neither is the #_ . This means that #_ can be used inside a nested form to comment just a part of the expression In this example the third vector of values is not read by the Clojure reader and therefore is not passed as an argument to + function by map (map + [1 2 3] [4 5 6] #_[7 8 9])","title":"comment nested forms"},{"location":"reference/clojure-syntax/comments/#stacking-comments","text":"The comment reader macro has the ability to stack these comments on forms, so using #_#_ will comment out two successive forms. In a let form we can comment out a name binding that is causing problems. As the name and value are both forms, then we use a stacked #_ to comment both out. We also do the same in the body of the let, so as to not include the evaluation of the string or name2 local name in the str form. (let [name1 \"value\" #_#_name2 \"another-value] (str \"First name is: \" name1 #_#_\" second name is: \" name2","title":"Stacking comments"},{"location":"reference/clojure-syntax/control-flow/","text":"Control Flow \u03bb\ufe0e The following section of functions gives examples of simple control flow. As you gain more experience with Clojure, you will discover more functional ways to achieve the same (or better) results. Hint Although these functions may seem similar to other non-functional languages, there are subtle differences If \u03bb\ufe0e Using the if function you can test if an expression evaluates to true. If it is true, the first value is returned, if its false the second value is returned. Here is a simple example to see if one number is bigger that another ( if ( > 3 2 ) \"Higher\" \"Lower\" ) => \"Higher\" Here is an example of an condition inside an anonymous function. ( defn even-number [ number ] ( if ( odd? number ) ( inc number ) number )) ( even-number 41 ) ;; => 42 When \u03bb\ufe0e When a condition is true, then return the value of evaluating the next expression. If the condition is false, then return nil ( when ( > 3 2 ) \"Higher\" ) => \"Higher\" Case \u03bb\ufe0e When one of these things is true, do this, else default ( case ( inc 3 ) 1 \"Not even close\" 2 \"I wish I was that young\" 3 \"That was my previous value\" 4 \"You sunk my battleship\" \"I dont think you understood the question\" ) => \"You sunk my battleship\" Cond \u03bb\ufe0e Return the associated value of the first condition that is true, or return the default value specified by :otherwise ( cond ( = 7 ( inc 2 )) \"(inc 2) is not 7, so this condition is false\" ( = 16 ( * 8 2 )) \"This is the first correct condition so its associated expression is returned\" ( zero? ( - ( * 8 8 ) 64 )) \"This is true but not returned as a previous condition is true\" :otherwise \"None of the above are true\" ) ;; => \"This is the first correct condition so its associated expression is returned\" For \u03bb\ufe0e Using the for function you can Iterate through the values in a collection and evaluate each value in tern with with a condition, using either :when or :while . (for [x (range 10) :when (odd? x)] x) (for [x (range 10) :while (even? x)] x) (for [x (range 10) y (range 10)] [x y]) While \u03bb\ufe0e Do something while the condition is true ( while ( condition ) ( do something )) Here is a simple while example that uses a (mutable) counter and prints out the results to the repl window. ;; create a counter using a mutable counter ( def counter ( atom 10 )) ;; While the counter is positive (is a number greater than zero), print out the current value of the counter. ( while ( pos? @ counter ) ( do ( println @ counter ) ( swap! counter dec ))) This example uses mutable state and causes a side effect by printing to the repl. Both these kinds of things are typically kept to a minimum in Clojure. TODO An alternative would be to use use the iteration over a collection to control the while condition","title":"Control Flow"},{"location":"reference/clojure-syntax/control-flow/#control-flow","text":"The following section of functions gives examples of simple control flow. As you gain more experience with Clojure, you will discover more functional ways to achieve the same (or better) results. Hint Although these functions may seem similar to other non-functional languages, there are subtle differences","title":"Control Flow"},{"location":"reference/clojure-syntax/control-flow/#if","text":"Using the if function you can test if an expression evaluates to true. If it is true, the first value is returned, if its false the second value is returned. Here is a simple example to see if one number is bigger that another ( if ( > 3 2 ) \"Higher\" \"Lower\" ) => \"Higher\" Here is an example of an condition inside an anonymous function. ( defn even-number [ number ] ( if ( odd? number ) ( inc number ) number )) ( even-number 41 ) ;; => 42","title":"If"},{"location":"reference/clojure-syntax/control-flow/#when","text":"When a condition is true, then return the value of evaluating the next expression. If the condition is false, then return nil ( when ( > 3 2 ) \"Higher\" ) => \"Higher\"","title":"When"},{"location":"reference/clojure-syntax/control-flow/#case","text":"When one of these things is true, do this, else default ( case ( inc 3 ) 1 \"Not even close\" 2 \"I wish I was that young\" 3 \"That was my previous value\" 4 \"You sunk my battleship\" \"I dont think you understood the question\" ) => \"You sunk my battleship\"","title":"Case"},{"location":"reference/clojure-syntax/control-flow/#cond","text":"Return the associated value of the first condition that is true, or return the default value specified by :otherwise ( cond ( = 7 ( inc 2 )) \"(inc 2) is not 7, so this condition is false\" ( = 16 ( * 8 2 )) \"This is the first correct condition so its associated expression is returned\" ( zero? ( - ( * 8 8 ) 64 )) \"This is true but not returned as a previous condition is true\" :otherwise \"None of the above are true\" ) ;; => \"This is the first correct condition so its associated expression is returned\"","title":"Cond"},{"location":"reference/clojure-syntax/control-flow/#for","text":"Using the for function you can Iterate through the values in a collection and evaluate each value in tern with with a condition, using either :when or :while . (for [x (range 10) :when (odd? x)] x) (for [x (range 10) :while (even? x)] x) (for [x (range 10) y (range 10)] [x y])","title":"For"},{"location":"reference/clojure-syntax/control-flow/#while","text":"Do something while the condition is true ( while ( condition ) ( do something )) Here is a simple while example that uses a (mutable) counter and prints out the results to the repl window. ;; create a counter using a mutable counter ( def counter ( atom 10 )) ;; While the counter is positive (is a number greater than zero), print out the current value of the counter. ( while ( pos? @ counter ) ( do ( println @ counter ) ( swap! counter dec ))) This example uses mutable state and causes a side effect by printing to the repl. Both these kinds of things are typically kept to a minimum in Clojure. TODO An alternative would be to use use the iteration over a collection to control the while condition","title":"While"},{"location":"reference/clojure-syntax/defining-functions/","text":"Defining Functions \u03bb\ufe0e clojure.core/defn defines a custom function that can be called from anywhere in the current namespace by just using the name. A defined function can be called from where ever its namespace is required in other namespaces. Here is a simple function definition that takes a number and divides it by two (defn half-a-number \"Divide a given number by 2\" [number] (/ number 2)) Once you have defined a function, you can call it by using the function name as the first element of a list, () . Any other elements in the list are arguments passed to the function. (half-a-number 4) Understanding the defn syntax \u03bb\ufe0e The standard form of defn : ( defn name doc-string? attr-map? [ params* ] prepost-map? body ) name is a symbol used to call the function. doc-string? is an optional string used to provide a meaningful description of the function definition. This description is the living documentation of the function and can be accessed via `clojure.repl/doc** functions and Clojure aware editors. attr-map? is an optional map for pre-conditions for a function. [params*] is a zero or more vector of symbols that represent the arguments passed to a function. The number of symbols defined must be matched when calling the function, or an exception will occur. prepost-map? an optional map for post-conditions for a function. body is the algorithm that will evaluate when the function is called. There is a second form of the defn function, one which responds differently based on the number of arguments used to call the function (polymorphic). ( defn name doc-string? attr-map? ([ params* ] prepost-map? body ) + attr-map? ) Thinking Functionally - Polymorphism has examples of using defn to define polymorphic functions Breaking down the defn syntax \u03bb\ufe0e The syntax defn is what we call a macro, it is a simpler way to write clojure code that does the same thing. You can think of defining a function with defn as two steps Give the function a name - using the def syntax Define the functions behaviour and arguments it takes - using the fn syntax Here is the same function if you typed it out in full ( def half-a-number ( fn [ number ] ( / number 2 ))) Hint::Macroexpand functions \u03bb\ufe0e The macroexpand-1 function takes an expression that includes one or more macros and returns the expanded version of Clojure code. The macroexpand-all will also expand macros into Clojure code, doing so recursively for all macros it finds. Clojure editors also provide evaluation functions that will macroexpand.","title":"Defining Functions"},{"location":"reference/clojure-syntax/defining-functions/#defining-functions","text":"clojure.core/defn defines a custom function that can be called from anywhere in the current namespace by just using the name. A defined function can be called from where ever its namespace is required in other namespaces. Here is a simple function definition that takes a number and divides it by two (defn half-a-number \"Divide a given number by 2\" [number] (/ number 2)) Once you have defined a function, you can call it by using the function name as the first element of a list, () . Any other elements in the list are arguments passed to the function. (half-a-number 4)","title":"Defining Functions"},{"location":"reference/clojure-syntax/defining-functions/#understanding-the-defn-syntax","text":"The standard form of defn : ( defn name doc-string? attr-map? [ params* ] prepost-map? body ) name is a symbol used to call the function. doc-string? is an optional string used to provide a meaningful description of the function definition. This description is the living documentation of the function and can be accessed via `clojure.repl/doc** functions and Clojure aware editors. attr-map? is an optional map for pre-conditions for a function. [params*] is a zero or more vector of symbols that represent the arguments passed to a function. The number of symbols defined must be matched when calling the function, or an exception will occur. prepost-map? an optional map for post-conditions for a function. body is the algorithm that will evaluate when the function is called. There is a second form of the defn function, one which responds differently based on the number of arguments used to call the function (polymorphic). ( defn name doc-string? attr-map? ([ params* ] prepost-map? body ) + attr-map? ) Thinking Functionally - Polymorphism has examples of using defn to define polymorphic functions","title":"Understanding the defn syntax"},{"location":"reference/clojure-syntax/defining-functions/#breaking-down-the-defn-syntax","text":"The syntax defn is what we call a macro, it is a simpler way to write clojure code that does the same thing. You can think of defining a function with defn as two steps Give the function a name - using the def syntax Define the functions behaviour and arguments it takes - using the fn syntax Here is the same function if you typed it out in full ( def half-a-number ( fn [ number ] ( / number 2 )))","title":"Breaking down the defn syntax"},{"location":"reference/clojure-syntax/defining-functions/#hintmacroexpand-functions","text":"The macroexpand-1 function takes an expression that includes one or more macros and returns the expanded version of Clojure code. The macroexpand-all will also expand macros into Clojure code, doing so recursively for all macros it finds. Clojure editors also provide evaluation functions that will macroexpand.","title":"Hint::Macroexpand functions"},{"location":"reference/clojure-syntax/global-definitions/","text":"Global definitions \u03bb\ufe0e Fixme work in progress","title":"Global definitions"},{"location":"reference/clojure-syntax/global-definitions/#global-definitions","text":"Fixme work in progress","title":"Global definitions"},{"location":"reference/clojure-syntax/java-interop/","text":"Java Interoperability \u03bb\ufe0e Clojure provides very clear and simple syntax for Java interoperability , using the following functions import - add functions from the Java library into the current namespace new - create a new Java object . - is the short form of the new function As Clojure is hosted on the Java Virtual Machine (JVM), its very easy to include libraries from any other languages that runs on the JVM, for example Java, Groovy, Scala, Jython, JRuby, Jaskell, etc. The Leiningen build tool provides a simple way to include libraries as dependencies, using the :dependencies section of the project.clj file. Any library published to Maven Central is available for download by Leiningen, as both Maven Central and Clojars.org repositories are used by default. Hint Clojure projects and REPL environments include the java.lang library automatically. Any methods from that library can be used without having to import them or include any dependencies The syntax \u03bb\ufe0e Its very easy to call Java methods and objects from clojure using the following syntax ( .instanceMember instance args* ) ( .instanceMember Classname args* ) ( .-instanceField instance ) ( Classname/staticMethod args* ) Classname/staticField Note Use the instanceMember .toUpperCase to convert a string from lower case to upper case Call the .toUpperCase function on any string you like, for example ( .toUpperCase \"I was low, but now I'm up\" ) The string passed as an argument should now be all uppercase: \"I WAS LOW, BUT NOW I'M UP\" Note Use the staticField Math/PI to return the approximate value of Pi You can treat any static field like any name defined in your Clojure code, so when evaluated the static field simply returns the value it represents In this case the Math/PI static field simply returns the approximate value of Pi that fits into a java.lang.Double type. Math/PI -> 3.141592653589793 Getting the Java environment \u03bb\ufe0e Earlier we used Clojure functions to find information about our environment. We can also used the getProperty() method from the java.lang.System object to ask for the java version and jvm name . Note Get version of Java & the JVM, returning those values as a meaningful string. Then get the version of the Clojure project ( str \"You are running Java version \" ( System/getProperty \"java.version\" ) \"with the JVM\" ( System/getProperty \"java.vm.name\" )) ( str \"Latest project version: \" ( System/getProperty \"playground.version\" )) Note Use System/getenv to return your system's environment variables as a map ( System/getenv ) You may notice that this is a map data structure that we return, so we can use use destructuring or the maps behaviour itself to pull out information. Hint A full list of properties can be seen in the getProperty() documentation There are more examples of Java Interoperability in the next few sections.","title":"Java Interoperability"},{"location":"reference/clojure-syntax/java-interop/#java-interoperability","text":"Clojure provides very clear and simple syntax for Java interoperability , using the following functions import - add functions from the Java library into the current namespace new - create a new Java object . - is the short form of the new function As Clojure is hosted on the Java Virtual Machine (JVM), its very easy to include libraries from any other languages that runs on the JVM, for example Java, Groovy, Scala, Jython, JRuby, Jaskell, etc. The Leiningen build tool provides a simple way to include libraries as dependencies, using the :dependencies section of the project.clj file. Any library published to Maven Central is available for download by Leiningen, as both Maven Central and Clojars.org repositories are used by default. Hint Clojure projects and REPL environments include the java.lang library automatically. Any methods from that library can be used without having to import them or include any dependencies","title":"Java Interoperability"},{"location":"reference/clojure-syntax/java-interop/#the-syntax","text":"Its very easy to call Java methods and objects from clojure using the following syntax ( .instanceMember instance args* ) ( .instanceMember Classname args* ) ( .-instanceField instance ) ( Classname/staticMethod args* ) Classname/staticField Note Use the instanceMember .toUpperCase to convert a string from lower case to upper case Call the .toUpperCase function on any string you like, for example ( .toUpperCase \"I was low, but now I'm up\" ) The string passed as an argument should now be all uppercase: \"I WAS LOW, BUT NOW I'M UP\" Note Use the staticField Math/PI to return the approximate value of Pi You can treat any static field like any name defined in your Clojure code, so when evaluated the static field simply returns the value it represents In this case the Math/PI static field simply returns the approximate value of Pi that fits into a java.lang.Double type. Math/PI -> 3.141592653589793","title":"The syntax"},{"location":"reference/clojure-syntax/java-interop/#getting-the-java-environment","text":"Earlier we used Clojure functions to find information about our environment. We can also used the getProperty() method from the java.lang.System object to ask for the java version and jvm name . Note Get version of Java & the JVM, returning those values as a meaningful string. Then get the version of the Clojure project ( str \"You are running Java version \" ( System/getProperty \"java.version\" ) \"with the JVM\" ( System/getProperty \"java.vm.name\" )) ( str \"Latest project version: \" ( System/getProperty \"playground.version\" )) Note Use System/getenv to return your system's environment variables as a map ( System/getenv ) You may notice that this is a map data structure that we return, so we can use use destructuring or the maps behaviour itself to pull out information. Hint A full list of properties can be seen in the getProperty() documentation There are more examples of Java Interoperability in the next few sections.","title":"Getting the Java environment"},{"location":"reference/clojure-syntax/local-bindings/","text":"Local Bindings \u03bb\ufe0e Fixme work in progress","title":"Local Bindings"},{"location":"reference/clojure-syntax/local-bindings/#local-bindings","text":"Fixme work in progress","title":"Local Bindings"},{"location":"reference/clojure-syntax/more-java-fun/","text":"More Java fun \u03bb\ufe0e Lets try some more examples to show how easy it is to use Java methods and objects. Remember that everything in java.lang is available in your Clojure project by default Returning specific types \u03bb\ufe0e Clojure has types, after all it runs on the JVM and included java.lang library in ever project. Types are inferred at runtime, saving you the need to design types yourself. Sometimes you want to ensure a value is of a particular type and you can use Java to do this. Note Return a string value as an integer When you create a new java.lang.Integer object you can provide a default value by passing either a number or string type. ( new Integer \"123\" ) ;; Or the more common short-hand forms ( Integer. \"123\" ) This is the equivalent to the Java code: Integer myInt = new Integer ( \"123\" ); The . function essentially instantiates a new object from the class, in this case Integer , passing any arguments to its constructor. Hint Example: converting the port number read from an environment variable as a string which needs to be passed to the Jetty server as a number. See the Clojure Webapp workshop an example. More on types in the section a quick look at types fixme The following is work in progress Using Java date \u03bb\ufe0e Note Use java.util.Date to explore date and time ( import java.util.Date ) ( Date. ) ( def now ( Date. )) ( str now ) Its easy to create a local reference to a Java Date object instance and then call methods on that date object ( let [ date ( java.util.Date. )] ( .getHours date )) Or using the threading macro, we can make the code a little clearer (-> (java.util.Date.) (.getHours)) Its Joda Time \u03bb\ufe0e clj-time is a Clojure wrapper for Joda time. As this is an external library, you need to add it to your project.clj file as a dependency. To find the latest version, check the clj-time library on Clojars.org Note Add the clj-time dependency to your project (restart needed), require the clj-time library in your code and use the functions now , formatters & unparse (require '[clj-time.core :as time]) (require '[clj-time.format :as time-format]) (time/now) ;; ISO 8601 UTC format (def time-formatter (time-format/formatters :basic-date-time)) (time-format/unparse custom-formatter (date-time 2010 10 3)) Swing coding \u03bb\ufe0e Swing GUI coding in Java feels quite messy to me, however using Swing in Clojure feels much cleaner. Using the doto function allow you to chain function (Java method) calls together. Note Start with the import function to add the necessary swing libraries. Then create a button and add it to a panel, adding that panel to a frame. (import '(javax.swing JFrame JPanel JButton)) (def button (JButton. \"Click Me!\")) (def panel (doto (JPanel.) (.add button))) (def frame (doto (JFrame. \"Hello Frame\") (.setSize 200 200) (.setContentPane panel) (.setVisible true))) Let\u2019s make our button show a message using an JOptionPane/showMessageDialog widget (import 'javax.swing.JOptionPane) (defn say-hello [] (JOptionPane/showMessageDialog nil \"Hello, World!\" \"Greeting\" JOptionPane/INFORMATION_MESSAGE)) To connect this function to our button, write a class implementing the ActionListener interface. Clojure\u2019s proxy feature is the easiest way to do this: (import 'java.awt.event.ActionListener) (def act (proxy [ActionListener] [] (actionPerformed [event] (say-hello)))) act is an instance of an anonymous class implementing the actionPerformed method, so attach this class as a listener the button (.addActionListener button act) Now evaluate the say-hello function to see the new button in action. (say-hello) Hint Seesaw is a really nice library for swing development. Also talk a look at the Seesaw minesweeper series. Understanding the dot special form \u03bb\ufe0e Fixme This section onwards needs reworking All of these examples (except java.lang.Math/PI) use macros which expand to use the dot special form. In general, you won't need to use the dot special form unless you want to write your own macros to interact with Java objects and classes. Nevertheless, here is each example followed by its macroexpansion: (macroexpand-1 '(.toUpperCase \"By Bluebeard's bananas!\")) ; => (. \"By Bluebeard's bananas!\" toUpperCase) (macroexpand-1 '(.indexOf \"Synergism of our bleeding edges\" \"y\")) ; => (. \"Synergism of our bleeding edges\" indexOf \"y\") (macroexpand-1 '(Math/abs -3)) ; => (. Math abs -3) You can think of the general form of the dot operator as: (. object-expr-or-classname-symbol method-or-member-symbol optional-args*) There are a few more details to the dot operator than that, and if you're interested in exploring it further you can look at clojure.org's documentation on Java interop. Input/output involves resources, be they files, sockets, buffers, or whatever. Java has separate classes for reading a resource's contents, writings its contents, and for interacting with the resource's properties. For example, the java.io.File class is used to interact with a file's properties. Among other things, you can use it to check whether a file exists, to get the file's read/write/execute permissions, and to get its filesystem path: (let [file (java.io.File. \"/\")] (println (.exists file)) (println (.canWrite file)) (println (.getPath file))) ; => true ; => false ; => / Noticeably missing from this list of capabilities are reading and writing. To read a file, you could use the java.io.BufferedReader class or perhaps java.io.FileReader. Likewise, you can use the java.io.BufferedWriter or java.io.FileWriter class for writing. There are other classes available for reading and writing as well, and which one you choose depends on your specific needs. Reader and Writer classes all have the same base set of methods for their interfaces; readers implement read, close, and more, while writers implement append, write, close, and flush. So, Java gives you a variety of tools for performing IO. A cynical person might say that Java gives you enough rope to hang yourself, and if you find such a person I hope you give them just enough arms to hug them. Either way, Clojure makes things easier for you. First, there's spit and slurp. Spit writes to a resource, and slurp reads from one. Here's an example of using them to write and read a file: (spit \"/tmp/hercules-todo-list\" \"- wash hair - charm the multi-headed snake\") (slurp \"/tmp/hercules-todo-list\") ; => \"- wash hair ; => - charm the multi-headed snake\" You can also use these functions with objects representing resources other than files. The next example uses a StringWriter, which allows you to perform IO operations on a string: (let [s (java.io.StringWriter.)] (spit s \"- charm the multi-headed snake\") (.toString s)) ; => \"- charm the multi-headed snake\" Naturally, you can also read from a StringReader with slurp: (let [s (java.io.StringReader. \"- charm the multi-headed snake\")] (slurp s)) ; => \"- charm the multi-headed snake\" Of course, you can also use the read and write methods for resources. It doesn't really make much of a difference which you use; spit and slurp are often convenient because they work with just a string representing a filesystem path or a URL. The with-open macro is another convenience: it implicitly closes a resource at the end of its body. There's also the reader function, a nice utility which, according to the clojure.java.io api docs, \"attempts to coerce its argument to an open java.io.Reader.\" This is convenient when you don't want to use slurp because you don't want to try to read a resource in its entirety, and you don't want to figure out which Java class you need to use. You could use it along with with-open and the line-seq function if you're trying to read a file one line at a time: (with-open [todo-list-rdr (clojure.java.io/reader \"/tmp/hercules-todo-list\")] (doseq [todo (line-seq todo-list-rdr)] (println todo))) ; => \"- wash hair ; => - charm the multi-headed snake\" That should be enough for you to get started with IO in Clojure. If you're trying to do something more sophisticated, definitely take a look at the clojure.java.io docs, the java.nio.file package docs, or the java.io package docs. 5. Summary In this chapter, you learned what it means for Clojure to be hosted on the JVM. Clojure programs get compiled to Java bytecode and executed within a JVM process. Clojure programs also have access to Java libraries, and you can easily interact with them using Clojure's interop facilities. 6. Resources From http://clojure.org/java_interop \u03bb\ufe0e (.instanceMember instance args*) (.instanceMember Classname args*) (.-instanceField instance) (.toUpperCase \"fred\") -> \"FRED\" (.getName String) -> \"java.lang.String\" (.-x (java.awt.Point. 1 2)) -> 1 (System/getProperty \"java.vm.version\") -> \"1.6.0_07-b06-57\" Math/PI -> 3.141592653589793 The preferred idiomatic forms for accessing field or method members are given above. The instance member form works for both fields and methods. The instanceField form is preferred for fields and required if both a field and a 0-argument method of the same name exist. They all expand into calls to the dot operator (described below) at macroexpansion time. The expansions are as follows: (.instanceMember instance args*) ==> (. instance instanceMember args*) (.instanceMember Classname args*) ==> (. (identity Classname) instanceMember args*) (.-instanceField instance) ==> (. instance -instanceField) (Classname/staticMethod args*) ==> (. Classname staticMethod args*) Classname/staticField ==> (. Classname staticField) The Dot special form (. instance-expr member-symbol) (. Classname-symbol member-symbol) (. instance-expr -field-symbol) (. instance-expr (method-symbol args*)) or (. instance-expr method-symbol args*) (. Classname-symbol (method-symbol args*)) or (. Classname-symbol method-symbol args*) Special form. The '.' special form is the basis for access to Java. It can be considered a member-access operator, and/or read as 'in the scope of'. If the first operand is a symbol that resolves to a class name, the access is considered to be to a static member of the named class. Note that nested classes are named EnclosingClass$NestedClass, per the JVM spec. Otherwise it is presumed to be an instance member and the first argument is evaluated to produce the target object. If the second operand is a symbol and no args are supplied it is taken to be a field access - the name of the field is the name of the symbol, and the value of the expression is the value of the field, unless there is a no argument public method of the same name, in which case it resolves to a call to the method. If the second operand is a symbol starting with -, the member-symbol will resolve only as field access (never as a 0-arity method) and should be preferred when that is the intent. If the second operand is a list, or args are supplied, it is taken to be a method call. The first element of the list must be a simple symbol, and the name of the method is the name of the symbol. The args, if any, are evaluated from left to right, and passed to the matching method, which is called, and its value returned. If the method has a void return type, the value of the expression will be nil. Note that placing the method name in a list with any args is optional in the canonic form, but can be useful to gather args in macros built upon the form. Note that boolean return values will be turned into Booleans, chars will become Characters, and numeric primitives will become Numbers unless they are immediately consumed by a method taking a primitive. The member access forms given at the top of this section are preferred for use in all cases other than in macros. (.. instance-expr member+) (.. Classname-symbol member+) member => fieldName-symbol or (instanceMethodName-symbol args*) Macro. Expands into a member access (.) of the first member on the first argument, followed by the next member on the result, etc. For instance: (.. System (getProperties) (get \"os.name\")) expands to: (. (. System (getProperties)) (get \"os.name\")) but is easier to write, read, and understand. See also the -> macro which can be used similarly: (-> (System/getProperties) (.get \"os.name\")) (doto instance-expr (instanceMethodName-symbol args ) ) Macro. Evaluates instance-expr then calls all of the methods/functions with the supplied arguments in succession on the resulting object, returning it. (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2)) -> {a=1, b=2} Note the above applies to the latest Clojure SVN revision. If you are using the 20080916 release only method calls are allowed, and the syntax is: (doto (new java.util.HashMap) (put \"a\" 1) (put \"b\" 2)) -> {a=1, b=2} (Classname. args ) (new Classname args ) Special form. The args, if any, are evaluated from left to right, and passed to the constructor of the class named by Classname. The constructed object is returned. Alternative Macro Syntax As shown, in addition to the canonic special form new, Clojure supports special macroexpansion of symbols containing '.': (new Classname args*) can be written (Classname. args*) ;; note trailing dot the latter expanding into the former at macro expansion time. (instance? Class expr) Evaluates expr and tests if it is an instance of the class. Returns true or false (set! (. instance-expr instanceFieldName-symbol) expr) (set! (. Classname-symbol staticFieldName-symbol) expr) Assignment special form. When the first operand is a field member access form, the assignment is to the corresponding field. If it is an instance field, the instance expr will be evaluated, then the expr. In all cases the value of expr is returned. Note - you cannot assign to function params or local bindings. Only Java fields, Vars, Refs and Agents are mutable in Clojure. (memfn method-name arg-names*) Macro. Expands into code that creates a fn that expects to be passed an object and any args and calls the named instance method on the object passing the args. Use when you want to treat a Java method as a first-class fn. (map (memfn charAt i) [\"fred\" \"ethel\" \"lucy\"] [1 2 3]) -> (\\r \\h \\y) Note it almost always preferable to do this directly now, with syntax like: (map #(.charAt %1 %2) [\"fred\" \"ethel\" \"lucy\"] [1 2 3]) -> (\\r \\h \\y) (bean obj) Takes a Java object and returns a read-only implementation of the map abstraction based upon its JavaBean properties. (bean [[ http://java.awt.Color/black|java.awt.Color/black ]]) -> {:RGB -16777216, :alpha 255, :transparency 1, :class class java.awt.Color, :green 0, :blue 0, :colorSpace java.awt.color.ICC_ColorSpace@c94b51, :red 0} Support for Java in Clojure Library Functions Many of the Clojure library functions have defined semantics for objects of Java types. contains? and get work on Java Maps, arrays, Strings, the latter two with integer keys. count works on Java Strings, Collections and arrays. nth works on Java Strings, Lists and arrays. seq works on Java reference arrays, Iterables and Strings. Since much of the rest of the library is built upon these functions, there is great support for using Java objects in Clojure algorithms. Implementing Interfaces and Extending Classes Clojure supports the dynamic creation of objects that implement one or more interfaces and/or extend a class with the proxy macro. The resulting objects are of an anonymous class. You can also generate statically-named classes and .class files with gen-class. As of Clojure 1.2, reify is also available for implementing interfaces. ( proxy [class-and-interfaces] [args] fs+) class-and-interfaces - a vector of class names args - a (possibly empty) vector of arguments to the superclass constructor. f => (name [params ] body) or (name ([params ] body) ([params+] body) ...) Macro Expands to code which creates a instance of a proxy class that implements the named class/interface(s) by calling the supplied fns. A single class, if provided, must be first. If not provided it defaults to Object. The interfaces names must be valid interface types. If a method fn is not provided for a class method, the superclass method will be called. If a method fn is not provided for an interface method, an UnsupportedOperationException will be thrown should it be called. Method fns are closures and can capture the environment in which proxy is called. Each method fn takes an additional implicit first argument, which is bound to this. Note that while method fns can be provided to override protected methods, they have no other access to protected members, nor to super, as these capabilities cannot be a proxy. Arrays Clojure supports the creation, reading and modification of Java arrays. It is recommended that you limit use of arrays to interop with Java libraries that require them as arguments or use them as return values. Note that many other Clojure functions work with arrays such as via the seq library. The functions listed here exist for initial creation of arrays, or to support mutation or higher performance operations on arrays. Create array from existing collection: aclone amap to-array to-array-2d into-array Multi-dimensional array support: aget aset to-array-2d make-array Type-specific array constructors: boolean-array byte-array char-array double-array float-array int-array long-array object-array short-array Primitive array casts: booleans bytes chars doubles floats ints longs shorts Mutate an array: aset Process an existing array: aget alength amap areduce Type Hints Clojure supports the use of type hints to assist the compiler in avoiding reflection in performance-critical areas of code. Normally, one should avoid the use of type hints until there is a known performance bottleneck. Type hints are metadata tags placed on symbols or expressions that are consumed by the compiler. They can be placed on function parameters, let-bound names, var names (when defined), and expressions: (defn len [x] (.length x)) (defn len2 [^String x] (.length x)) user=> (time (reduce + (map len (repeat 1000000 \"asdf\")))) \"Elapsed time: 3007.198 msecs\" 4000000 user=> (time (reduce + (map len2 (repeat 1000000 \"asdf\")))) \"Elapsed time: 308.045 msecs\" 4000000 Once a type hint has been placed on an identifier or expression, the compiler will try to resolve any calls to methods thereupon at compile time. In addition, the compiler will track the use of any return values and infer types for their use and so on, so very few hints are needed to get a fully compile-time resolved series of calls. Note that type hints are not needed for static members (or their return values!) as the compiler always has the type for statics. There is a warn-on-reflection flag (defaults to false) which will cause the compiler to warn you when it can't resolve to a direct call: (set! warn-on-reflection true) -> true (defn foo [s] (.charAt s 1)) -> Reflection warning, line: 2 - call to charAt can't be resolved. -> #user/foo (defn foo [^String s] (.charAt s 1)) -> #user/foo For function return values, the type hint can be placed before the arguments vector: (defn hinted (^String []) (^Integer [a]) (^java.util.List [a & args])) -> #user/hinted Aliases Clojure provides aliases for primitive Java types and arrays which do not have typical representations as Java class names. For example, long arrays (long-array []) have a type of \"[J\". int - A primitive int ints - An int array long - A primitive long longs - A long array float - A primitive float floats - A float array double - A primitive double doubles - A double array void - A void return short - A primitive short shorts - A short array boolean - A primitive boolean booleans - A boolean array byte - A primitive byte bytes - A byte array char - A primitive character chars - A character array Support for Java Primitives Clojure has support for high-performance manipulation of, and arithmetic involving, Java primitive types in local contexts. All Java primitive types are supported: int, float, long, double, boolean, char, short, and byte. let/loop-bound locals can be of primitive types, having the inferred, possibly primitive type of their init-form. recur forms that rebind primitive locals do so without boxing, and do type-checking for same primitive type. Arithmetic (+,-,*,/,inc,dec,<,<=,>,>= etc) is overloaded for primitive types where semantics are same. aget/aset are overloaded for arrays of primitives aclone, alength functions for arrays of primitives constructor functions for primitive arrays: float-array, int-array, etc. Type hints for primitive arrays - ^ints, ^floats, etc. Coercion ops int, float, etc. produce primitives when consumer can take primitive The num coercion function boxes primitives to force generic arithmetic Array cast functions ints longs, etc. which produce int[], long[], etc. A set of \"unchecked\" operations for utmost performing, but potentially unsafe, integer (int/long) ops: unchecked-multiply unchecked-dec unchecked-inc unchecked-negate unchecked-add unchecked-subtract unchecked-remainder unchecked-divide A dynamic var to automatically swap safe operations with unchecked operations: *unchecked-math* amap and areduce macros for functionally (i.e. non-destructively) processing one or more arrays in order to produce a new array or aggregate value respectively. Rather than write this Java: static public float asum(float[] xs){ float ret = 0; for(int i = 0; i < xs.length; i++) ret += xs[i]; return ret; } you can write this Clojure: (defn asum [^floats xs] (areduce xs i ret (float 0) (+ ret (aget xs i)))) and the resulting code is exactly the same speed (when run with java -server). The best aspect of this is that you need not do anything special in your initial coding. Quite often these optimizations are unneeded. Should a bit of code be a bottleneck, you can speed it up with minor adornment: (defn foo [n] (loop [i 0] (if (< i n) (recur (inc i)) i))) (time (foo 100000)) \"Elapsed time: 0.391 msecs\" 100000 (defn foo2 [n] (let [n (int n)] (loop [i (int 0)] (if (< i n) (recur (inc i)) i)))) (time (foo2 100000)) \"Elapsed time: 0.084 msecs\" 100000 Coercions At times it is necessary to have a value of a particular primitive type. These coercion functions yield a value of the indicated type as long as such a coercion is possible: bigdec bigint boolean byte char double float int long num short Some optimization tips All arguments are passed to Clojure fns as objects, so there's no point to putting non-array primitive type hints on fn args. Instead, use the let technique shown to place args in primitive locals if they need to participate in primitive arithmetic in the body. (let [foo (int bar)] ...) is the correct way to get a primitive local. Do not use ^Integer etc. Don't rush to unchecked math unless you want truncating operations. HotSpot does a good job at optimizing the overflow check, which will yield an exception instead of silent truncation. On a typical example, that has about a 5% difference in speed - well worth it. Also, people reading your code don't know if you are using unchecked for truncation or performance - best to reserve it for the former and comment if the latter. There's usually no point in trying to optimize an outer loop, in fact it can hurt you as you'll be representing things as primitives which just have to be re-boxed in order to become args to the inner call. The only exception is reflection warnings - you must get rid of them in any code that gets called frequently. Almost every time someone presents something they are trying to optimize with hints, the faster version has far fewer hints than the original. If a hint doesn't improve things in the end - take it out. Many people seem to presume only the unchecked- ops do primitive arithmetic - not so. When the args are primitive locals, regular + and * etc do primitive math with an overflow check - fast and safe. So, the simplest route to fast math is to leave the operators alone and just make sure the source literals and locals are primitive. Arithmetic on primitives yields primitives. If you've got a loop (which you probably do if you need to optimize) make sure the loop locals are primitives first - then if you accidentally are producing a boxed intermediate result you'll get an error on recur. Don't solve that error by coercing your intermediate result, instead, figure out what argument or local is not primitive. Simple XML Support Included with the distribution is simple XML support, found in the src/xml.clj file. All names from this file are in the xml namespace. (parse source) Parses and loads the source, which can be a File, InputStream or String naming a URI. Returns a tree of the xml/element struct-map, which has the keys :tag, :attrs, and :content. and accessor fns tag, attrs, and content. (xml/parse \"/Users/rich/dev/clojure/build.xml\") -> {:tag :project, :attrs {:name \"clojure\", :default \"jar\"}, :content [{:tag :description, ... Calling Clojure From Java The clojure.java.api package provides a minimal interface to bootstrap Clojure access from other JVM languages. It does this by providing: The ability to use Clojure's namespaces to locate an arbitrary var, returning the var's clojure.lang.IFn interface. A convenience method read for reading data using Clojure's edn reader IFns provide complete access to Clojure's APIs. You can also access any other library written in Clojure, after adding either its source or compiled form to the classpath. The public Java API for Clojure consists of the following classes and interfaces: clojure.java.api.Clojure clojure.lang.IFn All other Java classes should be treated as implementation details, and applications should avoid relying on them. To lookup and call a Clojure function: IFn plus = Clojure.var(\"clojure.core\", \"+\"); plus.invoke(1, 2); Functions in clojure.core are automatically loaded. Other namespaces can be loaded via require: IFn require = Clojure.var(\"clojure.core\", \"require\"); require.invoke(Clojure.read(\"clojure.set\")); IFns can be passed to higher order functions, e.g. the example below passes plus to read: IFn map = Clojure.var(\"clojure.core\", \"map\"); IFn inc = Clojure.var(\"clojure.core\", \"inc\"); map.invoke(inc, Clojure.read(\"[1 2 3]\")); Most IFns in Clojure refer to functions. A few, however, refer to non-function data values. To access these, use deref instead of fn: IFn printLength = Clojure.var(\"clojure.core\", \" print-length \"); IFn deref = Clojure.var(\"clojure.core\", \"deref\"); deref.invoke(printLength);","title":"More Java fun"},{"location":"reference/clojure-syntax/more-java-fun/#more-java-fun","text":"Lets try some more examples to show how easy it is to use Java methods and objects. Remember that everything in java.lang is available in your Clojure project by default","title":"More Java fun"},{"location":"reference/clojure-syntax/more-java-fun/#returning-specific-types","text":"Clojure has types, after all it runs on the JVM and included java.lang library in ever project. Types are inferred at runtime, saving you the need to design types yourself. Sometimes you want to ensure a value is of a particular type and you can use Java to do this. Note Return a string value as an integer When you create a new java.lang.Integer object you can provide a default value by passing either a number or string type. ( new Integer \"123\" ) ;; Or the more common short-hand forms ( Integer. \"123\" ) This is the equivalent to the Java code: Integer myInt = new Integer ( \"123\" ); The . function essentially instantiates a new object from the class, in this case Integer , passing any arguments to its constructor. Hint Example: converting the port number read from an environment variable as a string which needs to be passed to the Jetty server as a number. See the Clojure Webapp workshop an example. More on types in the section a quick look at types fixme The following is work in progress","title":"Returning specific types"},{"location":"reference/clojure-syntax/more-java-fun/#using-java-date","text":"Note Use java.util.Date to explore date and time ( import java.util.Date ) ( Date. ) ( def now ( Date. )) ( str now ) Its easy to create a local reference to a Java Date object instance and then call methods on that date object ( let [ date ( java.util.Date. )] ( .getHours date )) Or using the threading macro, we can make the code a little clearer (-> (java.util.Date.) (.getHours))","title":"Using Java date"},{"location":"reference/clojure-syntax/more-java-fun/#its-joda-time","text":"clj-time is a Clojure wrapper for Joda time. As this is an external library, you need to add it to your project.clj file as a dependency. To find the latest version, check the clj-time library on Clojars.org Note Add the clj-time dependency to your project (restart needed), require the clj-time library in your code and use the functions now , formatters & unparse (require '[clj-time.core :as time]) (require '[clj-time.format :as time-format]) (time/now) ;; ISO 8601 UTC format (def time-formatter (time-format/formatters :basic-date-time)) (time-format/unparse custom-formatter (date-time 2010 10 3))","title":"Its Joda Time"},{"location":"reference/clojure-syntax/more-java-fun/#swing-coding","text":"Swing GUI coding in Java feels quite messy to me, however using Swing in Clojure feels much cleaner. Using the doto function allow you to chain function (Java method) calls together. Note Start with the import function to add the necessary swing libraries. Then create a button and add it to a panel, adding that panel to a frame. (import '(javax.swing JFrame JPanel JButton)) (def button (JButton. \"Click Me!\")) (def panel (doto (JPanel.) (.add button))) (def frame (doto (JFrame. \"Hello Frame\") (.setSize 200 200) (.setContentPane panel) (.setVisible true))) Let\u2019s make our button show a message using an JOptionPane/showMessageDialog widget (import 'javax.swing.JOptionPane) (defn say-hello [] (JOptionPane/showMessageDialog nil \"Hello, World!\" \"Greeting\" JOptionPane/INFORMATION_MESSAGE)) To connect this function to our button, write a class implementing the ActionListener interface. Clojure\u2019s proxy feature is the easiest way to do this: (import 'java.awt.event.ActionListener) (def act (proxy [ActionListener] [] (actionPerformed [event] (say-hello)))) act is an instance of an anonymous class implementing the actionPerformed method, so attach this class as a listener the button (.addActionListener button act) Now evaluate the say-hello function to see the new button in action. (say-hello) Hint Seesaw is a really nice library for swing development. Also talk a look at the Seesaw minesweeper series.","title":"Swing coding"},{"location":"reference/clojure-syntax/more-java-fun/#understanding-the-dot-special-form","text":"Fixme This section onwards needs reworking All of these examples (except java.lang.Math/PI) use macros which expand to use the dot special form. In general, you won't need to use the dot special form unless you want to write your own macros to interact with Java objects and classes. Nevertheless, here is each example followed by its macroexpansion: (macroexpand-1 '(.toUpperCase \"By Bluebeard's bananas!\")) ; => (. \"By Bluebeard's bananas!\" toUpperCase) (macroexpand-1 '(.indexOf \"Synergism of our bleeding edges\" \"y\")) ; => (. \"Synergism of our bleeding edges\" indexOf \"y\") (macroexpand-1 '(Math/abs -3)) ; => (. Math abs -3) You can think of the general form of the dot operator as: (. object-expr-or-classname-symbol method-or-member-symbol optional-args*) There are a few more details to the dot operator than that, and if you're interested in exploring it further you can look at clojure.org's documentation on Java interop. Input/output involves resources, be they files, sockets, buffers, or whatever. Java has separate classes for reading a resource's contents, writings its contents, and for interacting with the resource's properties. For example, the java.io.File class is used to interact with a file's properties. Among other things, you can use it to check whether a file exists, to get the file's read/write/execute permissions, and to get its filesystem path: (let [file (java.io.File. \"/\")] (println (.exists file)) (println (.canWrite file)) (println (.getPath file))) ; => true ; => false ; => / Noticeably missing from this list of capabilities are reading and writing. To read a file, you could use the java.io.BufferedReader class or perhaps java.io.FileReader. Likewise, you can use the java.io.BufferedWriter or java.io.FileWriter class for writing. There are other classes available for reading and writing as well, and which one you choose depends on your specific needs. Reader and Writer classes all have the same base set of methods for their interfaces; readers implement read, close, and more, while writers implement append, write, close, and flush. So, Java gives you a variety of tools for performing IO. A cynical person might say that Java gives you enough rope to hang yourself, and if you find such a person I hope you give them just enough arms to hug them. Either way, Clojure makes things easier for you. First, there's spit and slurp. Spit writes to a resource, and slurp reads from one. Here's an example of using them to write and read a file: (spit \"/tmp/hercules-todo-list\" \"- wash hair - charm the multi-headed snake\") (slurp \"/tmp/hercules-todo-list\") ; => \"- wash hair ; => - charm the multi-headed snake\" You can also use these functions with objects representing resources other than files. The next example uses a StringWriter, which allows you to perform IO operations on a string: (let [s (java.io.StringWriter.)] (spit s \"- charm the multi-headed snake\") (.toString s)) ; => \"- charm the multi-headed snake\" Naturally, you can also read from a StringReader with slurp: (let [s (java.io.StringReader. \"- charm the multi-headed snake\")] (slurp s)) ; => \"- charm the multi-headed snake\" Of course, you can also use the read and write methods for resources. It doesn't really make much of a difference which you use; spit and slurp are often convenient because they work with just a string representing a filesystem path or a URL. The with-open macro is another convenience: it implicitly closes a resource at the end of its body. There's also the reader function, a nice utility which, according to the clojure.java.io api docs, \"attempts to coerce its argument to an open java.io.Reader.\" This is convenient when you don't want to use slurp because you don't want to try to read a resource in its entirety, and you don't want to figure out which Java class you need to use. You could use it along with with-open and the line-seq function if you're trying to read a file one line at a time: (with-open [todo-list-rdr (clojure.java.io/reader \"/tmp/hercules-todo-list\")] (doseq [todo (line-seq todo-list-rdr)] (println todo))) ; => \"- wash hair ; => - charm the multi-headed snake\" That should be enough for you to get started with IO in Clojure. If you're trying to do something more sophisticated, definitely take a look at the clojure.java.io docs, the java.nio.file package docs, or the java.io package docs. 5. Summary In this chapter, you learned what it means for Clojure to be hosted on the JVM. Clojure programs get compiled to Java bytecode and executed within a JVM process. Clojure programs also have access to Java libraries, and you can easily interact with them using Clojure's interop facilities. 6. Resources","title":"Understanding the dot special form"},{"location":"reference/clojure-syntax/more-java-fun/#from-httpclojureorgjava_interop","text":"(.instanceMember instance args*) (.instanceMember Classname args*) (.-instanceField instance) (.toUpperCase \"fred\") -> \"FRED\" (.getName String) -> \"java.lang.String\" (.-x (java.awt.Point. 1 2)) -> 1 (System/getProperty \"java.vm.version\") -> \"1.6.0_07-b06-57\" Math/PI -> 3.141592653589793 The preferred idiomatic forms for accessing field or method members are given above. The instance member form works for both fields and methods. The instanceField form is preferred for fields and required if both a field and a 0-argument method of the same name exist. They all expand into calls to the dot operator (described below) at macroexpansion time. The expansions are as follows: (.instanceMember instance args*) ==> (. instance instanceMember args*) (.instanceMember Classname args*) ==> (. (identity Classname) instanceMember args*) (.-instanceField instance) ==> (. instance -instanceField) (Classname/staticMethod args*) ==> (. Classname staticMethod args*) Classname/staticField ==> (. Classname staticField) The Dot special form (. instance-expr member-symbol) (. Classname-symbol member-symbol) (. instance-expr -field-symbol) (. instance-expr (method-symbol args*)) or (. instance-expr method-symbol args*) (. Classname-symbol (method-symbol args*)) or (. Classname-symbol method-symbol args*) Special form. The '.' special form is the basis for access to Java. It can be considered a member-access operator, and/or read as 'in the scope of'. If the first operand is a symbol that resolves to a class name, the access is considered to be to a static member of the named class. Note that nested classes are named EnclosingClass$NestedClass, per the JVM spec. Otherwise it is presumed to be an instance member and the first argument is evaluated to produce the target object. If the second operand is a symbol and no args are supplied it is taken to be a field access - the name of the field is the name of the symbol, and the value of the expression is the value of the field, unless there is a no argument public method of the same name, in which case it resolves to a call to the method. If the second operand is a symbol starting with -, the member-symbol will resolve only as field access (never as a 0-arity method) and should be preferred when that is the intent. If the second operand is a list, or args are supplied, it is taken to be a method call. The first element of the list must be a simple symbol, and the name of the method is the name of the symbol. The args, if any, are evaluated from left to right, and passed to the matching method, which is called, and its value returned. If the method has a void return type, the value of the expression will be nil. Note that placing the method name in a list with any args is optional in the canonic form, but can be useful to gather args in macros built upon the form. Note that boolean return values will be turned into Booleans, chars will become Characters, and numeric primitives will become Numbers unless they are immediately consumed by a method taking a primitive. The member access forms given at the top of this section are preferred for use in all cases other than in macros. (.. instance-expr member+) (.. Classname-symbol member+) member => fieldName-symbol or (instanceMethodName-symbol args*) Macro. Expands into a member access (.) of the first member on the first argument, followed by the next member on the result, etc. For instance: (.. System (getProperties) (get \"os.name\")) expands to: (. (. System (getProperties)) (get \"os.name\")) but is easier to write, read, and understand. See also the -> macro which can be used similarly: (-> (System/getProperties) (.get \"os.name\")) (doto instance-expr (instanceMethodName-symbol args ) ) Macro. Evaluates instance-expr then calls all of the methods/functions with the supplied arguments in succession on the resulting object, returning it. (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2)) -> {a=1, b=2} Note the above applies to the latest Clojure SVN revision. If you are using the 20080916 release only method calls are allowed, and the syntax is: (doto (new java.util.HashMap) (put \"a\" 1) (put \"b\" 2)) -> {a=1, b=2} (Classname. args ) (new Classname args ) Special form. The args, if any, are evaluated from left to right, and passed to the constructor of the class named by Classname. The constructed object is returned. Alternative Macro Syntax As shown, in addition to the canonic special form new, Clojure supports special macroexpansion of symbols containing '.': (new Classname args*) can be written (Classname. args*) ;; note trailing dot the latter expanding into the former at macro expansion time. (instance? Class expr) Evaluates expr and tests if it is an instance of the class. Returns true or false (set! (. instance-expr instanceFieldName-symbol) expr) (set! (. Classname-symbol staticFieldName-symbol) expr) Assignment special form. When the first operand is a field member access form, the assignment is to the corresponding field. If it is an instance field, the instance expr will be evaluated, then the expr. In all cases the value of expr is returned. Note - you cannot assign to function params or local bindings. Only Java fields, Vars, Refs and Agents are mutable in Clojure. (memfn method-name arg-names*) Macro. Expands into code that creates a fn that expects to be passed an object and any args and calls the named instance method on the object passing the args. Use when you want to treat a Java method as a first-class fn. (map (memfn charAt i) [\"fred\" \"ethel\" \"lucy\"] [1 2 3]) -> (\\r \\h \\y) Note it almost always preferable to do this directly now, with syntax like: (map #(.charAt %1 %2) [\"fred\" \"ethel\" \"lucy\"] [1 2 3]) -> (\\r \\h \\y) (bean obj) Takes a Java object and returns a read-only implementation of the map abstraction based upon its JavaBean properties. (bean [[ http://java.awt.Color/black|java.awt.Color/black ]]) -> {:RGB -16777216, :alpha 255, :transparency 1, :class class java.awt.Color, :green 0, :blue 0, :colorSpace java.awt.color.ICC_ColorSpace@c94b51, :red 0} Support for Java in Clojure Library Functions Many of the Clojure library functions have defined semantics for objects of Java types. contains? and get work on Java Maps, arrays, Strings, the latter two with integer keys. count works on Java Strings, Collections and arrays. nth works on Java Strings, Lists and arrays. seq works on Java reference arrays, Iterables and Strings. Since much of the rest of the library is built upon these functions, there is great support for using Java objects in Clojure algorithms. Implementing Interfaces and Extending Classes Clojure supports the dynamic creation of objects that implement one or more interfaces and/or extend a class with the proxy macro. The resulting objects are of an anonymous class. You can also generate statically-named classes and .class files with gen-class. As of Clojure 1.2, reify is also available for implementing interfaces. ( proxy [class-and-interfaces] [args] fs+) class-and-interfaces - a vector of class names args - a (possibly empty) vector of arguments to the superclass constructor. f => (name [params ] body) or (name ([params ] body) ([params+] body) ...) Macro Expands to code which creates a instance of a proxy class that implements the named class/interface(s) by calling the supplied fns. A single class, if provided, must be first. If not provided it defaults to Object. The interfaces names must be valid interface types. If a method fn is not provided for a class method, the superclass method will be called. If a method fn is not provided for an interface method, an UnsupportedOperationException will be thrown should it be called. Method fns are closures and can capture the environment in which proxy is called. Each method fn takes an additional implicit first argument, which is bound to this. Note that while method fns can be provided to override protected methods, they have no other access to protected members, nor to super, as these capabilities cannot be a proxy. Arrays Clojure supports the creation, reading and modification of Java arrays. It is recommended that you limit use of arrays to interop with Java libraries that require them as arguments or use them as return values. Note that many other Clojure functions work with arrays such as via the seq library. The functions listed here exist for initial creation of arrays, or to support mutation or higher performance operations on arrays. Create array from existing collection: aclone amap to-array to-array-2d into-array Multi-dimensional array support: aget aset to-array-2d make-array Type-specific array constructors: boolean-array byte-array char-array double-array float-array int-array long-array object-array short-array Primitive array casts: booleans bytes chars doubles floats ints longs shorts Mutate an array: aset Process an existing array: aget alength amap areduce Type Hints Clojure supports the use of type hints to assist the compiler in avoiding reflection in performance-critical areas of code. Normally, one should avoid the use of type hints until there is a known performance bottleneck. Type hints are metadata tags placed on symbols or expressions that are consumed by the compiler. They can be placed on function parameters, let-bound names, var names (when defined), and expressions: (defn len [x] (.length x)) (defn len2 [^String x] (.length x)) user=> (time (reduce + (map len (repeat 1000000 \"asdf\")))) \"Elapsed time: 3007.198 msecs\" 4000000 user=> (time (reduce + (map len2 (repeat 1000000 \"asdf\")))) \"Elapsed time: 308.045 msecs\" 4000000 Once a type hint has been placed on an identifier or expression, the compiler will try to resolve any calls to methods thereupon at compile time. In addition, the compiler will track the use of any return values and infer types for their use and so on, so very few hints are needed to get a fully compile-time resolved series of calls. Note that type hints are not needed for static members (or their return values!) as the compiler always has the type for statics. There is a warn-on-reflection flag (defaults to false) which will cause the compiler to warn you when it can't resolve to a direct call: (set! warn-on-reflection true) -> true (defn foo [s] (.charAt s 1)) -> Reflection warning, line: 2 - call to charAt can't be resolved. -> #user/foo (defn foo [^String s] (.charAt s 1)) -> #user/foo For function return values, the type hint can be placed before the arguments vector: (defn hinted (^String []) (^Integer [a]) (^java.util.List [a & args])) -> #user/hinted Aliases Clojure provides aliases for primitive Java types and arrays which do not have typical representations as Java class names. For example, long arrays (long-array []) have a type of \"[J\". int - A primitive int ints - An int array long - A primitive long longs - A long array float - A primitive float floats - A float array double - A primitive double doubles - A double array void - A void return short - A primitive short shorts - A short array boolean - A primitive boolean booleans - A boolean array byte - A primitive byte bytes - A byte array char - A primitive character chars - A character array Support for Java Primitives Clojure has support for high-performance manipulation of, and arithmetic involving, Java primitive types in local contexts. All Java primitive types are supported: int, float, long, double, boolean, char, short, and byte. let/loop-bound locals can be of primitive types, having the inferred, possibly primitive type of their init-form. recur forms that rebind primitive locals do so without boxing, and do type-checking for same primitive type. Arithmetic (+,-,*,/,inc,dec,<,<=,>,>= etc) is overloaded for primitive types where semantics are same. aget/aset are overloaded for arrays of primitives aclone, alength functions for arrays of primitives constructor functions for primitive arrays: float-array, int-array, etc. Type hints for primitive arrays - ^ints, ^floats, etc. Coercion ops int, float, etc. produce primitives when consumer can take primitive The num coercion function boxes primitives to force generic arithmetic Array cast functions ints longs, etc. which produce int[], long[], etc. A set of \"unchecked\" operations for utmost performing, but potentially unsafe, integer (int/long) ops: unchecked-multiply unchecked-dec unchecked-inc unchecked-negate unchecked-add unchecked-subtract unchecked-remainder unchecked-divide A dynamic var to automatically swap safe operations with unchecked operations: *unchecked-math* amap and areduce macros for functionally (i.e. non-destructively) processing one or more arrays in order to produce a new array or aggregate value respectively. Rather than write this Java: static public float asum(float[] xs){ float ret = 0; for(int i = 0; i < xs.length; i++) ret += xs[i]; return ret; } you can write this Clojure: (defn asum [^floats xs] (areduce xs i ret (float 0) (+ ret (aget xs i)))) and the resulting code is exactly the same speed (when run with java -server). The best aspect of this is that you need not do anything special in your initial coding. Quite often these optimizations are unneeded. Should a bit of code be a bottleneck, you can speed it up with minor adornment: (defn foo [n] (loop [i 0] (if (< i n) (recur (inc i)) i))) (time (foo 100000)) \"Elapsed time: 0.391 msecs\" 100000 (defn foo2 [n] (let [n (int n)] (loop [i (int 0)] (if (< i n) (recur (inc i)) i)))) (time (foo2 100000)) \"Elapsed time: 0.084 msecs\" 100000 Coercions At times it is necessary to have a value of a particular primitive type. These coercion functions yield a value of the indicated type as long as such a coercion is possible: bigdec bigint boolean byte char double float int long num short Some optimization tips All arguments are passed to Clojure fns as objects, so there's no point to putting non-array primitive type hints on fn args. Instead, use the let technique shown to place args in primitive locals if they need to participate in primitive arithmetic in the body. (let [foo (int bar)] ...) is the correct way to get a primitive local. Do not use ^Integer etc. Don't rush to unchecked math unless you want truncating operations. HotSpot does a good job at optimizing the overflow check, which will yield an exception instead of silent truncation. On a typical example, that has about a 5% difference in speed - well worth it. Also, people reading your code don't know if you are using unchecked for truncation or performance - best to reserve it for the former and comment if the latter. There's usually no point in trying to optimize an outer loop, in fact it can hurt you as you'll be representing things as primitives which just have to be re-boxed in order to become args to the inner call. The only exception is reflection warnings - you must get rid of them in any code that gets called frequently. Almost every time someone presents something they are trying to optimize with hints, the faster version has far fewer hints than the original. If a hint doesn't improve things in the end - take it out. Many people seem to presume only the unchecked- ops do primitive arithmetic - not so. When the args are primitive locals, regular + and * etc do primitive math with an overflow check - fast and safe. So, the simplest route to fast math is to leave the operators alone and just make sure the source literals and locals are primitive. Arithmetic on primitives yields primitives. If you've got a loop (which you probably do if you need to optimize) make sure the loop locals are primitives first - then if you accidentally are producing a boxed intermediate result you'll get an error on recur. Don't solve that error by coercing your intermediate result, instead, figure out what argument or local is not primitive. Simple XML Support Included with the distribution is simple XML support, found in the src/xml.clj file. All names from this file are in the xml namespace. (parse source) Parses and loads the source, which can be a File, InputStream or String naming a URI. Returns a tree of the xml/element struct-map, which has the keys :tag, :attrs, and :content. and accessor fns tag, attrs, and content. (xml/parse \"/Users/rich/dev/clojure/build.xml\") -> {:tag :project, :attrs {:name \"clojure\", :default \"jar\"}, :content [{:tag :description, ... Calling Clojure From Java The clojure.java.api package provides a minimal interface to bootstrap Clojure access from other JVM languages. It does this by providing: The ability to use Clojure's namespaces to locate an arbitrary var, returning the var's clojure.lang.IFn interface. A convenience method read for reading data using Clojure's edn reader IFns provide complete access to Clojure's APIs. You can also access any other library written in Clojure, after adding either its source or compiled form to the classpath. The public Java API for Clojure consists of the following classes and interfaces: clojure.java.api.Clojure clojure.lang.IFn All other Java classes should be treated as implementation details, and applications should avoid relying on them. To lookup and call a Clojure function: IFn plus = Clojure.var(\"clojure.core\", \"+\"); plus.invoke(1, 2); Functions in clojure.core are automatically loaded. Other namespaces can be loaded via require: IFn require = Clojure.var(\"clojure.core\", \"require\"); require.invoke(Clojure.read(\"clojure.set\")); IFns can be passed to higher order functions, e.g. the example below passes plus to read: IFn map = Clojure.var(\"clojure.core\", \"map\"); IFn inc = Clojure.var(\"clojure.core\", \"inc\"); map.invoke(inc, Clojure.read(\"[1 2 3]\")); Most IFns in Clojure refer to functions. A few, however, refer to non-function data values. To access these, use deref instead of fn: IFn printLength = Clojure.var(\"clojure.core\", \" print-length \"); IFn deref = Clojure.var(\"clojure.core\", \"deref\"); deref.invoke(printLength);","title":"From http://clojure.org/java_interop"},{"location":"reference/clojure-syntax/naming/","text":"Naming \u03bb\ufe0e Naming when requiring other namespaces \u03bb\ufe0e (require [cheshire.core :refer :all]) is an example of self-inflicted errors, as this library included a contains? function that will over-write the clojure.core/contains? function when using :refer :all or the (use ) expression. This situation is one example of why :refer :all and use are not recommended and can cause lots of debugging headaches. If a namespace is predominantly about using a specific library, then refer specific functions as they are used within the current namespace ( ns current.namespace ( :require [ cheshire.core :refer [ function-name another-function etc ])) Hint::clj-kondo lint tool shows unused functions \u03bb\ufe0e Using clj-kondo A classic example is a test namespace that uses clojure core (ns practicalli.random-function-test (:require [clojure.test :refer [deftest is testing]] [practicalli.random-function :as sut])) Otherwise use a meaningful alias, ideally referring to what that library is doing (which makes it easer to swap out with a different library later on if required). As Cheshire is a JSON related library, then (ns my.ns (:require [cheshire.core :as json])) This gives a context to all the functions called from that library and makes code easier for humans to understand.","title":"Naming"},{"location":"reference/clojure-syntax/naming/#naming","text":"","title":"Naming"},{"location":"reference/clojure-syntax/naming/#naming-when-requiring-other-namespaces","text":"(require [cheshire.core :refer :all]) is an example of self-inflicted errors, as this library included a contains? function that will over-write the clojure.core/contains? function when using :refer :all or the (use ) expression. This situation is one example of why :refer :all and use are not recommended and can cause lots of debugging headaches. If a namespace is predominantly about using a specific library, then refer specific functions as they are used within the current namespace ( ns current.namespace ( :require [ cheshire.core :refer [ function-name another-function etc ]))","title":"Naming when requiring other namespaces"},{"location":"reference/clojure-syntax/naming/#hintclj-kondo-lint-tool-shows-unused-functions","text":"Using clj-kondo A classic example is a test namespace that uses clojure core (ns practicalli.random-function-test (:require [clojure.test :refer [deftest is testing]] [practicalli.random-function :as sut])) Otherwise use a meaningful alias, ideally referring to what that library is doing (which makes it easer to swap out with a different library later on if required). As Cheshire is a JSON related library, then (ns my.ns (:require [cheshire.core :as json])) This gives a context to all the functions called from that library and makes code easier for humans to understand.","title":"Hint::clj-kondo lint tool shows unused functions"},{"location":"reference/clojure-syntax/numbers-maths/","text":"Maths \u03bb\ufe0e Fixme Split this into sections ? Writing some simple mathematics helps you get used to the form of Clojure. Unlike other languages, Clojure does not have operators for mathematics. Instead + - * / are all functions in their own right. As Clojure uses pre-fix notation then mathematical expressions are always unambiguous. There is no need for an operator precedence table in Clojure. Note Write some simple math to help you get used to the form of Clojure ( + 1 2 3 4 5 6 7 ) ( - 2 1 ) ( * 3 7 ) ( / 12 4 ) ( / 500 20 ) ( + 1 1 2489 459 2 . ) ( + 1 2 ( * 3 4 ) ( - 5 6 -7 )) Variable numbers of arguments \u03bb\ufe0e Mathematic functions show the flexibility of Clojure, as they take a variable number of arguments (variadic functions). Its common for Clojure functions to have zero, one or many arguments (many arguments typically represented as a built-in data structure (map, vector, set or list) Note Write some more maths to show the variadic nature of mathematic (and manu other) functions ( + ) ( * ) ( * 2 ) ( + 4 ) ( + 1 2 3 ) ( < 1 2 3 ) ( < 1 3 8 4 ) Note Explore some number related functions ( rem 22 7 ) ( mod 20 12 ) ( quot 13 4 ) ( inc 3 ) ( dec 4 ) ( min 1 2 3 5 8 13 ) ( max 1 2 3 5 8 13 ) ( repeat 4 9 ) ( range 10 ) ( range 18 66 ) ( range 2 99 2 ) Equality \u03bb\ufe0e Equality is represented by the = function. Yes, = is a proper function too, not just an operator as with other languages. Note Explore what equality means in Clojure. Equality is very useful when your data structures are immutable ( = 1 1 ) ( = 2 1 ) ( identical? \"foo\" \"bar\" ) ( identical? \"foo\" \"foo\" ) ( = \"foo\" \"bar\" ) ( = \"foo\" \"foo\" ) ( identical? :foo :bar ) ( identical? :foo :foo ) ( true ) ( false ) ( not true ) ( true? ( = 1 1 )) ( false ( = 1 -1 )) Equality is very efficient when your data structures are immutable. For example if you have very large data sets, you can simply compare a hash value to see if those data structures are the same. Of course you also have the not function for reversing logic too ( not true ) => false Boolean - True and False \u03bb\ufe0e ;; some truthiness with math functions for you to try ( + ) ( class ( + )) ( * ) ( true? + ) ( false? + ) ( true? * ) ( false? * ) ( true? 1 ) ( true? -1 ) ( true? true ) ( - 2 ) Boolean & Predicates \u03bb\ufe0e Predicates are functions that take a value and return a boolean result (true | false) ( true? true ) ( true? ( not true )) ( true? false ) ( true? ( not false )) ( true? nil ) Types \u03bb\ufe0e Clojure uses Java's object types for booleans, strings and numbers. Use the class function to inspect them. ( class 1 ) ; Integer literals are java.lang.Long by default ( class 1.1 ) ; Float literals are java.lang.Double ( class \"\" ) ; Strings always double-quoted, and are java.lang.String ( class false ) ; Booleans are java.lang.Boolean ( class nil ) ; The \"null\" value is called nil ( class ( list 1 2 3 4 )) ( class true ) ( class ()) ( class ( list 1 2 34 5 )) ( class ( str 2 3 4 5 )) ( class ( + 22/7 )) ( class 5 ) ( class \"fish\" ) ( type [ 1 2 3 ]) ( type { :a 1 :b 2 }) ( type ( take 3 ( range 10 ))) Ratios \u03bb\ufe0e To help maintain the precision of numbers, Clojure has a type called Ratio. So when you are dividing numbers you can keep the as a fraction using whole numbers, rather than constrain the result to a approximate ( / 2 ) A classic example is dividing 22 by 7 which is approximately the value of Pi ( / 22 7 ) ( class ( / 22 7 )) If you want to force Clojure to evaluate this then you can specify one of the numbers with a decimal point ( class ( / 22 7.0 ))","title":"Maths"},{"location":"reference/clojure-syntax/numbers-maths/#maths","text":"Fixme Split this into sections ? Writing some simple mathematics helps you get used to the form of Clojure. Unlike other languages, Clojure does not have operators for mathematics. Instead + - * / are all functions in their own right. As Clojure uses pre-fix notation then mathematical expressions are always unambiguous. There is no need for an operator precedence table in Clojure. Note Write some simple math to help you get used to the form of Clojure ( + 1 2 3 4 5 6 7 ) ( - 2 1 ) ( * 3 7 ) ( / 12 4 ) ( / 500 20 ) ( + 1 1 2489 459 2 . ) ( + 1 2 ( * 3 4 ) ( - 5 6 -7 ))","title":"Maths"},{"location":"reference/clojure-syntax/numbers-maths/#variable-numbers-of-arguments","text":"Mathematic functions show the flexibility of Clojure, as they take a variable number of arguments (variadic functions). Its common for Clojure functions to have zero, one or many arguments (many arguments typically represented as a built-in data structure (map, vector, set or list) Note Write some more maths to show the variadic nature of mathematic (and manu other) functions ( + ) ( * ) ( * 2 ) ( + 4 ) ( + 1 2 3 ) ( < 1 2 3 ) ( < 1 3 8 4 ) Note Explore some number related functions ( rem 22 7 ) ( mod 20 12 ) ( quot 13 4 ) ( inc 3 ) ( dec 4 ) ( min 1 2 3 5 8 13 ) ( max 1 2 3 5 8 13 ) ( repeat 4 9 ) ( range 10 ) ( range 18 66 ) ( range 2 99 2 )","title":"Variable numbers of arguments"},{"location":"reference/clojure-syntax/numbers-maths/#equality","text":"Equality is represented by the = function. Yes, = is a proper function too, not just an operator as with other languages. Note Explore what equality means in Clojure. Equality is very useful when your data structures are immutable ( = 1 1 ) ( = 2 1 ) ( identical? \"foo\" \"bar\" ) ( identical? \"foo\" \"foo\" ) ( = \"foo\" \"bar\" ) ( = \"foo\" \"foo\" ) ( identical? :foo :bar ) ( identical? :foo :foo ) ( true ) ( false ) ( not true ) ( true? ( = 1 1 )) ( false ( = 1 -1 )) Equality is very efficient when your data structures are immutable. For example if you have very large data sets, you can simply compare a hash value to see if those data structures are the same. Of course you also have the not function for reversing logic too ( not true ) => false","title":"Equality"},{"location":"reference/clojure-syntax/numbers-maths/#boolean-true-and-false","text":";; some truthiness with math functions for you to try ( + ) ( class ( + )) ( * ) ( true? + ) ( false? + ) ( true? * ) ( false? * ) ( true? 1 ) ( true? -1 ) ( true? true ) ( - 2 )","title":"Boolean - True and False"},{"location":"reference/clojure-syntax/numbers-maths/#boolean-predicates","text":"Predicates are functions that take a value and return a boolean result (true | false) ( true? true ) ( true? ( not true )) ( true? false ) ( true? ( not false )) ( true? nil )","title":"Boolean &amp; Predicates"},{"location":"reference/clojure-syntax/numbers-maths/#types","text":"Clojure uses Java's object types for booleans, strings and numbers. Use the class function to inspect them. ( class 1 ) ; Integer literals are java.lang.Long by default ( class 1.1 ) ; Float literals are java.lang.Double ( class \"\" ) ; Strings always double-quoted, and are java.lang.String ( class false ) ; Booleans are java.lang.Boolean ( class nil ) ; The \"null\" value is called nil ( class ( list 1 2 3 4 )) ( class true ) ( class ()) ( class ( list 1 2 34 5 )) ( class ( str 2 3 4 5 )) ( class ( + 22/7 )) ( class 5 ) ( class \"fish\" ) ( type [ 1 2 3 ]) ( type { :a 1 :b 2 }) ( type ( take 3 ( range 10 )))","title":"Types"},{"location":"reference/clojure-syntax/numbers-maths/#ratios","text":"To help maintain the precision of numbers, Clojure has a type called Ratio. So when you are dividing numbers you can keep the as a fraction using whole numbers, rather than constrain the result to a approximate ( / 2 ) A classic example is dividing 22 by 7 which is approximately the value of Pi ( / 22 7 ) ( class ( / 22 7 )) If you want to force Clojure to evaluate this then you can specify one of the numbers with a decimal point ( class ( / 22 7.0 ))","title":"Ratios"},{"location":"reference/clojure-syntax/parenthesis/","text":"Parenthesis - defining the structure of Clojure code \u03bb\ufe0e Clojure uses parenthesis, round brackets () , as a simple way to define the structure of the code and provide clear and unambiguous scope. This structure is the syntax of symbolic expressions . Parenthesis, or parens for short, are used to define and call functions in our code, include libraries and in fact any behavior we wish to express. Clojure includes 3 other bracket types to specifically identify data: '() quoted lists and sequences, [] for vectors (arrays) and argument lists, {} for hash-maps and #{} for sets of data. No other terminators or precedence rules are required to understand how to read and write Clojure. The Parenthesis hangup \u03bb\ufe0e Some raise the concern that there are \"too many brackets\" in Clojure. Clojure doesn't require any additional parens compared to other languages, it simply moves the open parens to the start of the expression giving a clearly defined structure to the code With support for higher order functions, functional composition and threading macros, Clojure code typically uses fewer parens than other languages especially as the scope of the problem space grows. All languages use parens to wrap a part of an expression, requiring additional syntax to identify the boundaries of each expression so it can be parsed by humans and computers alike. Clojure uses a single way to express everything, homoiconicity, where as most other languages require additional syntax for different parts of the code. Using parens, Clojure has a well defined structure that provides a clearly defined scope to every part of the code. There is no requirement to remember a long list of ad-hoc precedence rules, e.g. JavaScript operator precedence . This structure of Clojure code is simple to parse for both humans and computers. it is simple to navigate, simple to avoid breaking the syntax of the language and simple to provide tooling that keeps the syntax of the code correct. After realising the simplicity that parens bring, you have to wonder why other (non-lisp) languages made their syntax more complex. Working with Parens \u03bb\ufe0e Clojure aware editors all support structured editing to manage parens and ensure they remain balanced (same number of open and close parens). A developer only needs to type the open paren and the editor will automatically add the closing paren. Parens cannot be deleted unless their content is empty. Code can be pulled into parens (slurp) or pushed out of parens (barf). Code can be split, joined, wrapped, unwrapped, transposed, convoluted and raised, all without breaking the structure. Smartparens for Structural editing - a modern update of ParEdit The animated guide to ParEdit Homoiconicity and Macros \u03bb\ufe0e Clojure is a dialect of LISP and naturally was designed to be a homoiconic language. This means the syntax for behavior and data is the same. This greatly simplifies the syntax of Clojure and all LISP style languages. The Clojure Reader is a parser that reads in data structures as expression, rather than parsing of text required by other languages. The result of parsing is a collection of data structures that can be traversed (asymmetric syntax tree - AST). Compared to most languages the compiler does very little and you can consider Clojure really does not have a syntax. Code is written as data structures that are accessible to the other parts of the code, providing a way to write code that manipulate those data structures and generate new code. In Clojure this type of code is called a macro, a piece of code that writes new code. None of this would work as simply as it does without using parens and the symbolic expression syntax. Inspired by Beating the Averages by Paul Graham Example: Function invocation \u03bb\ufe0e The choice was made early in the design of Lisp that lists would be used for function invocation in the form: ( function arg1 arg2 arg3 ) ;; => value returned The advantages of this design are: a function call is just one expression, called a \"form\" function calls can be constructed (cons function-symbol list-of-args) functions can be arguments to other functions (higher order functions) simple syntax to parse - everything between two parentheses is a self-contained expression. fewer parens due to high order functions, composition and threading macros The function name could have been put outside the parentheses: function (arg1 arg2 arg3) => some result This design has many disadvantages: a function call is no longer a single form and have to pass the function name and the argument list. syntax is complex and requires additional syntax rules to define a function call code generation is very complex same number of parens as Clojure or possibly more (no direct support for higher order functions)","title":"Parenthesis - defining the structure of Clojure code"},{"location":"reference/clojure-syntax/parenthesis/#parenthesis-defining-the-structure-of-clojure-code","text":"Clojure uses parenthesis, round brackets () , as a simple way to define the structure of the code and provide clear and unambiguous scope. This structure is the syntax of symbolic expressions . Parenthesis, or parens for short, are used to define and call functions in our code, include libraries and in fact any behavior we wish to express. Clojure includes 3 other bracket types to specifically identify data: '() quoted lists and sequences, [] for vectors (arrays) and argument lists, {} for hash-maps and #{} for sets of data. No other terminators or precedence rules are required to understand how to read and write Clojure.","title":"Parenthesis - defining the structure of Clojure code"},{"location":"reference/clojure-syntax/parenthesis/#the-parenthesis-hangup","text":"Some raise the concern that there are \"too many brackets\" in Clojure. Clojure doesn't require any additional parens compared to other languages, it simply moves the open parens to the start of the expression giving a clearly defined structure to the code With support for higher order functions, functional composition and threading macros, Clojure code typically uses fewer parens than other languages especially as the scope of the problem space grows. All languages use parens to wrap a part of an expression, requiring additional syntax to identify the boundaries of each expression so it can be parsed by humans and computers alike. Clojure uses a single way to express everything, homoiconicity, where as most other languages require additional syntax for different parts of the code. Using parens, Clojure has a well defined structure that provides a clearly defined scope to every part of the code. There is no requirement to remember a long list of ad-hoc precedence rules, e.g. JavaScript operator precedence . This structure of Clojure code is simple to parse for both humans and computers. it is simple to navigate, simple to avoid breaking the syntax of the language and simple to provide tooling that keeps the syntax of the code correct. After realising the simplicity that parens bring, you have to wonder why other (non-lisp) languages made their syntax more complex.","title":"The Parenthesis hangup"},{"location":"reference/clojure-syntax/parenthesis/#working-with-parens","text":"Clojure aware editors all support structured editing to manage parens and ensure they remain balanced (same number of open and close parens). A developer only needs to type the open paren and the editor will automatically add the closing paren. Parens cannot be deleted unless their content is empty. Code can be pulled into parens (slurp) or pushed out of parens (barf). Code can be split, joined, wrapped, unwrapped, transposed, convoluted and raised, all without breaking the structure. Smartparens for Structural editing - a modern update of ParEdit The animated guide to ParEdit","title":"Working with Parens"},{"location":"reference/clojure-syntax/parenthesis/#homoiconicity-and-macros","text":"Clojure is a dialect of LISP and naturally was designed to be a homoiconic language. This means the syntax for behavior and data is the same. This greatly simplifies the syntax of Clojure and all LISP style languages. The Clojure Reader is a parser that reads in data structures as expression, rather than parsing of text required by other languages. The result of parsing is a collection of data structures that can be traversed (asymmetric syntax tree - AST). Compared to most languages the compiler does very little and you can consider Clojure really does not have a syntax. Code is written as data structures that are accessible to the other parts of the code, providing a way to write code that manipulate those data structures and generate new code. In Clojure this type of code is called a macro, a piece of code that writes new code. None of this would work as simply as it does without using parens and the symbolic expression syntax. Inspired by Beating the Averages by Paul Graham","title":"Homoiconicity and Macros"},{"location":"reference/clojure-syntax/parenthesis/#example-function-invocation","text":"The choice was made early in the design of Lisp that lists would be used for function invocation in the form: ( function arg1 arg2 arg3 ) ;; => value returned The advantages of this design are: a function call is just one expression, called a \"form\" function calls can be constructed (cons function-symbol list-of-args) functions can be arguments to other functions (higher order functions) simple syntax to parse - everything between two parentheses is a self-contained expression. fewer parens due to high order functions, composition and threading macros The function name could have been put outside the parentheses: function (arg1 arg2 arg3) => some result This design has many disadvantages: a function call is no longer a single form and have to pass the function name and the argument list. syntax is complex and requires additional syntax rules to define a function call code generation is very complex same number of parens as Clojure or possibly more (no direct support for higher order functions)","title":"Example: Function invocation"},{"location":"reference/clojure-syntax/private-functions/","text":"Private functions \u03bb\ufe0e Fixme work in progress","title":"Private functions"},{"location":"reference/clojure-syntax/private-functions/#private-functions","text":"Fixme work in progress","title":"Private functions"},{"location":"reference/clojure-syntax/quick-look-at-types/","text":"A quick look at types \u03bb\ufe0e As we mentioned before, underneath Clojure lurks Java byte code so there are going to be types in Clojure. However, Clojure being a dynamic language, most of the time you can just let Clojure manage the types for you. Hint When you run Clojure on a different host platform, eg. .Net or Javascript (via Clojurescript), Clojure will use the types of that host platform. Should you want to know the type of something you are working on, you can use two functions, type and class . Note Discover the class or type of some common Clojure code ( class 1 ) ( class 1.1 ) ( class \"\" ) ( class true ) ( class false ) ( class nil ) ( class ()) ( class ( list 1 2 3 4 )) ( class ( str 2 3 4 5 )) ( class ( + 22/7 )) ( type [ 1 2 3 ]) ( type { :a 1 :b 2 }) ( type ( take 3 ( range 10 ))) Hint If you cant live without static type checking, look at core.typed , a type system for Clojure all in one library","title":"A quick look at types"},{"location":"reference/clojure-syntax/quick-look-at-types/#a-quick-look-at-types","text":"As we mentioned before, underneath Clojure lurks Java byte code so there are going to be types in Clojure. However, Clojure being a dynamic language, most of the time you can just let Clojure manage the types for you. Hint When you run Clojure on a different host platform, eg. .Net or Javascript (via Clojurescript), Clojure will use the types of that host platform. Should you want to know the type of something you are working on, you can use two functions, type and class . Note Discover the class or type of some common Clojure code ( class 1 ) ( class 1.1 ) ( class \"\" ) ( class true ) ( class false ) ( class nil ) ( class ()) ( class ( list 1 2 3 4 )) ( class ( str 2 3 4 5 )) ( class ( + 22/7 )) ( type [ 1 2 3 ]) ( type { :a 1 :b 2 }) ( type ( take 3 ( range 10 ))) Hint If you cant live without static type checking, look at core.typed , a type system for Clojure all in one library","title":"A quick look at types"},{"location":"reference/clojure-syntax/ratios/","text":"Ratios \u03bb\ufe0e In mathematics you need to ensure that you manage precision of your calculations when you are dividing numbers. Once you create a decimal number then everything it touches had a greater potential to becoming a decimal. Note Calculate a rough approximation to Pi by dividing 22 by 7 (/ 22 7) (class (/ 22 7)) (/ (* 22/7 3) 3) If the result of an integer calculation would be a decimal number, then Clojure holds the value as a Ratio. This is one example of lazy evaluation. Rather than calculate the decimal value at some particular precision (number of decimal points). Clojure is saving the calculation until its needed, at which time the specific precision required should be known. Note Explore the ratio type further and see how to get a decimal value as the result ( / 14 4 ) ( / 16 12 ) ( / 2 ) ( / 22 7.0 ) ( type ( / 22 7.0 )) ( float ( / 22 7 )) ( double ( / 22 7 )) When one or more of the numbers in the division is a decimal, then Clojure will return a decimal value. Or you can coerce a value to a specific decimal type, eg. float or double.","title":"Ratios"},{"location":"reference/clojure-syntax/ratios/#ratios","text":"In mathematics you need to ensure that you manage precision of your calculations when you are dividing numbers. Once you create a decimal number then everything it touches had a greater potential to becoming a decimal. Note Calculate a rough approximation to Pi by dividing 22 by 7 (/ 22 7) (class (/ 22 7)) (/ (* 22/7 3) 3) If the result of an integer calculation would be a decimal number, then Clojure holds the value as a Ratio. This is one example of lazy evaluation. Rather than calculate the decimal value at some particular precision (number of decimal points). Clojure is saving the calculation until its needed, at which time the specific precision required should be known. Note Explore the ratio type further and see how to get a decimal value as the result ( / 14 4 ) ( / 16 12 ) ( / 2 ) ( / 22 7.0 ) ( type ( / 22 7.0 )) ( float ( / 22 7 )) ( double ( / 22 7 )) When one or more of the numbers in the division is a decimal, then Clojure will return a decimal value. Or you can coerce a value to a specific decimal type, eg. float or double.","title":"Ratios"},{"location":"reference/clojure-syntax/strings/","text":"Strings \u03bb\ufe0e Strings in Clojure are actually Java Strings. Hint Why do you think this design decision was taken for Clojure? If you think about the state property of String objects, then you realise that String Objects are immutable and cannot be changed. As this is the default approach for other data structures and values in Clojure it makes sense to use Java Strings instead of writing a Clojure implementation. As Clojure strings are Java strings, then you can use all the same functions you can in Java. Note Use the Java function println to output a string ( println \"Hello, whats different with me? What value do I return\" ) Something different happens when you evaluate this expression. The actual value returned is nil , not the string. You see the string because println is writing to the console (i.e the REPL). Hint Avoid code that creates side-effects where possible to keep your software less complex to understand. You may be used to using println statements to help you debug your code, however, with the fast feedback you get from developing in the REPL then there is usually no need for them. Strings the Clojure way \u03bb\ufe0e Its more common to use the str function when working with strings, as this function returns the string as its. value when evaluated. (str \"Hello, I am returned as a value of this expression\") Note Join strings together with the function str ( str \"I\" \"like\" \"to\" \"be\" \"close\" \"together\" ( str \"Hello\" \", \" \"Devoxx UK\" ) ( str \"Hello \" \"developers\" \", \" \"welcome\" \" \" \"to\" \" \" \"HackTheTower UK\" ) You can see that there are no side-effects when using str and the string is returned as the value of the function call. Using Interpose with Strings \u03bb\ufe0e Its easy to join strings together with the str function, however str leaves no spaces between words. Using Regex \u03bb\ufe0e Java Interop for Strings \u03bb\ufe0e Note Change the case of strings and other common actions using the String object methods, in the form (.methodName object) ( .toUpperCase \"show me the money\" ) ( .getName String ) ( .indexOf \"Where is the $ in this string\" \"$\" ) Hint Look at the API docs for java.lang.String for other methods you can call.","title":"Strings"},{"location":"reference/clojure-syntax/strings/#strings","text":"Strings in Clojure are actually Java Strings. Hint Why do you think this design decision was taken for Clojure? If you think about the state property of String objects, then you realise that String Objects are immutable and cannot be changed. As this is the default approach for other data structures and values in Clojure it makes sense to use Java Strings instead of writing a Clojure implementation. As Clojure strings are Java strings, then you can use all the same functions you can in Java. Note Use the Java function println to output a string ( println \"Hello, whats different with me? What value do I return\" ) Something different happens when you evaluate this expression. The actual value returned is nil , not the string. You see the string because println is writing to the console (i.e the REPL). Hint Avoid code that creates side-effects where possible to keep your software less complex to understand. You may be used to using println statements to help you debug your code, however, with the fast feedback you get from developing in the REPL then there is usually no need for them.","title":"Strings"},{"location":"reference/clojure-syntax/strings/#strings-the-clojure-way","text":"Its more common to use the str function when working with strings, as this function returns the string as its. value when evaluated. (str \"Hello, I am returned as a value of this expression\") Note Join strings together with the function str ( str \"I\" \"like\" \"to\" \"be\" \"close\" \"together\" ( str \"Hello\" \", \" \"Devoxx UK\" ) ( str \"Hello \" \"developers\" \", \" \"welcome\" \" \" \"to\" \" \" \"HackTheTower UK\" ) You can see that there are no side-effects when using str and the string is returned as the value of the function call.","title":"Strings the Clojure way"},{"location":"reference/clojure-syntax/strings/#using-interpose-with-strings","text":"Its easy to join strings together with the str function, however str leaves no spaces between words.","title":"Using Interpose with Strings"},{"location":"reference/clojure-syntax/strings/#using-regex","text":"","title":"Using Regex"},{"location":"reference/clojure-syntax/strings/#java-interop-for-strings","text":"Note Change the case of strings and other common actions using the String object methods, in the form (.methodName object) ( .toUpperCase \"show me the money\" ) ( .getName String ) ( .indexOf \"Where is the $ in this string\" \"$\" ) Hint Look at the API docs for java.lang.String for other methods you can call.","title":"Java Interop for Strings"},{"location":"reference/clojure-syntax/syntax/","text":"Clojure syntax \u03bb\ufe0e Clojure is perceived as having an abundance of () , the symbols that represent a list. As Clojure is a LISP (List Processing) language then everything is written in the form of a list. This makes Clojure very powerful and also easier to read. Using a list structure also demonstrates the data-centric nature of Clojure. Every item in the list has a value, with the first item evaluated by a function call. Hint::Parens everywhere \u03bb\ufe0e The seemingly abundance of () can be confusing until its realized there are fewer \"special characters\" in Clojure than other languages. Clojure aware editors support matching parens, adding a closed paren when typing an open paren, ensuring it is easy to write correctly formed Clojure. Syntax differences are a trivial reason to avoid trying Clojure. Syntax aware editors significantly reduce typing by automatically closing parenthesis and eliminating errors due to missing delimiters (ie. no more errors due to missing ; in C-based languages) Prefix notation \u03bb\ufe0e Instead of having a mix of notations like in many other languages, Clojure uses pre-fix notation entirely. In Clojure operators are applied uniformly and there is no room for ambiguity: ( + 1 2 3 5 8 13 21 ) ( + 1 2 ( - 4 1 ) 5 ( * 2 4 ) 13 ( / 42 2 )) ( str \"Clojure\" \" uses \" \"prefix notation\" ) In Java and other C-based languages you have to explicitly add operators everywhere and there can be a mixture of notations ( 1 + 2 + 3 + 5 + 8 + 13 + 21 ); ( 1 + 2 + ( - 4 1 ) + 5 + ( * 2 4 ) + 13 + ( / 42 2 )); StringBuffer description = new StringBuffer ( \"C-based languages\" + \" mix \" + \"notation\" ); x += 1 ; x ++ ; x -- ; x += y ; x -= y ; x *= y ; x /= y ; References \u03bb\ufe0e Clojure Style Guide","title":"Clojure syntax"},{"location":"reference/clojure-syntax/syntax/#clojure-syntax","text":"Clojure is perceived as having an abundance of () , the symbols that represent a list. As Clojure is a LISP (List Processing) language then everything is written in the form of a list. This makes Clojure very powerful and also easier to read. Using a list structure also demonstrates the data-centric nature of Clojure. Every item in the list has a value, with the first item evaluated by a function call.","title":"Clojure syntax"},{"location":"reference/clojure-syntax/syntax/#hintparens-everywhere","text":"The seemingly abundance of () can be confusing until its realized there are fewer \"special characters\" in Clojure than other languages. Clojure aware editors support matching parens, adding a closed paren when typing an open paren, ensuring it is easy to write correctly formed Clojure. Syntax differences are a trivial reason to avoid trying Clojure. Syntax aware editors significantly reduce typing by automatically closing parenthesis and eliminating errors due to missing delimiters (ie. no more errors due to missing ; in C-based languages)","title":"Hint::Parens everywhere"},{"location":"reference/clojure-syntax/syntax/#prefix-notation","text":"Instead of having a mix of notations like in many other languages, Clojure uses pre-fix notation entirely. In Clojure operators are applied uniformly and there is no room for ambiguity: ( + 1 2 3 5 8 13 21 ) ( + 1 2 ( - 4 1 ) 5 ( * 2 4 ) 13 ( / 42 2 )) ( str \"Clojure\" \" uses \" \"prefix notation\" ) In Java and other C-based languages you have to explicitly add operators everywhere and there can be a mixture of notations ( 1 + 2 + 3 + 5 + 8 + 13 + 21 ); ( 1 + 2 + ( - 4 1 ) + 5 + ( * 2 4 ) + 13 + ( / 42 2 )); StringBuffer description = new StringBuffer ( \"C-based languages\" + \" mix \" + \"notation\" ); x += 1 ; x ++ ; x -- ; x += y ; x -= y ; x *= y ; x /= y ;","title":"Prefix notation"},{"location":"reference/clojure-syntax/syntax/#references","text":"Clojure Style Guide","title":"References"},{"location":"reference/clojure-syntax/threading-syntactic-sugar/","text":"Threading Syntax Sugar \u03bb\ufe0e The previous code is written in classic Lisp style. When you come to read Lisp, you start from the inside out. In this case you start with (slurp ...) and what it returns is used as the argument to (read-string ...) and so on... In our minds we probably constructed the following basic algorithm: * Get the contents of the project.clj file using slurp * Read the text of that file using read-string * Select just the third string using nth 2 (using an index starting at 0) Can we rewrite our Clojure code to fit the way we think? Thread first macro \u03bb\ufe0e Using the thread-first macro -> we can chain Clojure functions together with a terser syntax, passing the result of the first evaluation as the first argument to the next function and so on. Using this style, we can write code that matches the algorithm in our head. To make this really simple lets create a contrived example of the threading macro. Here we use the str function to join strings together. Each individual str function joins its own strings together, passing the resulting string as the first argument to the next function. ( -> ( str \"This\" \" \" \"is\" \" \" ) ( str \"the\" \" \" \"threading\" \" \" \"macro\" ) ( str \"in\" \" \" \"action.\" )) ;; => \"This is the threading macro in action\" Thread-last macro \u03bb\ufe0e Using the thread-last macro, ->> , the result of a function is passed as the last argument of the next function call. So in another simple series of str function calls, our text comes out backwards. ( ->> ( str \" This\" ) ( str \" is\" ) ( str \" backwards\" )) ;; => backwards is This\" \u03bb\ufe0e Note Refactor the Clojure code using the thread-first macro ( -> \"./project.clj\" slurp read-string ( nth 2 )) Hint The \"project.clj\" is a string, so when you evaluate it as an expression, it simply returns the same string. That string is then passed as an argument to any following functions. Using the threading macro, the result of every function is passed onto the next function in the list. This can be seen very clearly using ,,, to denote where the value is passed to the next function ( -> \"project.clj\" slurp ,,, read-string ,,, ( nth ,,, 2 )) Hint Commas in clojure are treated as whitespace, they are simply ignored when it comes to evaluating code. Typically commas are rarely used and only to help human readability of the code Note Create a new map that contains the project configuration for the current project ( ->> \"project.clj\" slurp read-string ( drop 2 ) ( cons :version ) ( apply hash-map ) ( def project-configs )) ;; Evaluate the new map defined as project project We pull out the map of project information using slurp , tidy the text up using read-string and drop the first two elements (defproject playground). This returns a list that we want to turn into a map, but first we need to add a key to the version number. Using the cons function we can add an element to the start of the list, in this case the :version keyword Now we can successfully convert the list that is returned into a map, with balanced key-value pairs. Then we simply create a name for this new map, project-configs , so we can refer to it elsewhere in the code. Hint The slurp function holds the contents of the whole file in memory, so it may not be appropriate for very large files. If you are dealing with a large file, consider wrapping slurp in a lazy evaluation or use Java IO (eg. java.io.BufferedReader , java.io.FileReader. ). See the Clojure I/O cookbook and The Ins & Outs of Clojure for examples.","title":"Threading Syntax Sugar"},{"location":"reference/clojure-syntax/threading-syntactic-sugar/#threading-syntax-sugar","text":"The previous code is written in classic Lisp style. When you come to read Lisp, you start from the inside out. In this case you start with (slurp ...) and what it returns is used as the argument to (read-string ...) and so on... In our minds we probably constructed the following basic algorithm: * Get the contents of the project.clj file using slurp * Read the text of that file using read-string * Select just the third string using nth 2 (using an index starting at 0) Can we rewrite our Clojure code to fit the way we think?","title":"Threading Syntax Sugar"},{"location":"reference/clojure-syntax/threading-syntactic-sugar/#thread-first-macro","text":"Using the thread-first macro -> we can chain Clojure functions together with a terser syntax, passing the result of the first evaluation as the first argument to the next function and so on. Using this style, we can write code that matches the algorithm in our head. To make this really simple lets create a contrived example of the threading macro. Here we use the str function to join strings together. Each individual str function joins its own strings together, passing the resulting string as the first argument to the next function. ( -> ( str \"This\" \" \" \"is\" \" \" ) ( str \"the\" \" \" \"threading\" \" \" \"macro\" ) ( str \"in\" \" \" \"action.\" )) ;; => \"This is the threading macro in action\"","title":"Thread first macro"},{"location":"reference/clojure-syntax/threading-syntactic-sugar/#thread-last-macro","text":"Using the thread-last macro, ->> , the result of a function is passed as the last argument of the next function call. So in another simple series of str function calls, our text comes out backwards. ( ->> ( str \" This\" ) ( str \" is\" ) ( str \" backwards\" )) ;; => backwards is This\"","title":"Thread-last macro"},{"location":"reference/clojure-syntax/threading-syntactic-sugar/#_1","text":"Note Refactor the Clojure code using the thread-first macro ( -> \"./project.clj\" slurp read-string ( nth 2 )) Hint The \"project.clj\" is a string, so when you evaluate it as an expression, it simply returns the same string. That string is then passed as an argument to any following functions. Using the threading macro, the result of every function is passed onto the next function in the list. This can be seen very clearly using ,,, to denote where the value is passed to the next function ( -> \"project.clj\" slurp ,,, read-string ,,, ( nth ,,, 2 )) Hint Commas in clojure are treated as whitespace, they are simply ignored when it comes to evaluating code. Typically commas are rarely used and only to help human readability of the code Note Create a new map that contains the project configuration for the current project ( ->> \"project.clj\" slurp read-string ( drop 2 ) ( cons :version ) ( apply hash-map ) ( def project-configs )) ;; Evaluate the new map defined as project project We pull out the map of project information using slurp , tidy the text up using read-string and drop the first two elements (defproject playground). This returns a list that we want to turn into a map, but first we need to add a key to the version number. Using the cons function we can add an element to the start of the list, in this case the :version keyword Now we can successfully convert the list that is returned into a map, with balanced key-value pairs. Then we simply create a name for this new map, project-configs , so we can refer to it elsewhere in the code. Hint The slurp function holds the contents of the whole file in memory, so it may not be appropriate for very large files. If you are dealing with a large file, consider wrapping slurp in a lazy evaluation or use Java IO (eg. java.io.BufferedReader , java.io.FileReader. ). See the Clojure I/O cookbook and The Ins & Outs of Clojure for examples.","title":""},{"location":"reference/clojure-syntax/whats-my-environment/","text":"Whats my environment \u03bb\ufe0e Clojure has symbols (names that point to values). Some of these symbols are built into the language and their names start (and usually end with) the * character. When symbols are evaluated they return the value that they point to. Note Check the version of Clojure running in your REPL. Enter the following code into the Clojure REPL: *clojure-version* The full clojure version can be used to check you are running a particular version, major or minor of Clojure core. This information is represented as a map containing :major , :minor , :incremental and :qualifier keys. Feature releases may increment :minor and/or :major, bugfix releases will increment :incremental. Possible values of :qualifier include \"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\" Hint A map in Clojure is a built in data structure represented by { } . A map is a key-value pair and there must be a value for every key for the map to be valid. Keys are often defined using :keyword , a self-referential pointer that can be used to look up values in a map or other data structures. Viewing the Class path \u03bb\ufe0e Clojure compiles to Java bytecode that runs on the JVM, so that code needs to be available in the Java class path. Note Look at the class path for your project The directory where the Clojure compiler will create the .class files for the current project. All .class files must be on the class path otherwise the Clojure run time environment will not know they exist. *compile-path* Namespace \u03bb\ufe0e A namespace in clojure is a way to seperate functions and data structures into logical components (similar to Java packages). A clojure.lang.Namespace object representing the current namespace. Note Find out the current namespace *ns* Last 3 values in the REPL \u03bb\ufe0e You can also get the 3 most most recent values returned in the REPL. Note Evaluate the following three expressions in the REPL, then pull out the last three results ( + 1 2 3 ) ( + 1 2 ( + 1 2 ) ( + 2 3 )) ( str \"Java will be fully functional in version \" ( + 10 ( rand-int 20 )) Now get the last three values returned in the REPL ( str *1 *2 *3 ) Hint You can cycle through previous expressions entered into the REPL using the Shift-UpArrow keyboard shortcut","title":"Whats my environment"},{"location":"reference/clojure-syntax/whats-my-environment/#whats-my-environment","text":"Clojure has symbols (names that point to values). Some of these symbols are built into the language and their names start (and usually end with) the * character. When symbols are evaluated they return the value that they point to. Note Check the version of Clojure running in your REPL. Enter the following code into the Clojure REPL: *clojure-version* The full clojure version can be used to check you are running a particular version, major or minor of Clojure core. This information is represented as a map containing :major , :minor , :incremental and :qualifier keys. Feature releases may increment :minor and/or :major, bugfix releases will increment :incremental. Possible values of :qualifier include \"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\" Hint A map in Clojure is a built in data structure represented by { } . A map is a key-value pair and there must be a value for every key for the map to be valid. Keys are often defined using :keyword , a self-referential pointer that can be used to look up values in a map or other data structures.","title":"Whats my environment"},{"location":"reference/clojure-syntax/whats-my-environment/#viewing-the-class-path","text":"Clojure compiles to Java bytecode that runs on the JVM, so that code needs to be available in the Java class path. Note Look at the class path for your project The directory where the Clojure compiler will create the .class files for the current project. All .class files must be on the class path otherwise the Clojure run time environment will not know they exist. *compile-path*","title":"Viewing the Class path"},{"location":"reference/clojure-syntax/whats-my-environment/#namespace","text":"A namespace in clojure is a way to seperate functions and data structures into logical components (similar to Java packages). A clojure.lang.Namespace object representing the current namespace. Note Find out the current namespace *ns*","title":"Namespace"},{"location":"reference/clojure-syntax/whats-my-environment/#last-3-values-in-the-repl","text":"You can also get the 3 most most recent values returned in the REPL. Note Evaluate the following three expressions in the REPL, then pull out the last three results ( + 1 2 3 ) ( + 1 2 ( + 1 2 ) ( + 2 3 )) ( str \"Java will be fully functional in version \" ( + 10 ( rand-int 20 )) Now get the last three values returned in the REPL ( str *1 *2 *3 ) Hint You can cycle through previous expressions entered into the REPL using the Shift-UpArrow keyboard shortcut","title":"Last 3 values in the REPL"},{"location":"reference/clojure-syntax/syntax/","text":"Clojure Syntax \u03bb\ufe0e The Clojure syntax is very small and is actually a data structure, defined as a list, () , with the first element of a list being a function call and all other elements arguments to that function. Examples are editable (using an embedded REPL) so feel free to experiment and watch as the return value changes as you change the code. Reload the page if you want to reset all the code back to the starting point. edn based notation \u03bb\ufe0e The core Clojure syntax is defined in the extensible data notation (edn) . edn demonstrates that Clojure code is defined as a series of data structures Clojure adds an execution model on top of edn to make a programming language and is a super-set of edn. edn is used as a data transfer format, especially for Datomic the Clojure transactional database A case for Clojure by James Reeves provides a great introduction to edn Calling functions \u03bb\ufe0e The first element in a list, () , is treated as a call to a function. The examples show how to call functions with multiple arguments. (+ 1 2) (+ 3 (* 2 (- 7 2) 4) (/ 16 4)) (str \"Clojure is \" (- 2020 2007) \" years old\") (inc 1) (map inc [1 2 3 4 5]) (filter odd? (range 11)) Hint::Prefix notation and parens \u03bb\ufe0e Hugging code with () is a simple syntax to define the scope of code expressions. No additional ; , , or spaces are required. Treating the first element of a list as a function call is referred to as prefix notation, which greatly simplifies Clojure syntax. Prefix notation makes mathematical expressions completely deterministic, eliminating the need for operator precedence . Understanding functions \u03bb\ufe0e Functions contain doc-strings describing what that function does. The doc function returns the doc-string of a particular function. Most editors also support viewing of doc-strings as well as jumping to function definitions to view the source code (doc doc) Strongly typed under the covers \u03bb\ufe0e Clojure is a dynamically typed language so types do not need to be explicitly defined, although type hints can be added for performance where required. Clojure is strongly typed and everything is a type underneath, relative to the host platform (Clojure uses Java types, ClojureScript uses JavaScript types). The type of anything in Clojure can be returned using the type function. (type 42) ;; (type {:hash \"data\" :map \"more data\"}) (type {:hash \"data\" :map \"more data\"}) Modeling data with Collection types \u03bb\ufe0e Clojure has 4 main collection types, all immutable (cannot change once created) and can contain any Clojure types. (str \"lists used mainly \" (* 2 2) \" \" :code) [0 \"indexed\" :array (* 2 2) \"random-access\"] {:key \"value\" \"hash-map\" \"also referred to as dictionary\"} #{1 2 3 4 \"unique\" \"set\" \"of\" \"values\" \"unordered\" (* 3 9)} Hint::Persistent data types \u03bb\ufe0e To change data in Clojure new copies are created rather than changing existing values. The copies of data will share values from the original data that are common in both. This sharing is called persistent data types and enables immutable data to be used efficiently. Defining names for values (vars) \u03bb\ufe0e Names can be bound to any values, from simple values like numbers, collections or even function calls. Using def is convenient way to create names for values that are shared in your code. evaluating a name will return the value it is bound to. (def public-health-data ({:date \"2020-01-01\" :confirmed-cases 23014 :recovery-percent 15} {:date \"2020-01-02\" :confirmed-cases 23014 :recovery-percent 15} {:date \"2020-01-03\" :confirmed-cases 23014 :recovery-percent 15})) public-health-data Hint::def for shared values, let for locally scoped values \u03bb\ufe0e let function is used to bind names to values locally, such as within a function definition. Names bound with def have namespace scope so can be used with any code in that namespace. Using data structures \u03bb\ufe0e Using the map and inc function, increment all the numbers in a vector (map inc [1 2 3 4 5]) The above map function is roughly equivalent to the following expression (conj [] (inc 1) (inc 2) (inc 3) (inc 4) (inc 5)) The conj function creates a new collection by combining a collection and one or more values. map reduce filter are common functions for iterating through a collection / sequence of values (map * [1 3 5 8 13 21] [3 5 8 13 21 34]) (filter even? [1 3 5 8 13 21 34]) (reduce + [31 28 30 31 30 31]) (empty? []) Defining custom functions \u03bb\ufe0e (defn square-of \"Calculates the square of a given number\" [number] (* number number)) (square-of 9) Function definitions can also be used within other expressions, useful for mapping custom functions over a collection (map (fn [x] (* x x)) [1 2 3 4 5]) Host Interoperability \u03bb\ufe0e The REPL in this web page is running inside a JavaScript engine, so JavaScript functions can be used from within ClojureScript code (ClojureScript is Clojure that runs in JavaScript environments). In the box below, replace () with (js/alert \"I am a pop-up alert\") () JavaScript libraries can be used with ClojureScript, such as React.js (defn concentric-circles [] [:svg {:style {:border \"1px solid\" :background \"white\" :width \"150px\" :height \"150px\"}} [:circle {:r 50, :cx 75, :cy 75, :fill \"green\"}] [:circle {:r 25, :cx 75, :cy 75, :fill \"blue\"}] [:path {:stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 30,40 C 100,40 50,110 120,110\"}] [:path {:stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 75,75 C 50,90 50,110 35,110\"}]])","title":"Clojure Syntax"},{"location":"reference/clojure-syntax/syntax/#clojure-syntax","text":"The Clojure syntax is very small and is actually a data structure, defined as a list, () , with the first element of a list being a function call and all other elements arguments to that function. Examples are editable (using an embedded REPL) so feel free to experiment and watch as the return value changes as you change the code. Reload the page if you want to reset all the code back to the starting point.","title":"Clojure Syntax"},{"location":"reference/clojure-syntax/syntax/#edn-based-notation","text":"The core Clojure syntax is defined in the extensible data notation (edn) . edn demonstrates that Clojure code is defined as a series of data structures Clojure adds an execution model on top of edn to make a programming language and is a super-set of edn. edn is used as a data transfer format, especially for Datomic the Clojure transactional database A case for Clojure by James Reeves provides a great introduction to edn","title":"edn based notation"},{"location":"reference/clojure-syntax/syntax/#calling-functions","text":"The first element in a list, () , is treated as a call to a function. The examples show how to call functions with multiple arguments. (+ 1 2) (+ 3 (* 2 (- 7 2) 4) (/ 16 4)) (str \"Clojure is \" (- 2020 2007) \" years old\") (inc 1) (map inc [1 2 3 4 5]) (filter odd? (range 11))","title":"Calling functions"},{"location":"reference/clojure-syntax/syntax/#hintprefix-notation-and-parens","text":"Hugging code with () is a simple syntax to define the scope of code expressions. No additional ; , , or spaces are required. Treating the first element of a list as a function call is referred to as prefix notation, which greatly simplifies Clojure syntax. Prefix notation makes mathematical expressions completely deterministic, eliminating the need for operator precedence .","title":"Hint::Prefix notation and parens"},{"location":"reference/clojure-syntax/syntax/#understanding-functions","text":"Functions contain doc-strings describing what that function does. The doc function returns the doc-string of a particular function. Most editors also support viewing of doc-strings as well as jumping to function definitions to view the source code (doc doc)","title":"Understanding functions"},{"location":"reference/clojure-syntax/syntax/#strongly-typed-under-the-covers","text":"Clojure is a dynamically typed language so types do not need to be explicitly defined, although type hints can be added for performance where required. Clojure is strongly typed and everything is a type underneath, relative to the host platform (Clojure uses Java types, ClojureScript uses JavaScript types). The type of anything in Clojure can be returned using the type function. (type 42) ;; (type {:hash \"data\" :map \"more data\"}) (type {:hash \"data\" :map \"more data\"})","title":"Strongly typed under the covers"},{"location":"reference/clojure-syntax/syntax/#modeling-data-with-collection-types","text":"Clojure has 4 main collection types, all immutable (cannot change once created) and can contain any Clojure types. (str \"lists used mainly \" (* 2 2) \" \" :code) [0 \"indexed\" :array (* 2 2) \"random-access\"] {:key \"value\" \"hash-map\" \"also referred to as dictionary\"} #{1 2 3 4 \"unique\" \"set\" \"of\" \"values\" \"unordered\" (* 3 9)}","title":"Modeling data with Collection types"},{"location":"reference/clojure-syntax/syntax/#hintpersistent-data-types","text":"To change data in Clojure new copies are created rather than changing existing values. The copies of data will share values from the original data that are common in both. This sharing is called persistent data types and enables immutable data to be used efficiently.","title":"Hint::Persistent data types"},{"location":"reference/clojure-syntax/syntax/#defining-names-for-values-vars","text":"Names can be bound to any values, from simple values like numbers, collections or even function calls. Using def is convenient way to create names for values that are shared in your code. evaluating a name will return the value it is bound to. (def public-health-data ({:date \"2020-01-01\" :confirmed-cases 23014 :recovery-percent 15} {:date \"2020-01-02\" :confirmed-cases 23014 :recovery-percent 15} {:date \"2020-01-03\" :confirmed-cases 23014 :recovery-percent 15})) public-health-data","title":"Defining names for values (vars)"},{"location":"reference/clojure-syntax/syntax/#hintdef-for-shared-values-let-for-locally-scoped-values","text":"let function is used to bind names to values locally, such as within a function definition. Names bound with def have namespace scope so can be used with any code in that namespace.","title":"Hint::def for shared values, let for locally scoped values"},{"location":"reference/clojure-syntax/syntax/#using-data-structures","text":"Using the map and inc function, increment all the numbers in a vector (map inc [1 2 3 4 5]) The above map function is roughly equivalent to the following expression (conj [] (inc 1) (inc 2) (inc 3) (inc 4) (inc 5)) The conj function creates a new collection by combining a collection and one or more values. map reduce filter are common functions for iterating through a collection / sequence of values (map * [1 3 5 8 13 21] [3 5 8 13 21 34]) (filter even? [1 3 5 8 13 21 34]) (reduce + [31 28 30 31 30 31]) (empty? [])","title":"Using data structures"},{"location":"reference/clojure-syntax/syntax/#defining-custom-functions","text":"(defn square-of \"Calculates the square of a given number\" [number] (* number number)) (square-of 9) Function definitions can also be used within other expressions, useful for mapping custom functions over a collection (map (fn [x] (* x x)) [1 2 3 4 5])","title":"Defining custom functions"},{"location":"reference/clojure-syntax/syntax/#host-interoperability","text":"The REPL in this web page is running inside a JavaScript engine, so JavaScript functions can be used from within ClojureScript code (ClojureScript is Clojure that runs in JavaScript environments). In the box below, replace () with (js/alert \"I am a pop-up alert\") () JavaScript libraries can be used with ClojureScript, such as React.js (defn concentric-circles [] [:svg {:style {:border \"1px solid\" :background \"white\" :width \"150px\" :height \"150px\"}} [:circle {:r 50, :cx 75, :cy 75, :fill \"green\"}] [:circle {:r 25, :cx 75, :cy 75, :fill \"blue\"}] [:path {:stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 30,40 C 100,40 50,110 120,110\"}] [:path {:stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 75,75 C 50,90 50,110 35,110\"}]])","title":"Host Interoperability"},{"location":"reference/creative-coding/","text":"Creative coding with Clojure \u03bb\ufe0e Clojure is a very versatile language and can generate data visualizations and graphics from data. Quil - generate 2D graphics and animations Thi.ng - computational design tools play.cljc - making games (OpenGL and WebGL) Oz - data visualization and scientific document processing library (see practicalli/oz-visualisations for examples) Scalable Vector Graphics \u03bb\ufe0e Clojure can generate Scalable Vector Graphics (SVG) as they are represented as data. SVG images are drawn from a collection of points and paths. SVG images keep their quality when made larger or smaller. Using SVG images for the web and responsive design is highly recommended. This example of an SVG image is made from: * a green circle and a smaller blue circle * a white curvy path ( defn concentric-circles [] [ :svg { :style { :border \"1px solid\" :background \"white\" :width \"150px\" :height \"150px\" }} [ :circle { :r 50 , :cx 75 , :cy 75 , :fill \"green\" }] [ :circle { :r 30 , :cx 75 , :cy 75 , :fill \"blue\" }] [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 30,40 C 100,40 50,110 120,110\" }]]) Add the following path to the above code to make a curvy lambda symbol [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 75,75 C 50,90 50,110 35,110\" }] The complete solution: ( defn concentric-circles [] [ :svg { :style { :border \"1px solid\" :background \"white\" :width \"150px\" :height \"150px\" }} [ :circle { :r 50 , :cx 75 , :cy 75 , :fill \"green\" }] [ :circle { :r 30 , :cx 75 , :cy 75 , :fill \"blue\" }] [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 30,40 C 100,40 50,110 120,110\" }] [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 75,75 C 50,90 50,110 35,110\" }]])","title":"Creative coding with Clojure"},{"location":"reference/creative-coding/#creative-coding-with-clojure","text":"Clojure is a very versatile language and can generate data visualizations and graphics from data. Quil - generate 2D graphics and animations Thi.ng - computational design tools play.cljc - making games (OpenGL and WebGL) Oz - data visualization and scientific document processing library (see practicalli/oz-visualisations for examples)","title":"Creative coding with Clojure"},{"location":"reference/creative-coding/#scalable-vector-graphics","text":"Clojure can generate Scalable Vector Graphics (SVG) as they are represented as data. SVG images are drawn from a collection of points and paths. SVG images keep their quality when made larger or smaller. Using SVG images for the web and responsive design is highly recommended. This example of an SVG image is made from: * a green circle and a smaller blue circle * a white curvy path ( defn concentric-circles [] [ :svg { :style { :border \"1px solid\" :background \"white\" :width \"150px\" :height \"150px\" }} [ :circle { :r 50 , :cx 75 , :cy 75 , :fill \"green\" }] [ :circle { :r 30 , :cx 75 , :cy 75 , :fill \"blue\" }] [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 30,40 C 100,40 50,110 120,110\" }]]) Add the following path to the above code to make a curvy lambda symbol [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 75,75 C 50,90 50,110 35,110\" }] The complete solution: ( defn concentric-circles [] [ :svg { :style { :border \"1px solid\" :background \"white\" :width \"150px\" :height \"150px\" }} [ :circle { :r 50 , :cx 75 , :cy 75 , :fill \"green\" }] [ :circle { :r 30 , :cx 75 , :cy 75 , :fill \"blue\" }] [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 30,40 C 100,40 50,110 120,110\" }] [ :path { :stroke-width 12 :stroke \"white\" :fill \"none\" :d \"M 75,75 C 50,90 50,110 35,110\" }]])","title":"Scalable Vector Graphics"},{"location":"reference/jvm/","text":"Reference: Java Virtual Machine \u03bb\ufe0e Understand the configuration options for the Java Virtual machine (JVM) which Clojure is hosted upon. Overview of tools for monitoring and profiling Clojure applications running on the JVM, to ensure effective running of Clojure applications in production. Common JVM Options - for development and deployment JVM Profiling tools - understand resources and help diagnose run-time problems Hint:: JDK_JAVA_OPTIONS Environment Variable \u03bb\ufe0e JDK_JAVA_OPTIONS is the official Environment Variable for setting options when calling java , javac and other Java commands to start running a Java Virtual Machine (Java version 9 onward). Display resources available to the JVM \u03bb\ufe0e -XshowSettings:system displays the resources the JVM believes it has access too when running any Java command and is a very simple diagnostic tool to start with. See the environment resources available to the JVM without running a Clojure or Java application: java -XshowSettings:system -version Include -XshowSettings:system when running any Java command to provide simple diagnostics, e.g. when running a Clojure Uberjar java -XshowSettings:system -jar practicalli-service.jar Hint::Print resources in Container systems \u03bb\ufe0e -XshowSettings:system is especially useful for environments which may vary in resources available, such as containers (Docker, Kubernettes, etc.) JVM option types \u03bb\ufe0e -X - nonstandard VM options -XX standard VM options -XX options are not checked for validity, so are ignored if the VM does not recognize the option. Options can therefore be used across different VM versions without ensuring a particular level of the VM. -D a system property for the application running on the JVM using a name=value Java Modules \u03bb\ufe0e Java 9 introduced modules to move features out of JVM itself and include them as optional modules. Before CLJS-2377 issue was resolved , ClojureScript (2017) depended on java.xml.bind.DataTypeConverter . java.xml.bind package was deprecated in Java 9 and moved to a non-default module. At that time, compiling a ClojureScript project without adding the java.xml.bind module would return the error: <Exception details> ... Caused by: java.lang.ClassNotFoundException: javax.xml.bind.DatatypeConverter clojure J--add-modules \"java.xml.bind\" command line option will include the module :jvm-opts [\"--add-modules\" \"java.xml.bind\"] added to Clojure CLI deps.edn or Leiningen project.clj file will include the module. -Djdk.launcher.addmods=java.xml.bind added to the JAVA_TOOL_OPTIONS environment variable ( jdk.launcher.addmods --add-modules doesn\u2019t work in JAVA_TOOL_OPTIONS ) Unified Logging sub-system \u03bb\ufe0e -Xlog - JEP 158 References \u03bb\ufe0e Best practice for JVM Tuning with G1 GC Command Line Options - IBM SDK documentation Best HotSpot JVM Options and switches for Java 11 through Java 17","title":"Reference: Java Virtual Machine"},{"location":"reference/jvm/#reference-java-virtual-machine","text":"Understand the configuration options for the Java Virtual machine (JVM) which Clojure is hosted upon. Overview of tools for monitoring and profiling Clojure applications running on the JVM, to ensure effective running of Clojure applications in production. Common JVM Options - for development and deployment JVM Profiling tools - understand resources and help diagnose run-time problems","title":"Reference: Java Virtual Machine"},{"location":"reference/jvm/#hintjdk_java_options-environment-variable","text":"JDK_JAVA_OPTIONS is the official Environment Variable for setting options when calling java , javac and other Java commands to start running a Java Virtual Machine (Java version 9 onward).","title":"Hint::JDK_JAVA_OPTIONS Environment Variable"},{"location":"reference/jvm/#display-resources-available-to-the-jvm","text":"-XshowSettings:system displays the resources the JVM believes it has access too when running any Java command and is a very simple diagnostic tool to start with. See the environment resources available to the JVM without running a Clojure or Java application: java -XshowSettings:system -version Include -XshowSettings:system when running any Java command to provide simple diagnostics, e.g. when running a Clojure Uberjar java -XshowSettings:system -jar practicalli-service.jar","title":"Display resources available to the JVM"},{"location":"reference/jvm/#hintprint-resources-in-container-systems","text":"-XshowSettings:system is especially useful for environments which may vary in resources available, such as containers (Docker, Kubernettes, etc.)","title":"Hint::Print resources in Container systems"},{"location":"reference/jvm/#jvm-option-types","text":"-X - nonstandard VM options -XX standard VM options -XX options are not checked for validity, so are ignored if the VM does not recognize the option. Options can therefore be used across different VM versions without ensuring a particular level of the VM. -D a system property for the application running on the JVM using a name=value","title":"JVM option types"},{"location":"reference/jvm/#java-modules","text":"Java 9 introduced modules to move features out of JVM itself and include them as optional modules. Before CLJS-2377 issue was resolved , ClojureScript (2017) depended on java.xml.bind.DataTypeConverter . java.xml.bind package was deprecated in Java 9 and moved to a non-default module. At that time, compiling a ClojureScript project without adding the java.xml.bind module would return the error: <Exception details> ... Caused by: java.lang.ClassNotFoundException: javax.xml.bind.DatatypeConverter clojure J--add-modules \"java.xml.bind\" command line option will include the module :jvm-opts [\"--add-modules\" \"java.xml.bind\"] added to Clojure CLI deps.edn or Leiningen project.clj file will include the module. -Djdk.launcher.addmods=java.xml.bind added to the JAVA_TOOL_OPTIONS environment variable ( jdk.launcher.addmods --add-modules doesn\u2019t work in JAVA_TOOL_OPTIONS )","title":"Java Modules"},{"location":"reference/jvm/#unified-logging-sub-system","text":"-Xlog - JEP 158","title":"Unified Logging sub-system"},{"location":"reference/jvm/#references","text":"Best practice for JVM Tuning with G1 GC Command Line Options - IBM SDK documentation Best HotSpot JVM Options and switches for Java 11 through Java 17","title":"References"},{"location":"reference/jvm/common-options/","text":"Commonly used JVM Options \u03bb\ufe0e The JVM is excellent at self-optimising its performance. Introducing specific options should only be done if specific resource or performance issues have been identified. Examples of commonly used options for any language on the Java Virtual Machine (JVM). Understanding memory usage has more options to diagnose out of memory errors, garbage collection pauses and JIT compilation Hint:: JDK_JAVA_OPTIONS Environment Variable \u03bb\ufe0e JDK_JAVA_OPTIONS is the official Environment Variable for setting options when calling java , javac and other Java commands to start running a Java Virtual Machine (Java version 9 onward). Java heap size \u03bb\ufe0e Java Ergonomics should provide sensible default options. Performance analysis of the running code may show advantages of manually setting memory sizes. Set the initial heap size if memory usage will quickly grow -Xms \u2013 start heap size for JVM, e.g. -Xms2048m sets an initial heap size of 2 GB -XX:InitialRAMPercentage=n sets the initial heap as n percentage of total RAM Set the maximum heap size if usage is relatively high under normal conditions -Xmx \u2013 maximum heap size of JVM, e.g. -Xmx2048m -XX:MaxRAMPercentage=n sets the maximum heap as n percentage of total RAM -Xss - set java thread stack size -Xms and -Xmx are commonly used together (where there is a know fixed value for memory resources). Set heap with respect to garbage collection \u03bb\ufe0e -XX:MaxHeapFreeRatio \u2013 maximum percentage of heap free after garbage collection to avoid shrinking. -XX:MinHeapFreeRatio \u2013 minimum percentage of heap free after GC to avoid expansion VisualVM or JConsole can monitor the heap usage Container Environments \u03bb\ufe0e -XX:InitialRAMPercentage and -XX:MaxRAMPercentage options should be used to set relative limits to the resources available from the host. Setting specific heap sizes with -Xms and -Xmx is strongly discouraged in Container environments, as resources available to the container from the host could change between deployments (e.g. a change in operational configuration in Kubernettes, etc.) Stack traces \u03bb\ufe0e -XX:-OmitStackTraceInFastThrow no StackTrace for implicit exceptions thrown by JVM, e.g. NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ArrayStoreException or ClassCastException. Reflection \u03bb\ufe0e --illegal-access option controls how deep reflection warnings are handled. permit (default) - generates warning only when the first illegal access was detected warn - emit warning after each illegal access detection debug - add stack trace to warning deny - like debug for the first detection, then killing the program. Java 16 deprecates --illegal-access flag, via work done for JEP403 - may still be useful for 3rd party Java libraries. Enable class data sharing \u03bb\ufe0e -Xshareclasses enables class data sharing in a shared class cache. The JVM connects to an existing cache (creating a cache if none exist). Multiple caches specified by adding a sub-option to the -Xshareclasses option. Handling \u2018OutOfMemory\u2019 Error \u03bb\ufe0e Generating a Heap Dump for out of memory (OOM) issues is recommended for production systems, to provide data for a deep analysis of the problem. Generating a heap dump does not add overhead to the running JVM. -XX:+HeapDumpOnOutOfMemoryError - trigger heap dump on out of memory failure -XX:HeapDumpPath=path-to-heap-dump-directory - sets path to write the heap dump file (defaults to directory in which java command was ran from) A heap dump file can gigabytes in size, so assure that the target file system has sufficient capacity. -XX:OnOutOfMemoryError=\"shutdown -r\" - restart the process immediately after out of memory failure The option can take multiple commands, separated by a ; , e.g. -XX:OnOutOfMemoryError=\"< cmd args >;< cmd args >\" Trace classloading and unloading \u03bb\ufe0e Identify memory leaks suspected from the JVM Class Loader, e.g. classes are not unloading or garbage collected -XX:+TraceClassLoading - log classes loaded into the JVM -XX:+TraceClassUnloading - log classes unloaded from the JVM Profiling \u03bb\ufe0e Profiling JVM processes provides a fine-grained view of application execution and resource utilization. Monitor parameters including Method Executions, Thread Executions, Garbage Collections and Object Creations. -Xprof -Xrunhprof Consider using a profile tool, such as VisualVM Skip byte code verification \u03bb\ufe0e The byte code for each class loaded by the JVM Class Loader is verified, which is a relatively expensive task at startup. Adding classes on the boot classpath skips the cost of the verification, although also introduces a security risk so should only be used when classes have been previously verified. -Xbootclasspath specifies classpath entries to load without verification Profiling an application is a more suitable long term solution than skipping byte code verification Checks carried out by the verifier include Uninitialized Variables Access rules for private data and methods are not violated Method calls match the object Reference There are no operand stack overflows or under-flows Arguments to all JVM instructions are valid types Final classes are not subclassed and final methods are not overridden field and method references have valid names, valid classes and valid type descriptor Print GC \u03bb\ufe0e Enable the garbage collection logging to capture detailed statistics, e.g. type of garbage collector, how often memory is restored and how much time memory was held for. Garbage collection can last several milliseconds, so logging is useful for latency-sensitive processes. -verbose:gc - logs garbage collector runs and how long they're taking. -XX:+PrintGCDetails - includes the data from -verbose:gc but also adds information about the size of the new generation and more accurate timings. -XX:-PrintGCTimeStamps - Print timestamps at garbage collection. Consider using LMAX disruptor for a Garbage Collection free architecture for ultra latency-sensitive applications Deprecated: PermGen Size \u03bb\ufe0e -XX:PermSize - size of PermGen space where string pool and class metadata is saved. Option is useful for web servers which load classes of a web application during deployment (e.g. deploying a jar or war to Tomcat). Metaspace has taken over PermGen space in Java 8","title":"Commonly used JVM Options"},{"location":"reference/jvm/common-options/#commonly-used-jvm-options","text":"The JVM is excellent at self-optimising its performance. Introducing specific options should only be done if specific resource or performance issues have been identified. Examples of commonly used options for any language on the Java Virtual Machine (JVM). Understanding memory usage has more options to diagnose out of memory errors, garbage collection pauses and JIT compilation","title":"Commonly used JVM Options"},{"location":"reference/jvm/common-options/#hintjdk_java_options-environment-variable","text":"JDK_JAVA_OPTIONS is the official Environment Variable for setting options when calling java , javac and other Java commands to start running a Java Virtual Machine (Java version 9 onward).","title":"Hint::JDK_JAVA_OPTIONS Environment Variable"},{"location":"reference/jvm/common-options/#java-heap-size","text":"Java Ergonomics should provide sensible default options. Performance analysis of the running code may show advantages of manually setting memory sizes. Set the initial heap size if memory usage will quickly grow -Xms \u2013 start heap size for JVM, e.g. -Xms2048m sets an initial heap size of 2 GB -XX:InitialRAMPercentage=n sets the initial heap as n percentage of total RAM Set the maximum heap size if usage is relatively high under normal conditions -Xmx \u2013 maximum heap size of JVM, e.g. -Xmx2048m -XX:MaxRAMPercentage=n sets the maximum heap as n percentage of total RAM -Xss - set java thread stack size -Xms and -Xmx are commonly used together (where there is a know fixed value for memory resources).","title":"Java heap size"},{"location":"reference/jvm/common-options/#set-heap-with-respect-to-garbage-collection","text":"-XX:MaxHeapFreeRatio \u2013 maximum percentage of heap free after garbage collection to avoid shrinking. -XX:MinHeapFreeRatio \u2013 minimum percentage of heap free after GC to avoid expansion VisualVM or JConsole can monitor the heap usage","title":"Set heap with respect to garbage collection"},{"location":"reference/jvm/common-options/#container-environments","text":"-XX:InitialRAMPercentage and -XX:MaxRAMPercentage options should be used to set relative limits to the resources available from the host. Setting specific heap sizes with -Xms and -Xmx is strongly discouraged in Container environments, as resources available to the container from the host could change between deployments (e.g. a change in operational configuration in Kubernettes, etc.)","title":"Container Environments"},{"location":"reference/jvm/common-options/#stack-traces","text":"-XX:-OmitStackTraceInFastThrow no StackTrace for implicit exceptions thrown by JVM, e.g. NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ArrayStoreException or ClassCastException.","title":"Stack traces"},{"location":"reference/jvm/common-options/#reflection","text":"--illegal-access option controls how deep reflection warnings are handled. permit (default) - generates warning only when the first illegal access was detected warn - emit warning after each illegal access detection debug - add stack trace to warning deny - like debug for the first detection, then killing the program. Java 16 deprecates --illegal-access flag, via work done for JEP403 - may still be useful for 3rd party Java libraries.","title":"Reflection"},{"location":"reference/jvm/common-options/#enable-class-data-sharing","text":"-Xshareclasses enables class data sharing in a shared class cache. The JVM connects to an existing cache (creating a cache if none exist). Multiple caches specified by adding a sub-option to the -Xshareclasses option.","title":"Enable class data sharing"},{"location":"reference/jvm/common-options/#handling-outofmemory-error","text":"Generating a Heap Dump for out of memory (OOM) issues is recommended for production systems, to provide data for a deep analysis of the problem. Generating a heap dump does not add overhead to the running JVM. -XX:+HeapDumpOnOutOfMemoryError - trigger heap dump on out of memory failure -XX:HeapDumpPath=path-to-heap-dump-directory - sets path to write the heap dump file (defaults to directory in which java command was ran from) A heap dump file can gigabytes in size, so assure that the target file system has sufficient capacity. -XX:OnOutOfMemoryError=\"shutdown -r\" - restart the process immediately after out of memory failure The option can take multiple commands, separated by a ; , e.g. -XX:OnOutOfMemoryError=\"< cmd args >;< cmd args >\"","title":"Handling \u2018OutOfMemory\u2019 Error"},{"location":"reference/jvm/common-options/#trace-classloading-and-unloading","text":"Identify memory leaks suspected from the JVM Class Loader, e.g. classes are not unloading or garbage collected -XX:+TraceClassLoading - log classes loaded into the JVM -XX:+TraceClassUnloading - log classes unloaded from the JVM","title":"Trace classloading and unloading"},{"location":"reference/jvm/common-options/#profiling","text":"Profiling JVM processes provides a fine-grained view of application execution and resource utilization. Monitor parameters including Method Executions, Thread Executions, Garbage Collections and Object Creations. -Xprof -Xrunhprof Consider using a profile tool, such as VisualVM","title":"Profiling"},{"location":"reference/jvm/common-options/#skip-byte-code-verification","text":"The byte code for each class loaded by the JVM Class Loader is verified, which is a relatively expensive task at startup. Adding classes on the boot classpath skips the cost of the verification, although also introduces a security risk so should only be used when classes have been previously verified. -Xbootclasspath specifies classpath entries to load without verification Profiling an application is a more suitable long term solution than skipping byte code verification Checks carried out by the verifier include Uninitialized Variables Access rules for private data and methods are not violated Method calls match the object Reference There are no operand stack overflows or under-flows Arguments to all JVM instructions are valid types Final classes are not subclassed and final methods are not overridden field and method references have valid names, valid classes and valid type descriptor","title":"Skip byte code verification"},{"location":"reference/jvm/common-options/#print-gc","text":"Enable the garbage collection logging to capture detailed statistics, e.g. type of garbage collector, how often memory is restored and how much time memory was held for. Garbage collection can last several milliseconds, so logging is useful for latency-sensitive processes. -verbose:gc - logs garbage collector runs and how long they're taking. -XX:+PrintGCDetails - includes the data from -verbose:gc but also adds information about the size of the new generation and more accurate timings. -XX:-PrintGCTimeStamps - Print timestamps at garbage collection. Consider using LMAX disruptor for a Garbage Collection free architecture for ultra latency-sensitive applications","title":"Print GC"},{"location":"reference/jvm/common-options/#deprecated-permgen-size","text":"-XX:PermSize - size of PermGen space where string pool and class metadata is saved. Option is useful for web servers which load classes of a web application during deployment (e.g. deploying a jar or war to Tomcat). Metaspace has taken over PermGen space in Java 8","title":"Deprecated: PermGen Size"},{"location":"reference/jvm/experimental-options/","text":"Reference: JVM Experimental Options \u03bb\ufe0e The HotSpot JVM provides the opportunity to try features that may appear in future release, although are currently not production-ready. HotSpot JVM experimental features need to be unlocked by specifying the -XX:+UnlockExperimentalVMOptions option. For example, the ZGC garbage collector in JDK 11 can be accessed using java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC The ZGC collector became a product option in JDK 15, so is no longer experimental. Manageable \u03bb\ufe0e Show locks held by java.util.concurrent classes in a HotSpot JVM thread dump: java -XX:+UnlockExperimentalVMOptions -XX:+PrintConcurrentLocks These options can be set at runtime via the MXBean API or related JDK tools Diagnostic \u03bb\ufe0e Accessing advanced diagnostic information about the HotSpot JVM. These options require you to use the -XX:+UnlockDiagnosticVMOptions option before they can be used. View advance compilation optimisations using the -XX:+LogCompilation option: java -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation The HotSpot JVM outputs a log file containing details of all the optimisations made by the JIT compilers. Inspect the output to understand which parts of your program were optimized and to identify parts of the program that might not have been optimized as expected. The LogCompilation output is verbose but can be visualized in a tool such as JITWatch, which can tell you about method inlining, escape analysis, lock elision, and other optimizations that the HotSpot JVM made to your running code.","title":"Reference: JVM Experimental Options"},{"location":"reference/jvm/experimental-options/#reference-jvm-experimental-options","text":"The HotSpot JVM provides the opportunity to try features that may appear in future release, although are currently not production-ready. HotSpot JVM experimental features need to be unlocked by specifying the -XX:+UnlockExperimentalVMOptions option. For example, the ZGC garbage collector in JDK 11 can be accessed using java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC The ZGC collector became a product option in JDK 15, so is no longer experimental.","title":"Reference: JVM Experimental Options"},{"location":"reference/jvm/experimental-options/#manageable","text":"Show locks held by java.util.concurrent classes in a HotSpot JVM thread dump: java -XX:+UnlockExperimentalVMOptions -XX:+PrintConcurrentLocks These options can be set at runtime via the MXBean API or related JDK tools","title":"Manageable"},{"location":"reference/jvm/experimental-options/#diagnostic","text":"Accessing advanced diagnostic information about the HotSpot JVM. These options require you to use the -XX:+UnlockDiagnosticVMOptions option before they can be used. View advance compilation optimisations using the -XX:+LogCompilation option: java -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation The HotSpot JVM outputs a log file containing details of all the optimisations made by the JIT compilers. Inspect the output to understand which parts of your program were optimized and to identify parts of the program that might not have been optimized as expected. The LogCompilation output is verbose but can be visualized in a tool such as JITWatch, which can tell you about method inlining, escape analysis, lock elision, and other optimizations that the HotSpot JVM made to your running code.","title":"Diagnostic"},{"location":"reference/jvm/java-17-flags/","text":"Reference: Java 17 JVM flags \u03bb\ufe0e A complete list of all flags available for the JVM, created using the -XX:+PrintFlagsFinal option and the results written to a file java -XX:+PrintFlagsFinal > java-flags.md Find specific flags by using grep on the output with a name java -XX:+PrintFlagsFinal -version | grep MaxHeap Type Name Units ? ? uintx MaxHeapFreeRatio 70 {manageable} {default} size_t MaxHeapSize 8342470656 {product} {ergonomic} size_t SoftMaxHeapSize 8342470656 {manageable} {ergonomic} Full list of JVM flags \u03bb\ufe0e Type Option Name Default value Product Category int ActiveProcessorCount -1 {product} {default} uintx AdaptiveSizeDecrementScaleFactor 4 {product} {default} uintx AdaptiveSizeMajorGCDecayTimeScale 10 {product} {default} uintx AdaptiveSizePolicyCollectionCostMargin 50 {product} {default} uintx AdaptiveSizePolicyInitializingSteps 20 {product} {default} uintx AdaptiveSizePolicyOutputInterval 0 {product} {default} uintx AdaptiveSizePolicyWeight 10 {product} {default} uintx AdaptiveSizeThroughPutPolicy 0 {product} {default} uintx AdaptiveTimeWeight 25 {product} {default} bool AdjustStackSizeForTLS false {product} {default} bool AggressiveHeap false {product} {default} intx AliasLevel 3 {C2 product} {default} bool AlignVector false {C2 product} {default} ccstr AllocateHeapAt {product} {default} intx AllocateInstancePrefetchLines 1 {product} {default} intx AllocatePrefetchDistance 256 {product} {default} intx AllocatePrefetchInstr 0 {product} {default} intx AllocatePrefetchLines 3 {product} {default} intx AllocatePrefetchStepSize 64 {product} {default} intx AllocatePrefetchStyle 1 {product} {default} bool AllowParallelDefineClass false {product} {default} bool AllowRedefinitionToAddDeleteMethods false {product} {default} bool AllowUserSignalHandlers false {product} {default} bool AllowVectorizeOnDemand true {C2 product} {default} bool AlwaysActAsServerClassMachine false {product} {default} bool AlwaysCompileLoopMethods false {product} {default} bool AlwaysLockClassLoader false {product} {default} bool AlwaysPreTouch false {product} {default} bool AlwaysRestoreFPU false {product} {default} bool AlwaysTenure false {product} {default} ccstr ArchiveClassesAtExit {product} {default} intx ArrayCopyLoadStoreMaxElem 8 {C2 product} {default} size_t AsyncLogBufferSize 2097152 {product} {default} intx AutoBoxCacheMax 128 {C2 product} {default} intx BCEATraceLevel 0 {product} {default} bool BackgroundCompilation true {pd product} {default} size_t BaseFootPrintEstimate 268435456 {product} {default} intx BiasedLockingBulkRebiasThreshold 20 {product} {default} intx BiasedLockingBulkRevokeThreshold 40 {product} {default} intx BiasedLockingDecayTime 25000 {product} {default} intx BiasedLockingStartupDelay 0 {product} {default} bool BlockLayoutByFrequency true {C2 product} {default} intx BlockLayoutMinDiamondPercentage 20 {C2 product} {default} bool BlockLayoutRotateLoops true {C2 product} {default} intx C1InlineStackLimit 5 {C1 product} {default} intx C1MaxInlineLevel 9 {C1 product} {default} intx C1MaxInlineSize 35 {C1 product} {default} intx C1MaxRecursiveInlineLevel 1 {C1 product} {default} intx C1MaxTrivialSize 6 {C1 product} {default} bool C1OptimizeVirtualCallProfiling true {C1 product} {default} bool C1ProfileBranches true {C1 product} {default} bool C1ProfileCalls true {C1 product} {default} bool C1ProfileCheckcasts true {C1 product} {default} bool C1ProfileInlinedCalls true {C1 product} {default} bool C1ProfileVirtualCalls true {C1 product} {default} bool C1UpdateMethodData true {C1 product} {default} intx CICompilerCount 12 {product} {ergonomic} bool CICompilerCountPerCPU true {product} {default} bool CITime false {product} {default} bool CheckJNICalls false {product} {default} bool ClassUnloading true {product} {default} bool ClassUnloadingWithConcurrentMark true {product} {default} bool ClipInlining true {product} {default} uintx CodeCacheExpansionSize 65536 {pd product} {default} bool CompactStrings true {pd product} {default} ccstr CompilationMode default {product} {default} ccstrlist CompileCommand {product} {default} ccstr CompileCommandFile {product} {default} ccstrlist CompileOnly {product} {default} intx CompileThreshold 10000 {pd product} {default} double CompileThresholdScaling 1.000000 {product} {default} intx CompilerThreadPriority -1 {product} {default} intx CompilerThreadStackSize 1024 {pd product} {default} size_t CompressedClassSpaceSize 1073741824 {product} {default} uint ConcGCThreads 3 {product} {ergonomic} intx ConditionalMoveLimit 3 {C2 pd product} {default} intx ContendedPaddingWidth 128 {product} {default} bool CrashOnOutOfMemoryError false {product} {default} bool CreateCoredumpOnCrash true {product} {default} bool CriticalJNINatives false {product} {default} bool DTraceAllocProbes false {product} {default} bool DTraceMethodProbes false {product} {default} bool DTraceMonitorProbes false {product} {default} bool DisableAttachMechanism false {product} {default} bool DisableExplicitGC false {product} {default} bool DisplayVMOutputToStderr false {product} {default} bool DisplayVMOutputToStdout false {product} {default} bool DoEscapeAnalysis true {C2 product} {default} bool DoReserveCopyInSuperWord true {C2 product} {default} bool DontCompileHugeMethods true {product} {default} bool DontYieldALot false {pd product} {default} ccstr DumpLoadedClassList {product} {default} bool DumpReplayDataOnError true {product} {default} bool DumpSharedSpaces false {product} {default} bool DynamicDumpSharedSpaces false {product} {default} bool EagerXrunInit false {product} {default} intx EliminateAllocationArraySizeLimit 64 {C2 product} {default} bool EliminateAllocations true {C2 product} {default} bool EliminateAutoBox true {C2 product} {default} bool EliminateLocks true {C2 product} {default} bool EliminateNestedLocks true {C2 product} {default} bool EnableContended true {product} {default} bool EnableDynamicAgentLoading true {product} {default} size_t ErgoHeapSizeLimit 0 {product} {default} ccstr ErrorFile {product} {default} bool ErrorFileToStderr false {product} {default} bool ErrorFileToStdout false {product} {default} uint64_t ErrorLogTimeout 120 {product} {default} double EscapeAnalysisTimeout 20.000000 {C2 product} {default} bool EstimateArgEscape true {product} {default} bool ExecutingUnitTests false {product} {default} bool ExitOnOutOfMemoryError false {product} {default} bool ExplicitGCInvokesConcurrent false {product} {default} bool ExtendedDTraceProbes false {product} {default} bool ExtensiveErrorReports false {product} {default} ccstr ExtraSharedClassListFile {product} {default} bool FilterSpuriousWakeups true {product} {default} bool FlightRecorder false {product} {default} ccstr FlightRecorderOptions {product} {default} bool ForceTimeHighResolution false {product} {default} intx FreqInlineSize 325 {C2 pd product} {default} double G1ConcMarkStepDurationMillis 10.000000 {product} {default} uintx G1ConcRSHotCardLimit 4 {product} {default} size_t G1ConcRSLogCacheSize 10 {product} {default} size_t G1ConcRefinementGreenZone 0 {product} {default} size_t G1ConcRefinementRedZone 0 {product} {default} uintx G1ConcRefinementServiceIntervalMillis 300 {product} {default} uint G1ConcRefinementThreads 13 {product} {ergonomic} size_t G1ConcRefinementThresholdStep 2 {product} {default} size_t G1ConcRefinementYellowZone 0 {product} {default} uintx G1ConfidencePercent 50 {product} {default} size_t G1HeapRegionSize 4194304 {product} {ergonomic} uintx G1HeapWastePercent 5 {product} {default} uintx G1MixedGCCountTarget 8 {product} {default} uintx G1PeriodicGCInterval 0 {manageable} {default} bool G1PeriodicGCInvokesConcurrent true {product} {default} double G1PeriodicGCSystemLoadThreshold 0.000000 {manageable} {default} intx G1RSetRegionEntries 768 {product} {default} intx G1RSetSparseRegionEntries 32 {product} {default} intx G1RSetUpdatingPauseTimePercent 10 {product} {default} uint G1RefProcDrainInterval 1000 {product} {default} uintx G1ReservePercent 10 {product} {default} uintx G1SATBBufferEnqueueingThresholdPercent 60 {product} {default} size_t G1SATBBufferSize 1024 {product} {default} size_t G1UpdateBufferSize 256 {product} {default} bool G1UseAdaptiveConcRefinement true {product} {default} bool G1UseAdaptiveIHOP true {product} {default} uintx GCDrainStackTargetSize 64 {product} {ergonomic} uintx GCHeapFreeLimit 2 {product} {default} uintx GCLockerEdenExpansionPercent 5 {product} {default} uintx GCPauseIntervalMillis 201 {product} {default} uintx GCTimeLimit 98 {product} {default} uintx GCTimeRatio 12 {product} {default} size_t HeapBaseMinAddress 2147483648 {pd product} {default} bool HeapDumpAfterFullGC false {manageable} {default} bool HeapDumpBeforeFullGC false {manageable} {default} intx HeapDumpGzipLevel 0 {manageable} {default} bool HeapDumpOnOutOfMemoryError false {manageable} {default} ccstr HeapDumpPath {manageable} {default} uintx HeapFirstMaximumCompactionCount 3 {product} {default} uintx HeapMaximumCompactionInterval 20 {product} {default} uintx HeapSearchSteps 3 {product} {default} size_t HeapSizePerGCThread 43620760 {product} {default} bool IgnoreEmptyClassPaths false {product} {default} bool IgnoreUnrecognizedVMOptions false {product} {default} uintx IncreaseFirstTierCompileThresholdAt 50 {product} {default} bool IncrementalInline true {C2 product} {default} uintx InitialCodeCacheSize 2555904 {pd product} {default} size_t InitialHeapSize 490733568 {product} {ergonomic} uintx InitialRAMFraction 64 {product} {default} double InitialRAMPercentage 1.562500 {product} {default} uintx InitialSurvivorRatio 8 {product} {default} uintx InitialTenuringThreshold 7 {product} {default} uintx InitiatingHeapOccupancyPercent 45 {product} {default} bool Inline true {product} {default} ccstr InlineDataFile {product} {default} intx InlineSmallCode 2500 {C2 pd product} {default} bool InlineSynchronizedMethods true {C1 product} {default} intx InteriorEntryAlignment 16 {C2 pd product} {default} intx InterpreterProfilePercentage 33 {product} {default} bool JavaMonitorsInStackTrace true {product} {default} intx JavaPriority10_To_OSPriority -1 {product} {default} intx JavaPriority1_To_OSPriority -1 {product} {default} intx JavaPriority2_To_OSPriority -1 {product} {default} intx JavaPriority3_To_OSPriority -1 {product} {default} intx JavaPriority4_To_OSPriority -1 {product} {default} intx JavaPriority5_To_OSPriority -1 {product} {default} intx JavaPriority6_To_OSPriority -1 {product} {default} intx JavaPriority7_To_OSPriority -1 {product} {default} intx JavaPriority8_To_OSPriority -1 {product} {default} intx JavaPriority9_To_OSPriority -1 {product} {default} size_t LargePageHeapSizeThreshold 134217728 {product} {default} size_t LargePageSizeInBytes 0 {product} {default} intx LiveNodeCountInliningCutoff 40000 {C2 product} {default} bool LoadExecStackDllInVMThread true {product} {default} intx LoopMaxUnroll 16 {C2 product} {default} intx LoopOptsCount 43 {C2 product} {default} intx LoopPercentProfileLimit 30 {C2 pd product} {default} uintx LoopStripMiningIter 1000 {C2 product} {default} uintx LoopStripMiningIterShortLoop 100 {C2 product} {default} intx LoopUnrollLimit 60 {C2 pd product} {default} intx LoopUnrollMin 4 {C2 product} {default} bool LoopUnswitching true {C2 product} {default} bool ManagementServer false {product} {default} size_t MarkStackSize 4194304 {product} {ergonomic} size_t MarkStackSizeMax 536870912 {product} {default} uint MarkSweepAlwaysCompactCount 4 {product} {default} uintx MarkSweepDeadRatio 5 {product} {default} intx MaxBCEAEstimateLevel 5 {product} {default} intx MaxBCEAEstimateSize 150 {product} {default} uint64_t MaxDirectMemorySize 0 {product} {default} bool MaxFDLimit true {product} {default} uintx MaxGCMinorPauseMillis 18446744073709551615 {product} {default} uintx MaxGCPauseMillis 200 {product} {default} uintx MaxHeapFreeRatio 70 {manageable} {default} size_t MaxHeapSize 7818182656 {product} {ergonomic} intx MaxInlineLevel 15 {C2 product} {default} intx MaxInlineSize 35 {C2 product} {default} intx MaxJNILocalCapacity 65536 {product} {default} intx MaxJavaStackTraceDepth 1024 {product} {default} intx MaxJumpTableSize 65000 {C2 product} {default} intx MaxJumpTableSparseness 5 {C2 product} {default} intx MaxLabelRootDepth 1100 {C2 product} {default} intx MaxLoopPad 15 {C2 product} {default} size_t MaxMetaspaceExpansion 5439488 {product} {default} uintx MaxMetaspaceFreeRatio 70 {product} {default} size_t MaxMetaspaceSize 18446744073709551615 {product} {default} size_t MaxNewSize 4689231872 {product} {ergonomic} intx MaxNodeLimit 80000 {C2 product} {default} uint64_t MaxRAM 137438953472 {pd product} {default} uintx MaxRAMFraction 4 {product} {default} double MaxRAMPercentage 25.000000 {product} {default} intx MaxRecursiveInlineLevel 1 {C2 product} {default} uintx MaxTenuringThreshold 15 {product} {default} intx MaxTrivialSize 6 {C2 product} {default} intx MaxVectorSize 32 {C2 product} {default} ccstr MetaspaceReclaimPolicy balanced {product} {default} size_t MetaspaceSize 22020096 {product} {default} bool MethodFlushing true {product} {default} size_t MinHeapDeltaBytes 4194304 {product} {ergonomic} uintx MinHeapFreeRatio 40 {manageable} {default} size_t MinHeapSize 8388608 {product} {ergonomic} intx MinInliningThreshold 250 {product} {default} intx MinJumpTableSize 10 {C2 pd product} {default} size_t MinMetaspaceExpansion 327680 {product} {default} uintx MinMetaspaceFreeRatio 40 {product} {default} uintx MinRAMFraction 2 {product} {default} double MinRAMPercentage 50.000000 {product} {default} uintx MinSurvivorRatio 3 {product} {default} size_t MinTLABSize 2048 {product} {default} intx MultiArrayExpandLimit 6 {C2 product} {default} uintx NUMAChunkResizeWeight 20 {product} {default} size_t NUMAInterleaveGranularity 2097152 {product} {default} uintx NUMAPageScanRate 256 {product} {default} size_t NUMASpaceResizeRate 1073741824 {product} {default} bool NUMAStats false {product} {default} ccstr NativeMemoryTracking off {product} {default} bool NeverActAsServerClassMachine false {pd product} {default} bool NeverTenure false {product} {default} uintx NewRatio 2 {product} {default} size_t NewSize 1363144 {product} {default} size_t NewSizeThreadIncrease 5320 {pd product} {default} intx NmethodSweepActivity 10 {product} {default} intx NodeLimitFudgeFactor 2000 {C2 product} {default} uintx NonNMethodCodeHeapSize 7602480 {pd product} {ergonomic} uintx NonProfiledCodeHeapSize 122027880 {pd product} {ergonomic} intx NumberOfLoopInstrToAlign 4 {C2 product} {default} intx ObjectAlignmentInBytes 8 {product lp64_product} {default} size_t OldPLABSize 1024 {product} {default} size_t OldSize 5452592 {product} {default} bool OmitStackTraceInFastThrow true {product} {default} ccstrlist OnError {product} {default} ccstrlist OnOutOfMemoryError {product} {default} intx OnStackReplacePercentage 140 {pd product} {default} bool OptimizeFill false {C2 product} {default} bool OptimizePtrCompare true {C2 product} {default} bool OptimizeStringConcat true {C2 product} {default} bool OptoBundling false {C2 pd product} {default} intx OptoLoopAlignment 16 {pd product} {default} bool OptoRegScheduling true {C2 pd product} {default} bool OptoScheduling false {C2 pd product} {default} uintx PLABWeight 75 {product} {default} bool PSChunkLargeArrays true {product} {default} int ParGCArrayScanChunk 50 {product} {default} uintx ParallelGCBufferWastePct 10 {product} {default} uint ParallelGCThreads 13 {product} {default} size_t ParallelOldDeadWoodLimiterMean 50 {product} {default} size_t ParallelOldDeadWoodLimiterStdDev 80 {product} {default} bool ParallelRefProcBalancingEnabled true {product} {default} bool ParallelRefProcEnabled true {product} {default} bool PartialPeelAtUnsignedTests true {C2 product} {default} bool PartialPeelLoop true {C2 product} {default} intx PartialPeelNewPhiDelta 0 {C2 product} {default} uintx PausePadding 1 {product} {default} intx PerBytecodeRecompilationCutoff 200 {product} {default} intx PerBytecodeTrapLimit 4 {product} {default} intx PerMethodRecompilationCutoff 400 {product} {default} intx PerMethodTrapLimit 100 {product} {default} bool PerfAllowAtExitRegistration false {product} {default} bool PerfBypassFileSystemCheck false {product} {default} intx PerfDataMemorySize 32768 {product} {default} intx PerfDataSamplingInterval 50 {product} {default} ccstr PerfDataSaveFile {product} {default} bool PerfDataSaveToFile false {product} {default} bool PerfDisableSharedMem false {product} {default} intx PerfMaxStringConstLength 1024 {product} {default} size_t PreTouchParallelChunkSize 4194304 {pd product} {default} bool PreferContainerQuotaForCPUCount true {product} {default} bool PreferInterpreterNativeStubs false {pd product} {default} intx PrefetchCopyIntervalInBytes 576 {product} {default} intx PrefetchFieldsAhead 1 {product} {default} intx PrefetchScanIntervalInBytes 576 {product} {default} bool PreserveAllAnnotations false {product} {default} bool PreserveFramePointer false {pd product} {default} size_t PretenureSizeThreshold 0 {product} {default} bool PrintClassHistogram false {manageable} {default} bool PrintCodeCache false {product} {default} bool PrintCodeCacheOnCompilation false {product} {default} bool PrintCommandLineFlags false {product} {default} bool PrintCompilation false {product} {default} bool PrintConcurrentLocks false {manageable} {default} bool PrintExtendedThreadInfo false {product} {default} bool PrintFlagsFinal true {product} {command line} bool PrintFlagsInitial false {product} {default} bool PrintFlagsRanges false {product} {default} bool PrintGC false {product} {default} bool PrintGCDetails false {product} {default} bool PrintHeapAtSIGBREAK true {product} {default} bool PrintSharedArchiveAndExit false {product} {default} bool PrintSharedDictionary false {product} {default} bool PrintStringTableStatistics false {product} {default} bool PrintTieredEvents false {product} {default} bool PrintVMOptions false {product} {default} bool PrintWarnings true {product} {default} uintx ProcessDistributionStride 4 {product} {default} bool ProfileInterpreter true {pd product} {default} intx ProfileMaturityPercentage 20 {product} {default} uintx ProfiledCodeHeapSize 122027880 {pd product} {ergonomic} uintx PromotedPadding 3 {product} {default} uintx QueuedAllocationWarningCount 0 {product} {default} int RTMRetryCount 5 {ARCH product} {default} bool RangeCheckElimination true {product} {default} bool ReassociateInvariants true {C2 product} {default} bool RecordDynamicDumpInfo false {product} {default} bool ReduceBulkZeroing true {C2 product} {default} bool ReduceFieldZeroing true {C2 product} {default} bool ReduceInitialCardMarks true {C2 product} {default} bool ReduceSignalUsage false {product} {default} intx RefDiscoveryPolicy 0 {product} {default} bool RegisterFinalizersAtInit true {product} {default} bool RelaxAccessControlCheck false {product} {default} ccstr ReplayDataFile {product} {default} bool RequireSharedSpaces false {product} {default} uintx ReservedCodeCacheSize 251658240 {pd product} {ergonomic} bool ResizePLAB true {product} {default} bool ResizeTLAB true {product} {default} bool RestoreMXCSROnJNICalls false {product} {default} bool RestrictContended true {product} {default} bool RestrictReservedStack true {product} {default} bool RewriteBytecodes true {pd product} {default} bool RewriteFrequentPairs true {pd product} {default} bool SafepointTimeout false {product} {default} intx SafepointTimeoutDelay 10000 {product} {default} bool ScavengeBeforeFullGC false {product} {default} bool SegmentedCodeCache true {product} {ergonomic} intx SelfDestructTimer 0 {product} {default} ccstr SharedArchiveConfigFile {product} {default} ccstr SharedArchiveFile {product} {default} size_t SharedBaseAddress 34359738368 {product} {default} ccstr SharedClassListFile {product} {default} uintx SharedSymbolTableBucketSize 4 {product} {default} ccstr ShenandoahGCHeuristics adaptive {product} {default} ccstr ShenandoahGCMode satb {product} {default} bool ShowCodeDetailsInExceptionMessages true {manageable} {default} bool ShowMessageBoxOnError false {product} {default} bool ShrinkHeapInSteps true {product} {default} size_t SoftMaxHeapSize 7818182656 {manageable} {ergonomic} intx SoftRefLRUPolicyMSPerMB 1000 {product} {default} bool SplitIfBlocks true {C2 product} {default} intx StackRedPages 1 {pd product} {default} intx StackReservedPages 1 {pd product} {default} intx StackShadowPages 20 {pd product} {default} bool StackTraceInThrowable true {product} {default} intx StackYellowPages 2 {pd product} {default} uintx StartAggressiveSweepingAt 10 {product} {default} bool StartAttachListener false {product} {default} ccstr StartFlightRecording {product} {default} uint StringDeduplicationAgeThreshold 3 {product} {default} uintx StringTableSize 65536 {product} {default} bool SuperWordLoopUnrollAnalysis true {C2 pd product} {default} bool SuperWordReductions true {C2 product} {default} bool SuppressFatalErrorMessage false {product} {default} uintx SurvivorPadding 3 {product} {default} uintx SurvivorRatio 8 {product} {default} double SweeperThreshold 0.500000 {product} {default} uintx TLABAllocationWeight 35 {product} {default} uintx TLABRefillWasteFraction 64 {product} {default} size_t TLABSize 0 {product} {default} bool TLABStats true {product} {default} uintx TLABWasteIncrement 4 {product} {default} uintx TLABWasteTargetPercent 1 {product} {default} uintx TargetPLABWastePct 10 {product} {default} uintx TargetSurvivorRatio 50 {product} {default} uintx TenuredGenerationSizeIncrement 20 {product} {default} uintx TenuredGenerationSizeSupplement 80 {product} {default} uintx TenuredGenerationSizeSupplementDecay 2 {product} {default} intx ThreadPriorityPolicy 0 {product} {default} bool ThreadPriorityVerbose false {product} {default} intx ThreadStackSize 1024 {pd product} {default} uintx ThresholdTolerance 10 {product} {default} intx Tier0BackedgeNotifyFreqLog 10 {product} {default} intx Tier0InvokeNotifyFreqLog 7 {product} {default} intx Tier0ProfilingStartPercentage 200 {product} {default} intx Tier23InlineeNotifyFreqLog 20 {product} {default} intx Tier2BackEdgeThreshold 0 {product} {default} intx Tier2BackedgeNotifyFreqLog 14 {product} {default} intx Tier2CompileThreshold 0 {product} {default} intx Tier2InvokeNotifyFreqLog 11 {product} {default} intx Tier3BackEdgeThreshold 60000 {product} {default} intx Tier3BackedgeNotifyFreqLog 13 {product} {default} intx Tier3CompileThreshold 2000 {product} {default} intx Tier3DelayOff 2 {product} {default} intx Tier3DelayOn 5 {product} {default} intx Tier3InvocationThreshold 200 {product} {default} intx Tier3InvokeNotifyFreqLog 10 {product} {default} intx Tier3LoadFeedback 5 {product} {default} intx Tier3MinInvocationThreshold 100 {product} {default} intx Tier4BackEdgeThreshold 40000 {product} {default} intx Tier4CompileThreshold 15000 {product} {default} intx Tier4InvocationThreshold 5000 {product} {default} intx Tier4LoadFeedback 3 {product} {default} intx Tier4MinInvocationThreshold 600 {product} {default} bool TieredCompilation true {pd product} {default} intx TieredCompileTaskTimeout 50 {product} {default} intx TieredRateUpdateMaxTime 25 {product} {default} intx TieredRateUpdateMinTime 1 {product} {default} intx TieredStopAtLevel 4 {product} {default} bool TimeLinearScan false {C1 product} {default} ccstr TraceJVMTI {product} {default} intx TrackedInitializationLimit 50 {C2 product} {default} bool TrapBasedNullChecks false {pd product} {default} bool TrapBasedRangeChecks false {C2 pd product} {default} intx TypeProfileArgsLimit 2 {product} {default} uintx TypeProfileLevel 111 {pd product} {default} intx TypeProfileMajorReceiverPercent 90 {C2 product} {default} intx TypeProfileParmsLimit 2 {product} {default} intx TypeProfileWidth 2 {product} {default} intx UnguardOnExecutionViolation 0 {product} {default} bool UseAES true {product} {default} intx UseAVX 2 {ARCH product} {default} bool UseAdaptiveGenerationSizePolicyAtMajorCollection true {product} {default} bool UseAdaptiveGenerationSizePolicyAtMinorCollection true {product} {default} bool UseAdaptiveNUMAChunkSizing true {product} {default} bool UseAdaptiveSizeDecayMajorGCCost true {product} {default} bool UseAdaptiveSizePolicy true {product} {default} bool UseAdaptiveSizePolicyFootprintGoal true {product} {default} bool UseAdaptiveSizePolicyWithSystemGC false {product} {default} bool UseAddressNop true {ARCH product} {default} bool UseBASE64Intrinsics false {product} {default} bool UseBMI1Instructions true {ARCH product} {default} bool UseBMI2Instructions true {ARCH product} {default} bool UseBiasedLocking false {product} {default} bool UseBimorphicInlining true {C2 product} {default} bool UseCLMUL true {ARCH product} {default} bool UseCMoveUnconditionally false {C2 product} {default} bool UseCodeAging true {product} {default} bool UseCodeCacheFlushing true {product} {default} bool UseCompiler true {product} {default} bool UseCompressedClassPointers true {product lp64_product} {ergonomic} bool UseCompressedOops true {product lp64_product} {ergonomic} bool UseCondCardMark false {product} {default} bool UseContainerSupport true {product} {default} bool UseCountLeadingZerosInstruction true {ARCH product} {default} bool UseCountTrailingZerosInstruction true {ARCH product} {default} bool UseCountedLoopSafepoints true {C2 product} {default} bool UseCounterDecay true {product} {default} bool UseDivMod true {C2 product} {default} bool UseDynamicNumberOfCompilerThreads true {product} {default} bool UseDynamicNumberOfGCThreads true {product} {default} bool UseEmptySlotsInSupers true {product} {default} bool UseFMA true {product} {default} bool UseFPUForSpilling true {C2 product} {default} bool UseFastJNIAccessors true {product} {default} bool UseFastStosb false {ARCH product} {default} bool UseG1GC true {product} {ergonomic} bool UseGCOverheadLimit true {product} {default} bool UseHeavyMonitors false {product} {default} bool UseHugeTLBFS false {product} {default} bool UseInlineCaches true {product} {default} bool UseInterpreter true {product} {default} bool UseJumpTables true {C2 product} {default} bool UseLargePages false {pd product} {default} bool UseLargePagesIndividualAllocation false {pd product} {default} bool UseLinuxPosixThreadCPUClocks true {product} {default} bool UseLoopCounter true {product} {default} bool UseLoopInvariantCodeMotion true {C1 product} {default} bool UseLoopPredicate true {C2 product} {default} bool UseMaximumCompactionOnSystemGC true {product} {default} bool UseNUMA false {product} {default} bool UseNUMAInterleaving false {product} {default} bool UseNewLongLShift true {ARCH product} {default} bool UseNotificationThread true {product} {default} bool UseOnStackReplacement true {pd product} {default} bool UseOnlyInlinedBimorphic true {C2 product} {default} bool UseOprofile false {product} {default} bool UseOptoBiasInlining false {C2 product} {default} bool UsePSAdaptiveSurvivorSizePolicy true {product} {default} bool UseParallelGC false {product} {default} bool UsePerfData true {product} {default} bool UsePopCountInstruction true {product} {default} bool UseProfiledLoopPredicate true {C2 product} {default} bool UseRTMDeopt false {ARCH product} {default} bool UseRTMLocking false {ARCH product} {default} bool UseSHA true {product} {default} bool UseSHM false {product} {default} intx UseSSE 4 {ARCH product} {default} bool UseSSE42Intrinsics true {ARCH product} {default} bool UseSerialGC false {product} {default} bool UseSharedSpaces true {product} {default} bool UseShenandoahGC false {product} {default} bool UseSignalChaining true {product} {default} bool UseStoreImmI16 true {ARCH product} {default} bool UseStringDeduplication false {product} {default} bool UseSubwordForMaxVector true {C2 product} {default} bool UseSuperWord true {C2 product} {default} bool UseTLAB true {product} {default} bool UseThreadPriorities true {pd product} {default} bool UseTransparentHugePages false {product} {default} bool UseTypeProfile true {product} {default} bool UseTypeSpeculation true {C2 product} {default} bool UseUnalignedLoadStores true {ARCH product} {default} bool UseVectorCmov false {C2 product} {default} bool UseXMMForArrayCopy true {product} {default} bool UseXMMForObjInit true {ARCH product} {default} bool UseXmmI2D true {ARCH product} {default} bool UseXmmI2F true {ARCH product} {default} bool UseXmmLoadAndClearUpper true {ARCH product} {default} bool UseXmmRegToRegMoveAll true {ARCH product} {default} bool UseZGC false {product} {default} intx VMThreadPriority -1 {product} {default} intx VMThreadStackSize 1024 {pd product} {default} intx ValueMapInitialSize 11 {C1 product} {default} intx ValueMapMaxLoopSize 8 {C1 product} {default} intx ValueSearchLimit 1000 {C2 product} {default} bool VerifySharedSpaces false {product} {default} uintx YoungGenerationSizeIncrement 20 {product} {default} uintx YoungGenerationSizeSupplement 80 {product} {default} uintx YoungGenerationSizeSupplementDecay 8 {product} {default} size_t YoungPLABSize 4096 {product} {default} double ZAllocationSpikeTolerance 2.000000 {product} {default} double ZCollectionInterval 0.000000 {product} {default} double ZFragmentationLimit 25.000000 {product} {default} size_t ZMarkStackSpaceLimit 8589934592 {product} {default} bool ZProactive true {product} {default} bool ZUncommit true {product} {default} uintx ZUncommitDelay 300 {product} {default} bool ZeroTLAB false {product} {default}","title":"Reference: Java 17 JVM flags"},{"location":"reference/jvm/java-17-flags/#reference-java-17-jvm-flags","text":"A complete list of all flags available for the JVM, created using the -XX:+PrintFlagsFinal option and the results written to a file java -XX:+PrintFlagsFinal > java-flags.md Find specific flags by using grep on the output with a name java -XX:+PrintFlagsFinal -version | grep MaxHeap Type Name Units ? ? uintx MaxHeapFreeRatio 70 {manageable} {default} size_t MaxHeapSize 8342470656 {product} {ergonomic} size_t SoftMaxHeapSize 8342470656 {manageable} {ergonomic}","title":"Reference: Java 17 JVM flags"},{"location":"reference/jvm/java-17-flags/#full-list-of-jvm-flags","text":"Type Option Name Default value Product Category int ActiveProcessorCount -1 {product} {default} uintx AdaptiveSizeDecrementScaleFactor 4 {product} {default} uintx AdaptiveSizeMajorGCDecayTimeScale 10 {product} {default} uintx AdaptiveSizePolicyCollectionCostMargin 50 {product} {default} uintx AdaptiveSizePolicyInitializingSteps 20 {product} {default} uintx AdaptiveSizePolicyOutputInterval 0 {product} {default} uintx AdaptiveSizePolicyWeight 10 {product} {default} uintx AdaptiveSizeThroughPutPolicy 0 {product} {default} uintx AdaptiveTimeWeight 25 {product} {default} bool AdjustStackSizeForTLS false {product} {default} bool AggressiveHeap false {product} {default} intx AliasLevel 3 {C2 product} {default} bool AlignVector false {C2 product} {default} ccstr AllocateHeapAt {product} {default} intx AllocateInstancePrefetchLines 1 {product} {default} intx AllocatePrefetchDistance 256 {product} {default} intx AllocatePrefetchInstr 0 {product} {default} intx AllocatePrefetchLines 3 {product} {default} intx AllocatePrefetchStepSize 64 {product} {default} intx AllocatePrefetchStyle 1 {product} {default} bool AllowParallelDefineClass false {product} {default} bool AllowRedefinitionToAddDeleteMethods false {product} {default} bool AllowUserSignalHandlers false {product} {default} bool AllowVectorizeOnDemand true {C2 product} {default} bool AlwaysActAsServerClassMachine false {product} {default} bool AlwaysCompileLoopMethods false {product} {default} bool AlwaysLockClassLoader false {product} {default} bool AlwaysPreTouch false {product} {default} bool AlwaysRestoreFPU false {product} {default} bool AlwaysTenure false {product} {default} ccstr ArchiveClassesAtExit {product} {default} intx ArrayCopyLoadStoreMaxElem 8 {C2 product} {default} size_t AsyncLogBufferSize 2097152 {product} {default} intx AutoBoxCacheMax 128 {C2 product} {default} intx BCEATraceLevel 0 {product} {default} bool BackgroundCompilation true {pd product} {default} size_t BaseFootPrintEstimate 268435456 {product} {default} intx BiasedLockingBulkRebiasThreshold 20 {product} {default} intx BiasedLockingBulkRevokeThreshold 40 {product} {default} intx BiasedLockingDecayTime 25000 {product} {default} intx BiasedLockingStartupDelay 0 {product} {default} bool BlockLayoutByFrequency true {C2 product} {default} intx BlockLayoutMinDiamondPercentage 20 {C2 product} {default} bool BlockLayoutRotateLoops true {C2 product} {default} intx C1InlineStackLimit 5 {C1 product} {default} intx C1MaxInlineLevel 9 {C1 product} {default} intx C1MaxInlineSize 35 {C1 product} {default} intx C1MaxRecursiveInlineLevel 1 {C1 product} {default} intx C1MaxTrivialSize 6 {C1 product} {default} bool C1OptimizeVirtualCallProfiling true {C1 product} {default} bool C1ProfileBranches true {C1 product} {default} bool C1ProfileCalls true {C1 product} {default} bool C1ProfileCheckcasts true {C1 product} {default} bool C1ProfileInlinedCalls true {C1 product} {default} bool C1ProfileVirtualCalls true {C1 product} {default} bool C1UpdateMethodData true {C1 product} {default} intx CICompilerCount 12 {product} {ergonomic} bool CICompilerCountPerCPU true {product} {default} bool CITime false {product} {default} bool CheckJNICalls false {product} {default} bool ClassUnloading true {product} {default} bool ClassUnloadingWithConcurrentMark true {product} {default} bool ClipInlining true {product} {default} uintx CodeCacheExpansionSize 65536 {pd product} {default} bool CompactStrings true {pd product} {default} ccstr CompilationMode default {product} {default} ccstrlist CompileCommand {product} {default} ccstr CompileCommandFile {product} {default} ccstrlist CompileOnly {product} {default} intx CompileThreshold 10000 {pd product} {default} double CompileThresholdScaling 1.000000 {product} {default} intx CompilerThreadPriority -1 {product} {default} intx CompilerThreadStackSize 1024 {pd product} {default} size_t CompressedClassSpaceSize 1073741824 {product} {default} uint ConcGCThreads 3 {product} {ergonomic} intx ConditionalMoveLimit 3 {C2 pd product} {default} intx ContendedPaddingWidth 128 {product} {default} bool CrashOnOutOfMemoryError false {product} {default} bool CreateCoredumpOnCrash true {product} {default} bool CriticalJNINatives false {product} {default} bool DTraceAllocProbes false {product} {default} bool DTraceMethodProbes false {product} {default} bool DTraceMonitorProbes false {product} {default} bool DisableAttachMechanism false {product} {default} bool DisableExplicitGC false {product} {default} bool DisplayVMOutputToStderr false {product} {default} bool DisplayVMOutputToStdout false {product} {default} bool DoEscapeAnalysis true {C2 product} {default} bool DoReserveCopyInSuperWord true {C2 product} {default} bool DontCompileHugeMethods true {product} {default} bool DontYieldALot false {pd product} {default} ccstr DumpLoadedClassList {product} {default} bool DumpReplayDataOnError true {product} {default} bool DumpSharedSpaces false {product} {default} bool DynamicDumpSharedSpaces false {product} {default} bool EagerXrunInit false {product} {default} intx EliminateAllocationArraySizeLimit 64 {C2 product} {default} bool EliminateAllocations true {C2 product} {default} bool EliminateAutoBox true {C2 product} {default} bool EliminateLocks true {C2 product} {default} bool EliminateNestedLocks true {C2 product} {default} bool EnableContended true {product} {default} bool EnableDynamicAgentLoading true {product} {default} size_t ErgoHeapSizeLimit 0 {product} {default} ccstr ErrorFile {product} {default} bool ErrorFileToStderr false {product} {default} bool ErrorFileToStdout false {product} {default} uint64_t ErrorLogTimeout 120 {product} {default} double EscapeAnalysisTimeout 20.000000 {C2 product} {default} bool EstimateArgEscape true {product} {default} bool ExecutingUnitTests false {product} {default} bool ExitOnOutOfMemoryError false {product} {default} bool ExplicitGCInvokesConcurrent false {product} {default} bool ExtendedDTraceProbes false {product} {default} bool ExtensiveErrorReports false {product} {default} ccstr ExtraSharedClassListFile {product} {default} bool FilterSpuriousWakeups true {product} {default} bool FlightRecorder false {product} {default} ccstr FlightRecorderOptions {product} {default} bool ForceTimeHighResolution false {product} {default} intx FreqInlineSize 325 {C2 pd product} {default} double G1ConcMarkStepDurationMillis 10.000000 {product} {default} uintx G1ConcRSHotCardLimit 4 {product} {default} size_t G1ConcRSLogCacheSize 10 {product} {default} size_t G1ConcRefinementGreenZone 0 {product} {default} size_t G1ConcRefinementRedZone 0 {product} {default} uintx G1ConcRefinementServiceIntervalMillis 300 {product} {default} uint G1ConcRefinementThreads 13 {product} {ergonomic} size_t G1ConcRefinementThresholdStep 2 {product} {default} size_t G1ConcRefinementYellowZone 0 {product} {default} uintx G1ConfidencePercent 50 {product} {default} size_t G1HeapRegionSize 4194304 {product} {ergonomic} uintx G1HeapWastePercent 5 {product} {default} uintx G1MixedGCCountTarget 8 {product} {default} uintx G1PeriodicGCInterval 0 {manageable} {default} bool G1PeriodicGCInvokesConcurrent true {product} {default} double G1PeriodicGCSystemLoadThreshold 0.000000 {manageable} {default} intx G1RSetRegionEntries 768 {product} {default} intx G1RSetSparseRegionEntries 32 {product} {default} intx G1RSetUpdatingPauseTimePercent 10 {product} {default} uint G1RefProcDrainInterval 1000 {product} {default} uintx G1ReservePercent 10 {product} {default} uintx G1SATBBufferEnqueueingThresholdPercent 60 {product} {default} size_t G1SATBBufferSize 1024 {product} {default} size_t G1UpdateBufferSize 256 {product} {default} bool G1UseAdaptiveConcRefinement true {product} {default} bool G1UseAdaptiveIHOP true {product} {default} uintx GCDrainStackTargetSize 64 {product} {ergonomic} uintx GCHeapFreeLimit 2 {product} {default} uintx GCLockerEdenExpansionPercent 5 {product} {default} uintx GCPauseIntervalMillis 201 {product} {default} uintx GCTimeLimit 98 {product} {default} uintx GCTimeRatio 12 {product} {default} size_t HeapBaseMinAddress 2147483648 {pd product} {default} bool HeapDumpAfterFullGC false {manageable} {default} bool HeapDumpBeforeFullGC false {manageable} {default} intx HeapDumpGzipLevel 0 {manageable} {default} bool HeapDumpOnOutOfMemoryError false {manageable} {default} ccstr HeapDumpPath {manageable} {default} uintx HeapFirstMaximumCompactionCount 3 {product} {default} uintx HeapMaximumCompactionInterval 20 {product} {default} uintx HeapSearchSteps 3 {product} {default} size_t HeapSizePerGCThread 43620760 {product} {default} bool IgnoreEmptyClassPaths false {product} {default} bool IgnoreUnrecognizedVMOptions false {product} {default} uintx IncreaseFirstTierCompileThresholdAt 50 {product} {default} bool IncrementalInline true {C2 product} {default} uintx InitialCodeCacheSize 2555904 {pd product} {default} size_t InitialHeapSize 490733568 {product} {ergonomic} uintx InitialRAMFraction 64 {product} {default} double InitialRAMPercentage 1.562500 {product} {default} uintx InitialSurvivorRatio 8 {product} {default} uintx InitialTenuringThreshold 7 {product} {default} uintx InitiatingHeapOccupancyPercent 45 {product} {default} bool Inline true {product} {default} ccstr InlineDataFile {product} {default} intx InlineSmallCode 2500 {C2 pd product} {default} bool InlineSynchronizedMethods true {C1 product} {default} intx InteriorEntryAlignment 16 {C2 pd product} {default} intx InterpreterProfilePercentage 33 {product} {default} bool JavaMonitorsInStackTrace true {product} {default} intx JavaPriority10_To_OSPriority -1 {product} {default} intx JavaPriority1_To_OSPriority -1 {product} {default} intx JavaPriority2_To_OSPriority -1 {product} {default} intx JavaPriority3_To_OSPriority -1 {product} {default} intx JavaPriority4_To_OSPriority -1 {product} {default} intx JavaPriority5_To_OSPriority -1 {product} {default} intx JavaPriority6_To_OSPriority -1 {product} {default} intx JavaPriority7_To_OSPriority -1 {product} {default} intx JavaPriority8_To_OSPriority -1 {product} {default} intx JavaPriority9_To_OSPriority -1 {product} {default} size_t LargePageHeapSizeThreshold 134217728 {product} {default} size_t LargePageSizeInBytes 0 {product} {default} intx LiveNodeCountInliningCutoff 40000 {C2 product} {default} bool LoadExecStackDllInVMThread true {product} {default} intx LoopMaxUnroll 16 {C2 product} {default} intx LoopOptsCount 43 {C2 product} {default} intx LoopPercentProfileLimit 30 {C2 pd product} {default} uintx LoopStripMiningIter 1000 {C2 product} {default} uintx LoopStripMiningIterShortLoop 100 {C2 product} {default} intx LoopUnrollLimit 60 {C2 pd product} {default} intx LoopUnrollMin 4 {C2 product} {default} bool LoopUnswitching true {C2 product} {default} bool ManagementServer false {product} {default} size_t MarkStackSize 4194304 {product} {ergonomic} size_t MarkStackSizeMax 536870912 {product} {default} uint MarkSweepAlwaysCompactCount 4 {product} {default} uintx MarkSweepDeadRatio 5 {product} {default} intx MaxBCEAEstimateLevel 5 {product} {default} intx MaxBCEAEstimateSize 150 {product} {default} uint64_t MaxDirectMemorySize 0 {product} {default} bool MaxFDLimit true {product} {default} uintx MaxGCMinorPauseMillis 18446744073709551615 {product} {default} uintx MaxGCPauseMillis 200 {product} {default} uintx MaxHeapFreeRatio 70 {manageable} {default} size_t MaxHeapSize 7818182656 {product} {ergonomic} intx MaxInlineLevel 15 {C2 product} {default} intx MaxInlineSize 35 {C2 product} {default} intx MaxJNILocalCapacity 65536 {product} {default} intx MaxJavaStackTraceDepth 1024 {product} {default} intx MaxJumpTableSize 65000 {C2 product} {default} intx MaxJumpTableSparseness 5 {C2 product} {default} intx MaxLabelRootDepth 1100 {C2 product} {default} intx MaxLoopPad 15 {C2 product} {default} size_t MaxMetaspaceExpansion 5439488 {product} {default} uintx MaxMetaspaceFreeRatio 70 {product} {default} size_t MaxMetaspaceSize 18446744073709551615 {product} {default} size_t MaxNewSize 4689231872 {product} {ergonomic} intx MaxNodeLimit 80000 {C2 product} {default} uint64_t MaxRAM 137438953472 {pd product} {default} uintx MaxRAMFraction 4 {product} {default} double MaxRAMPercentage 25.000000 {product} {default} intx MaxRecursiveInlineLevel 1 {C2 product} {default} uintx MaxTenuringThreshold 15 {product} {default} intx MaxTrivialSize 6 {C2 product} {default} intx MaxVectorSize 32 {C2 product} {default} ccstr MetaspaceReclaimPolicy balanced {product} {default} size_t MetaspaceSize 22020096 {product} {default} bool MethodFlushing true {product} {default} size_t MinHeapDeltaBytes 4194304 {product} {ergonomic} uintx MinHeapFreeRatio 40 {manageable} {default} size_t MinHeapSize 8388608 {product} {ergonomic} intx MinInliningThreshold 250 {product} {default} intx MinJumpTableSize 10 {C2 pd product} {default} size_t MinMetaspaceExpansion 327680 {product} {default} uintx MinMetaspaceFreeRatio 40 {product} {default} uintx MinRAMFraction 2 {product} {default} double MinRAMPercentage 50.000000 {product} {default} uintx MinSurvivorRatio 3 {product} {default} size_t MinTLABSize 2048 {product} {default} intx MultiArrayExpandLimit 6 {C2 product} {default} uintx NUMAChunkResizeWeight 20 {product} {default} size_t NUMAInterleaveGranularity 2097152 {product} {default} uintx NUMAPageScanRate 256 {product} {default} size_t NUMASpaceResizeRate 1073741824 {product} {default} bool NUMAStats false {product} {default} ccstr NativeMemoryTracking off {product} {default} bool NeverActAsServerClassMachine false {pd product} {default} bool NeverTenure false {product} {default} uintx NewRatio 2 {product} {default} size_t NewSize 1363144 {product} {default} size_t NewSizeThreadIncrease 5320 {pd product} {default} intx NmethodSweepActivity 10 {product} {default} intx NodeLimitFudgeFactor 2000 {C2 product} {default} uintx NonNMethodCodeHeapSize 7602480 {pd product} {ergonomic} uintx NonProfiledCodeHeapSize 122027880 {pd product} {ergonomic} intx NumberOfLoopInstrToAlign 4 {C2 product} {default} intx ObjectAlignmentInBytes 8 {product lp64_product} {default} size_t OldPLABSize 1024 {product} {default} size_t OldSize 5452592 {product} {default} bool OmitStackTraceInFastThrow true {product} {default} ccstrlist OnError {product} {default} ccstrlist OnOutOfMemoryError {product} {default} intx OnStackReplacePercentage 140 {pd product} {default} bool OptimizeFill false {C2 product} {default} bool OptimizePtrCompare true {C2 product} {default} bool OptimizeStringConcat true {C2 product} {default} bool OptoBundling false {C2 pd product} {default} intx OptoLoopAlignment 16 {pd product} {default} bool OptoRegScheduling true {C2 pd product} {default} bool OptoScheduling false {C2 pd product} {default} uintx PLABWeight 75 {product} {default} bool PSChunkLargeArrays true {product} {default} int ParGCArrayScanChunk 50 {product} {default} uintx ParallelGCBufferWastePct 10 {product} {default} uint ParallelGCThreads 13 {product} {default} size_t ParallelOldDeadWoodLimiterMean 50 {product} {default} size_t ParallelOldDeadWoodLimiterStdDev 80 {product} {default} bool ParallelRefProcBalancingEnabled true {product} {default} bool ParallelRefProcEnabled true {product} {default} bool PartialPeelAtUnsignedTests true {C2 product} {default} bool PartialPeelLoop true {C2 product} {default} intx PartialPeelNewPhiDelta 0 {C2 product} {default} uintx PausePadding 1 {product} {default} intx PerBytecodeRecompilationCutoff 200 {product} {default} intx PerBytecodeTrapLimit 4 {product} {default} intx PerMethodRecompilationCutoff 400 {product} {default} intx PerMethodTrapLimit 100 {product} {default} bool PerfAllowAtExitRegistration false {product} {default} bool PerfBypassFileSystemCheck false {product} {default} intx PerfDataMemorySize 32768 {product} {default} intx PerfDataSamplingInterval 50 {product} {default} ccstr PerfDataSaveFile {product} {default} bool PerfDataSaveToFile false {product} {default} bool PerfDisableSharedMem false {product} {default} intx PerfMaxStringConstLength 1024 {product} {default} size_t PreTouchParallelChunkSize 4194304 {pd product} {default} bool PreferContainerQuotaForCPUCount true {product} {default} bool PreferInterpreterNativeStubs false {pd product} {default} intx PrefetchCopyIntervalInBytes 576 {product} {default} intx PrefetchFieldsAhead 1 {product} {default} intx PrefetchScanIntervalInBytes 576 {product} {default} bool PreserveAllAnnotations false {product} {default} bool PreserveFramePointer false {pd product} {default} size_t PretenureSizeThreshold 0 {product} {default} bool PrintClassHistogram false {manageable} {default} bool PrintCodeCache false {product} {default} bool PrintCodeCacheOnCompilation false {product} {default} bool PrintCommandLineFlags false {product} {default} bool PrintCompilation false {product} {default} bool PrintConcurrentLocks false {manageable} {default} bool PrintExtendedThreadInfo false {product} {default} bool PrintFlagsFinal true {product} {command line} bool PrintFlagsInitial false {product} {default} bool PrintFlagsRanges false {product} {default} bool PrintGC false {product} {default} bool PrintGCDetails false {product} {default} bool PrintHeapAtSIGBREAK true {product} {default} bool PrintSharedArchiveAndExit false {product} {default} bool PrintSharedDictionary false {product} {default} bool PrintStringTableStatistics false {product} {default} bool PrintTieredEvents false {product} {default} bool PrintVMOptions false {product} {default} bool PrintWarnings true {product} {default} uintx ProcessDistributionStride 4 {product} {default} bool ProfileInterpreter true {pd product} {default} intx ProfileMaturityPercentage 20 {product} {default} uintx ProfiledCodeHeapSize 122027880 {pd product} {ergonomic} uintx PromotedPadding 3 {product} {default} uintx QueuedAllocationWarningCount 0 {product} {default} int RTMRetryCount 5 {ARCH product} {default} bool RangeCheckElimination true {product} {default} bool ReassociateInvariants true {C2 product} {default} bool RecordDynamicDumpInfo false {product} {default} bool ReduceBulkZeroing true {C2 product} {default} bool ReduceFieldZeroing true {C2 product} {default} bool ReduceInitialCardMarks true {C2 product} {default} bool ReduceSignalUsage false {product} {default} intx RefDiscoveryPolicy 0 {product} {default} bool RegisterFinalizersAtInit true {product} {default} bool RelaxAccessControlCheck false {product} {default} ccstr ReplayDataFile {product} {default} bool RequireSharedSpaces false {product} {default} uintx ReservedCodeCacheSize 251658240 {pd product} {ergonomic} bool ResizePLAB true {product} {default} bool ResizeTLAB true {product} {default} bool RestoreMXCSROnJNICalls false {product} {default} bool RestrictContended true {product} {default} bool RestrictReservedStack true {product} {default} bool RewriteBytecodes true {pd product} {default} bool RewriteFrequentPairs true {pd product} {default} bool SafepointTimeout false {product} {default} intx SafepointTimeoutDelay 10000 {product} {default} bool ScavengeBeforeFullGC false {product} {default} bool SegmentedCodeCache true {product} {ergonomic} intx SelfDestructTimer 0 {product} {default} ccstr SharedArchiveConfigFile {product} {default} ccstr SharedArchiveFile {product} {default} size_t SharedBaseAddress 34359738368 {product} {default} ccstr SharedClassListFile {product} {default} uintx SharedSymbolTableBucketSize 4 {product} {default} ccstr ShenandoahGCHeuristics adaptive {product} {default} ccstr ShenandoahGCMode satb {product} {default} bool ShowCodeDetailsInExceptionMessages true {manageable} {default} bool ShowMessageBoxOnError false {product} {default} bool ShrinkHeapInSteps true {product} {default} size_t SoftMaxHeapSize 7818182656 {manageable} {ergonomic} intx SoftRefLRUPolicyMSPerMB 1000 {product} {default} bool SplitIfBlocks true {C2 product} {default} intx StackRedPages 1 {pd product} {default} intx StackReservedPages 1 {pd product} {default} intx StackShadowPages 20 {pd product} {default} bool StackTraceInThrowable true {product} {default} intx StackYellowPages 2 {pd product} {default} uintx StartAggressiveSweepingAt 10 {product} {default} bool StartAttachListener false {product} {default} ccstr StartFlightRecording {product} {default} uint StringDeduplicationAgeThreshold 3 {product} {default} uintx StringTableSize 65536 {product} {default} bool SuperWordLoopUnrollAnalysis true {C2 pd product} {default} bool SuperWordReductions true {C2 product} {default} bool SuppressFatalErrorMessage false {product} {default} uintx SurvivorPadding 3 {product} {default} uintx SurvivorRatio 8 {product} {default} double SweeperThreshold 0.500000 {product} {default} uintx TLABAllocationWeight 35 {product} {default} uintx TLABRefillWasteFraction 64 {product} {default} size_t TLABSize 0 {product} {default} bool TLABStats true {product} {default} uintx TLABWasteIncrement 4 {product} {default} uintx TLABWasteTargetPercent 1 {product} {default} uintx TargetPLABWastePct 10 {product} {default} uintx TargetSurvivorRatio 50 {product} {default} uintx TenuredGenerationSizeIncrement 20 {product} {default} uintx TenuredGenerationSizeSupplement 80 {product} {default} uintx TenuredGenerationSizeSupplementDecay 2 {product} {default} intx ThreadPriorityPolicy 0 {product} {default} bool ThreadPriorityVerbose false {product} {default} intx ThreadStackSize 1024 {pd product} {default} uintx ThresholdTolerance 10 {product} {default} intx Tier0BackedgeNotifyFreqLog 10 {product} {default} intx Tier0InvokeNotifyFreqLog 7 {product} {default} intx Tier0ProfilingStartPercentage 200 {product} {default} intx Tier23InlineeNotifyFreqLog 20 {product} {default} intx Tier2BackEdgeThreshold 0 {product} {default} intx Tier2BackedgeNotifyFreqLog 14 {product} {default} intx Tier2CompileThreshold 0 {product} {default} intx Tier2InvokeNotifyFreqLog 11 {product} {default} intx Tier3BackEdgeThreshold 60000 {product} {default} intx Tier3BackedgeNotifyFreqLog 13 {product} {default} intx Tier3CompileThreshold 2000 {product} {default} intx Tier3DelayOff 2 {product} {default} intx Tier3DelayOn 5 {product} {default} intx Tier3InvocationThreshold 200 {product} {default} intx Tier3InvokeNotifyFreqLog 10 {product} {default} intx Tier3LoadFeedback 5 {product} {default} intx Tier3MinInvocationThreshold 100 {product} {default} intx Tier4BackEdgeThreshold 40000 {product} {default} intx Tier4CompileThreshold 15000 {product} {default} intx Tier4InvocationThreshold 5000 {product} {default} intx Tier4LoadFeedback 3 {product} {default} intx Tier4MinInvocationThreshold 600 {product} {default} bool TieredCompilation true {pd product} {default} intx TieredCompileTaskTimeout 50 {product} {default} intx TieredRateUpdateMaxTime 25 {product} {default} intx TieredRateUpdateMinTime 1 {product} {default} intx TieredStopAtLevel 4 {product} {default} bool TimeLinearScan false {C1 product} {default} ccstr TraceJVMTI {product} {default} intx TrackedInitializationLimit 50 {C2 product} {default} bool TrapBasedNullChecks false {pd product} {default} bool TrapBasedRangeChecks false {C2 pd product} {default} intx TypeProfileArgsLimit 2 {product} {default} uintx TypeProfileLevel 111 {pd product} {default} intx TypeProfileMajorReceiverPercent 90 {C2 product} {default} intx TypeProfileParmsLimit 2 {product} {default} intx TypeProfileWidth 2 {product} {default} intx UnguardOnExecutionViolation 0 {product} {default} bool UseAES true {product} {default} intx UseAVX 2 {ARCH product} {default} bool UseAdaptiveGenerationSizePolicyAtMajorCollection true {product} {default} bool UseAdaptiveGenerationSizePolicyAtMinorCollection true {product} {default} bool UseAdaptiveNUMAChunkSizing true {product} {default} bool UseAdaptiveSizeDecayMajorGCCost true {product} {default} bool UseAdaptiveSizePolicy true {product} {default} bool UseAdaptiveSizePolicyFootprintGoal true {product} {default} bool UseAdaptiveSizePolicyWithSystemGC false {product} {default} bool UseAddressNop true {ARCH product} {default} bool UseBASE64Intrinsics false {product} {default} bool UseBMI1Instructions true {ARCH product} {default} bool UseBMI2Instructions true {ARCH product} {default} bool UseBiasedLocking false {product} {default} bool UseBimorphicInlining true {C2 product} {default} bool UseCLMUL true {ARCH product} {default} bool UseCMoveUnconditionally false {C2 product} {default} bool UseCodeAging true {product} {default} bool UseCodeCacheFlushing true {product} {default} bool UseCompiler true {product} {default} bool UseCompressedClassPointers true {product lp64_product} {ergonomic} bool UseCompressedOops true {product lp64_product} {ergonomic} bool UseCondCardMark false {product} {default} bool UseContainerSupport true {product} {default} bool UseCountLeadingZerosInstruction true {ARCH product} {default} bool UseCountTrailingZerosInstruction true {ARCH product} {default} bool UseCountedLoopSafepoints true {C2 product} {default} bool UseCounterDecay true {product} {default} bool UseDivMod true {C2 product} {default} bool UseDynamicNumberOfCompilerThreads true {product} {default} bool UseDynamicNumberOfGCThreads true {product} {default} bool UseEmptySlotsInSupers true {product} {default} bool UseFMA true {product} {default} bool UseFPUForSpilling true {C2 product} {default} bool UseFastJNIAccessors true {product} {default} bool UseFastStosb false {ARCH product} {default} bool UseG1GC true {product} {ergonomic} bool UseGCOverheadLimit true {product} {default} bool UseHeavyMonitors false {product} {default} bool UseHugeTLBFS false {product} {default} bool UseInlineCaches true {product} {default} bool UseInterpreter true {product} {default} bool UseJumpTables true {C2 product} {default} bool UseLargePages false {pd product} {default} bool UseLargePagesIndividualAllocation false {pd product} {default} bool UseLinuxPosixThreadCPUClocks true {product} {default} bool UseLoopCounter true {product} {default} bool UseLoopInvariantCodeMotion true {C1 product} {default} bool UseLoopPredicate true {C2 product} {default} bool UseMaximumCompactionOnSystemGC true {product} {default} bool UseNUMA false {product} {default} bool UseNUMAInterleaving false {product} {default} bool UseNewLongLShift true {ARCH product} {default} bool UseNotificationThread true {product} {default} bool UseOnStackReplacement true {pd product} {default} bool UseOnlyInlinedBimorphic true {C2 product} {default} bool UseOprofile false {product} {default} bool UseOptoBiasInlining false {C2 product} {default} bool UsePSAdaptiveSurvivorSizePolicy true {product} {default} bool UseParallelGC false {product} {default} bool UsePerfData true {product} {default} bool UsePopCountInstruction true {product} {default} bool UseProfiledLoopPredicate true {C2 product} {default} bool UseRTMDeopt false {ARCH product} {default} bool UseRTMLocking false {ARCH product} {default} bool UseSHA true {product} {default} bool UseSHM false {product} {default} intx UseSSE 4 {ARCH product} {default} bool UseSSE42Intrinsics true {ARCH product} {default} bool UseSerialGC false {product} {default} bool UseSharedSpaces true {product} {default} bool UseShenandoahGC false {product} {default} bool UseSignalChaining true {product} {default} bool UseStoreImmI16 true {ARCH product} {default} bool UseStringDeduplication false {product} {default} bool UseSubwordForMaxVector true {C2 product} {default} bool UseSuperWord true {C2 product} {default} bool UseTLAB true {product} {default} bool UseThreadPriorities true {pd product} {default} bool UseTransparentHugePages false {product} {default} bool UseTypeProfile true {product} {default} bool UseTypeSpeculation true {C2 product} {default} bool UseUnalignedLoadStores true {ARCH product} {default} bool UseVectorCmov false {C2 product} {default} bool UseXMMForArrayCopy true {product} {default} bool UseXMMForObjInit true {ARCH product} {default} bool UseXmmI2D true {ARCH product} {default} bool UseXmmI2F true {ARCH product} {default} bool UseXmmLoadAndClearUpper true {ARCH product} {default} bool UseXmmRegToRegMoveAll true {ARCH product} {default} bool UseZGC false {product} {default} intx VMThreadPriority -1 {product} {default} intx VMThreadStackSize 1024 {pd product} {default} intx ValueMapInitialSize 11 {C1 product} {default} intx ValueMapMaxLoopSize 8 {C1 product} {default} intx ValueSearchLimit 1000 {C2 product} {default} bool VerifySharedSpaces false {product} {default} uintx YoungGenerationSizeIncrement 20 {product} {default} uintx YoungGenerationSizeSupplement 80 {product} {default} uintx YoungGenerationSizeSupplementDecay 8 {product} {default} size_t YoungPLABSize 4096 {product} {default} double ZAllocationSpikeTolerance 2.000000 {product} {default} double ZCollectionInterval 0.000000 {product} {default} double ZFragmentationLimit 25.000000 {product} {default} size_t ZMarkStackSpaceLimit 8589934592 {product} {default} bool ZProactive true {product} {default} bool ZUncommit true {product} {default} uintx ZUncommitDelay 300 {product} {default} bool ZeroTLAB false {product} {default}","title":"Full list of JVM flags"},{"location":"reference/jvm/profile-tools/","text":"Profile JVM applications \u03bb\ufe0e Profile applications on the JVM, visualising memory and CPU resources, identifying bottlenecks and areas of the code to review to optimise a running application. Using FlameGraphs To Illuminate The JVM by Nitsan Wakart at Devoxx UK 2017 A Simple Approach to the Advanced JVM Profiling - JetBrains Java VisualVM \u03bb\ufe0e A simplified and robust profiling tool for Java applications, bundled with the Java Development Kit (JDK) and using JConsole, jstat, jstack, jinfo, and jmap. {% tabs ubuntu=\"Ubuntu/Debian\", manual=\"Manually add Alias\" %} {% content \"ubuntu\" %} Ubuntu / Debian includes VisualVM in the software center sudo apt install visualvm {% endtabs %} JDK Flight Recorder \u03bb\ufe0e JDK Flight Recorder is a production time profiling and diagnostics engine built into the JVM Extremely low overhead - no measurable impact on the running application High performance flight recording engine and high performance data collection Safe and reliable in production, tested on all platforms as part of the JVM/JDK-testing Time machine records data before, up to, and right after a problem occurs (even if the JVM process crashes) jcmd to access the flight recorder data from the command line Mission control provides a graphical tool to visualise flight recorder data. Continuous Monitoring with JDK Flight Recorder - Java channel - September 2020 JDK11 - Introduction to JDK Flight Recorder - September 2020 Production profiling with JDK Flight Recorder & JDK Mission Control - Madrid JUG Mission Control \u03bb\ufe0e Mission Control is an open source desktop tool for visualising production time profiling and diagnostics from the JDK flight recorder tool. JDK Mission Control supports OpenJDK 11 and above. JDK Mission Control consists of A JDK Flight Recorder (JFR) analyser and visualiser A Java Management Extensions (JMX) Console A heap dump (hprof format) analyzer (JOverflow) Eclipse Mission Control from Adoptium . Java Mission Control demo - 2014 outated but might be useful if nothing newer {% youtube %} https://youtu.be/aJH_aZNQ-G4 Profiling guides \u03bb\ufe0e Profiling your Java Application - A Beginner\u2019s Guide - Victor Rentea Explore three of the best free tools for profiling a Java (Spring) application: * Using Java Flight Recorder to profile method execution times * Using Micrometer-Prometheus-Grafana to profile connection starvation issues * Using Glowroot to identify long-running queries {% youtube %} https://youtu.be/3PWgGzpHykc References \u03bb\ufe0e Java Profilers - Baeldung - overview of several profiling tools Java SE HotSpot Virtual Machine Garbage Collection Tuning Guide - Oracle","title":"Profile tools"},{"location":"reference/jvm/profile-tools/#profile-jvm-applications","text":"Profile applications on the JVM, visualising memory and CPU resources, identifying bottlenecks and areas of the code to review to optimise a running application. Using FlameGraphs To Illuminate The JVM by Nitsan Wakart at Devoxx UK 2017 A Simple Approach to the Advanced JVM Profiling - JetBrains","title":"Profile JVM applications"},{"location":"reference/jvm/profile-tools/#java-visualvm","text":"A simplified and robust profiling tool for Java applications, bundled with the Java Development Kit (JDK) and using JConsole, jstat, jstack, jinfo, and jmap. {% tabs ubuntu=\"Ubuntu/Debian\", manual=\"Manually add Alias\" %} {% content \"ubuntu\" %} Ubuntu / Debian includes VisualVM in the software center sudo apt install visualvm {% endtabs %}","title":"Java VisualVM"},{"location":"reference/jvm/profile-tools/#jdk-flight-recorder","text":"JDK Flight Recorder is a production time profiling and diagnostics engine built into the JVM Extremely low overhead - no measurable impact on the running application High performance flight recording engine and high performance data collection Safe and reliable in production, tested on all platforms as part of the JVM/JDK-testing Time machine records data before, up to, and right after a problem occurs (even if the JVM process crashes) jcmd to access the flight recorder data from the command line Mission control provides a graphical tool to visualise flight recorder data. Continuous Monitoring with JDK Flight Recorder - Java channel - September 2020 JDK11 - Introduction to JDK Flight Recorder - September 2020 Production profiling with JDK Flight Recorder & JDK Mission Control - Madrid JUG","title":"JDK Flight Recorder"},{"location":"reference/jvm/profile-tools/#mission-control","text":"Mission Control is an open source desktop tool for visualising production time profiling and diagnostics from the JDK flight recorder tool. JDK Mission Control supports OpenJDK 11 and above. JDK Mission Control consists of A JDK Flight Recorder (JFR) analyser and visualiser A Java Management Extensions (JMX) Console A heap dump (hprof format) analyzer (JOverflow) Eclipse Mission Control from Adoptium . Java Mission Control demo - 2014 outated but might be useful if nothing newer {% youtube %} https://youtu.be/aJH_aZNQ-G4","title":"Mission Control"},{"location":"reference/jvm/profile-tools/#profiling-guides","text":"Profiling your Java Application - A Beginner\u2019s Guide - Victor Rentea Explore three of the best free tools for profiling a Java (Spring) application: * Using Java Flight Recorder to profile method execution times * Using Micrometer-Prometheus-Grafana to profile connection starvation issues * Using Glowroot to identify long-running queries {% youtube %} https://youtu.be/3PWgGzpHykc","title":"Profiling guides"},{"location":"reference/jvm/profile-tools/#references","text":"Java Profilers - Baeldung - overview of several profiling tools Java SE HotSpot Virtual Machine Garbage Collection Tuning Guide - Oracle","title":"References"},{"location":"reference/jvm/understanding-memory-usage/","text":"Understanding memory usage. \u03bb\ufe0e Adjusting the heap size and Garbage Collection behaviour is often the simplest means to improving application performance and stability. A mismatch between the heap size. Allocating additional memory to the HotSpot JVM is a relatively cheap way to improve the performance of an application. Garbage collection cost is in the form of execution pauses while the HotSpot JVM cleans up the no-longer-needed heap allocations. Report a full breakdown of the HotSpot JVM\u2019s memory usage upon exit using the following option combination: -XX:+UnlockDiagnosticVMOptions \u2011XX:NativeMemoryTracking = summary \u2011XX:+PrintNMTStatistics. Out Of Memory errors \u03bb\ufe0e When experiencing OutOfMemory errors, consider how the HotSpot JVM should behave if the application runs out of memory. -XX:+ExitOnOutOfMemoryError - HotSpot JVM exits on the first OutOfMemory error, suitable if the JVM will be automatically restarted (such as in container services) -XX:+HeapDumpOnOutOfMemoryError - dump contents of heap to file, <java_pid>.hprof , to help diagnose memory leaks -XX:HeapDumpPath defines the path for the heap dump, default is current directory Choose A Garbage Collector \u03bb\ufe0e The HotSpot Virtual Machine Garbage Collection Tuning Guide provides advice on selecting a suitable garbage collector (GC) G1GC collector is the default used by the JDK ergonomics process on most hardware. Other garbage collectors available include: -XX:+UseSerialGC - serial collector, performing all GC work on a single thread -XX:+UseParallelGC - parallel (throughput) collector, performs compaction using multiple threads. -XX:+UseZGC - ZGC collector scalable low latency garbage collector (experimental in JDK 11, so requires -XX:+UnlockExperimentalVMOptions ). Enable garbage collection logging -Xlog:gc - basic GC logging -Xlog:gc* - verbose GC logging Object Allocation \u03bb\ufe0e Applications that create short-lived objects at a high allocation rates can lead to the premature promotion of short-lived objects to the old-generation heap space. There the objects will accumulate until a full garbage collection is needed To avoid premature promotion: -XX:NewSize=n - initial size for the young generation -XX:MaxNewSize=n - maximum size for the young generation -XX:MaxTenuringThreshold=n - maximum number of young-generation collections an object can survive before it is promoted to the old generation Just In Time Optimisation \u03bb\ufe0e Understand how the Just In Time (JIT) compiler optimises the code. Once an application garbage collection pauses are an acceptable level, check the JIT compilers are optimizing the parts of your program you think are important for performance. Enable compilation logging: -XX:+PrintCompilation print basic information about each JIT compilation to the console -XX:+UnlockDiagnosticVMOptions \u2011XX:+PrintCompilation \u2011XX:+PrintInlining - information about method in-lining","title":"Understanding memory usage."},{"location":"reference/jvm/understanding-memory-usage/#understanding-memory-usage","text":"Adjusting the heap size and Garbage Collection behaviour is often the simplest means to improving application performance and stability. A mismatch between the heap size. Allocating additional memory to the HotSpot JVM is a relatively cheap way to improve the performance of an application. Garbage collection cost is in the form of execution pauses while the HotSpot JVM cleans up the no-longer-needed heap allocations. Report a full breakdown of the HotSpot JVM\u2019s memory usage upon exit using the following option combination: -XX:+UnlockDiagnosticVMOptions \u2011XX:NativeMemoryTracking = summary \u2011XX:+PrintNMTStatistics.","title":"Understanding memory usage."},{"location":"reference/jvm/understanding-memory-usage/#out-of-memory-errors","text":"When experiencing OutOfMemory errors, consider how the HotSpot JVM should behave if the application runs out of memory. -XX:+ExitOnOutOfMemoryError - HotSpot JVM exits on the first OutOfMemory error, suitable if the JVM will be automatically restarted (such as in container services) -XX:+HeapDumpOnOutOfMemoryError - dump contents of heap to file, <java_pid>.hprof , to help diagnose memory leaks -XX:HeapDumpPath defines the path for the heap dump, default is current directory","title":"Out Of Memory errors"},{"location":"reference/jvm/understanding-memory-usage/#choose-a-garbage-collector","text":"The HotSpot Virtual Machine Garbage Collection Tuning Guide provides advice on selecting a suitable garbage collector (GC) G1GC collector is the default used by the JDK ergonomics process on most hardware. Other garbage collectors available include: -XX:+UseSerialGC - serial collector, performing all GC work on a single thread -XX:+UseParallelGC - parallel (throughput) collector, performs compaction using multiple threads. -XX:+UseZGC - ZGC collector scalable low latency garbage collector (experimental in JDK 11, so requires -XX:+UnlockExperimentalVMOptions ). Enable garbage collection logging -Xlog:gc - basic GC logging -Xlog:gc* - verbose GC logging","title":"Choose A Garbage Collector"},{"location":"reference/jvm/understanding-memory-usage/#object-allocation","text":"Applications that create short-lived objects at a high allocation rates can lead to the premature promotion of short-lived objects to the old-generation heap space. There the objects will accumulate until a full garbage collection is needed To avoid premature promotion: -XX:NewSize=n - initial size for the young generation -XX:MaxNewSize=n - maximum size for the young generation -XX:MaxTenuringThreshold=n - maximum number of young-generation collections an object can survive before it is promoted to the old generation","title":"Object Allocation"},{"location":"reference/jvm/understanding-memory-usage/#just-in-time-optimisation","text":"Understand how the Just In Time (JIT) compiler optimises the code. Once an application garbage collection pauses are an acceptable level, check the JIT compilers are optimizing the parts of your program you think are important for performance. Enable compilation logging: -XX:+PrintCompilation print basic information about each JIT compilation to the console -XX:+UnlockDiagnosticVMOptions \u2011XX:+PrintCompilation \u2011XX:+PrintInlining - information about method in-lining","title":"Just In Time Optimisation"},{"location":"reference/performance/","text":"Clojure Performance \u03bb\ufe0e Two excellent presentations on Clojure performance Optimising the critical path \u03bb\ufe0e Using two of Clojure's fundamental building blocks, macros and higher order functions, Clojure code can be sped up significantly without sacrificing common idioms. Premature optimisation is the root of all evil, this is not a reason to pass up opportunities to improve the critical 3%. {% youtube %} https://youtu.be/5BKn4rUoggg Presentation: Dressed up performance in Clojure - Ben Sless - reClojure 2021 Naked Performance \u03bb\ufe0e Lessons learned on building Clojure/Script systems that are both ridiculously fast and will fail fast on errors. Compare the performance of mutable, persistent & zero-copy data structures, showing how to use interpreters and compilers to build beautiful and performant abstractions. A shot demo on building a simple non-blocking web server that runs idiomatic Clojure to serve millions of requests per second. Clojure is awesome, and it can be fast too. {% youtube %} https://youtu.be/3SSHjKT3ZmA Naked Performance (with Clojure) \u2013 Tommi Reiman - Metosin","title":"Clojure Performance"},{"location":"reference/performance/#clojure-performance","text":"Two excellent presentations on Clojure performance","title":"Clojure Performance"},{"location":"reference/performance/#optimising-the-critical-path","text":"Using two of Clojure's fundamental building blocks, macros and higher order functions, Clojure code can be sped up significantly without sacrificing common idioms. Premature optimisation is the root of all evil, this is not a reason to pass up opportunities to improve the critical 3%. {% youtube %} https://youtu.be/5BKn4rUoggg Presentation: Dressed up performance in Clojure - Ben Sless - reClojure 2021","title":"Optimising the critical path"},{"location":"reference/performance/#naked-performance","text":"Lessons learned on building Clojure/Script systems that are both ridiculously fast and will fail fast on errors. Compare the performance of mutable, persistent & zero-copy data structures, showing how to use interpreters and compilers to build beautiful and performant abstractions. A shot demo on building a simple non-blocking web server that runs idiomatic Clojure to serve millions of requests per second. Clojure is awesome, and it can be fast too. {% youtube %} https://youtu.be/3SSHjKT3ZmA Naked Performance (with Clojure) \u2013 Tommi Reiman - Metosin","title":"Naked Performance"},{"location":"reference/performance/advanced-types/","text":"Advanced types \u03bb\ufe0e Clojure support for Java Primitives Clojure has support for high-performance with Java primitive types in local contexts. All Java primitive types are supported: int, float, long, double, boolean, char, short, and byte. In the extremely rare occasions where this is needed, it is added via metadata and therefore only adds to the existing code without rewriting it. Rather than write this Java: static public float asum ( float [] xs ){ float ret = 0 ; for ( int i = 0 ; i < xs . length ; i ++ ) ret += xs [ i ] ; return ret ; } you can write this Clojure: ( defn asum [ ^ floats xs ] ( areduce xs i ret ( float 0 ) ( + ret ( aget xs i )))) and the resulting code is exactly the same speed (when run with java -server). Optimization tips for types \u03bb\ufe0e All arguments are passed to Clojure fns as objects, so there's no point to putting non-array primitive type hints on fn args. Instead, use the let technique shown to place args in primitive locals if they need to participate in primitive arithmetic in the body. (let [foo (int bar)] ...) is the correct way to get a primitive local. Do not use ^Integer etc. Don't rush to unchecked math unless you want truncating operations. HotSpot does a good job at optimizing the overflow check, which will yield an exception instead of silent truncation. On a typical example, that has about a 5% difference in speed - well worth it. Also, people reading your code don't know if you are using unchecked for truncation or performance - best to reserve it for the former and comment if the latter. There's usually no point in trying to optimize an outer loop, in fact it can hurt you as you'll be representing things as primitives which just have to be re-boxed in order to become args to the inner call. The only exception is reflection warnings - you must get rid of them in any code that gets called frequently. Almost every time someone presents something they are trying to optimize with hints, the faster version has far fewer hints than the original. If a hint doesn't improve things in the end - take it out. Many people seem to presume only the unchecked- ops do primitive arithmetic - not so. When the args are primitive locals, regular + and * etc do primitive math with an overflow check - fast and safe. So, the simplest route to fast math is to leave the operators alone and just make sure the source literals and locals are primitive. Arithmetic on primitives yields primitives. If you've got a loop (which you probably do if you need to optimize) make sure the loop locals are primitives first - then if you accidentally are producing a boxed intermediate result you'll get an error on recur. Don't solve that error by coercing your intermediate result, instead, figure out what argument or local is not primitive.","title":"Advanced types"},{"location":"reference/performance/advanced-types/#advanced-types","text":"Clojure support for Java Primitives Clojure has support for high-performance with Java primitive types in local contexts. All Java primitive types are supported: int, float, long, double, boolean, char, short, and byte. In the extremely rare occasions where this is needed, it is added via metadata and therefore only adds to the existing code without rewriting it. Rather than write this Java: static public float asum ( float [] xs ){ float ret = 0 ; for ( int i = 0 ; i < xs . length ; i ++ ) ret += xs [ i ] ; return ret ; } you can write this Clojure: ( defn asum [ ^ floats xs ] ( areduce xs i ret ( float 0 ) ( + ret ( aget xs i )))) and the resulting code is exactly the same speed (when run with java -server).","title":"Advanced types"},{"location":"reference/performance/advanced-types/#optimization-tips-for-types","text":"All arguments are passed to Clojure fns as objects, so there's no point to putting non-array primitive type hints on fn args. Instead, use the let technique shown to place args in primitive locals if they need to participate in primitive arithmetic in the body. (let [foo (int bar)] ...) is the correct way to get a primitive local. Do not use ^Integer etc. Don't rush to unchecked math unless you want truncating operations. HotSpot does a good job at optimizing the overflow check, which will yield an exception instead of silent truncation. On a typical example, that has about a 5% difference in speed - well worth it. Also, people reading your code don't know if you are using unchecked for truncation or performance - best to reserve it for the former and comment if the latter. There's usually no point in trying to optimize an outer loop, in fact it can hurt you as you'll be representing things as primitives which just have to be re-boxed in order to become args to the inner call. The only exception is reflection warnings - you must get rid of them in any code that gets called frequently. Almost every time someone presents something they are trying to optimize with hints, the faster version has far fewer hints than the original. If a hint doesn't improve things in the end - take it out. Many people seem to presume only the unchecked- ops do primitive arithmetic - not so. When the args are primitive locals, regular + and * etc do primitive math with an overflow check - fast and safe. So, the simplest route to fast math is to leave the operators alone and just make sure the source literals and locals are primitive. Arithmetic on primitives yields primitives. If you've got a loop (which you probably do if you need to optimize) make sure the loop locals are primitives first - then if you accidentally are producing a boxed intermediate result you'll get an error on recur. Don't solve that error by coercing your intermediate result, instead, figure out what argument or local is not primitive.","title":"Optimization tips for types"},{"location":"reference/standard-library/","text":"Standard Library - clojure.core \u03bb\ufe0e Examples of using the functions from the clojure.core namespace and other important functions, macros and special forms that are part of the org.clojure/clojure library. Functions, Macros and Special forms \u03bb\ufe0e The majority of times macros and special forms act just like any other defined function (i.e. fn , defn ) A macro is a piece of code that evaluates into a function when read by the macro reader, or by the developer using macroexpand function. An expanded macro may also contain macros, so expansion could take place several levels ( macroexpand-all ). macros are not composable like functions, so functions like apply reduce map cannot use a macro (use a function instead). Special forms are built into the Clojure runtime, so will not be found in clojure.core * Special forms: if do let quote var fn loop recur throw try * Special forms for Java interop: . new set!","title":"Standard Library - clojure.core"},{"location":"reference/standard-library/#standard-library-clojurecore","text":"Examples of using the functions from the clojure.core namespace and other important functions, macros and special forms that are part of the org.clojure/clojure library.","title":"Standard Library - clojure.core"},{"location":"reference/standard-library/#functions-macros-and-special-forms","text":"The majority of times macros and special forms act just like any other defined function (i.e. fn , defn ) A macro is a piece of code that evaluates into a function when read by the macro reader, or by the developer using macroexpand function. An expanded macro may also contain macros, so expansion could take place several levels ( macroexpand-all ). macros are not composable like functions, so functions like apply reduce map cannot use a macro (use a function instead). Special forms are built into the Clojure runtime, so will not be found in clojure.core * Special forms: if do let quote var fn loop recur throw try * Special forms for Java interop: . new set!","title":"Functions, Macros and Special forms"},{"location":"reference/standard-library/cond-thread-macro/","text":"Clojure cond-> \u03bb\ufe0e cond-> and cond->> are versatile macros available since version 1.5, although its more of a nieche use, its really useful in that neiche What is cond->? Usage: (cond-> expr & clauses) Takes an expression and a set of test/form pairs. Threads expr (via ->) through each form for which the corresponding test expression is true. Note that, unlike cond branching, cond-> threading does not short circuit after the first true test expression. Deconstruct \u03bb\ufe0e ( cond-> 10 false inc ) ;; => 10 In the above example 10 is the expr mentioned in the docstring and everything after it are the clauses. Each clause is a pair made up of a test and a form. In this example there is a single clause with the value false as the test the function inc as the form. Since the test evaluates to a false value the expression is not threaded into the form. As a result the original expression, 10, is returned. Let\u2019s look at an example with a truthy test. ( cond-> 10 true ( - 2 ) ;;=> 8 Once again, 10 is the starting expression. The single clause has a test that evaluates to true so the expression is threaded into the first position of the form (- 2). The result is 8 and this is returned. An example of a cond-> with multiple clauses. Explanations are inline with the code. ( cond-> 10 ; start with 10 ;; test evaluates to true, so apply inc to 10. Current value is now 11. true inc ;; (zero? 1) evaluates to false, do not perform action. Current value stays 11. ( zero? 1 ) ( + 2 ) ;; (pos? 4) evaluates to true, thread 11 into first position of form. ( pos? 4 ) ( - 5 )) ;; => 6 ; The result of (- 11 5) is 6. If you understand the above example then you have a good grasp of cond->. But when is this functionality useful? When to use cond->? \u03bb\ufe0e Looking through the codebases I work on, I almost primarily see cond-> being used with the initial expression being a hash-map. It is being used in situations where we want to selectively assoc, update, or dissoc something from a map. If cond-> did not exist you would accomplish those selective modifications with code similar to below. ( if ( some-pred? q ) ( assoc m :a-key :a-value ) m ) Rewrite the above with cond->. ( cond-> m ( some-pred? q ) ( assoc :a-key :a-value )) If you\u2019re not used to seeing cond-> the above transformation might seem like a step backwards. I know it felt that way to me when I first saw cond->. Give yourself time to get familiar with it and you\u2019ll be glad you\u2019re using it. A meatier example of using cond-> is demonstrated below. Here we\u2019re manipulating data structures designed for use with honeysql to generate SQL statements. We start with a base-query and selectively modify it based on incoming parameters. ( defn query [ req-params ] ( let [ and-clause ( fnil conj [ :and ]) base-query { :select [ :name :job ] :from [ :person ]}] ( cond-> base-query ( :job req-params ) ( update :where and-clause [ := :job ( :job req-params )]) ( :name req-params ) ( update :where and-clause [ := :name ( :name req-params )]) ( :min-age req-params ) ( update :where and-clause [ :> :age ( :min-age req-params )])))) Hopefully this gives you a taste of cond->. I\u2019ve found it to be quite useful. It has a place in every Clojure developer\u2019s toolbox.","title":"Cond thread macro"},{"location":"reference/standard-library/cond-thread-macro/#clojure-cond-","text":"cond-> and cond->> are versatile macros available since version 1.5, although its more of a nieche use, its really useful in that neiche What is cond->? Usage: (cond-> expr & clauses) Takes an expression and a set of test/form pairs. Threads expr (via ->) through each form for which the corresponding test expression is true. Note that, unlike cond branching, cond-> threading does not short circuit after the first true test expression.","title":"Clojure cond-&gt;"},{"location":"reference/standard-library/cond-thread-macro/#deconstruct","text":"( cond-> 10 false inc ) ;; => 10 In the above example 10 is the expr mentioned in the docstring and everything after it are the clauses. Each clause is a pair made up of a test and a form. In this example there is a single clause with the value false as the test the function inc as the form. Since the test evaluates to a false value the expression is not threaded into the form. As a result the original expression, 10, is returned. Let\u2019s look at an example with a truthy test. ( cond-> 10 true ( - 2 ) ;;=> 8 Once again, 10 is the starting expression. The single clause has a test that evaluates to true so the expression is threaded into the first position of the form (- 2). The result is 8 and this is returned. An example of a cond-> with multiple clauses. Explanations are inline with the code. ( cond-> 10 ; start with 10 ;; test evaluates to true, so apply inc to 10. Current value is now 11. true inc ;; (zero? 1) evaluates to false, do not perform action. Current value stays 11. ( zero? 1 ) ( + 2 ) ;; (pos? 4) evaluates to true, thread 11 into first position of form. ( pos? 4 ) ( - 5 )) ;; => 6 ; The result of (- 11 5) is 6. If you understand the above example then you have a good grasp of cond->. But when is this functionality useful?","title":"Deconstruct"},{"location":"reference/standard-library/cond-thread-macro/#when-to-use-cond-","text":"Looking through the codebases I work on, I almost primarily see cond-> being used with the initial expression being a hash-map. It is being used in situations where we want to selectively assoc, update, or dissoc something from a map. If cond-> did not exist you would accomplish those selective modifications with code similar to below. ( if ( some-pred? q ) ( assoc m :a-key :a-value ) m ) Rewrite the above with cond->. ( cond-> m ( some-pred? q ) ( assoc :a-key :a-value )) If you\u2019re not used to seeing cond-> the above transformation might seem like a step backwards. I know it felt that way to me when I first saw cond->. Give yourself time to get familiar with it and you\u2019ll be glad you\u2019re using it. A meatier example of using cond-> is demonstrated below. Here we\u2019re manipulating data structures designed for use with honeysql to generate SQL statements. We start with a base-query and selectively modify it based on incoming parameters. ( defn query [ req-params ] ( let [ and-clause ( fnil conj [ :and ]) base-query { :select [ :name :job ] :from [ :person ]}] ( cond-> base-query ( :job req-params ) ( update :where and-clause [ := :job ( :job req-params )]) ( :name req-params ) ( update :where and-clause [ := :name ( :name req-params )]) ( :min-age req-params ) ( update :where and-clause [ :> :age ( :min-age req-params )])))) Hopefully this gives you a taste of cond->. I\u2019ve found it to be quite useful. It has a place in every Clojure developer\u2019s toolbox.","title":"When to use cond-&gt;?"},{"location":"reference/standard-library/destructuring/","text":"Destructuring - abstract structural binding \u03bb\ufe0e Destructuring is a form of pattern matching where you return specific elements from a collection and assign those elements names. It is commonly used in function parameter lists or with the let function. Destructuring is also known as abstract structural binding A simple example of destructuring is assigning the values of a collection, in this case a vector. ( def co-ordinates [ 5 7 ]) ( let [[ x y ] co-ordinates ] ( str \"x:\" x \"y:\" y )) ;; => x: 5 y: 7 ;; Sometimes we do not need all the information, so we can just use the elements we need. ( def three-dee-co-ordinates [ 2 7 4 ]) ( let [[ x y ] three-dee-co-ordinates ] ( str \"I only need the 2D co-ordinates, X: \" x \" and Y: \" y )) ;; => \"I only need the 2D co-ordinates, X: 2 and Y: 7\" Its quite common to take the first element as a specific name and use another name for the rest of the elements ( def shopping-list [ \"oranges\" \"apples\" \"spinach\" \"carrots\" \"potatoes\" \"beetroot\" ]) ( defn get-item [ items ] ( let [[ next-item & other-items ] items ] ( str \"The next item to get is: \" next-item ))) ( get-item shopping-list ) ;; => \"The next item to get is: oranges\" This example seems a little redundant at first, however if we add recursion then we can iterate through the shopping list and it should make more sense splitting a vector into a head and a tail. When defining a function with an arglist** you use an ampersand. The same is true in destructuring. (def indexes [1 2 3]) user=> (let [[x & more] indexes] (println \"x:\" x \"more:\" more)) x: 1 more: (2 3) It's also worth noting that you can bind the entire vector to a local using the :as directive. user=> (def indexes [1 2 3]) 'user/indexes \u03bb\ufe0e user=> (let [[x & more :as full-list] indexes] (println \"x:\" x \"more:\" more \"full list:\" full-list)) x: 1 more: (2 3) full list: [1 2 3] Vector examples are the easiest; however, in practice I find myself using destructuring with maps far more often. Simple destructuring on a map is as easy as choosing a local name and providing the key. user=> (def point {:x 5 :y 7}) 'user/point \u03bb\ufe0e user=> (let [{the-x :x the-y :y} point] (println \"x:\" the-x \"y:\" the-y)) x: 5 y: 7 As the example shows, the values of :x and :y are bound to locals with the names the-x and the-y. In practice we would never prepend \"the-\" to our local names; however, using different names provides a bit of clarity for our first example. In production code you would be much more likely to want locals with the same name as the key. This works perfectly well, as the next example shows. user=> (def point {:x 5 :y 7}) 'user/point \u03bb\ufe0e user=> (let [{x :x y :y} point] (println \"x:\" x \"y:\" y)) x: 5 y: 7 While this works perfectly well, creating locals with the same name as the keys becomes tedious and annoying (especially when your keys are longer than one letter). Clojure anticipates this frustration and provides :keys directive that allows you to specify keys that you would like as locals with the same name. user=> (def point {:x 5 :y 7}) 'user/point \u03bb\ufe0e user=> (let [{:keys [x y]} point] (println \"x:\" x \"y:\" y)) x: 5 y: 7 There are a few directives that work while destructuring maps. The above example shows the use of :keys. In practice I end up using :keys the most; however, I've also used the :as directive while working with maps. The following example illustrates the use of an :as directive to bind a local with the entire map. user=> (def point {:x 5 :y 7}) 'user/point \u03bb\ufe0e user=> (let [{:keys [x y] :as the-point} point] (println \"x:\" x \"y:\" y \"point:\" the-point)) x: 5 y: 7 point: {:x 5, :y 7} We've now seen the :as directive used for both vectors and maps. In both cases the local is always assigned to the entire expression that is being destructured. For completeness I'll document the :or directive; however, I must admit that I've never used it in practice. The :or directive is used to assign default values when the map being destructured doesn't contain a specified key. user=> (def point {:y 7}) 'user/point \u03bb\ufe0e user=> (let [{:keys [x y] :or {x 0 y 0}} point] (println \"x:\" x \"y:\" y)) x: 0 y: 7 Lastly, it's also worth noting that you can destructure nested maps, vectors and a combination of both. The following example destructures a nested map user=> (def book {:name \"SICP\" :details {:pages 657 :isbn-10 \"0262011530\"}}) 'user/book \u03bb\ufe0e user=> (let [{name :name {pages :pages isbn-10 :isbn-10} :details} book] (println \"name:\" name \"pages:\" pages \"isbn-10:\" isbn-10)) name: SICP pages: 657 isbn-10: 0262011530 As you would expect, you can also use directives while destructuring nested maps. user=> (def book {:name \"SICP\" :details {:pages 657 :isbn-10 \"0262011530\"}}) 'user/book \u03bb\ufe0e user=> user=> (let [{name :name {:keys [pages isbn-10]} :details} book] (println \"name:\" name \"pages:\" pages \"isbn-10:\" isbn-10)) name: SICP pages: 657 isbn-10: 0262011530 Destructuring nested vectors is also very straight-forward, as the following example illustrates user=> (def numbers [[1 2][3 4]]) 'user/numbers \u03bb\ufe0e user=> (let [[[a b][c d]] numbers] (println \"a:\" a \"b:\" b \"c:\" c \"d:\" d)) a: 1 b: 2 c: 3 d: 4 Since binding forms can be nested within one another arbitrarily, you can pull apart just about anything -- http://clojure.org/special_forms The following example destructures a map and a vector at the same time. user=> (def golfer {:name \"Jim\" :scores [3 5 4 5]}) 'user/golfer \u03bb\ufe0e user=> (let [{name :name [hole1 hole2] :scores} golfer] (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2)) name: Jim hole1: 3 hole2: 5 The same example can be rewritten using a function definition to show the simplicity of using destructuring in parameter lists. user=> (defn print-status [{name :name [hole1 hole2] :scores}] (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2)) 'user/print-status \u03bb\ufe0e user=> (print-status {:name \"Jim\" :scores [3 5 4 5]}) name: Jim hole1: 3 hole2: 5 There are other (less used) directives and deeper explanations available on http://clojure.org/special_forms and in The Joy of Clojure. I recommend both. **(defn do-something [x y & more] ... ) Posted by Jay Fields at 7:44 AM Email ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest Labels: clojure, destructuring 10 comments: fogus8:26 AM Nice post. One other note that naturally follows from the end of your post is that destructuring forms the basis of Clojure's named arguments: (defn print-status [& {name :name [hole1 hole2] :scores}] (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2)) (print-status :name \"Joey\" :scores [42 18]) You can also use pre-conditions to check if certain arguments are passed in: (defn print-status [& {name :name [hole1 hole2] :scores}] {:pre [name]} (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2)) (print-status :scores [42 18]) ; java.lang.AssertionError: Assert failed: name (print-status :name \"Joey\" :scores [42 18]) ; name: Joey hole1: 42 hole2: 18 :f Reply Jay Fields9:08 AM Good stuff Fogus, thanks. Cheers, Jay Reply Matt Todd5:31 PM Can you combine :as and :or et al? Reply Anonymous7:29 PM Yes, all the directives can be used at the same time. Cheers, Jay Reply Laurent PETIT3:08 AM Hi, one note about using destructuring for function arguments : by doing so, you're quite explicitly establishing a more detailed contract with the consumer of the function. That is, you open the internals of the passed arguments. Depending on the fact that the user may or may not be aware of the internals of the arguments, it may or may not be a good idea. So I tend to think about the use of destructuring function arguments directly in the function signature, depending on whether the \"layout\" of the arguments of the function is part of the user API. Reply Clojure Destructuring Tutorial and Cheat Sheet \u03bb\ufe0e ( Related blog post ) Simply put, destructuring in Clojure is a way extract values from a data structure and bind them to symbols, without having to explicitly traverse the data structure. It allows for elegant and concise Clojure code. Vectors \u03bb\ufe0e Syntax: [symbol another-symbol] [\"value\" \"another-value\"] ( def my-vector [ :a :b :c :d ]) ( def my-nested-vector [ :a :b :c :d [ :x :y :z ]]) ( let [[ a b c d ] my-vector ] ( println a b c d )) ;; => :a :b :c :d ( let [[ a _ _ d [ x y z ]] my-nested-vector ] ( println a d x y z )) ;; => :a :d :x :y :z You don't have to match the full vector. ( let [[ a b c ] my-vector ] ( println a b c )) ;; => :a :b :c You can use & the-rest to bind the remaining part of the vector to the-rest . ( let [[ a b & the-rest ] my-vector ] ( println a b the-rest )) ;; => :a :b (:c :d) When a destructuring form \"exceeds\" a vector (i.e. there not enough items in the vector to bind to), the excess symbols will be bound to nil . ( let [[ a b c d e f g ] my-vector ] ( println a b c d e f g )) ;; => :a :b :c :d nil nil nil You can use :as some-symbol as the last two items in the destructuring form to bind the whole vector to some-symbol ( let [[ :as all ] my-vector ] ( println all )) ;; => [:a :b :c :d] ( let [[ a :as all ] my-vector ] ( println a all )) ;; => :a [:a :b :c :d] ( let [[ a _ _ _ [ x y z :as nested ] :as all ] my-nested-vector ] ( println a x y z nested all )) ;; => :a :x :y :z [:x :y :z] [:a :b :c :d [:x :y :z]] You can use both & the-rest and :as some-symbol . ( let [[ a b & the-rest :as all ] my-vector ] ( println a b the-rest all )) ;; => :a :b (:c :d) [:a :b :c :d] Optional arguments for functions \u03bb\ufe0e With destructuring and the & the-rest form, you can specify optional arguments to functions. ( defn foo [ a b & more-args ] ( println a b more-args )) ( foo :a :b ) ;; => :a :b nil ( foo :a :b :x ) ;; => :a :b (:x) ( foo :a :b :x :y :z ) ;; => :a :b (:x :y :z) ( defn foo [ a b & [ x y z ]] ( println a b x y z )) ( foo :a :b ) ;; => :a :b nil nil nil ( foo :a :b :x ) ;; => :a :b :x nil nil ( foo :a :b :x :y :z ) ;; => :a :b :x :y :z Maps \u03bb\ufe0e Syntax: {symbol :key, another-symbol :another-key} {:key \"value\" :another-key \"another-value\"} ( def my-hashmap { :a \"A\" :b \"B\" :c \"C\" :d \"D\" }) ( def my-nested-hashmap { :a \"A\" :b \"B\" :c \"C\" :d \"D\" :q { :x \"X\" :y \"Y\" :z \"Z\" }}) ( let [{ a :a d :d } my-hashmap ] ( println a d )) ;; => A D ( let [{ a :a , b :b , { x :x , y :y } :q } my-nested-hashmap ] ( println a b x y )) ;; => A B X Y Similar to vectors, if a key is not found in the map, the symbol will be bound to nil . ( let [{ a :a , not-found :not-found , b :b } my-hashmap ] ( println a not-found b )) ;; => A nil B You can provide an optional default value for these missing keys with the :or keyword and a map of default values. ( let [{ a :a , not-found :not-found , b :b , :or { not-found \":)\" }} my-hashmap ] ( println a not-found b )) ;; => A :) B The :as some-symbol form is also available for maps, but unlike vectors it can be specified anywhere (but still preferred to be the last two pairs). ( let [{ a :a , b :b , :as all } my-hashmap ] ( println a b all )) ;; => A B {:a A :b B :c C :d D} And combining :as and :or keywords (again, :as preferred to be the last). ( let [{ a :a , b :b , not-found :not-found , :or { not-found \":)\" } , :as all } my-hashmap ] ( println a b not-found all )) ;; => A B :) {:a A :b B :c C :d D} There is no & the-rest for maps. Shortcuts \u03bb\ufe0e Having to specify {symbol :symbol} for each key is repetitive and verbose (it's almost always going to be the symbol equivalent of the key), so shortcuts are provided so you only have to type the symbol once. Here are all the previous examples using the :keys keyword followed by a vector of symbols: ( let [{ :keys [ a d ]} my-hashmap ] ( println a d )) ;; => A D ( let [{ :keys [ a b ] , { :keys [ x y ]} :q } my-nested-hashmap ] ( println a b x y )) ;; => A B X Y ( let [{ :keys [ a not-found b ]} my-hashmap ] ( println a not-found b )) ;; => A nil B ( let [{ :keys [ a not-found b ] , :or { not-found \":)\" }} my-hashmap ] ( println a not-found b )) ;; => A :) B ( let [{ :keys [ a b ] , :as all } my-hashmap ] ( println a b all )) ;; => A B {:a A :b B :c C :d D} ( let [{ :keys [ a b not-found ] , :or { not-found \":)\" } , :as all } my-hashmap ] ( println a b not-found all )) ;; => A B :) {:a A :b B :c C :d D} There are also :strs and :syms alternatives, for when your map has strings or symbols for keys (instead of keywords), respectively. ( let [{ :strs [ a d ]} { \"a\" \"A\" , \"b\" \"B\" , \"c\" \"C\" , \"d\" \"D\" }] ( println a d )) ;; => A D ( let [{ :syms [ a d ]} { 'a \"A\" , 'b \"B\" , 'c \"C\" , 'd \"D\" }] ( println a d )) ;; => A D Keyword arguments for function \u03bb\ufe0e Map destructuring also works with lists (but not vectors). ( let [{ :keys [ a b ]} ' ( \"X\" , \"Y\" , :a \"A\" , :b \"B\" )] ( println a b )) ;; => A B This allows your functions to have optional keyword arguments. ( defn foo [ a b & { :keys [ x y ]}] ( println a b x y )) ( foo \"A\" \"B\" ) ;; => A B nil nil ( foo \"A\" \"B\" :x \"X\" ) ;; => A B X nil ( foo \"A\" \"B\" :x \"X\" :y \"Y\" ) ;; => A B X Y","title":"Destructuring - abstract structural binding"},{"location":"reference/standard-library/destructuring/#destructuring-abstract-structural-binding","text":"Destructuring is a form of pattern matching where you return specific elements from a collection and assign those elements names. It is commonly used in function parameter lists or with the let function. Destructuring is also known as abstract structural binding A simple example of destructuring is assigning the values of a collection, in this case a vector. ( def co-ordinates [ 5 7 ]) ( let [[ x y ] co-ordinates ] ( str \"x:\" x \"y:\" y )) ;; => x: 5 y: 7 ;; Sometimes we do not need all the information, so we can just use the elements we need. ( def three-dee-co-ordinates [ 2 7 4 ]) ( let [[ x y ] three-dee-co-ordinates ] ( str \"I only need the 2D co-ordinates, X: \" x \" and Y: \" y )) ;; => \"I only need the 2D co-ordinates, X: 2 and Y: 7\" Its quite common to take the first element as a specific name and use another name for the rest of the elements ( def shopping-list [ \"oranges\" \"apples\" \"spinach\" \"carrots\" \"potatoes\" \"beetroot\" ]) ( defn get-item [ items ] ( let [[ next-item & other-items ] items ] ( str \"The next item to get is: \" next-item ))) ( get-item shopping-list ) ;; => \"The next item to get is: oranges\" This example seems a little redundant at first, however if we add recursion then we can iterate through the shopping list and it should make more sense splitting a vector into a head and a tail. When defining a function with an arglist** you use an ampersand. The same is true in destructuring. (def indexes [1 2 3]) user=> (let [[x & more] indexes] (println \"x:\" x \"more:\" more)) x: 1 more: (2 3) It's also worth noting that you can bind the entire vector to a local using the :as directive. user=> (def indexes [1 2 3])","title":"Destructuring - abstract structural binding"},{"location":"reference/standard-library/destructuring/#userindexes","text":"user=> (let [[x & more :as full-list] indexes] (println \"x:\" x \"more:\" more \"full list:\" full-list)) x: 1 more: (2 3) full list: [1 2 3] Vector examples are the easiest; however, in practice I find myself using destructuring with maps far more often. Simple destructuring on a map is as easy as choosing a local name and providing the key. user=> (def point {:x 5 :y 7})","title":"'user/indexes"},{"location":"reference/standard-library/destructuring/#userpoint","text":"user=> (let [{the-x :x the-y :y} point] (println \"x:\" the-x \"y:\" the-y)) x: 5 y: 7 As the example shows, the values of :x and :y are bound to locals with the names the-x and the-y. In practice we would never prepend \"the-\" to our local names; however, using different names provides a bit of clarity for our first example. In production code you would be much more likely to want locals with the same name as the key. This works perfectly well, as the next example shows. user=> (def point {:x 5 :y 7})","title":"'user/point"},{"location":"reference/standard-library/destructuring/#userpoint_1","text":"user=> (let [{x :x y :y} point] (println \"x:\" x \"y:\" y)) x: 5 y: 7 While this works perfectly well, creating locals with the same name as the keys becomes tedious and annoying (especially when your keys are longer than one letter). Clojure anticipates this frustration and provides :keys directive that allows you to specify keys that you would like as locals with the same name. user=> (def point {:x 5 :y 7})","title":"'user/point"},{"location":"reference/standard-library/destructuring/#userpoint_2","text":"user=> (let [{:keys [x y]} point] (println \"x:\" x \"y:\" y)) x: 5 y: 7 There are a few directives that work while destructuring maps. The above example shows the use of :keys. In practice I end up using :keys the most; however, I've also used the :as directive while working with maps. The following example illustrates the use of an :as directive to bind a local with the entire map. user=> (def point {:x 5 :y 7})","title":"'user/point"},{"location":"reference/standard-library/destructuring/#userpoint_3","text":"user=> (let [{:keys [x y] :as the-point} point] (println \"x:\" x \"y:\" y \"point:\" the-point)) x: 5 y: 7 point: {:x 5, :y 7} We've now seen the :as directive used for both vectors and maps. In both cases the local is always assigned to the entire expression that is being destructured. For completeness I'll document the :or directive; however, I must admit that I've never used it in practice. The :or directive is used to assign default values when the map being destructured doesn't contain a specified key. user=> (def point {:y 7})","title":"'user/point"},{"location":"reference/standard-library/destructuring/#userpoint_4","text":"user=> (let [{:keys [x y] :or {x 0 y 0}} point] (println \"x:\" x \"y:\" y)) x: 0 y: 7 Lastly, it's also worth noting that you can destructure nested maps, vectors and a combination of both. The following example destructures a nested map user=> (def book {:name \"SICP\" :details {:pages 657 :isbn-10 \"0262011530\"}})","title":"'user/point"},{"location":"reference/standard-library/destructuring/#userbook","text":"user=> (let [{name :name {pages :pages isbn-10 :isbn-10} :details} book] (println \"name:\" name \"pages:\" pages \"isbn-10:\" isbn-10)) name: SICP pages: 657 isbn-10: 0262011530 As you would expect, you can also use directives while destructuring nested maps. user=> (def book {:name \"SICP\" :details {:pages 657 :isbn-10 \"0262011530\"}})","title":"'user/book"},{"location":"reference/standard-library/destructuring/#userbook_1","text":"user=> user=> (let [{name :name {:keys [pages isbn-10]} :details} book] (println \"name:\" name \"pages:\" pages \"isbn-10:\" isbn-10)) name: SICP pages: 657 isbn-10: 0262011530 Destructuring nested vectors is also very straight-forward, as the following example illustrates user=> (def numbers [[1 2][3 4]])","title":"'user/book"},{"location":"reference/standard-library/destructuring/#usernumbers","text":"user=> (let [[[a b][c d]] numbers] (println \"a:\" a \"b:\" b \"c:\" c \"d:\" d)) a: 1 b: 2 c: 3 d: 4 Since binding forms can be nested within one another arbitrarily, you can pull apart just about anything -- http://clojure.org/special_forms The following example destructures a map and a vector at the same time. user=> (def golfer {:name \"Jim\" :scores [3 5 4 5]})","title":"'user/numbers"},{"location":"reference/standard-library/destructuring/#usergolfer","text":"user=> (let [{name :name [hole1 hole2] :scores} golfer] (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2)) name: Jim hole1: 3 hole2: 5 The same example can be rewritten using a function definition to show the simplicity of using destructuring in parameter lists. user=> (defn print-status [{name :name [hole1 hole2] :scores}] (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2))","title":"'user/golfer"},{"location":"reference/standard-library/destructuring/#userprint-status","text":"user=> (print-status {:name \"Jim\" :scores [3 5 4 5]}) name: Jim hole1: 3 hole2: 5 There are other (less used) directives and deeper explanations available on http://clojure.org/special_forms and in The Joy of Clojure. I recommend both. **(defn do-something [x y & more] ... ) Posted by Jay Fields at 7:44 AM Email ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest Labels: clojure, destructuring 10 comments: fogus8:26 AM Nice post. One other note that naturally follows from the end of your post is that destructuring forms the basis of Clojure's named arguments: (defn print-status [& {name :name [hole1 hole2] :scores}] (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2)) (print-status :name \"Joey\" :scores [42 18]) You can also use pre-conditions to check if certain arguments are passed in: (defn print-status [& {name :name [hole1 hole2] :scores}] {:pre [name]} (println \"name:\" name \"hole1:\" hole1 \"hole2:\" hole2)) (print-status :scores [42 18]) ; java.lang.AssertionError: Assert failed: name (print-status :name \"Joey\" :scores [42 18]) ; name: Joey hole1: 42 hole2: 18 :f Reply Jay Fields9:08 AM Good stuff Fogus, thanks. Cheers, Jay Reply Matt Todd5:31 PM Can you combine :as and :or et al? Reply Anonymous7:29 PM Yes, all the directives can be used at the same time. Cheers, Jay Reply Laurent PETIT3:08 AM Hi, one note about using destructuring for function arguments : by doing so, you're quite explicitly establishing a more detailed contract with the consumer of the function. That is, you open the internals of the passed arguments. Depending on the fact that the user may or may not be aware of the internals of the arguments, it may or may not be a good idea. So I tend to think about the use of destructuring function arguments directly in the function signature, depending on whether the \"layout\" of the arguments of the function is part of the user API. Reply","title":"'user/print-status"},{"location":"reference/standard-library/destructuring/#clojure-destructuring-tutorial-and-cheat-sheet","text":"( Related blog post ) Simply put, destructuring in Clojure is a way extract values from a data structure and bind them to symbols, without having to explicitly traverse the data structure. It allows for elegant and concise Clojure code.","title":"Clojure Destructuring Tutorial and Cheat Sheet"},{"location":"reference/standard-library/destructuring/#vectors","text":"Syntax: [symbol another-symbol] [\"value\" \"another-value\"] ( def my-vector [ :a :b :c :d ]) ( def my-nested-vector [ :a :b :c :d [ :x :y :z ]]) ( let [[ a b c d ] my-vector ] ( println a b c d )) ;; => :a :b :c :d ( let [[ a _ _ d [ x y z ]] my-nested-vector ] ( println a d x y z )) ;; => :a :d :x :y :z You don't have to match the full vector. ( let [[ a b c ] my-vector ] ( println a b c )) ;; => :a :b :c You can use & the-rest to bind the remaining part of the vector to the-rest . ( let [[ a b & the-rest ] my-vector ] ( println a b the-rest )) ;; => :a :b (:c :d) When a destructuring form \"exceeds\" a vector (i.e. there not enough items in the vector to bind to), the excess symbols will be bound to nil . ( let [[ a b c d e f g ] my-vector ] ( println a b c d e f g )) ;; => :a :b :c :d nil nil nil You can use :as some-symbol as the last two items in the destructuring form to bind the whole vector to some-symbol ( let [[ :as all ] my-vector ] ( println all )) ;; => [:a :b :c :d] ( let [[ a :as all ] my-vector ] ( println a all )) ;; => :a [:a :b :c :d] ( let [[ a _ _ _ [ x y z :as nested ] :as all ] my-nested-vector ] ( println a x y z nested all )) ;; => :a :x :y :z [:x :y :z] [:a :b :c :d [:x :y :z]] You can use both & the-rest and :as some-symbol . ( let [[ a b & the-rest :as all ] my-vector ] ( println a b the-rest all )) ;; => :a :b (:c :d) [:a :b :c :d]","title":"Vectors"},{"location":"reference/standard-library/destructuring/#optional-arguments-for-functions","text":"With destructuring and the & the-rest form, you can specify optional arguments to functions. ( defn foo [ a b & more-args ] ( println a b more-args )) ( foo :a :b ) ;; => :a :b nil ( foo :a :b :x ) ;; => :a :b (:x) ( foo :a :b :x :y :z ) ;; => :a :b (:x :y :z) ( defn foo [ a b & [ x y z ]] ( println a b x y z )) ( foo :a :b ) ;; => :a :b nil nil nil ( foo :a :b :x ) ;; => :a :b :x nil nil ( foo :a :b :x :y :z ) ;; => :a :b :x :y :z","title":"Optional arguments for functions"},{"location":"reference/standard-library/destructuring/#maps","text":"Syntax: {symbol :key, another-symbol :another-key} {:key \"value\" :another-key \"another-value\"} ( def my-hashmap { :a \"A\" :b \"B\" :c \"C\" :d \"D\" }) ( def my-nested-hashmap { :a \"A\" :b \"B\" :c \"C\" :d \"D\" :q { :x \"X\" :y \"Y\" :z \"Z\" }}) ( let [{ a :a d :d } my-hashmap ] ( println a d )) ;; => A D ( let [{ a :a , b :b , { x :x , y :y } :q } my-nested-hashmap ] ( println a b x y )) ;; => A B X Y Similar to vectors, if a key is not found in the map, the symbol will be bound to nil . ( let [{ a :a , not-found :not-found , b :b } my-hashmap ] ( println a not-found b )) ;; => A nil B You can provide an optional default value for these missing keys with the :or keyword and a map of default values. ( let [{ a :a , not-found :not-found , b :b , :or { not-found \":)\" }} my-hashmap ] ( println a not-found b )) ;; => A :) B The :as some-symbol form is also available for maps, but unlike vectors it can be specified anywhere (but still preferred to be the last two pairs). ( let [{ a :a , b :b , :as all } my-hashmap ] ( println a b all )) ;; => A B {:a A :b B :c C :d D} And combining :as and :or keywords (again, :as preferred to be the last). ( let [{ a :a , b :b , not-found :not-found , :or { not-found \":)\" } , :as all } my-hashmap ] ( println a b not-found all )) ;; => A B :) {:a A :b B :c C :d D} There is no & the-rest for maps.","title":"Maps"},{"location":"reference/standard-library/destructuring/#shortcuts","text":"Having to specify {symbol :symbol} for each key is repetitive and verbose (it's almost always going to be the symbol equivalent of the key), so shortcuts are provided so you only have to type the symbol once. Here are all the previous examples using the :keys keyword followed by a vector of symbols: ( let [{ :keys [ a d ]} my-hashmap ] ( println a d )) ;; => A D ( let [{ :keys [ a b ] , { :keys [ x y ]} :q } my-nested-hashmap ] ( println a b x y )) ;; => A B X Y ( let [{ :keys [ a not-found b ]} my-hashmap ] ( println a not-found b )) ;; => A nil B ( let [{ :keys [ a not-found b ] , :or { not-found \":)\" }} my-hashmap ] ( println a not-found b )) ;; => A :) B ( let [{ :keys [ a b ] , :as all } my-hashmap ] ( println a b all )) ;; => A B {:a A :b B :c C :d D} ( let [{ :keys [ a b not-found ] , :or { not-found \":)\" } , :as all } my-hashmap ] ( println a b not-found all )) ;; => A B :) {:a A :b B :c C :d D} There are also :strs and :syms alternatives, for when your map has strings or symbols for keys (instead of keywords), respectively. ( let [{ :strs [ a d ]} { \"a\" \"A\" , \"b\" \"B\" , \"c\" \"C\" , \"d\" \"D\" }] ( println a d )) ;; => A D ( let [{ :syms [ a d ]} { 'a \"A\" , 'b \"B\" , 'c \"C\" , 'd \"D\" }] ( println a d )) ;; => A D","title":"Shortcuts"},{"location":"reference/standard-library/destructuring/#keyword-arguments-for-function","text":"Map destructuring also works with lists (but not vectors). ( let [{ :keys [ a b ]} ' ( \"X\" , \"Y\" , :a \"A\" , :b \"B\" )] ( println a b )) ;; => A B This allows your functions to have optional keyword arguments. ( defn foo [ a b & { :keys [ x y ]}] ( println a b x y )) ( foo \"A\" \"B\" ) ;; => A B nil nil ( foo \"A\" \"B\" :x \"X\" ) ;; => A B X nil ( foo \"A\" \"B\" :x \"X\" :y \"Y\" ) ;; => A B X Y","title":"Keyword arguments for function"},{"location":"reference/standard-library/predicate-functions/","text":"clojure.core predicate functions \u03bb\ufe0e The predicate functions defined in clojure.core. A predicate function takes a single argument and returns a truthy value, e.g. true or false clojure.core predicates Description >0? (^:private) >1? (^:private) any? associative? boolean? bound? bytes? chunked-seq? (^:static) class? coll? contains? counted? decimal? delay? distinct? double? empty? even? every? false? fits-table? (defn-) float? fn? future? future-cancelled? future-done? ident? identical? ifn? indexed? inst? int? integer? isa? is-annotation? (defn-) is-runtime-annotation? (defn-) keyword? libspec? (defn-) list? map-entry? nat-int? neg? neg-int? nil? number? odd? pos? pos-int? qualified-ident? qualified-keyword? qualified-symbol? ratio? rational? reader-conditional? realized? reduced? reversible? seqable? sequential? set? simple-ident? simple-keyword? simple-symbol? some? sorted? special-symbol? symbol? tagged-literal? thread-bound? true? uri? uuid? var? volatile? zero?","title":"Predicate functions"},{"location":"reference/standard-library/predicate-functions/#clojurecore-predicate-functions","text":"The predicate functions defined in clojure.core. A predicate function takes a single argument and returns a truthy value, e.g. true or false clojure.core predicates Description >0? (^:private) >1? (^:private) any? associative? boolean? bound? bytes? chunked-seq? (^:static) class? coll? contains? counted? decimal? delay? distinct? double? empty? even? every? false? fits-table? (defn-) float? fn? future? future-cancelled? future-done? ident? identical? ifn? indexed? inst? int? integer? isa? is-annotation? (defn-) is-runtime-annotation? (defn-) keyword? libspec? (defn-) list? map-entry? nat-int? neg? neg-int? nil? number? odd? pos? pos-int? qualified-ident? qualified-keyword? qualified-symbol? ratio? rational? reader-conditional? realized? reduced? reversible? seqable? sequential? set? simple-ident? simple-keyword? simple-symbol? some? sorted? special-symbol? symbol? tagged-literal? thread-bound? true? uri? uuid? var? volatile? zero?","title":"clojure.core predicate functions"},{"location":"reference/standard-library/regular-expressions/","text":"Regular Expressions - regex \u03bb\ufe0e Regular expressions are a powerful and compact way to find specific patterns in text strings. Clojure provides a simple syntax for Java regex patterns. #\"pattern\" is the literal representation of a regular expressions in Clojure, where pattern is the regular expression. (re-pattern pattern) will return the Clojure literal representation of a given regex pattern. The regular expression syntax cheatsheet by Mozilla is an excellent reference for regular expression patterns. Regular expressions overview \u03bb\ufe0e Regular expressions in Clojure {% youtube %} https://youtu.be/iTimmZcNToY find the most common word in a book using regular expressions {% youtube %} https://youtu.be/hpz2vHaTz44 References \u03bb\ufe0e 4Clojure #37 - regular expressions Regex in Clojure - purelyfunctional.tv Double escaping not required \u03bb\ufe0e The Clojure syntax means you do not need to double escape special characters, eg. \\\\ , and keeps the patterns clean and simple to read. In other languages, backslashes intended for consumption by the regex compiler must be doubled. ( java.util.regex.Pattern/compile \"\\\\d\" ) ;;=> #\"\\d\" The rules for embedding unusual literal characters or predefined character classes are listed in the Javadoc for Pattern. Host platform support \u03bb\ufe0e Clojure runs on the Java Virtual Machine and uses Java regular expressions . Regular expressions in Clojure create a java.util.regex.Pattern type ( type # \"pattern\" ) ;;=> java.util.regex.Pattern ClojureScript runs on JavaScript engines and uses Javascript regular expressions. Option flags \u03bb\ufe0e Regular expression option flags can make a pattern case-insensitive or enable multiline mode. Clojure's regex literals starting with (? ) set the mode for the rest of the pattern. For example, the pattern #\"(?i)yo\" matches the strings \u201cyo\u201d , \u201cyO\u201d , \u201cYo\u201d , and \u201cYO\u201d . Flags that can be used in Clojure regular-expression patterns, along with their long name and a description of what they do. See Java's documentation for the java.util.regex.Pattern class for more details. Flag Flag Name Description d UNIX_LINES ., ^, and $ match only the Unix line terminator '\\n'. i CASE_INSENSITIVE ASCII characters are matched without regard to uppercase or lower-case. x COMMENTS Whitespace and comments in the pattern are ignored. m MULTILINE ^ and $ match near line terminators instead of only at the beginning or end of the entire input string. s DOTALL . matches any character including the line terminator. u UNICODE_CASE Causes the i flag to use Unicode case insensitivity instead of ASCII. The re-seq function is Clojure's regex workhorse. It returns a lazy seq of all matches in a string, which means it can be used to efficiently test whether a string matches or to find all matches in a string or a mapped file: ( re-seq # \"\\w+\" \"one-two/three\" ) ;;=> (\"one\" \"two\" \"three\") The preceding regular expression has no capturing groups, so each match in the returned seq is a string. A capturing group (subsegments that are accessible via the returned match object) in the regex causes each returned item to be a vector: ( re-seq # \"\\w*(\\w)\" \"one-two/three\" ) ([ \"one\" \"e\" ] [ \"two\" \"o\" ] [ \"three\" \"e\" ]) Things to avoid \u03bb\ufe0e Java's regular-expression engine includes a Matcher object that mutates in a non-thread-safe way as it walks through a string finding matches. This object is exposed by Clojure via the re-matcher function and can be used as an argument to re-groups and the single-parameter form of re-find. Avoid these unless you're certain you know what you're doing. These dangerous functions are used internally by the implementations of some of the recommended functions described earlier, but in each case they're careful to disallow access to the Matcher object they use. Use matchers at your own risk, or better yet don't use them directly at all.","title":"Regular Expressions - regex"},{"location":"reference/standard-library/regular-expressions/#regular-expressions-regex","text":"Regular expressions are a powerful and compact way to find specific patterns in text strings. Clojure provides a simple syntax for Java regex patterns. #\"pattern\" is the literal representation of a regular expressions in Clojure, where pattern is the regular expression. (re-pattern pattern) will return the Clojure literal representation of a given regex pattern. The regular expression syntax cheatsheet by Mozilla is an excellent reference for regular expression patterns.","title":"Regular Expressions - regex"},{"location":"reference/standard-library/regular-expressions/#regular-expressions-overview","text":"Regular expressions in Clojure {% youtube %} https://youtu.be/iTimmZcNToY find the most common word in a book using regular expressions {% youtube %} https://youtu.be/hpz2vHaTz44","title":"Regular expressions overview"},{"location":"reference/standard-library/regular-expressions/#references","text":"4Clojure #37 - regular expressions Regex in Clojure - purelyfunctional.tv","title":"References"},{"location":"reference/standard-library/regular-expressions/#double-escaping-not-required","text":"The Clojure syntax means you do not need to double escape special characters, eg. \\\\ , and keeps the patterns clean and simple to read. In other languages, backslashes intended for consumption by the regex compiler must be doubled. ( java.util.regex.Pattern/compile \"\\\\d\" ) ;;=> #\"\\d\" The rules for embedding unusual literal characters or predefined character classes are listed in the Javadoc for Pattern.","title":"Double escaping not required"},{"location":"reference/standard-library/regular-expressions/#host-platform-support","text":"Clojure runs on the Java Virtual Machine and uses Java regular expressions . Regular expressions in Clojure create a java.util.regex.Pattern type ( type # \"pattern\" ) ;;=> java.util.regex.Pattern ClojureScript runs on JavaScript engines and uses Javascript regular expressions.","title":"Host platform support"},{"location":"reference/standard-library/regular-expressions/#option-flags","text":"Regular expression option flags can make a pattern case-insensitive or enable multiline mode. Clojure's regex literals starting with (? ) set the mode for the rest of the pattern. For example, the pattern #\"(?i)yo\" matches the strings \u201cyo\u201d , \u201cyO\u201d , \u201cYo\u201d , and \u201cYO\u201d . Flags that can be used in Clojure regular-expression patterns, along with their long name and a description of what they do. See Java's documentation for the java.util.regex.Pattern class for more details. Flag Flag Name Description d UNIX_LINES ., ^, and $ match only the Unix line terminator '\\n'. i CASE_INSENSITIVE ASCII characters are matched without regard to uppercase or lower-case. x COMMENTS Whitespace and comments in the pattern are ignored. m MULTILINE ^ and $ match near line terminators instead of only at the beginning or end of the entire input string. s DOTALL . matches any character including the line terminator. u UNICODE_CASE Causes the i flag to use Unicode case insensitivity instead of ASCII. The re-seq function is Clojure's regex workhorse. It returns a lazy seq of all matches in a string, which means it can be used to efficiently test whether a string matches or to find all matches in a string or a mapped file: ( re-seq # \"\\w+\" \"one-two/three\" ) ;;=> (\"one\" \"two\" \"three\") The preceding regular expression has no capturing groups, so each match in the returned seq is a string. A capturing group (subsegments that are accessible via the returned match object) in the regex causes each returned item to be a vector: ( re-seq # \"\\w*(\\w)\" \"one-two/three\" ) ([ \"one\" \"e\" ] [ \"two\" \"o\" ] [ \"three\" \"e\" ])","title":"Option flags"},{"location":"reference/standard-library/regular-expressions/#things-to-avoid","text":"Java's regular-expression engine includes a Matcher object that mutates in a non-thread-safe way as it walks through a string finding matches. This object is exposed by Clojure via the re-matcher function and can be used as an argument to re-groups and the single-parameter form of re-find. Avoid these unless you're certain you know what you're doing. These dangerous functions are used internally by the implementations of some of the recommended functions described earlier, but in each case they're careful to disallow access to the Matcher object they use. Use matchers at your own risk, or better yet don't use them directly at all.","title":"Things to avoid"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/","text":"Common Regular Expression patterns \u03bb\ufe0e Common string formats used in software development and examples of regular expressions to check their correctness. Username Regular Expression Pattern \u03bb\ufe0e A 8 to 24 character passwords that can include any lower case character or digit (number). Only the underscore and dash special characters can be used. (re-matches #\"^[a-z0-9_-]{8,24}$\" \"good-username\") Breakdown the regex pattern: ^[a-z0-9_-]{8,24}$ ^ # Start of the line [a-z0-9_-] # Match characters and symbols in the list, a-z, 0-9 , underscore , hyphen {8,24} # Length at least 8 characters and maximum length of 24 $ # End of the line Password Regular Expression Pattern \u03bb\ufe0e A password should be 8 to 24 character string with at least one digit, one upper case letter, one lower case letter and one special symbol, @#$% . (re-matches #\"((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{8,24})\" \"G00d @ username\") The order of the grouping formulas does not matter Breakdown the regex pattern: ((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{8,24}) ( # Start of group (?=.*\\d) # must contains one digit from 0-9 (?=.*[a-z]) # must contains one lowercase characters (?=.*[A-Z]) # must contains one uppercase characters (?=.*[@#$%]) # must contains one special symbols in the list \"@#$%\" . # match anything with previous condition checking {8,24} # length at least 8 characters and maximum of 24 ) # End of group ?= means apply the assertion condition, which is meaningless by itself and works in combination with others. Hexadecimal Color Code Regular Expression Pattern \u03bb\ufe0e The string must start with a # symbol , follow by a letter from a to f , A to Z or a digit from 0 to 9 with a length of exactly 3 or 6.` This regular expression pattern is very useful for the Hexadecimal web colors code checking. (re-matches #\"^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$\" \"#FFAABB\") Breakdown the regex pattern: ^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$ ^ #start of the line # # must contain a \"#\" symbols ( # start of group #1 [A-Fa-f0-9]{3} # any strings in the list, with length of 3 | # ..or [A-Fa-f0-9]{6} # any strings in the list, with length of 6 ) # end of group #1 $ #end of the line Email Regular Expression Pattern \u03bb\ufe0e The account side of an email address starts with _A-Za-z0-9-\\\\+ optional follow by .[_A-Za-z0-9-] , ending with an @ symbol. The domain starts with A-Za-z0-9- , follow by first level domain, e.g .org , .io and .[A-Za-z0-9] optionally follow by a second level domain, e.g. .ac.uk , .com.au or \\\\.[A-Za-z]{2,} , where second level domain must start with a dot . and length must equal or more than 2 characters. (re-matches #\"^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$\" \"jenny.jenn@jetpack.com.au\") Hint::Double escaping special characters \u03bb\ufe0e Double escaping of special characters is not required in the Clojure syntax. Breakdown the regex pattern: ^[_A-Za-z0-9-]+(\\\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(\\\\.[A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$ ^ #start of the line [_A-Za-z0-9-]+ # must start with string in the bracket [ ], must contains one or more (+) ( # start of group #1 \\\\.[_A-Za-z0-9-]+ # follow by a dot \".\" and string in the bracket [ ], must contains one or more (+) )* # end of group #1, this group is optional (*) @ # must contains a \"@\" symbol [A-Za-z0-9]+ # follow by string in the bracket [ ], must contains one or more (+) ( # start of group #2 - first level TLD checking \\\\.[A-Za-z0-9]+ # follow by a dot \".\" and string in the bracket [ ], must contains one or more (+) )* # end of group #2, this group is optional (*) ( # start of group #3 - second level TLD checking \\\\.[A-Za-z]{2,} # follow by a dot \".\" and string in the bracket [ ], with minimum length of 2 ) # end of group #3 $ #end of the line Image File name and Extension Regular Expression Pattern \u03bb\ufe0e A file extension name is 1 or more characters without white space, follow by dot . and string end in jpg or png or gif or bmp . The file name extension is case-insensitive. Change the combination (jpg|png|gif|bmp) for other file extension. (re-matches #\"(?i)([^\\s]+(\\.(jpg|png|gif|bmp))$)\" \"clojure-logo.png\") Hint::in-line modifiers not supported in JavaScript \u03bb\ufe0e The REPL above uses ClojureScript, hosted on JavaScript. JavaScript does not support in-line modifier flags such as (?i) for a case insensitive pattern. In-line flags will be converted by the ClojureScript reader if they are the first element in the literal regular expression pattern , or if the js/RegExp function is used to create the regular expression. Breakdown the regex pattern: ([^\\s]+(\\.(?i)(jpg|png|gif|bmp))$) ( #Start of the group #1 [^\\s]+ # must contains one or more anything (except white space) ( # start of the group #2 \\. # follow by a dot \".\" (?i) # ignore the case sensitive checking ( # start of the group #3 jpg # contains characters \"jpg\" | # ..or png # contains characters \"png\" | # ..or gif # contains characters \"gif\" | # ..or bmp # contains characters \"bmp\" ) # end of the group #3 ) # end of the group #2 $ # end of the string ) #end of the group #1 IP Address Regular Expression Pattern \u03bb\ufe0e An IP address comprises of 4 groups of numbers between 0 and 255, with each group separated by a dot. Example IP address are: 192.168.0.1 , 127.0.0.1 , 192.120.240.100 (re-matches #\"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$\" \"192.168.0.1\") Breakdown the regex pattern: ^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\. ([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$ ^ #start of the line ( # start of group #1 [01]?\\\\d\\\\d? # Can be one or two digits. If three digits appear, it must start either 0 or 1 # e.g ([0-9], [0-9][0-9],[0-1][0-9][0-9]) | # ...or 2[0-4]\\\\d # start with 2, follow by 0-4 and end with any digit (2[0-4][0-9]) | # ...or 25[0-5] # start with 2, follow by 5 and end with 0-5 (25[0-5]) ) # end of group #2 \\. # follow by a dot \".\" .... # repeat with 3 time (3x) $ #end of the line Time Format Regular Expression Pattern \u03bb\ufe0e Time in 12-Hour Format Regular Expression Pattern. The 12-hour clock format start between 0-12, then a semi colon, : , follow by 00-59 . The pattern ends with am or pm . (re-matches #\"(?i)(1[012]|[1-9]):[0-5][0-9](\\s)?(am|pm)\" \"12:59am\") Breakdown the regex pattern: (1[012]|[1-9]):[0-5][0-9](\\\\s)?(?i)(am|pm) ( #start of group #1 1[012] # start with 10, 11, 12 | # or [1-9] # start with 1,2,...9 ) #end of group #1 : # follow by a semi colon (:) [0-5][0-9] # follow by 0..5 and 0..9, which means 00 to 59 (\\\\s)? # follow by a white space (optional) (?i) # next checking is case insensitive (am|pm) # follow by am or pm Time in 24-Hour Format Regular Expression Pattern \u03bb\ufe0e The 24-hour clock format start between 0-23 or 00-23, then a semi colon : and follow by 00-59. (re-matches #\"(([01]?[0-9]|2[0-3]):[0-5][0-9])\" \"23:58\") Breakdown the regex pattern: ([01]?[0-9]|2[0-3]):[0-5][0-9] ( #start of group #1 [01]?[0-9] # start with 0-9,1-9,00-09,10-19 | # or 2[0-3] # start with 20-23 ) #end of group #1 : # follow by a semi colon (:) [0-5][0-9] # follow by 0..5 and 0..9, which means 00 to 59 Date Format (dd/mm/yyyy) Regular Expression Pattern \u03bb\ufe0e Date format in the form dd/mm/yyyy . Validating a leap year and if there is 30 or 31 days in a month is not simple though. (re-matches #\"(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/((19|20)\\d\\d)\" \"20/02/2020\") Breakdown the regex pattern: (0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/((19|20)\\\\d\\\\d) ( #start of group #1 0?[1-9] # 01-09 or 1-9 | # ..or [12][0-9] # 10-19 or 20-29 | # ..or 3[01] # 30, 31 ) #end of group #1 / # follow by a \"/\" ( # start of group #2 0?[1-9] # 01-09 or 1-9 | # ..or 1[012] # 10,11,12 ) # end of group #2 / # follow by a \"/\" ( # start of group #3 (19|20)\\\\d\\\\d # 19[0-9][0-9] or 20[0-9][0-9] ) # end of group #3 Reference: \u03bb\ufe0e https://mkyong.com/regular-expressions/10-java-regular-expression-examples-you-should-know","title":"Common Regular Expression patterns"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#common-regular-expression-patterns","text":"Common string formats used in software development and examples of regular expressions to check their correctness.","title":"Common Regular Expression patterns"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#username-regular-expression-pattern","text":"A 8 to 24 character passwords that can include any lower case character or digit (number). Only the underscore and dash special characters can be used. (re-matches #\"^[a-z0-9_-]{8,24}$\" \"good-username\") Breakdown the regex pattern: ^[a-z0-9_-]{8,24}$ ^ # Start of the line [a-z0-9_-] # Match characters and symbols in the list, a-z, 0-9 , underscore , hyphen {8,24} # Length at least 8 characters and maximum length of 24 $ # End of the line","title":"Username Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#password-regular-expression-pattern","text":"A password should be 8 to 24 character string with at least one digit, one upper case letter, one lower case letter and one special symbol, @#$% . (re-matches #\"((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{8,24})\" \"G00d @ username\") The order of the grouping formulas does not matter Breakdown the regex pattern: ((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{8,24}) ( # Start of group (?=.*\\d) # must contains one digit from 0-9 (?=.*[a-z]) # must contains one lowercase characters (?=.*[A-Z]) # must contains one uppercase characters (?=.*[@#$%]) # must contains one special symbols in the list \"@#$%\" . # match anything with previous condition checking {8,24} # length at least 8 characters and maximum of 24 ) # End of group ?= means apply the assertion condition, which is meaningless by itself and works in combination with others.","title":"Password Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#hexadecimal-color-code-regular-expression-pattern","text":"The string must start with a # symbol , follow by a letter from a to f , A to Z or a digit from 0 to 9 with a length of exactly 3 or 6.` This regular expression pattern is very useful for the Hexadecimal web colors code checking. (re-matches #\"^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$\" \"#FFAABB\") Breakdown the regex pattern: ^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$ ^ #start of the line # # must contain a \"#\" symbols ( # start of group #1 [A-Fa-f0-9]{3} # any strings in the list, with length of 3 | # ..or [A-Fa-f0-9]{6} # any strings in the list, with length of 6 ) # end of group #1 $ #end of the line","title":"Hexadecimal Color Code Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#email-regular-expression-pattern","text":"The account side of an email address starts with _A-Za-z0-9-\\\\+ optional follow by .[_A-Za-z0-9-] , ending with an @ symbol. The domain starts with A-Za-z0-9- , follow by first level domain, e.g .org , .io and .[A-Za-z0-9] optionally follow by a second level domain, e.g. .ac.uk , .com.au or \\\\.[A-Za-z]{2,} , where second level domain must start with a dot . and length must equal or more than 2 characters. (re-matches #\"^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$\" \"jenny.jenn@jetpack.com.au\")","title":"Email Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#hintdouble-escaping-special-characters","text":"Double escaping of special characters is not required in the Clojure syntax. Breakdown the regex pattern: ^[_A-Za-z0-9-]+(\\\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9]+(\\\\.[A-Za-z0-9]+)*(\\\\.[A-Za-z]{2,})$ ^ #start of the line [_A-Za-z0-9-]+ # must start with string in the bracket [ ], must contains one or more (+) ( # start of group #1 \\\\.[_A-Za-z0-9-]+ # follow by a dot \".\" and string in the bracket [ ], must contains one or more (+) )* # end of group #1, this group is optional (*) @ # must contains a \"@\" symbol [A-Za-z0-9]+ # follow by string in the bracket [ ], must contains one or more (+) ( # start of group #2 - first level TLD checking \\\\.[A-Za-z0-9]+ # follow by a dot \".\" and string in the bracket [ ], must contains one or more (+) )* # end of group #2, this group is optional (*) ( # start of group #3 - second level TLD checking \\\\.[A-Za-z]{2,} # follow by a dot \".\" and string in the bracket [ ], with minimum length of 2 ) # end of group #3 $ #end of the line","title":"Hint::Double escaping special characters"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#image-file-name-and-extension-regular-expression-pattern","text":"A file extension name is 1 or more characters without white space, follow by dot . and string end in jpg or png or gif or bmp . The file name extension is case-insensitive. Change the combination (jpg|png|gif|bmp) for other file extension. (re-matches #\"(?i)([^\\s]+(\\.(jpg|png|gif|bmp))$)\" \"clojure-logo.png\")","title":"Image File name and Extension Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#hintin-line-modifiers-not-supported-in-javascript","text":"The REPL above uses ClojureScript, hosted on JavaScript. JavaScript does not support in-line modifier flags such as (?i) for a case insensitive pattern. In-line flags will be converted by the ClojureScript reader if they are the first element in the literal regular expression pattern , or if the js/RegExp function is used to create the regular expression. Breakdown the regex pattern: ([^\\s]+(\\.(?i)(jpg|png|gif|bmp))$) ( #Start of the group #1 [^\\s]+ # must contains one or more anything (except white space) ( # start of the group #2 \\. # follow by a dot \".\" (?i) # ignore the case sensitive checking ( # start of the group #3 jpg # contains characters \"jpg\" | # ..or png # contains characters \"png\" | # ..or gif # contains characters \"gif\" | # ..or bmp # contains characters \"bmp\" ) # end of the group #3 ) # end of the group #2 $ # end of the string ) #end of the group #1","title":"Hint::in-line modifiers not supported in JavaScript"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#ip-address-regular-expression-pattern","text":"An IP address comprises of 4 groups of numbers between 0 and 255, with each group separated by a dot. Example IP address are: 192.168.0.1 , 127.0.0.1 , 192.120.240.100 (re-matches #\"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$\" \"192.168.0.1\") Breakdown the regex pattern: ^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\. ([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$ ^ #start of the line ( # start of group #1 [01]?\\\\d\\\\d? # Can be one or two digits. If three digits appear, it must start either 0 or 1 # e.g ([0-9], [0-9][0-9],[0-1][0-9][0-9]) | # ...or 2[0-4]\\\\d # start with 2, follow by 0-4 and end with any digit (2[0-4][0-9]) | # ...or 25[0-5] # start with 2, follow by 5 and end with 0-5 (25[0-5]) ) # end of group #2 \\. # follow by a dot \".\" .... # repeat with 3 time (3x) $ #end of the line","title":"IP Address Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#time-format-regular-expression-pattern","text":"Time in 12-Hour Format Regular Expression Pattern. The 12-hour clock format start between 0-12, then a semi colon, : , follow by 00-59 . The pattern ends with am or pm . (re-matches #\"(?i)(1[012]|[1-9]):[0-5][0-9](\\s)?(am|pm)\" \"12:59am\") Breakdown the regex pattern: (1[012]|[1-9]):[0-5][0-9](\\\\s)?(?i)(am|pm) ( #start of group #1 1[012] # start with 10, 11, 12 | # or [1-9] # start with 1,2,...9 ) #end of group #1 : # follow by a semi colon (:) [0-5][0-9] # follow by 0..5 and 0..9, which means 00 to 59 (\\\\s)? # follow by a white space (optional) (?i) # next checking is case insensitive (am|pm) # follow by am or pm","title":"Time Format Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#time-in-24-hour-format-regular-expression-pattern","text":"The 24-hour clock format start between 0-23 or 00-23, then a semi colon : and follow by 00-59. (re-matches #\"(([01]?[0-9]|2[0-3]):[0-5][0-9])\" \"23:58\") Breakdown the regex pattern: ([01]?[0-9]|2[0-3]):[0-5][0-9] ( #start of group #1 [01]?[0-9] # start with 0-9,1-9,00-09,10-19 | # or 2[0-3] # start with 20-23 ) #end of group #1 : # follow by a semi colon (:) [0-5][0-9] # follow by 0..5 and 0..9, which means 00 to 59","title":"Time in 24-Hour Format Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#date-format-ddmmyyyy-regular-expression-pattern","text":"Date format in the form dd/mm/yyyy . Validating a leap year and if there is 30 or 31 days in a month is not simple though. (re-matches #\"(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/((19|20)\\d\\d)\" \"20/02/2020\") Breakdown the regex pattern: (0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/((19|20)\\\\d\\\\d) ( #start of group #1 0?[1-9] # 01-09 or 1-9 | # ..or [12][0-9] # 10-19 or 20-29 | # ..or 3[01] # 30, 31 ) #end of group #1 / # follow by a \"/\" ( # start of group #2 0?[1-9] # 01-09 or 1-9 | # ..or 1[012] # 10,11,12 ) # end of group #2 / # follow by a \"/\" ( # start of group #3 (19|20)\\\\d\\\\d # 19[0-9][0-9] or 20[0-9][0-9] ) # end of group #3","title":"Date Format (dd/mm/yyyy) Regular Expression Pattern"},{"location":"reference/standard-library/regular-expressions/common-regex-patterns/#reference","text":"https://mkyong.com/regular-expressions/10-java-regular-expression-examples-you-should-know","title":"Reference:"},{"location":"reference/standard-library/regular-expressions/matching-sub-sequences/","text":"Matching sub-sequences \u03bb\ufe0e re-seq returns a lazy seq of all of the matches. The elements of the seq are the results that re-find would return. (re-seq #\"s+\" \"Helloween\") Most common word \u03bb\ufe0e re-seq is used in the most common word challenge to split a string into individual words. Extract from Project Guttenburg the text of The importance of being Earnest by Oscar Wilde. This returns a string of the whole book. The book is broken down into a collection of individual words using re-seq and a regular expression pattern. The collection of words is converted to lower case, so that The and the are not counted as separate words. frequencies returns a collection of tuples, each tuple being a word and a value representing how often it occurs. This collection is sorted by the value in descending order to show the word with the most occurrences at the top. ( ->> ( slurp \"http://www.gutenberg.org/cache/epub/844/pg844.txt\" ) ( re-seq # \"[a-zA-Z0-9|']+\" ) ( map # ( clojure.string/lower-case % )) frequencies ( sort-by val dec )) TODO: add link to complete example.","title":"Matching sub sequences"},{"location":"reference/standard-library/regular-expressions/matching-sub-sequences/#matching-sub-sequences","text":"re-seq returns a lazy seq of all of the matches. The elements of the seq are the results that re-find would return. (re-seq #\"s+\" \"Helloween\")","title":"Matching sub-sequences"},{"location":"reference/standard-library/regular-expressions/matching-sub-sequences/#most-common-word","text":"re-seq is used in the most common word challenge to split a string into individual words. Extract from Project Guttenburg the text of The importance of being Earnest by Oscar Wilde. This returns a string of the whole book. The book is broken down into a collection of individual words using re-seq and a regular expression pattern. The collection of words is converted to lower case, so that The and the are not counted as separate words. frequencies returns a collection of tuples, each tuple being a word and a value representing how often it occurs. This collection is sorted by the value in descending order to show the word with the most occurrences at the top. ( ->> ( slurp \"http://www.gutenberg.org/cache/epub/844/pg844.txt\" ) ( re-seq # \"[a-zA-Z0-9|']+\" ) ( map # ( clojure.string/lower-case % )) frequencies ( sort-by val dec )) TODO: add link to complete example.","title":"Most common word"},{"location":"reference/standard-library/regular-expressions/matching-sub-strings/","text":"Matching sub-strings \u03bb\ufe0e re-find returns the first match within the string, using return values similar to re-matches. nil is returned when the pattern does not find a match. (re-find #\"pump\" \"Halloween\") A matching pattern without groups returns the matched string (re-find #\"e+\" \"Halloween\") Match with groups returns a vector of results (re-find #\"s+(.*)(s+)\" \"success\")","title":"Matching sub strings"},{"location":"reference/standard-library/regular-expressions/matching-sub-strings/#matching-sub-strings","text":"re-find returns the first match within the string, using return values similar to re-matches. nil is returned when the pattern does not find a match. (re-find #\"pump\" \"Halloween\") A matching pattern without groups returns the matched string (re-find #\"e+\" \"Halloween\") Match with groups returns a vector of results (re-find #\"s+(.*)(s+)\" \"success\")","title":"Matching sub-strings"},{"location":"reference/standard-library/regular-expressions/matching-with-groups/","text":"Matching with regex groups \u03bb\ufe0e rematches takes a pattern and compares it with a string. If the pattern does not match the string then nil is returned to show the function returned a false value. (re-matches #\"pumpkin\" \"Halloween pumpkin\") ``` If there is an exact match and there are no groups (parens) in the regex, then the matched string is returned. ```eval-clojure (re-matches #\"pumpkin\" \"pumpkin\") If the pattern matches but there are groups, a vector of matching strings is returned. The first element in the vector is the entire match. The remaining elements are the group matches. (re-matches #\"Halloween(.*)\" \"Halloween pumpkin\")","title":"Matching with regex groups"},{"location":"reference/standard-library/regular-expressions/matching-with-groups/#matching-with-regex-groups","text":"rematches takes a pattern and compares it with a string. If the pattern does not match the string then nil is returned to show the function returned a false value. (re-matches #\"pumpkin\" \"Halloween pumpkin\") ``` If there is an exact match and there are no groups (parens) in the regex, then the matched string is returned. ```eval-clojure (re-matches #\"pumpkin\" \"pumpkin\") If the pattern matches but there are groups, a vector of matching strings is returned. The first element in the vector is the entire match. The remaining elements are the group matches. (re-matches #\"Halloween(.*)\" \"Halloween pumpkin\")","title":"Matching with regex groups"},{"location":"reference/standard-library/regular-expressions/string-replace-with-regex/","text":"String replace with regex pattern \u03bb\ufe0e clojure.string/replace takes a string, a pattern and a substring that will replace matching patterns. (clojure.string/replace \"mississippi\" #\"i..\" \"obb\") Groups can be referred to in the substring replacement (clojure.string/replace \"mississippi\" #\"(i)\" \"$1$1\") Replace with the value of a function applied to the match: (clojure.string/replace \"mississippi\" #\"(.)i(.)\" (fn [[_ b a]] (str (clojure.string/upper-case b) \"--\" (clojure.string/upper-case a)))) \"M--SS--SS--Ppi\" clojure.string/replace-first is a variation where just the first occurance is replaced.","title":"String replace with regex"},{"location":"reference/standard-library/regular-expressions/string-replace-with-regex/#string-replace-with-regex-pattern","text":"clojure.string/replace takes a string, a pattern and a substring that will replace matching patterns. (clojure.string/replace \"mississippi\" #\"i..\" \"obb\") Groups can be referred to in the substring replacement (clojure.string/replace \"mississippi\" #\"(i)\" \"$1$1\") Replace with the value of a function applied to the match: (clojure.string/replace \"mississippi\" #\"(.)i(.)\" (fn [[_ b a]] (str (clojure.string/upper-case b) \"--\" (clojure.string/upper-case a)))) \"M--SS--SS--Ppi\" clojure.string/replace-first is a variation where just the first occurance is replaced.","title":"String replace with regex pattern"},{"location":"reference/standard-library/regular-expressions/string-split-with-regex/","text":"String splitting using a regex pattern \u03bb\ufe0e clojure.string/split takes a string to be split and a pattern to split the string with. (clojure.string/split \"This is a string that I am splitting.\" #\"\\s+\") [\"This\" \"is\" \"a\" \"string\" \"that\" \"I\" \"am\" \"splitting.\"] Most common words example \u03bb\ufe0e Extract a list of the most commonly used English words, returned as a string of words that are separated by a comma. The #\",\" regex pattern splits the string of words to form a collection of individual words, each word being its own string. ( def common-english-words ( set ( clojure.string/split ( slurp \"http://www.textfixer.com/resources/common-english-words.txt\" ) # \",\" ))) TODO: add link to complete example.","title":"String split with regex"},{"location":"reference/standard-library/regular-expressions/string-split-with-regex/#string-splitting-using-a-regex-pattern","text":"clojure.string/split takes a string to be split and a pattern to split the string with. (clojure.string/split \"This is a string that I am splitting.\" #\"\\s+\") [\"This\" \"is\" \"a\" \"string\" \"that\" \"I\" \"am\" \"splitting.\"]","title":"String splitting using a regex pattern"},{"location":"reference/standard-library/regular-expressions/string-split-with-regex/#most-common-words-example","text":"Extract a list of the most commonly used English words, returned as a string of words that are separated by a comma. The #\",\" regex pattern splits the string of words to form a collection of individual words, each word being its own string. ( def common-english-words ( set ( clojure.string/split ( slurp \"http://www.textfixer.com/resources/common-english-words.txt\" ) # \",\" ))) TODO: add link to complete example.","title":"Most common words example"},{"location":"reference/standard-library/regular-expressions/sub-expression-matches/","text":"Sub-expression Matches \u03bb\ufe0e Pattern Description ^ Matches beginning of line. $ Matches end of line. . Matches any single character except newline. Using m option allows it to match newline as well. [...] Matches any single character in brackets. [^...] Matches any single character not in brackets \\A Beginning of entire string \\z End of entire string \\Z End of entire string except allowable final line terminator. re* Matches 0 or more occurrences of preceding expression. re+ Matches 1 or more of the previous thing re? Matches 0 or 1 occurrence of preceding expression. re{ n} Matches exactly n number of occurrences of preceding expression. re{ n,} Matches n or more occurrences of preceding expression. re{ n, m} Matches at least n and at most m occurrences of preceding expression. a b (re) Groups regular expressions and remembers matched text. (?: re) Groups regular expressions without remembering matched text. (?> re) Matches independent pattern without backtracking. \\w Matches word characters. \\W Matches nonword characters. \\s Matches whitespace. Equivalent to [\\t\\n\\r\\f]. \\S Matches nonwhitespace. \\d Matches digits. Equivalent to [0-9]. \\D Matches nondigits. \\A Matches beginning of string. \\Z Matches end of string. If a newline exists, it matches just before newline. \\z Matches end of string. \\G Matches point where last match finished. \\n Back-reference to capture group number \"n\" \\b Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets. \\B Matches nonword boundaries. \\n, \\t, etc. Matches newlines, carriage returns, tabs, etc. \\Q Escape (quote) all characters up to \\E \\E Ends quoting begun with \\Q","title":"Sub-expression Matches"},{"location":"reference/standard-library/regular-expressions/sub-expression-matches/#sub-expression-matches","text":"Pattern Description ^ Matches beginning of line. $ Matches end of line. . Matches any single character except newline. Using m option allows it to match newline as well. [...] Matches any single character in brackets. [^...] Matches any single character not in brackets \\A Beginning of entire string \\z End of entire string \\Z End of entire string except allowable final line terminator. re* Matches 0 or more occurrences of preceding expression. re+ Matches 1 or more of the previous thing re? Matches 0 or 1 occurrence of preceding expression. re{ n} Matches exactly n number of occurrences of preceding expression. re{ n,} Matches n or more occurrences of preceding expression. re{ n, m} Matches at least n and at most m occurrences of preceding expression. a b (re) Groups regular expressions and remembers matched text. (?: re) Groups regular expressions without remembering matched text. (?> re) Matches independent pattern without backtracking. \\w Matches word characters. \\W Matches nonword characters. \\s Matches whitespace. Equivalent to [\\t\\n\\r\\f]. \\S Matches nonwhitespace. \\d Matches digits. Equivalent to [0-9]. \\D Matches nondigits. \\A Matches beginning of string. \\Z Matches end of string. If a newline exists, it matches just before newline. \\z Matches end of string. \\G Matches point where last match finished. \\n Back-reference to capture group number \"n\" \\b Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets. \\B Matches nonword boundaries. \\n, \\t, etc. Matches newlines, carriage returns, tabs, etc. \\Q Escape (quote) all characters up to \\E \\E Ends quoting begun with \\Q","title":"Sub-expression Matches"},{"location":"reference/tagged-literals/","text":"Tagged Literals \u03bb\ufe0e Frequently used value types are afforded a \"tagged literal\" syntax. It is similar to a constructor, but this special syntax makes it de/serializable and easier to read at the REPL. Tagged literals start with a # followed by a symbol and a literal: #js [...] - JavaScript array literal #js {...} - JavaScript object literal #inst \"...\" - JavaScript date literal #uuid \"...\" - UUID literal #queue [...] - queue literal","title":"Tagged Literals"},{"location":"reference/tagged-literals/#tagged-literals","text":"Frequently used value types are afforded a \"tagged literal\" syntax. It is similar to a constructor, but this special syntax makes it de/serializable and easier to read at the REPL. Tagged literals start with a # followed by a symbol and a literal: #js [...] - JavaScript array literal #js {...} - JavaScript object literal #inst \"...\" - JavaScript date literal #uuid \"...\" - UUID literal #queue [...] - queue literal","title":"Tagged Literals"},{"location":"reference/tagged-literals/uuid/","text":"uuid tag literal \u03bb\ufe0e A universally unique identifier (UUID). #uuid \"8-4-4-4-12\" - numbers represent the number of hex digits #uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\" - actual example Representing UUIDs with #uuid rather than just a plain string has the following benefits: the reader will throw an exception on malformed UUIDs its UUID type is preserved and shown when serialized to edn. Creating UUIDs - Clojure \u03bb\ufe0e In Clojure, call the randomUUID method of the java.util.UUID class (java.util.UUID/randomUUID) This returns a UUID tagged literal. ( java.util.UUID/randomUUID ) ;; => #uuid \"44f3ffd7-6702-4b8a-af25-11bee4b5ec4f\" Looking at the type we can see its a Java object from the java.util.UUID class: ( type ( java.util.UUID/randomUUID )) ;; => java.util.UUID Creating UUIDs - ClojureScript \u03bb\ufe0e Randomly generate a UUID in ClojureScript: cljs.core/random-uuid To label a value as a UUID: cljs.core/uuid Hint::uuid does not validate the value \u03bb\ufe0e The ClojureScript documentation states that uuid? does not perform validation. Testing for a uuid \u03bb\ufe0e uuid? tests a given value and returns true if it is a uuid tagged literal value. tagged-literal? is the more general function for any tagged values.","title":"uuid tag literal"},{"location":"reference/tagged-literals/uuid/#uuid-tag-literal","text":"A universally unique identifier (UUID). #uuid \"8-4-4-4-12\" - numbers represent the number of hex digits #uuid \"97bda55b-6175-4c39-9e04-7c0205c709dc\" - actual example Representing UUIDs with #uuid rather than just a plain string has the following benefits: the reader will throw an exception on malformed UUIDs its UUID type is preserved and shown when serialized to edn.","title":"uuid tag literal"},{"location":"reference/tagged-literals/uuid/#creating-uuids-clojure","text":"In Clojure, call the randomUUID method of the java.util.UUID class (java.util.UUID/randomUUID) This returns a UUID tagged literal. ( java.util.UUID/randomUUID ) ;; => #uuid \"44f3ffd7-6702-4b8a-af25-11bee4b5ec4f\" Looking at the type we can see its a Java object from the java.util.UUID class: ( type ( java.util.UUID/randomUUID )) ;; => java.util.UUID","title":"Creating UUIDs - Clojure"},{"location":"reference/tagged-literals/uuid/#creating-uuids-clojurescript","text":"Randomly generate a UUID in ClojureScript: cljs.core/random-uuid To label a value as a UUID: cljs.core/uuid","title":"Creating UUIDs - ClojureScript"},{"location":"reference/tagged-literals/uuid/#hintuuid-does-not-validate-the-value","text":"The ClojureScript documentation states that uuid? does not perform validation.","title":"Hint::uuid does not validate the value"},{"location":"reference/tagged-literals/uuid/#testing-for-a-uuid","text":"uuid? tests a given value and returns true if it is a uuid tagged literal value. tagged-literal? is the more general function for any tagged values.","title":"Testing for a uuid"},{"location":"simple-projects/","text":"Small Projects \u03bb\ufe0e An effective way to get comfortable with Clojure is to start writing small projects. In this section several small projects are used to walk the audience through how to create and develop a project, as well as learn some Clojure functions and functional programming techniques along the way. Project Topics Description Random Clojure Function namespace vars command line application that displays a random function from the Clojure standard library Encoding and decoding projects hash-map dictionaries transforming messages between one form and another Data Transformation transforming larger and larger data sets Test Driven Development and Kata Unit testing Unit testing and solving challenges using different approaches Creating Clojure projects \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. Hint::TODO: Add more small projects \u03bb\ufe0e","title":"Small Projects"},{"location":"simple-projects/#small-projects","text":"An effective way to get comfortable with Clojure is to start writing small projects. In this section several small projects are used to walk the audience through how to create and develop a project, as well as learn some Clojure functions and functional programming techniques along the way. Project Topics Description Random Clojure Function namespace vars command line application that displays a random function from the Clojure standard library Encoding and decoding projects hash-map dictionaries transforming messages between one form and another Data Transformation transforming larger and larger data sets Test Driven Development and Kata Unit testing Unit testing and solving challenges using different approaches","title":"Small Projects"},{"location":"simple-projects/#creating-clojure-projects","text":"Use Clojure CLI tools and clj-new to create a new Clojure project.","title":"Creating Clojure projects"},{"location":"simple-projects/#hinttodo-add-more-small-projects","text":"","title":"Hint::TODO: Add more small projects"},{"location":"simple-projects/create-project/","text":"Create a project \u03bb\ufe0e Note Create a project called salary-calculator using Leiningen lein new salary-calculator This creates a new directory with the name of the project. We did not specify a project template, so Leiningen just used the default template. Viewing the Clojure project structure \u03bb\ufe0e Change into the directory created by Leiningen and view the directory structure (here we use the command tree , you can use a file manager or editor if you prefer). Hint Clojure uses Kebab-case for its naming conventions (think of a shish-kebab), however the Java runtime does not like minus symbol, - , in directory or file names. Therefore as there is a - symbol in the project name, Leiningen automatically changes the directory name to use the underscore _ symbol instead. Version the project with Git (optional) \u03bb\ufe0e Hint If you have already cloned the project from Github, skip this step Even when experimenting with a new language its good to put your code into version control, so you can experiment freely and go back to alternative ideas. Note Run the following Git commands within the root of the Clojure project (the directory containing project.clj) git init git add . git commit -m \"Clojure project created with Leiningen default template\" Command output should look similar to the following:","title":"Create a project"},{"location":"simple-projects/create-project/#create-a-project","text":"Note Create a project called salary-calculator using Leiningen lein new salary-calculator This creates a new directory with the name of the project. We did not specify a project template, so Leiningen just used the default template.","title":"Create a project"},{"location":"simple-projects/create-project/#viewing-the-clojure-project-structure","text":"Change into the directory created by Leiningen and view the directory structure (here we use the command tree , you can use a file manager or editor if you prefer). Hint Clojure uses Kebab-case for its naming conventions (think of a shish-kebab), however the Java runtime does not like minus symbol, - , in directory or file names. Therefore as there is a - symbol in the project name, Leiningen automatically changes the directory name to use the underscore _ symbol instead.","title":"Viewing the Clojure project structure"},{"location":"simple-projects/create-project/#version-the-project-with-git-optional","text":"Hint If you have already cloned the project from Github, skip this step Even when experimenting with a new language its good to put your code into version control, so you can experiment freely and go back to alternative ideas. Note Run the following Git commands within the root of the Clojure project (the directory containing project.clj) git init git add . git commit -m \"Clojure project created with Leiningen default template\" Command output should look similar to the following:","title":"Version the project with Git (optional)"},{"location":"simple-projects/generate-web-page/","text":"Simple Project: Generate Web Page \u03bb\ufe0e Generate a web page from Clojure code, using Hiccup Generate a full HTML webpage with content. Add a CSS library (bulma.io, bootstrap) to improve generation {% tabs repl=\"In the REPL\", project=\"In a Clojure Project\" %} {% content \"repl\" %} {% content \"project\" %} clojure -M:new app practicalli/generate-webpage {% endtabs %} Summary \u03bb\ufe0e Generating a web page in Clojure shows how easy it is to structure data and transform that data into other structures. Although this kind of project is easy enough to just do in a REPL directly, using a Clojure aware editor with a Clojure project makes changes to the code far simpler, without loosing any of the immediate feedback of the REPL. Most Clojure developers use the REPL by evaluating code in the editor showing the source code from the project. Practicalli WebApps book shows how to build websites, create self-documented API's, manage Web Application servers and use databases to persist data.","title":"Simple Project: Generate Web Page"},{"location":"simple-projects/generate-web-page/#simple-project-generate-web-page","text":"Generate a web page from Clojure code, using Hiccup Generate a full HTML webpage with content. Add a CSS library (bulma.io, bootstrap) to improve generation {% tabs repl=\"In the REPL\", project=\"In a Clojure Project\" %} {% content \"repl\" %} {% content \"project\" %} clojure -M:new app practicalli/generate-webpage {% endtabs %}","title":"Simple Project: Generate Web Page"},{"location":"simple-projects/generate-web-page/#summary","text":"Generating a web page in Clojure shows how easy it is to structure data and transform that data into other structures. Although this kind of project is easy enough to just do in a REPL directly, using a Clojure aware editor with a Clojure project makes changes to the code far simpler, without loosing any of the immediate feedback of the REPL. Most Clojure developers use the REPL by evaluating code in the editor showing the source code from the project. Practicalli WebApps book shows how to build websites, create self-documented API's, manage Web Application servers and use databases to persist data.","title":"Summary"},{"location":"simple-projects/random-clojure-function/","text":"Random Clojure Function \u03bb\ufe0e A simple application that returns a random function from the clojure.core namespace, along with the function argument list and its description (from the doc-string) There are 659 functions in clojure.core namespace and 955 in the standard library (as of June 2020). These functions are learned over time as experience is gained with Clojure. Live Coding Video walk-through \u03bb\ufe0e A Live coding video walk-through of this project shows how this application was developed, using Spacemacs editor and CircleCI for continuous integration. {% youtube %} https://youtu.be/sXZKrD4cAFk Hint::Use -M flag instead of -A \u03bb\ufe0e The -M flag has replaced the -A flag for including aliases when running Clojure main, which is the approach that the cider jack-in command uses. Create a project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/random-clojure-function This project has a deps.edn file that includes the aliases - :test - includes the test/ directory in the class path so unit test code is found - :runner to run the Cognitect Labs test runner which will find and run all unit tests REPL experiments \u03bb\ufe0e Start a repl and experiment or open src/practicalli/random-clojure-function.clj in a Clojure-aware editor Get a list of all the functions in the clojure.core namespace, preferably just the public functions. ns-publics returns a map of the function details from the clojure.core namespace ( ns-publics 'clojure.core ) The hash-map keys are function symbols and the values are the function vars { + ' # 'clojure.core/+ ' , decimal? # 'clojure.core/decimal? , sort-by # 'clojure.core/sort-by , macroexpand # 'clojure.core/macroexpand ,,, } The meta function will return a hash-map of details about a function, when given a function var. ( meta # 'map ) The hash-map has several useful pieces of information for the application, including :name , :doc , and :arglists ;; => {:added \"1.0\", ;; :ns #namespace[clojure.core], ;; :name map, ;; :file \"clojure/core.clj\", ;; :static true, ;; :column 1, ;; :line 2727, ;; :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), ;; :doc ;; \"Returns a lazy sequence consisting of the result of applying f to\\n the set of first items of each coll, followed by applying f to the\\n set of second items in each coll, until any one of the colls is\\n exhausted. Any remaining items in other colls are ignored. Function\\n f should accept number-of-colls arguments. Returns a transducer when\\n no collection is provided.\"} To use the meta function, the values from the ns-publics results should be used. ( vals ( ns-publics 'clojure.core )) rand-nth will return a random function var from the sequence of function vars ( rand-nth ( vals ( ns-publics 'clojure.core ))) A single function var is returned, so then the specific meta data can be returned. ( meta ( rand-nth ( vals ( ns-publics 'clojure.core )))) Define a name for all functions \u03bb\ufe0e Edit the src/practicalli/random-clojure-function.clj file and define a name for the collection of all public functions from clojure.core ( def standard-library-functions \"Fully qualified function names from clojure.core\" ( vals ( ns-publics 'clojure.core ))) Write Unit Tests \u03bb\ufe0e From the REPL experiments we have a basic approach for the application design, so codify that design by writing unit tests. This will also highlight regressions during the course of development. Edit the file test/practicalli/random_clojure_core_function_test.clj and add unit tests. The first test check th standard-library-functions contains entries. The second test checks the -main function returns a string (the function name and details). ( ns practicalli.random-clojure-core-function-test ( :require [ clojure.test :refer [ deftest is testing ]] [ practicalli.random-clojure-core-function :as SUT ])) ( deftest -main-test ( testing \"Show random function from Clojure standard library\" ( is ( seq SUT/standard-library-functions )) ( is ( string? ( SUT/-main ))))) Update the main function \u03bb\ufe0e Edit the src/practicalli/random-clojure-function.clj file. Change the -main function to return a string of the function name and description. ( defn -main \"Return a function name from the Clojure Standard library\" [ & args ] ( let [ function-details ( meta ( rand-nth standard-library-functions ))] ( str ( function-details :name ) \"\\n \" ( function-details :doc ))) ) Run the tests with the Cognitect Labs test runner from the aliases in the project clojure -M:test:runner The tests should pass. Running the application \u03bb\ufe0e Use the clojure command with the main namespace of the application. Clojure will look for the -main function and evaluate it. clojure -M -m practicalli.random-clojure-function This should return a random function name and its description. However, nothing is returned. Time to refactor the code. Improving the code \u03bb\ufe0e The tests pass, however, no output is shown when the application is run. The main function returns a string but nothing is sent to standard out, so running the application does not return anything. The str expression could be wrapped in a println, although that would make the result harder to test and not be very clean code. Refactor the -main to a specific function seems appropriate. Replace the -main-test with a random-function-test that will be used to test a new function of the same name which will be used for retrieving the random Clojure function. ( deftest random-function-test ( testing \"Show random function from Clojure standard library\" ( is ( seq SUT/standard-library-functions )) ( is ( string? ( SUT/random-function SUT/standard-library-functions ))))) Create a new function to return a random function from a given collection of functions, essentially moving the code from -main . The function extracts the function :name and :doc from the metadata of the randomly chosen function. ( defn random-function [ function-list ] ( let [ function-details ( meta ( rand-nth function-list ))] ( str ( function-details :name ) \"\\n \" ( function-details :doc ) \"\\n \" ))) Update the main function to call this new function. ( defn -main \"Return a function name from the Clojure Standard library\" [ & args ] ( println ( random-function standard-library-functions ))) Run the tests again. If the tests pass, then run the application again clojure -M -m practicalli.random-clojure-function A random function and its description are displayed. Adding the function signature \u03bb\ufe0e Edit the random-function code and add the function signature to the string returned by the application. Format the code so it is in the same structure of the output it produces, making the code clearer to understand. ( defn random-function [ function-list ] ( let [ function-details ( meta ( rand-nth function-list ))] ( str ( function-details :name ) \"\\n \" ( function-details :doc ) \"\\n \" ( function-details :arglists )))) Add more namespaces \u03bb\ufe0e All current namespaces on the classpath can be retrieved using the all-ns function. This returns a lazy-seq, (type (all-ns)) ( all-ns ) Using the list of namespace the ns-publics can retrieve all functions across all namespaces. Create a helper function to get the functions from a namespace, as this is going to be used in several places. ( defn function-list [ namespace ] ( vals ( ns-publics namespace ))) This function can be mapped over all the namespaces to get a sequence of all function vars. Using map creates a sequence for each namespace, returned as a sequence of sequences. Using mapcat will concatenate the nested sequences and return a flat sequence of function vars. ( mapcat # ( vals ( ns-publics % )) ( all-ns )) Bind the results of this expression to the name all-public-functions . ( def available-namespaces ( mapcat # ( vals ( ns-publics % )) ( all-ns ))) Control which namespaces are consulted \u03bb\ufe0e There is no way to control which library we get the functions from, limiting the ability of our application. Refactor the main namespace to act differently based on arguments passed: If no arguments are passed then all public functions are used to pull a random function from. If any argument is passed, the argument should be used as the namespace to pull a random function from. The argument is assumed to be a string. ns-publics function needs a namespace as a symbol, so the symbol function is used to convert the argument. ( symbol \"clojure.string\" ) The -main function uses [& args] as a means to take multiple arguments. All arguments are put into a vector, so the symbol function should be mapped over the elements in the vector to create symbols for all the namespaces. Use an anonymous function to convert the arguments to symbols and retrieve the list of public functions from each namespace. This saves mapping over the arguments twice. mapcat the function-list function over all the namespaces, converting each namespace to a symbol. ( mapcat # ( function-list ( symbol % )) args ) Update the main function with an if statement. Use seq as the condition to test if a sequence (the argument vector) has any elements (namespaces to use). If there are arguments, then get the functions for the specific namespaces. Else return all the functions from all the namespaces. ( defn -main \"Return a function name from the Clojure Standard library\" [ & args ] ( if ( seq args ) ( println ( random-function ( mapcat # ( function-list ( symbol % )) args ))) ( println ( random-function standard-library-functions )))) Use the fully qualified name for the namespace \u03bb\ufe0e Now that functions can come from a range of namespaces, the fully qualified namespace should be used for the function, eg. domain/namespace ( :ns ( meta ( rand-nth standard-library-functions ))) Update the random function to return the domain part of the namespace, separated by a / ( defn random-function [ function-list ] ( let [ function-details ( meta ( rand-nth function-list ))] ( str ( function-details :ns ) \"/\" ( function-details :name ) \"\\n \" ( function-details :arglists ) \"\\n \" ( function-details :doc )))) Use all available namespaces by default \u03bb\ufe0e Define a name to represent the collection of all available namespaces, in the context of the running REPL. ( def all-public-functions \"Fully qualified function names from available\" ( mapcat # ( vals ( ns-publics % )) ( all-ns ))) Update the -main function to use all available namespaces if no arguments are passed to the main function. ( defn -main \"Return a random function and its details from the available namespaces\" [ & args ] ( if ( seq args ) ( println ( random-function ( mapcat # ( function-list ( symbol % )) args ))) ( println ( random-function all-public-functions )))) Follow-on idea: Convert to a web service \u03bb\ufe0e Add http-kit server and send information back as a plain text, html, json and edn Follow-on idea: Convert to a library \u03bb\ufe0e Convert the project to a library so this feature can be used as a development tool for any project. Add functionality to list all functions from all namespaces or a specific namespace, or functions from all namespaces of a particular domain, e.g practicalli or practicalli.app","title":"Random Function"},{"location":"simple-projects/random-clojure-function/#random-clojure-function","text":"A simple application that returns a random function from the clojure.core namespace, along with the function argument list and its description (from the doc-string) There are 659 functions in clojure.core namespace and 955 in the standard library (as of June 2020). These functions are learned over time as experience is gained with Clojure.","title":"Random Clojure Function"},{"location":"simple-projects/random-clojure-function/#live-coding-video-walk-through","text":"A Live coding video walk-through of this project shows how this application was developed, using Spacemacs editor and CircleCI for continuous integration. {% youtube %} https://youtu.be/sXZKrD4cAFk","title":"Live Coding Video walk-through"},{"location":"simple-projects/random-clojure-function/#hintuse-m-flag-instead-of-a","text":"The -M flag has replaced the -A flag for including aliases when running Clojure main, which is the approach that the cider jack-in command uses.","title":"Hint::Use -M flag instead of -A"},{"location":"simple-projects/random-clojure-function/#create-a-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/random-clojure-function This project has a deps.edn file that includes the aliases - :test - includes the test/ directory in the class path so unit test code is found - :runner to run the Cognitect Labs test runner which will find and run all unit tests","title":"Create a project"},{"location":"simple-projects/random-clojure-function/#repl-experiments","text":"Start a repl and experiment or open src/practicalli/random-clojure-function.clj in a Clojure-aware editor Get a list of all the functions in the clojure.core namespace, preferably just the public functions. ns-publics returns a map of the function details from the clojure.core namespace ( ns-publics 'clojure.core ) The hash-map keys are function symbols and the values are the function vars { + ' # 'clojure.core/+ ' , decimal? # 'clojure.core/decimal? , sort-by # 'clojure.core/sort-by , macroexpand # 'clojure.core/macroexpand ,,, } The meta function will return a hash-map of details about a function, when given a function var. ( meta # 'map ) The hash-map has several useful pieces of information for the application, including :name , :doc , and :arglists ;; => {:added \"1.0\", ;; :ns #namespace[clojure.core], ;; :name map, ;; :file \"clojure/core.clj\", ;; :static true, ;; :column 1, ;; :line 2727, ;; :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), ;; :doc ;; \"Returns a lazy sequence consisting of the result of applying f to\\n the set of first items of each coll, followed by applying f to the\\n set of second items in each coll, until any one of the colls is\\n exhausted. Any remaining items in other colls are ignored. Function\\n f should accept number-of-colls arguments. Returns a transducer when\\n no collection is provided.\"} To use the meta function, the values from the ns-publics results should be used. ( vals ( ns-publics 'clojure.core )) rand-nth will return a random function var from the sequence of function vars ( rand-nth ( vals ( ns-publics 'clojure.core ))) A single function var is returned, so then the specific meta data can be returned. ( meta ( rand-nth ( vals ( ns-publics 'clojure.core ))))","title":"REPL experiments"},{"location":"simple-projects/random-clojure-function/#define-a-name-for-all-functions","text":"Edit the src/practicalli/random-clojure-function.clj file and define a name for the collection of all public functions from clojure.core ( def standard-library-functions \"Fully qualified function names from clojure.core\" ( vals ( ns-publics 'clojure.core )))","title":"Define a name for all functions"},{"location":"simple-projects/random-clojure-function/#write-unit-tests","text":"From the REPL experiments we have a basic approach for the application design, so codify that design by writing unit tests. This will also highlight regressions during the course of development. Edit the file test/practicalli/random_clojure_core_function_test.clj and add unit tests. The first test check th standard-library-functions contains entries. The second test checks the -main function returns a string (the function name and details). ( ns practicalli.random-clojure-core-function-test ( :require [ clojure.test :refer [ deftest is testing ]] [ practicalli.random-clojure-core-function :as SUT ])) ( deftest -main-test ( testing \"Show random function from Clojure standard library\" ( is ( seq SUT/standard-library-functions )) ( is ( string? ( SUT/-main )))))","title":"Write Unit Tests"},{"location":"simple-projects/random-clojure-function/#update-the-main-function","text":"Edit the src/practicalli/random-clojure-function.clj file. Change the -main function to return a string of the function name and description. ( defn -main \"Return a function name from the Clojure Standard library\" [ & args ] ( let [ function-details ( meta ( rand-nth standard-library-functions ))] ( str ( function-details :name ) \"\\n \" ( function-details :doc ))) ) Run the tests with the Cognitect Labs test runner from the aliases in the project clojure -M:test:runner The tests should pass.","title":"Update the main function"},{"location":"simple-projects/random-clojure-function/#running-the-application","text":"Use the clojure command with the main namespace of the application. Clojure will look for the -main function and evaluate it. clojure -M -m practicalli.random-clojure-function This should return a random function name and its description. However, nothing is returned. Time to refactor the code.","title":"Running the application"},{"location":"simple-projects/random-clojure-function/#improving-the-code","text":"The tests pass, however, no output is shown when the application is run. The main function returns a string but nothing is sent to standard out, so running the application does not return anything. The str expression could be wrapped in a println, although that would make the result harder to test and not be very clean code. Refactor the -main to a specific function seems appropriate. Replace the -main-test with a random-function-test that will be used to test a new function of the same name which will be used for retrieving the random Clojure function. ( deftest random-function-test ( testing \"Show random function from Clojure standard library\" ( is ( seq SUT/standard-library-functions )) ( is ( string? ( SUT/random-function SUT/standard-library-functions ))))) Create a new function to return a random function from a given collection of functions, essentially moving the code from -main . The function extracts the function :name and :doc from the metadata of the randomly chosen function. ( defn random-function [ function-list ] ( let [ function-details ( meta ( rand-nth function-list ))] ( str ( function-details :name ) \"\\n \" ( function-details :doc ) \"\\n \" ))) Update the main function to call this new function. ( defn -main \"Return a function name from the Clojure Standard library\" [ & args ] ( println ( random-function standard-library-functions ))) Run the tests again. If the tests pass, then run the application again clojure -M -m practicalli.random-clojure-function A random function and its description are displayed.","title":"Improving the code"},{"location":"simple-projects/random-clojure-function/#adding-the-function-signature","text":"Edit the random-function code and add the function signature to the string returned by the application. Format the code so it is in the same structure of the output it produces, making the code clearer to understand. ( defn random-function [ function-list ] ( let [ function-details ( meta ( rand-nth function-list ))] ( str ( function-details :name ) \"\\n \" ( function-details :doc ) \"\\n \" ( function-details :arglists ))))","title":"Adding the function signature"},{"location":"simple-projects/random-clojure-function/#add-more-namespaces","text":"All current namespaces on the classpath can be retrieved using the all-ns function. This returns a lazy-seq, (type (all-ns)) ( all-ns ) Using the list of namespace the ns-publics can retrieve all functions across all namespaces. Create a helper function to get the functions from a namespace, as this is going to be used in several places. ( defn function-list [ namespace ] ( vals ( ns-publics namespace ))) This function can be mapped over all the namespaces to get a sequence of all function vars. Using map creates a sequence for each namespace, returned as a sequence of sequences. Using mapcat will concatenate the nested sequences and return a flat sequence of function vars. ( mapcat # ( vals ( ns-publics % )) ( all-ns )) Bind the results of this expression to the name all-public-functions . ( def available-namespaces ( mapcat # ( vals ( ns-publics % )) ( all-ns )))","title":"Add more namespaces"},{"location":"simple-projects/random-clojure-function/#control-which-namespaces-are-consulted","text":"There is no way to control which library we get the functions from, limiting the ability of our application. Refactor the main namespace to act differently based on arguments passed: If no arguments are passed then all public functions are used to pull a random function from. If any argument is passed, the argument should be used as the namespace to pull a random function from. The argument is assumed to be a string. ns-publics function needs a namespace as a symbol, so the symbol function is used to convert the argument. ( symbol \"clojure.string\" ) The -main function uses [& args] as a means to take multiple arguments. All arguments are put into a vector, so the symbol function should be mapped over the elements in the vector to create symbols for all the namespaces. Use an anonymous function to convert the arguments to symbols and retrieve the list of public functions from each namespace. This saves mapping over the arguments twice. mapcat the function-list function over all the namespaces, converting each namespace to a symbol. ( mapcat # ( function-list ( symbol % )) args ) Update the main function with an if statement. Use seq as the condition to test if a sequence (the argument vector) has any elements (namespaces to use). If there are arguments, then get the functions for the specific namespaces. Else return all the functions from all the namespaces. ( defn -main \"Return a function name from the Clojure Standard library\" [ & args ] ( if ( seq args ) ( println ( random-function ( mapcat # ( function-list ( symbol % )) args ))) ( println ( random-function standard-library-functions ))))","title":"Control which namespaces are consulted"},{"location":"simple-projects/random-clojure-function/#use-the-fully-qualified-name-for-the-namespace","text":"Now that functions can come from a range of namespaces, the fully qualified namespace should be used for the function, eg. domain/namespace ( :ns ( meta ( rand-nth standard-library-functions ))) Update the random function to return the domain part of the namespace, separated by a / ( defn random-function [ function-list ] ( let [ function-details ( meta ( rand-nth function-list ))] ( str ( function-details :ns ) \"/\" ( function-details :name ) \"\\n \" ( function-details :arglists ) \"\\n \" ( function-details :doc ))))","title":"Use the fully qualified name for the namespace"},{"location":"simple-projects/random-clojure-function/#use-all-available-namespaces-by-default","text":"Define a name to represent the collection of all available namespaces, in the context of the running REPL. ( def all-public-functions \"Fully qualified function names from available\" ( mapcat # ( vals ( ns-publics % )) ( all-ns ))) Update the -main function to use all available namespaces if no arguments are passed to the main function. ( defn -main \"Return a random function and its details from the available namespaces\" [ & args ] ( if ( seq args ) ( println ( random-function ( mapcat # ( function-list ( symbol % )) args ))) ( println ( random-function all-public-functions ))))","title":"Use all available namespaces by default"},{"location":"simple-projects/random-clojure-function/#follow-on-idea-convert-to-a-web-service","text":"Add http-kit server and send information back as a plain text, html, json and edn","title":"Follow-on idea: Convert to a web service"},{"location":"simple-projects/random-clojure-function/#follow-on-idea-convert-to-a-library","text":"Convert the project to a library so this feature can be used as a development tool for any project. Add functionality to list all functions from all namespaces or a specific namespace, or functions from all namespaces of a particular domain, e.g practicalli or practicalli.app","title":"Follow-on idea: Convert to a library"},{"location":"simple-projects/reading-files/","text":"Some Basic Clojure \u03bb\ufe0e In this section we will evaluate some code so you can get familiar with the syntax and basic constructs of Clojure. It will also help ensure that your development environment is working okay. Note Create a project using the Clojure build tool Leiningen to explore some basic Clojure code Run the following command to create a project (you can use a different name to playground if you prefer) lein new playground Note Run a Clojure REPL to have the run-time environment for Clojure lein repl Now you are ready to enter Clojure code...","title":"Some Basic Clojure"},{"location":"simple-projects/reading-files/#some-basic-clojure","text":"In this section we will evaluate some code so you can get familiar with the syntax and basic constructs of Clojure. It will also help ensure that your development environment is working okay. Note Create a project using the Clojure build tool Leiningen to explore some basic Clojure code Run the following command to create a project (you can use a different name to playground if you prefer) lein new playground Note Run a Clojure REPL to have the run-time environment for Clojure lein repl Now you are ready to enter Clojure code...","title":"Some Basic Clojure"},{"location":"simple-projects/reading-project-file/","text":"Reading your Project configuration \u03bb\ufe0e Information about our Clojure project is contained within our project.clj file. We can read in this file and check the project information in that way. The slurp function reads in the contents of a file or content from a web page / URL. Note Read the Clojure project.clj file using the slurp function ( slurp \"project.clj\" ) The output of slurping the project file should similar to the following Note Tidy up the result of the slurp value using the function read-string ( read-string ( slurp \"project.clj\" )) Just the project version \u03bb\ufe0e Really we just want to get the project version, not all the information. As a list is returned from slurp and read-string then we can simply wrap a function around the first two functions to get the value we want The nth function takes the data structure as the first argument and the element number (starting from zero) as the second argument. Note Use the nth function with read-string and slurp to select the element we actually want. ( nth ( read-string ( slurp \"project.clj\" )) 2 )","title":"Reading your Project configuration"},{"location":"simple-projects/reading-project-file/#reading-your-project-configuration","text":"Information about our Clojure project is contained within our project.clj file. We can read in this file and check the project information in that way. The slurp function reads in the contents of a file or content from a web page / URL. Note Read the Clojure project.clj file using the slurp function ( slurp \"project.clj\" ) The output of slurping the project file should similar to the following Note Tidy up the result of the slurp value using the function read-string ( read-string ( slurp \"project.clj\" ))","title":"Reading your Project configuration"},{"location":"simple-projects/reading-project-file/#just-the-project-version","text":"Really we just want to get the project version, not all the information. As a list is returned from slurp and read-string then we can simply wrap a function around the first two functions to get the value we want The nth function takes the data structure as the first argument and the element number (starting from zero) as the second argument. Note Use the nth function with read-string and slurp to select the element we actually want. ( nth ( read-string ( slurp \"project.clj\" )) 2 )","title":"Just the project version"},{"location":"simple-projects/run-the-repl/","text":"Run the REPL \u03bb\ufe0e The REPL (Read, Evaluate, Print Loop) is the runtime environment for Clojure. The REPL evaluates your code and returns a result. You can evaluate a whole project or just a single expression. An expression is Clojure code contained within () . You can also evaluate symbols, numbers, strings, etc. Note From the root of your project directory, run the following command lein repl Check the REPL works with some simple maths. At the REPL prompt, user=> , enter the following code and press the return key ( + 1 2 3 ) The Clojure REPL should return the value 6 Hint The user=> prompt is telling you what namespace the REPL is currently running in, by default this is user . The => are characters representing the prompt, just like you get on the command line. If you need to close the REPL at any point, type (exit)","title":"Run the REPL"},{"location":"simple-projects/run-the-repl/#run-the-repl","text":"The REPL (Read, Evaluate, Print Loop) is the runtime environment for Clojure. The REPL evaluates your code and returns a result. You can evaluate a whole project or just a single expression. An expression is Clojure code contained within () . You can also evaluate symbols, numbers, strings, etc. Note From the root of your project directory, run the following command lein repl Check the REPL works with some simple maths. At the REPL prompt, user=> , enter the following code and press the return key ( + 1 2 3 ) The Clojure REPL should return the value 6 Hint The user=> prompt is telling you what namespace the REPL is currently running in, by default this is user . The => are characters representing the prompt, just like you get on the command line. If you need to close the REPL at any point, type (exit)","title":"Run the REPL"},{"location":"simple-projects/salary-calculator/","text":"Small project: Salary Calculator \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e This project will create a simple salary calculator that has the following features: Given an annual salary, show the hourly, daily weekly, monthly value Given an hourly rate, show the approximate permanent salary its equivalent to Create a new Clojure project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/salary-calculator Complete project also in Git \u03bb\ufe0e If you prefer not to type in all the code, there is a complete project available at the Devoxx-Clojure-Code Github repository . Clone the repository with the command git clone https://github.com/jr0cket/devoxx-clojure-code.git Each section is committed to a seperate branch so you can see the project incrementally unfold. Branches can be listed with the command git branch and you switch to a branch using the command git checkout name-of-branch . If you wish to merge a branch into master, checkout the master branch and use the command git merge name-of-branch","title":"Small project: Salary Calculator"},{"location":"simple-projects/salary-calculator/#small-project-salary-calculator","text":"","title":"Small project: Salary Calculator"},{"location":"simple-projects/salary-calculator/#todowork-in-progress-sorry","text":"This project will create a simple salary calculator that has the following features: Given an annual salary, show the hourly, daily weekly, monthly value Given an hourly rate, show the approximate permanent salary its equivalent to","title":"TODO::work in progress, sorry"},{"location":"simple-projects/salary-calculator/#create-a-new-clojure-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/salary-calculator","title":"Create a new Clojure project"},{"location":"simple-projects/salary-calculator/#complete-project-also-in-git","text":"If you prefer not to type in all the code, there is a complete project available at the Devoxx-Clojure-Code Github repository . Clone the repository with the command git clone https://github.com/jr0cket/devoxx-clojure-code.git Each section is committed to a seperate branch so you can see the project incrementally unfold. Branches can be listed with the command git branch and you switch to a branch using the command git checkout name-of-branch . If you wish to merge a branch into master, checkout the master branch and use the command git merge name-of-branch","title":"Complete project also in Git"},{"location":"simple-projects/split-the-bill/","text":"Split the bill \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e You are at a restaurant with a group of friends and relatives, having a reunion dinner after a year of not seeing each other. Once the meal comes to an end, its time to pay the bill. So how would you write code to split the bill? Start with the simplest possible approach, with everyone paying the same. Create a new Clojure project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/split-the-bill (str \"Create code to calculate the bill, including what each person should pay\") Tke a look at the Who am I section for ideas on how to model the bill. Also look at More Than Average for ideas on how to write code to work out how to pay the bill. Paying what was ordered \u03bb\ufe0e As not everyone had eaten the same amount of food or arrived at the same time, then there was an ask for everyone to pay just what they ordered. So create a collection to capture what each person ordered and create an itemised bill so each person knows what they should pay. Define a detailed bill based on what each person ordered, then create an itemised bill based on each persons order Now it was realised that what everyone ordered is not what everyone ate. So now we need to take the order and create an itemised bill based on what everyone actually ate (lets suspend believe here a little and assume everyone knows exactly what they ate, and is honest about it). Define a detailed bill based on what each person ordered, then create an itemised bill based on each person actually ate Spliting the bill with a Social Group \u03bb\ufe0e Extend the exercise by splitting bills over multiple events and activities with multiple people.","title":"Split the bill"},{"location":"simple-projects/split-the-bill/#split-the-bill","text":"","title":"Split the bill"},{"location":"simple-projects/split-the-bill/#todowork-in-progress-sorry","text":"You are at a restaurant with a group of friends and relatives, having a reunion dinner after a year of not seeing each other. Once the meal comes to an end, its time to pay the bill. So how would you write code to split the bill? Start with the simplest possible approach, with everyone paying the same.","title":"TODO::work in progress, sorry"},{"location":"simple-projects/split-the-bill/#create-a-new-clojure-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/split-the-bill (str \"Create code to calculate the bill, including what each person should pay\") Tke a look at the Who am I section for ideas on how to model the bill. Also look at More Than Average for ideas on how to write code to work out how to pay the bill.","title":"Create a new Clojure project"},{"location":"simple-projects/split-the-bill/#paying-what-was-ordered","text":"As not everyone had eaten the same amount of food or arrived at the same time, then there was an ask for everyone to pay just what they ordered. So create a collection to capture what each person ordered and create an itemised bill so each person knows what they should pay. Define a detailed bill based on what each person ordered, then create an itemised bill based on each persons order Now it was realised that what everyone ordered is not what everyone ate. So now we need to take the order and create an itemised bill based on what everyone actually ate (lets suspend believe here a little and assume everyone knows exactly what they ate, and is honest about it). Define a detailed bill based on what each person ordered, then create an itemised bill based on each person actually ate","title":"Paying what was ordered"},{"location":"simple-projects/split-the-bill/#spliting-the-bill-with-a-social-group","text":"Extend the exercise by splitting bills over multiple events and activities with multiple people.","title":"Spliting the bill with a Social Group"},{"location":"simple-projects/tripple-lock/","text":"Triple Lock \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e You have just bought a new safe too keep all the richest you will gain from becoming a Clojure developer (hopefully). The safe has a 3 combination lock to protect your new found wealth, but just how safe is the safe? Create a new Clojure project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/triple-lock Designing the combination lock \u03bb\ufe0e Lets consider how we would create such a combination lock in Clojure. The combination is managed by three tumbler wheels Each tumbler wheel has the same range of numbers on then, 0 to 9 Each tumbler wheel could have all the numbers it contains within a Collection in Clojure. The simplest approach would be to put the numbers 0 to 9 into a Vector (an array-like collection). [0 1 2 3 4 5 6 7 8 9] As the numbers on the tumbler wheel are just a range between 0 and 9, then rather than type out all the numbers we can use the range function to generate all the numbers for us. When we give the range function one argument, it will create all the whole numbers from 0 to the number before that of the argument. In the following example, we give range the argument of 10 and we receive the numbers from 0 to 9. (range 10) You can also give range two arguments, such as '(range 5 15)'. Be careful not to call the range function by itself, or it will try and generate an infinite range of numbers (until your computer memory is all used up). Create all the Combinations \u03bb\ufe0e Complete the following code (replacing the ,,,) to generate all the possible combinations of the lock (for [tumbler-1 (range 10) ,,, ,,, ,,, ,,,] [tumbler-1 ,,, ,,,]) Instead of showing all the possible combinations, count all the combinations and return the total number of combinations Take the code from the combinations and wrap it in the count function ;; now count the possible combinations (count ) To make our lock harder to break into, we should only allow the combinations where each tumbler wheel has a different number. So you cannot have combinations like 1-1-1, 1-2-2, 1-2-1, etc. How many combinations does that give us? Complete the following code to create a 3-tumbler wheel combination lock, where none of the numbers are the same Hint: Beware not to enter (range) without an argument as Clojure may try and evaluate infinity (count (for [tumbler-1 (range 10) ,,, ,,, ,,, ,,, :when (or (= tumbler-1 tumbler-2) ,,, ,,,)] [tumbler-1 ,,, ,,,])) Here is a suggested example of the completed 3-lock challenges.","title":"Tripple lock"},{"location":"simple-projects/tripple-lock/#triple-lock","text":"","title":"Triple Lock"},{"location":"simple-projects/tripple-lock/#todowork-in-progress-sorry","text":"You have just bought a new safe too keep all the richest you will gain from becoming a Clojure developer (hopefully). The safe has a 3 combination lock to protect your new found wealth, but just how safe is the safe?","title":"TODO::work in progress, sorry"},{"location":"simple-projects/tripple-lock/#create-a-new-clojure-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/triple-lock","title":"Create a new Clojure project"},{"location":"simple-projects/tripple-lock/#designing-the-combination-lock","text":"Lets consider how we would create such a combination lock in Clojure. The combination is managed by three tumbler wheels Each tumbler wheel has the same range of numbers on then, 0 to 9 Each tumbler wheel could have all the numbers it contains within a Collection in Clojure. The simplest approach would be to put the numbers 0 to 9 into a Vector (an array-like collection). [0 1 2 3 4 5 6 7 8 9] As the numbers on the tumbler wheel are just a range between 0 and 9, then rather than type out all the numbers we can use the range function to generate all the numbers for us. When we give the range function one argument, it will create all the whole numbers from 0 to the number before that of the argument. In the following example, we give range the argument of 10 and we receive the numbers from 0 to 9. (range 10) You can also give range two arguments, such as '(range 5 15)'. Be careful not to call the range function by itself, or it will try and generate an infinite range of numbers (until your computer memory is all used up).","title":"Designing the combination lock"},{"location":"simple-projects/tripple-lock/#create-all-the-combinations","text":"Complete the following code (replacing the ,,,) to generate all the possible combinations of the lock (for [tumbler-1 (range 10) ,,, ,,, ,,, ,,,] [tumbler-1 ,,, ,,,]) Instead of showing all the possible combinations, count all the combinations and return the total number of combinations Take the code from the combinations and wrap it in the count function ;; now count the possible combinations (count ) To make our lock harder to break into, we should only allow the combinations where each tumbler wheel has a different number. So you cannot have combinations like 1-1-1, 1-2-2, 1-2-1, etc. How many combinations does that give us? Complete the following code to create a 3-tumbler wheel combination lock, where none of the numbers are the same Hint: Beware not to enter (range) without an argument as Clojure may try and evaluate infinity (count (for [tumbler-1 (range 10) ,,, ,,, ,,, ,,, :when (or (= tumbler-1 tumbler-2) ,,, ,,,)] [tumbler-1 ,,, ,,,])) Here is a suggested example of the completed 3-lock challenges.","title":"Create all the Combinations"},{"location":"simple-projects/data-transformation/","text":"Data Transformation \u03bb\ufe0e In a sense all Clojure project are about data transformation, however, these projects will introduce you to many techniques used to transform larger and larger data sets. Project Topics Overview Most common word regex filter re-seq sort-by Find the most common word in a give book that is not a common English word","title":"Data Transformation"},{"location":"simple-projects/data-transformation/#data-transformation","text":"In a sense all Clojure project are about data transformation, however, these projects will introduce you to many techniques used to transform larger and larger data sets. Project Topics Overview Most common word regex filter re-seq sort-by Find the most common word in a give book that is not a common English word","title":"Data Transformation"},{"location":"simple-projects/data-transformation/most-common-word/","text":"Most common word \u03bb\ufe0e In this challenge we would like you to find the most used word in a book. The word should not be part of the common English words (i.e. the, a, i, is). This functionality is useful for generating word maps or identifying patterns across data sets. Copyright free books for use are available via Project Guttenburg, e.g. \u201cThe Importance of Being Earnest\u201d by Oscar Wilde . Suggested approach \u03bb\ufe0e A suggested approach to find the most common word: Pull the content of the book into a collection Use a regular expression to create a collection of individual words - eg. #\u201d[a-zA-Z0-9|\u2019]+\u201d Remove the common English words used in the book Convert all the words to lower case so they match with common words source Count the occurrences of the remaining words (eg. each word is associated with the number of times it appears in the book) Sort the words by the number of the occurrences Reverse the collection so the most commonly used word is shown first Create a project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/common-words Get the book contents \u03bb\ufe0e clojure.core/slurp will read in a local file or a remote resource (file, web page, etc) and return a single string of the contents. ( slurp \"https://www.gutenberg.org/files/844/844-0.txt\" ) Wrap the slurp expression in a def to bind a name to the book. ( def being-earnest ( slurp \"https://www.gutenberg.org/files/844/844-0.txt\" )) Project Gutenberg now compresses the books with GZip, so a stream can be created to read the file and decompress it. Then slurp is used to read in the uncompressed text of the book into a string. ( def being-earnest ( with-open [ uncompress-text ( java.util.zip.GZIPInputStream. ( clojure.java.io/input-stream \"https://www.gutenberg.org/cache/epub/844/pg844.txt\" ))] ( slurp uncompress-text ))) ``` ## Individual words from the book The book contents should be broken down into individual words. A regular expression can be used to identify word boundaries , especially where there are apostrophes and other characters. ` clojure.core/re-seq ` returns a new lazy sequence containing the successive matches of a pattern from a given string. So given a sentence Using ` re-seq ` to convert the first sentence of the ` being-earnest ` book using a regex word boundary pattern , ` \\w + ` . ``` clojure ( re-seq # \"\\w+\" \"Morning-room in Algernon's flat in Half-Moon Street.\" ) ;; => (\"Morning\" \"room\" \"in\" \"Algernon\" \"s\" \"flat\" \"in\" \"Half\" \"Moon\" \"Street\") The result is a sequence of the individual words, however, the hyphenated words and the apostrophes have been split into separate words. Extending the regex pattern the results can be refined. ( re-seq # \"[\\w|'-]+\" \"Morning-room in Algernon's flat in Half-Moon Street.\" ) ;; => (\"Morning-room in Algernon's flat in Half-Moon Street\") ( re-seq # \"[\\w|'-]+\" being-earnest ) The #\"[\\w|'-]+\" is the same pattern as the more explicit pattern #\"[a-zA-Z0-9|'-]+\" Removing common English words \u03bb\ufe0e In any book the most common word its highly likely to be a common English word (the, a, and, etc.). To make the most common word in any book more specific, the common English words should be removed. common-english-words.csv contains comma separate words. Using slurp and a regular expression the individual words can be extracted into a collection. Rather than re-seq the clojure.string/split can be used. This is a more specific function for splitting a string using a regular expression pattern, in this case the pattern for a comma, #\",\" . ( clojure.string/split ( slurp \"common-english-words.csv\" ) # \",\" ) An additional step is to place the common English words into a Clojure set, a data structure which contains a unique set of values. ( set ( clojure.string/split ( slurp \"common-english-words.csv\" ) # \",\" )) The advantage of using a set for the common English words is that the data structure can be used as a predicate to remove matching words. So a common English words set can be used to remove the common English words from being-earnest book. Define a name for the common English words set. ( def common-english-words ( set ( clojure.string/split ( slurp \"common-english-words.csv\" ) # \",\" ))) This can also be written using the threading macro, to show the sequential nature of the data transformation. ( def common-english-words ( -> ( slurp \"common-english-words.csv\" ) ( clojure.string/split # \",\" ) set )) The common-english-words set can now be used with the being-earnest book. ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest )) Counting Occurrences \u03bb\ufe0e clojure.core/frequencies takes a collection and returns a map where the keys are the unique elements from the collection and the value for each key is the number of times that element occurred in the collection. ( filter ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest ))) The resulting hash-map is not in any order. clojure.core/sort-by will return the same results but sorted by a given function. To sort a hash-map the key and val functions are function that will sort by key and value respectively. As it is the value that has the number of occurrences, then val is the function to use. ( sort-by val ( filter ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest )))) The result is sorted from smallest to largest value. The result could be reversed using clojure.core/reverse or by supplying an extra function to the sort-by expression. Using greater-than, > the result will be returned in descending order. ( sort-by val dec ( filter ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest )))) Assembling the most-common-word function \u03bb\ufe0e Define a function called most-common-word that assembles all the previous steps. The function should take all the values it needs for the calculation as arguments, creating a pure function without side effects. ( defn most-common-word [ book common-words ] ( sort-by val > ( frequencies ( remove common-words ( map # ( clojure.string/lower-case % ) ( re-seq # \"[\\w|'-]+\" book )))))) This may seem a little hard to parse, so the function definition can be re-written using a threading macro. ( defn most-common-word [ book common-words ] ( ->> book ( re-seq # \"[\\w|'-]+\" ,,, ) ( map # ( clojure.string/lower-case % )) ( remove common-words ) frequencies ( sort-by val > ))) Call this function with the being-earnest book and the common-english-words ( most-common-word being-earnest common-english-words ) Running from the command line \u03bb\ufe0e Update the code to take the book reference from the command line. Remove the def that hard-coded the being-earnest book. In the most-common-word wrap the book with slurp to read the book reference in and convert it to a string, to be processed by the rest of the expressions. Add a -main function that takes a reference for the source of the book and the source of the common words. ( ns practicalli.common-word ) ( defn decode-book [ book-gzip ] ( with-open [ uncompress-text ( java.util.zip.GZIPInputStream. ( clojure.java.io/input-stream book-gzip ))] ( slurp uncompress-text ))) ( defn common-words [ csv ] ( -> ( slurp csv ) ( clojure.string/split # \",\" ) set )) ( defn most-common-word [ book-gzip common-words ] ( ->> ( decode book-gzip ) ( re-seq # \"[\\w|'-]+\" ) ( map # ( clojure.string/lower-case % )) ( remove common-words ) frequencies ( sort-by val > ))) ( defn -main [ book-gzip common-word-csv ] ( most-common-word book-gzip ( common-words common-word-csv ))) Now call the code on the command line. clojure -m practicalli.common-word \"https://www.gutenberg.org/cache/epub/844/pg844.txt\" \"common-english-words.csv\"","title":"Most common word"},{"location":"simple-projects/data-transformation/most-common-word/#most-common-word","text":"In this challenge we would like you to find the most used word in a book. The word should not be part of the common English words (i.e. the, a, i, is). This functionality is useful for generating word maps or identifying patterns across data sets. Copyright free books for use are available via Project Guttenburg, e.g. \u201cThe Importance of Being Earnest\u201d by Oscar Wilde .","title":"Most common word"},{"location":"simple-projects/data-transformation/most-common-word/#suggested-approach","text":"A suggested approach to find the most common word: Pull the content of the book into a collection Use a regular expression to create a collection of individual words - eg. #\u201d[a-zA-Z0-9|\u2019]+\u201d Remove the common English words used in the book Convert all the words to lower case so they match with common words source Count the occurrences of the remaining words (eg. each word is associated with the number of times it appears in the book) Sort the words by the number of the occurrences Reverse the collection so the most commonly used word is shown first","title":"Suggested approach"},{"location":"simple-projects/data-transformation/most-common-word/#create-a-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/common-words","title":"Create a project"},{"location":"simple-projects/data-transformation/most-common-word/#get-the-book-contents","text":"clojure.core/slurp will read in a local file or a remote resource (file, web page, etc) and return a single string of the contents. ( slurp \"https://www.gutenberg.org/files/844/844-0.txt\" ) Wrap the slurp expression in a def to bind a name to the book. ( def being-earnest ( slurp \"https://www.gutenberg.org/files/844/844-0.txt\" )) Project Gutenberg now compresses the books with GZip, so a stream can be created to read the file and decompress it. Then slurp is used to read in the uncompressed text of the book into a string. ( def being-earnest ( with-open [ uncompress-text ( java.util.zip.GZIPInputStream. ( clojure.java.io/input-stream \"https://www.gutenberg.org/cache/epub/844/pg844.txt\" ))] ( slurp uncompress-text ))) ``` ## Individual words from the book The book contents should be broken down into individual words. A regular expression can be used to identify word boundaries , especially where there are apostrophes and other characters. ` clojure.core/re-seq ` returns a new lazy sequence containing the successive matches of a pattern from a given string. So given a sentence Using ` re-seq ` to convert the first sentence of the ` being-earnest ` book using a regex word boundary pattern , ` \\w + ` . ``` clojure ( re-seq # \"\\w+\" \"Morning-room in Algernon's flat in Half-Moon Street.\" ) ;; => (\"Morning\" \"room\" \"in\" \"Algernon\" \"s\" \"flat\" \"in\" \"Half\" \"Moon\" \"Street\") The result is a sequence of the individual words, however, the hyphenated words and the apostrophes have been split into separate words. Extending the regex pattern the results can be refined. ( re-seq # \"[\\w|'-]+\" \"Morning-room in Algernon's flat in Half-Moon Street.\" ) ;; => (\"Morning-room in Algernon's flat in Half-Moon Street\") ( re-seq # \"[\\w|'-]+\" being-earnest ) The #\"[\\w|'-]+\" is the same pattern as the more explicit pattern #\"[a-zA-Z0-9|'-]+\"","title":"Get the book contents"},{"location":"simple-projects/data-transformation/most-common-word/#removing-common-english-words","text":"In any book the most common word its highly likely to be a common English word (the, a, and, etc.). To make the most common word in any book more specific, the common English words should be removed. common-english-words.csv contains comma separate words. Using slurp and a regular expression the individual words can be extracted into a collection. Rather than re-seq the clojure.string/split can be used. This is a more specific function for splitting a string using a regular expression pattern, in this case the pattern for a comma, #\",\" . ( clojure.string/split ( slurp \"common-english-words.csv\" ) # \",\" ) An additional step is to place the common English words into a Clojure set, a data structure which contains a unique set of values. ( set ( clojure.string/split ( slurp \"common-english-words.csv\" ) # \",\" )) The advantage of using a set for the common English words is that the data structure can be used as a predicate to remove matching words. So a common English words set can be used to remove the common English words from being-earnest book. Define a name for the common English words set. ( def common-english-words ( set ( clojure.string/split ( slurp \"common-english-words.csv\" ) # \",\" ))) This can also be written using the threading macro, to show the sequential nature of the data transformation. ( def common-english-words ( -> ( slurp \"common-english-words.csv\" ) ( clojure.string/split # \",\" ) set )) The common-english-words set can now be used with the being-earnest book. ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest ))","title":"Removing common English words"},{"location":"simple-projects/data-transformation/most-common-word/#counting-occurrences","text":"clojure.core/frequencies takes a collection and returns a map where the keys are the unique elements from the collection and the value for each key is the number of times that element occurred in the collection. ( filter ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest ))) The resulting hash-map is not in any order. clojure.core/sort-by will return the same results but sorted by a given function. To sort a hash-map the key and val functions are function that will sort by key and value respectively. As it is the value that has the number of occurrences, then val is the function to use. ( sort-by val ( filter ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest )))) The result is sorted from smallest to largest value. The result could be reversed using clojure.core/reverse or by supplying an extra function to the sort-by expression. Using greater-than, > the result will be returned in descending order. ( sort-by val dec ( filter ( remove common-english-words ( re-seq # \"[\\w|'-]+\" being-earnest ))))","title":"Counting Occurrences"},{"location":"simple-projects/data-transformation/most-common-word/#assembling-the-most-common-word-function","text":"Define a function called most-common-word that assembles all the previous steps. The function should take all the values it needs for the calculation as arguments, creating a pure function without side effects. ( defn most-common-word [ book common-words ] ( sort-by val > ( frequencies ( remove common-words ( map # ( clojure.string/lower-case % ) ( re-seq # \"[\\w|'-]+\" book )))))) This may seem a little hard to parse, so the function definition can be re-written using a threading macro. ( defn most-common-word [ book common-words ] ( ->> book ( re-seq # \"[\\w|'-]+\" ,,, ) ( map # ( clojure.string/lower-case % )) ( remove common-words ) frequencies ( sort-by val > ))) Call this function with the being-earnest book and the common-english-words ( most-common-word being-earnest common-english-words )","title":"Assembling the most-common-word function"},{"location":"simple-projects/data-transformation/most-common-word/#running-from-the-command-line","text":"Update the code to take the book reference from the command line. Remove the def that hard-coded the being-earnest book. In the most-common-word wrap the book with slurp to read the book reference in and convert it to a string, to be processed by the rest of the expressions. Add a -main function that takes a reference for the source of the book and the source of the common words. ( ns practicalli.common-word ) ( defn decode-book [ book-gzip ] ( with-open [ uncompress-text ( java.util.zip.GZIPInputStream. ( clojure.java.io/input-stream book-gzip ))] ( slurp uncompress-text ))) ( defn common-words [ csv ] ( -> ( slurp csv ) ( clojure.string/split # \",\" ) set )) ( defn most-common-word [ book-gzip common-words ] ( ->> ( decode book-gzip ) ( re-seq # \"[\\w|'-]+\" ) ( map # ( clojure.string/lower-case % )) ( remove common-words ) frequencies ( sort-by val > ))) ( defn -main [ book-gzip common-word-csv ] ( most-common-word book-gzip ( common-words common-word-csv ))) Now call the code on the command line. clojure -m practicalli.common-word \"https://www.gutenberg.org/cache/epub/844/pg844.txt\" \"common-english-words.csv\"","title":"Running from the command line"},{"location":"simple-projects/encode-decode/","text":"Encoding and Decoding with Clojure \u03bb\ufe0e Projects that use a range of ciphers, from simple to more complex, to encode and decode text. A common approach to encoding and decoding text is to use a dictionary lookup, defined in Clojure as a hash-map. Each key-value pair provides a mapping for encoding and decoding. Looking up a a character as a key in the map provides a value that is the encrypted character. These projects show several ways to transform data in Clojure. Project Topics Description Boolean names to 0 or 1 hash-map get Convert boolean values to classic 1 or 0 values Caesar cipher - ROT13 seq cycle zipmap A simple alphabet rotation cipher RNA / DNA converter Convert between DNA and RNA Clacks telegram Encoding and decoding messages with Clacks Examples of Encoding \u03bb\ufe0e Portable Network Graphics for image compression Vorbis for music and video compression plus several commercial compression encoders Enigma machine - encrypted communications","title":"Encoding and Decoding with Clojure"},{"location":"simple-projects/encode-decode/#encoding-and-decoding-with-clojure","text":"Projects that use a range of ciphers, from simple to more complex, to encode and decode text. A common approach to encoding and decoding text is to use a dictionary lookup, defined in Clojure as a hash-map. Each key-value pair provides a mapping for encoding and decoding. Looking up a a character as a key in the map provides a value that is the encrypted character. These projects show several ways to transform data in Clojure. Project Topics Description Boolean names to 0 or 1 hash-map get Convert boolean values to classic 1 or 0 values Caesar cipher - ROT13 seq cycle zipmap A simple alphabet rotation cipher RNA / DNA converter Convert between DNA and RNA Clacks telegram Encoding and decoding messages with Clacks","title":"Encoding and Decoding with Clojure"},{"location":"simple-projects/encode-decode/#examples-of-encoding","text":"Portable Network Graphics for image compression Vorbis for music and video compression plus several commercial compression encoders Enigma machine - encrypted communications","title":"Examples of Encoding"},{"location":"simple-projects/encode-decode/caesar-cipher-rot13/","text":"Rotate by 13 (ROT13) \u03bb\ufe0e ROT13 is one of the simplest ciphers which uses an alphabet as a circle of characters, swapping each character with a character 13 positions later in the alphabet, assuming 26 character of an English alphabet. A dictionary can be generated to translate between the original alphabet and the rotated alphabet, providing a simple way to generate an encrypted message. Create a project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli.cypher-rot13 Define an alphabet \u03bb\ufe0e Define an alphabet to use as a basis for conversion. Take the string of all characters and convert to a sequence of character types. ( def english-alphabet ( seq \"abcdefghijklmnopqrstuvwxyz\" )) Generate a cypher \u03bb\ufe0e To convert a character, first build up a cypher. A cypher in this case is simply a hash-map that creates a dictionary lookup defining what each character should be changed to. cycle creates a lazy sequence of the alphabet that continually cycles. This provides an 'infinite' sequence from which we will take only the characters needed. (cycle \"abcdefghijklmnopqrstuvwxyz\") The dictionary is composed of the original alphabet and a new alphabet that is offset by 13 characters, half the number of characters in the dictionary. (drop 13 (cycle alphabet)) will drop the first 13 characters. As cycle creates an 'infinite' alphabet, there are still plenty of characters to make a second alphabet. (take 26 (drop 13 (cycle alphabet))) will get a new alphabet of 26 characters, starting from the 14th character, n . zipmap is used to join two collections together to form a hash-map, e.g. the lookup dictionary. In this case the original alphabet and the new alphabet. (zipmap alphabet (take 26 (drop 13 (cycle alphabet)))) This expression is nested and can be harder to parse by those new to Clojure. The code can be written using a threading marco, that demonstrated the flow of data transformation. Using the thread last macro, ->> , the result of each expression becomes the last argument for the next expression. ( ->> ( cycle alphabet ) ( drop 13 ) ( take 26 ) ( zipmap alphabet )) Using the clojure.core/replace function with the cypher hash-map and a string of text returns a converted string of text. Define a function \u03bb\ufe0e Define a rot13 function with the algorithm created. The function takes the alphabet and the text to be encrypted. Passing both pieces of data as arguments ensures that the function is pure, i.e. free from side effects. ( defn rot13 [ alphabet text ] ( let [ cipher ( ->> ( cycle alphabet ) ( drop 13 ) ( take 26 ) ( zipmap alphabet ))] ( apply str ( replace cipher text )))) Call the rot13 function with the english-alphabet and a sentence as a string. ( rot13 english-alphabet \"The Quick Brown Fox Jumped Over The Lazy Dog!\" ) An encrypted copy of the sentence is returned. Idiomatic improvements \u03bb\ufe0e clojure.string library is more idiomatic approach when working with string types. In the practicalli.cypher-rot13 solution apply str was used to join a sequence of characters into a string. clojure.string/join combines a sequence of characters into a string. Require the clojure.string namespace to use the functions contained within. Add the require to the namespace definition of practicalli.cypher-rot13 ( ns practicalli.cypher-rot13 ( :gen-class ) ( :require [ clojure.string :as string ])) Update the rot13 function to use clojure.string/join rather than apply str . ( defn rot13 [ alphabet text ] ( let [ cipher ( ->> ( cycle alphabet ) ( drop 13 ) ( take 26 ) ( zipmap alphabet ))] ( string/join ( replace cipher text ))))","title":"Rotate by 13 (ROT13)"},{"location":"simple-projects/encode-decode/caesar-cipher-rot13/#rotate-by-13-rot13","text":"ROT13 is one of the simplest ciphers which uses an alphabet as a circle of characters, swapping each character with a character 13 positions later in the alphabet, assuming 26 character of an English alphabet. A dictionary can be generated to translate between the original alphabet and the rotated alphabet, providing a simple way to generate an encrypted message.","title":"Rotate by 13 (ROT13)"},{"location":"simple-projects/encode-decode/caesar-cipher-rot13/#create-a-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli.cypher-rot13","title":"Create a project"},{"location":"simple-projects/encode-decode/caesar-cipher-rot13/#define-an-alphabet","text":"Define an alphabet to use as a basis for conversion. Take the string of all characters and convert to a sequence of character types. ( def english-alphabet ( seq \"abcdefghijklmnopqrstuvwxyz\" ))","title":"Define an alphabet"},{"location":"simple-projects/encode-decode/caesar-cipher-rot13/#generate-a-cypher","text":"To convert a character, first build up a cypher. A cypher in this case is simply a hash-map that creates a dictionary lookup defining what each character should be changed to. cycle creates a lazy sequence of the alphabet that continually cycles. This provides an 'infinite' sequence from which we will take only the characters needed. (cycle \"abcdefghijklmnopqrstuvwxyz\") The dictionary is composed of the original alphabet and a new alphabet that is offset by 13 characters, half the number of characters in the dictionary. (drop 13 (cycle alphabet)) will drop the first 13 characters. As cycle creates an 'infinite' alphabet, there are still plenty of characters to make a second alphabet. (take 26 (drop 13 (cycle alphabet))) will get a new alphabet of 26 characters, starting from the 14th character, n . zipmap is used to join two collections together to form a hash-map, e.g. the lookup dictionary. In this case the original alphabet and the new alphabet. (zipmap alphabet (take 26 (drop 13 (cycle alphabet)))) This expression is nested and can be harder to parse by those new to Clojure. The code can be written using a threading marco, that demonstrated the flow of data transformation. Using the thread last macro, ->> , the result of each expression becomes the last argument for the next expression. ( ->> ( cycle alphabet ) ( drop 13 ) ( take 26 ) ( zipmap alphabet )) Using the clojure.core/replace function with the cypher hash-map and a string of text returns a converted string of text.","title":"Generate a cypher"},{"location":"simple-projects/encode-decode/caesar-cipher-rot13/#define-a-function","text":"Define a rot13 function with the algorithm created. The function takes the alphabet and the text to be encrypted. Passing both pieces of data as arguments ensures that the function is pure, i.e. free from side effects. ( defn rot13 [ alphabet text ] ( let [ cipher ( ->> ( cycle alphabet ) ( drop 13 ) ( take 26 ) ( zipmap alphabet ))] ( apply str ( replace cipher text )))) Call the rot13 function with the english-alphabet and a sentence as a string. ( rot13 english-alphabet \"The Quick Brown Fox Jumped Over The Lazy Dog!\" ) An encrypted copy of the sentence is returned.","title":"Define a function"},{"location":"simple-projects/encode-decode/caesar-cipher-rot13/#idiomatic-improvements","text":"clojure.string library is more idiomatic approach when working with string types. In the practicalli.cypher-rot13 solution apply str was used to join a sequence of characters into a string. clojure.string/join combines a sequence of characters into a string. Require the clojure.string namespace to use the functions contained within. Add the require to the namespace definition of practicalli.cypher-rot13 ( ns practicalli.cypher-rot13 ( :gen-class ) ( :require [ clojure.string :as string ])) Update the rot13 function to use clojure.string/join rather than apply str . ( defn rot13 [ alphabet text ] ( let [ cipher ( ->> ( cycle alphabet ) ( drop 13 ) ( take 26 ) ( zipmap alphabet ))] ( string/join ( replace cipher text ))))","title":"Idiomatic improvements"},{"location":"simple-projects/encode-decode/clacks/","text":"The Clacks - encoding and decoding messages \u03bb\ufe0e TODO::Add unit testing \u03bb\ufe0e In the 33rd Discworld novel, Going Postal , messages are sent faster than a speeding horse via the Clacks system. The Clacks system composes of a series of towers spread across a continent with each tower sending a light signal to the next tower using combinations of lights for each character in the message. Each tower sees a grid of lights from a distant tower and sends the message on to the next tower. The Clacks system was introduced in the 24th Discworld novel called \"The Fifth Elephant\". \"Going Postal\" elaborates the full history of the Clacks system. The Challenge \u03bb\ufe0e Create a Clacks encoder that converts any English language message into its corresponding clacks signal, based on the Clacks alphabet as defined by the board game of the same name. The board game defines the alphabet as a 2 by 3 grid (although in the Discworld its actually 8 large squares). Naturally, the interpreter also converts the Clacks signal back into an English message too. Create a project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/clacks-messenger This project has a deps.edn file that includes the aliases - :test - includes the test/ directory in the class path so unit test code is found - :runner to run the Cognitect Labs test runner which will find and run all unit tests Representing a Clack \u03bb\ufe0e For each clack, the light pattern is read from the top of the first column to the bottom, then from the top of the second column to the bottom. A light in a position represents a 1 value and no light represents a 0 value. This gives us our 6 number pattern for each clack in the alphabet. The initial data structure chosen was essentially just modelling each individual clack. Since a clack is a 2x3 structure, the simplest way to represent a clacks is to have a vector that contains 2 vectors, each with three elements. So a simple expression of the letter a in the clacks alphabet would be: [[ 0 1 0 ][ 0 0 1 ]] Therefore we could define a single letter of our alphabet as follows: ( def a [[ 0 1 0 ][ 0 0 1 ]]) Before defining the complete alphabet using this data structure, test this is the right data structure for the conversion process. Testing a simple conversion with our data structure \u03bb\ufe0e Define a function to convert a single character into a clack: ( defn character->clack [ character ] ( if ( = character \"a\" ) a ( str \"Sorry, character is not yet in the alphabet, please create a pull request\" ))) Calling the function converts a string into the corresponding clack ( character->clack \"a\" ) Hint::Clojure function naming \u03bb\ufe0e -> is a naming convention to indicate a function is specifically transforming to a data format. For example, json->clj-map would be a generic function for transforming json to Clojure hash-map The code is simple for a single character, however, would require a lot of redundant code to convert the whole alphabet. We would need either a deeply nested set of if statements or a very long cond function, neither of which seems to be a particularly functional approach or idiomatic Clojure. If a cond statement was used, how would a clacks be converted back into a character? So perhaps we need to change the data structure, one that provides an easy way to map to values together. Also, there seems no value in mapping values to a 2x3 grid as long as we consistently express a clack. Define the alphabet with a hash-map \u03bb\ufe0e A hash map associates each key with a value and are used to create self-describing data. For example a person could be described as a hash-map { :name \"Jenny Jetpack\" :age \"21\" :twitter \"jenjetpack\" } Clojure keywords are often used for the keys because keywords can be used as a function with a map as an argument. This will return the value associated with the keyword in the map. The new design for the clacks data structure associates a keyword of each letter of the alphabet with its corresponding clacks light pattern code { :a [ 0 1 0 0 0 1 ]} Test the design by defining enough letters for the clacks alphabet to convert some simple words, i.e bat ( def alphabet { :a [ 0 1 0 0 0 1 ] :b [ 0 0 1 0 1 0 ] :t [ 1 0 0 1 1 1 ]}) Testing the map design \u03bb\ufe0e Use a keyword to lookup the value of its clack code ( :a alphabet ) ;; => [0 1 0 0 0 1] Create a simple function to convert a single character to its Clacks representation, referred to a clack. ( defn character->clack [ character ] (( keyword character ) alphabet )) The -> character is part of the function name. This is a Clojure naming convention used when the function you are defining converts from one type to another. And call the function as follows ( character->clack \"a\" ) ;; => [0 1 0 0 0 1] Converting a word \u03bb\ufe0e Now we want to convert a whole word to a clacks sequence. It seemed the easiest way to convert a whole word was to convert each letter at a time using the map to look up each clack code, returning all the clacks codes in a sequence. So we redefined the string->clacks function to take in a whole word. We used the map function to apply a conversion function over each element in the word (each element of the string). This conversion function called clacksify . ( defn clacksify [ letter ] ( let [ character ( str letter )] ( alphabet ( keyword character )))) ( defn string->clacks [ word ] ( map clacksify word )) Now we could convert any word that used the letters of our limited alphabet. We chose bat as a simple word. ( string->clacks \"bat\" ) As we are passing a string and not a keyword to the clacksify function, then we first convert the string to a keyword using the keyword function. Converting the clack to a string \u03bb\ufe0e Is there a simple way to look up a key given a value that is unique in the map? All Clack codes are unique in the map, but there did not seem to be a simple expression to find the key when given a value. We could have created a second mapping, however having two maps seemed redundant and a potential cause for silly bugs. The answer was simple once we found it. As the clack codes are unique, they could be used as keys for the letter values, we just needed to swap the map around. Swapping a map's keys and values was done by writing a reverse-map function. ( defn reverse-map \"Reverse the keys and value pairs in a map. Allows the map to be used to convert from a clack to a letter without defining a second map\" [ m ] ( into {} ( map ( fn [[ a b ]] [ b a ]) m ))) So we defined the function declacksify which takes a clack code and returns its corresponding character. The clack code returns the corresponding keyword rather than a character, so we use the name function to convert the keyword into a character name. ( defn declacksify [ clack ] ( name (( reverse-map alphabet ) clack ))) ( defn clacks->string [ clacks ] ( map declacksify clacks )) So calling these functions with a clacks ( declacksify [ 1 0 0 1 1 1 ]) ;; => \"t\" ( clacks->string [[ 0 0 1 0 1 0 ] [ 0 1 0 0 0 1 ] [ 1 0 0 1 1 1 ]]) ;; => (\"b\" \"a\" \"t\") At this point you may be thinking that using keywords to represent the characters of the alphabet may not be the most effective. Using keywords has required more code to be written, adding to the complexity of the solution. Tidying up the output \u03bb\ufe0e clacks->string function returns the right result, but not quite in the format required. Rather than a single string a sequence of characters is returned. Using the map function we can apply the str function over the resulting characters to give a single string. ( defn clacks->string [ clacks ] ( map str ( map declacksify clacks ))) Using clojure.string/join is a more idiomatic approach to converting a sequence of characters to a string ( require ' [ clojure.string :as string ]) ( defn clacks->string [ clacks ] ( string/join ( map declacksify clacks ))) Refactor the dictionary design \u03bb\ufe0e Converting characters to keywords and back again seem redundant when characters themselves can be used as keys in a hash-map. Using keywords is problematic when it comes to the space character as a keyword cannot be a space. Using :- to represent a space required the clacksification and declacksification functions to convert between :- and the space character. This also prevents hyphenated words working in the Clacks system. Refactor the dictionary to use a string for each character as the keys in the map, instead of Clojure keywords. This solves the issue with space and other special characters. ( def dictionary { \"a\" [ 0 1 1 0 0 0 0 1 ] \"b\" [ 0 1 1 0 0 0 1 0 ] \"c\" [ 0 1 1 0 0 0 1 1 ] \"d\" [ 0 1 1 0 0 1 0 0 ] \"e\" [ 0 1 1 0 0 1 0 1 ] ,,, }) Move the dictionary to its own namespace \u03bb\ufe0e As the dictionary can be quite large to represent in code, move the dictionary definition to its own namespace. Use a more specific name for the dictionary, describing what languages the dictionary is used for ( def english->clacks { \"a\" [ 0 1 1 0 0 0 0 1 ] \"b\" [ 0 1 1 0 0 0 1 0 ] \"c\" [ 0 1 1 0 0 0 1 1 ] \"d\" [ 0 1 1 0 0 1 0 0 ] \"e\" [ 0 1 1 0 0 1 0 1 ] ,,, }) A dictionary is required to translate from Clacks to English to decode the messages. Rather than write the reverse mappings for each character in the dictionary, in effect creating a second directory for the same two languages, use a function to invert the map by swapping keys and values. clojure.set/map-invert will swap each key/value pair in the map so the key becomes the value and the value becomes the key. Define a clacks->english dictionary that holds the result of the map-invert function call ( ns practicalli.clacks-dictionary ( :require [ clojure.set ])) ( def clacks->english { ,,, }) ( def clacks->english ( clojure.set/map-invert english->clacks )) Require the dictionary namespace using the alias dictionary to give the dictionary names context when used in the main namespace. Also require clojure.string using the alias string to use the join function. ( ns practicalli.clacks-messenger ( :require [ practicalli.clacks-dictionary :as dictionary ] [ clojure.string :as string ])) Removing side effects \u03bb\ufe0e Designing pure functions, those that receive all their data via arguments, is a common way to remove side effects . Include the dictionary as an argument to each of the functions. This ensures that each function is pure and prevents side effects (side causes). ( defn character->clack [ char dictionary ] ( let [ character ( str char )] ( get dictionary character ))) ( defn message->clacks [ message dictionary ] ( map # ( character->clack % dictionary ) message )) ( defn clack->character [ clack dictionary ] ( get ( clojure.set/map-invert dictionary ) clack )) ( defn clack->character [ clack dictionary ] ( get dictionary-inverted clack )) ;; Create a clacks code back to a message ( defn clacks->message [ clacks dictionary ] ( string/join ( map # ( clack->character % dictionary ) clacks ))) Test the updated functions by calling them via the REPL ( message->clacks \"cab\" dictionary/english->clacks ) ;; => ([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0]) ( message->clacks \"cab cab\" dictionary/english->clacks ) ;; => ([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0] [0 0 0 0 0 0 0 0] [0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0]) ;; Create a character from a clack code ;; test data ( clacks->message ' ([ 0 1 1 0 0 0 1 1 ] [ 0 1 1 0 0 0 0 1 ] [ 0 1 1 0 0 0 1 0 ]) dictionary/english->clacks ) ( clacks->message ' ([ 0 1 1 0 0 0 1 1 ] [ 0 1 1 0 0 0 0 1 ] [ 0 1 1 0 0 0 1 0 ] [ 0 0 0 0 0 0 0 0 ] [ 0 1 1 0 0 0 1 1 ] [ 0 1 1 0 0 0 0 1 ] [ 0 1 1 0 0 0 1 0 ]) dictionary ) Using different dictionaries \u03bb\ufe0e Thanks to a flexible design with no side effects or side causes then its really easy to replace the English language alphabet with another language that can be encoded into Clack codes. All that is required is to define a dictionary for another language. So languages based on the greek, latin or cyrillic alphabet could be send if a suitable alphabet with clack codes is supplied.","title":"The Clacks - encoding and decoding messages"},{"location":"simple-projects/encode-decode/clacks/#the-clacks-encoding-and-decoding-messages","text":"","title":"The Clacks - encoding and decoding messages"},{"location":"simple-projects/encode-decode/clacks/#todoadd-unit-testing","text":"In the 33rd Discworld novel, Going Postal , messages are sent faster than a speeding horse via the Clacks system. The Clacks system composes of a series of towers spread across a continent with each tower sending a light signal to the next tower using combinations of lights for each character in the message. Each tower sees a grid of lights from a distant tower and sends the message on to the next tower. The Clacks system was introduced in the 24th Discworld novel called \"The Fifth Elephant\". \"Going Postal\" elaborates the full history of the Clacks system.","title":"TODO::Add unit testing"},{"location":"simple-projects/encode-decode/clacks/#the-challenge","text":"Create a Clacks encoder that converts any English language message into its corresponding clacks signal, based on the Clacks alphabet as defined by the board game of the same name. The board game defines the alphabet as a 2 by 3 grid (although in the Discworld its actually 8 large squares). Naturally, the interpreter also converts the Clacks signal back into an English message too.","title":"The Challenge"},{"location":"simple-projects/encode-decode/clacks/#create-a-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/clacks-messenger This project has a deps.edn file that includes the aliases - :test - includes the test/ directory in the class path so unit test code is found - :runner to run the Cognitect Labs test runner which will find and run all unit tests","title":"Create a project"},{"location":"simple-projects/encode-decode/clacks/#representing-a-clack","text":"For each clack, the light pattern is read from the top of the first column to the bottom, then from the top of the second column to the bottom. A light in a position represents a 1 value and no light represents a 0 value. This gives us our 6 number pattern for each clack in the alphabet. The initial data structure chosen was essentially just modelling each individual clack. Since a clack is a 2x3 structure, the simplest way to represent a clacks is to have a vector that contains 2 vectors, each with three elements. So a simple expression of the letter a in the clacks alphabet would be: [[ 0 1 0 ][ 0 0 1 ]] Therefore we could define a single letter of our alphabet as follows: ( def a [[ 0 1 0 ][ 0 0 1 ]]) Before defining the complete alphabet using this data structure, test this is the right data structure for the conversion process.","title":"Representing a Clack"},{"location":"simple-projects/encode-decode/clacks/#testing-a-simple-conversion-with-our-data-structure","text":"Define a function to convert a single character into a clack: ( defn character->clack [ character ] ( if ( = character \"a\" ) a ( str \"Sorry, character is not yet in the alphabet, please create a pull request\" ))) Calling the function converts a string into the corresponding clack ( character->clack \"a\" )","title":"Testing a simple conversion with our data structure"},{"location":"simple-projects/encode-decode/clacks/#hintclojure-function-naming","text":"-> is a naming convention to indicate a function is specifically transforming to a data format. For example, json->clj-map would be a generic function for transforming json to Clojure hash-map The code is simple for a single character, however, would require a lot of redundant code to convert the whole alphabet. We would need either a deeply nested set of if statements or a very long cond function, neither of which seems to be a particularly functional approach or idiomatic Clojure. If a cond statement was used, how would a clacks be converted back into a character? So perhaps we need to change the data structure, one that provides an easy way to map to values together. Also, there seems no value in mapping values to a 2x3 grid as long as we consistently express a clack.","title":"Hint::Clojure function naming"},{"location":"simple-projects/encode-decode/clacks/#define-the-alphabet-with-a-hash-map","text":"A hash map associates each key with a value and are used to create self-describing data. For example a person could be described as a hash-map { :name \"Jenny Jetpack\" :age \"21\" :twitter \"jenjetpack\" } Clojure keywords are often used for the keys because keywords can be used as a function with a map as an argument. This will return the value associated with the keyword in the map. The new design for the clacks data structure associates a keyword of each letter of the alphabet with its corresponding clacks light pattern code { :a [ 0 1 0 0 0 1 ]} Test the design by defining enough letters for the clacks alphabet to convert some simple words, i.e bat ( def alphabet { :a [ 0 1 0 0 0 1 ] :b [ 0 0 1 0 1 0 ] :t [ 1 0 0 1 1 1 ]})","title":"Define the alphabet with a hash-map"},{"location":"simple-projects/encode-decode/clacks/#testing-the-map-design","text":"Use a keyword to lookup the value of its clack code ( :a alphabet ) ;; => [0 1 0 0 0 1] Create a simple function to convert a single character to its Clacks representation, referred to a clack. ( defn character->clack [ character ] (( keyword character ) alphabet )) The -> character is part of the function name. This is a Clojure naming convention used when the function you are defining converts from one type to another. And call the function as follows ( character->clack \"a\" ) ;; => [0 1 0 0 0 1]","title":"Testing the map design"},{"location":"simple-projects/encode-decode/clacks/#converting-a-word","text":"Now we want to convert a whole word to a clacks sequence. It seemed the easiest way to convert a whole word was to convert each letter at a time using the map to look up each clack code, returning all the clacks codes in a sequence. So we redefined the string->clacks function to take in a whole word. We used the map function to apply a conversion function over each element in the word (each element of the string). This conversion function called clacksify . ( defn clacksify [ letter ] ( let [ character ( str letter )] ( alphabet ( keyword character )))) ( defn string->clacks [ word ] ( map clacksify word )) Now we could convert any word that used the letters of our limited alphabet. We chose bat as a simple word. ( string->clacks \"bat\" ) As we are passing a string and not a keyword to the clacksify function, then we first convert the string to a keyword using the keyword function.","title":"Converting a word"},{"location":"simple-projects/encode-decode/clacks/#converting-the-clack-to-a-string","text":"Is there a simple way to look up a key given a value that is unique in the map? All Clack codes are unique in the map, but there did not seem to be a simple expression to find the key when given a value. We could have created a second mapping, however having two maps seemed redundant and a potential cause for silly bugs. The answer was simple once we found it. As the clack codes are unique, they could be used as keys for the letter values, we just needed to swap the map around. Swapping a map's keys and values was done by writing a reverse-map function. ( defn reverse-map \"Reverse the keys and value pairs in a map. Allows the map to be used to convert from a clack to a letter without defining a second map\" [ m ] ( into {} ( map ( fn [[ a b ]] [ b a ]) m ))) So we defined the function declacksify which takes a clack code and returns its corresponding character. The clack code returns the corresponding keyword rather than a character, so we use the name function to convert the keyword into a character name. ( defn declacksify [ clack ] ( name (( reverse-map alphabet ) clack ))) ( defn clacks->string [ clacks ] ( map declacksify clacks )) So calling these functions with a clacks ( declacksify [ 1 0 0 1 1 1 ]) ;; => \"t\" ( clacks->string [[ 0 0 1 0 1 0 ] [ 0 1 0 0 0 1 ] [ 1 0 0 1 1 1 ]]) ;; => (\"b\" \"a\" \"t\") At this point you may be thinking that using keywords to represent the characters of the alphabet may not be the most effective. Using keywords has required more code to be written, adding to the complexity of the solution.","title":"Converting the clack to a string"},{"location":"simple-projects/encode-decode/clacks/#tidying-up-the-output","text":"clacks->string function returns the right result, but not quite in the format required. Rather than a single string a sequence of characters is returned. Using the map function we can apply the str function over the resulting characters to give a single string. ( defn clacks->string [ clacks ] ( map str ( map declacksify clacks ))) Using clojure.string/join is a more idiomatic approach to converting a sequence of characters to a string ( require ' [ clojure.string :as string ]) ( defn clacks->string [ clacks ] ( string/join ( map declacksify clacks )))","title":"Tidying up the output"},{"location":"simple-projects/encode-decode/clacks/#refactor-the-dictionary-design","text":"Converting characters to keywords and back again seem redundant when characters themselves can be used as keys in a hash-map. Using keywords is problematic when it comes to the space character as a keyword cannot be a space. Using :- to represent a space required the clacksification and declacksification functions to convert between :- and the space character. This also prevents hyphenated words working in the Clacks system. Refactor the dictionary to use a string for each character as the keys in the map, instead of Clojure keywords. This solves the issue with space and other special characters. ( def dictionary { \"a\" [ 0 1 1 0 0 0 0 1 ] \"b\" [ 0 1 1 0 0 0 1 0 ] \"c\" [ 0 1 1 0 0 0 1 1 ] \"d\" [ 0 1 1 0 0 1 0 0 ] \"e\" [ 0 1 1 0 0 1 0 1 ] ,,, })","title":"Refactor the dictionary design"},{"location":"simple-projects/encode-decode/clacks/#move-the-dictionary-to-its-own-namespace","text":"As the dictionary can be quite large to represent in code, move the dictionary definition to its own namespace. Use a more specific name for the dictionary, describing what languages the dictionary is used for ( def english->clacks { \"a\" [ 0 1 1 0 0 0 0 1 ] \"b\" [ 0 1 1 0 0 0 1 0 ] \"c\" [ 0 1 1 0 0 0 1 1 ] \"d\" [ 0 1 1 0 0 1 0 0 ] \"e\" [ 0 1 1 0 0 1 0 1 ] ,,, }) A dictionary is required to translate from Clacks to English to decode the messages. Rather than write the reverse mappings for each character in the dictionary, in effect creating a second directory for the same two languages, use a function to invert the map by swapping keys and values. clojure.set/map-invert will swap each key/value pair in the map so the key becomes the value and the value becomes the key. Define a clacks->english dictionary that holds the result of the map-invert function call ( ns practicalli.clacks-dictionary ( :require [ clojure.set ])) ( def clacks->english { ,,, }) ( def clacks->english ( clojure.set/map-invert english->clacks )) Require the dictionary namespace using the alias dictionary to give the dictionary names context when used in the main namespace. Also require clojure.string using the alias string to use the join function. ( ns practicalli.clacks-messenger ( :require [ practicalli.clacks-dictionary :as dictionary ] [ clojure.string :as string ]))","title":"Move the dictionary to its own namespace"},{"location":"simple-projects/encode-decode/clacks/#removing-side-effects","text":"Designing pure functions, those that receive all their data via arguments, is a common way to remove side effects . Include the dictionary as an argument to each of the functions. This ensures that each function is pure and prevents side effects (side causes). ( defn character->clack [ char dictionary ] ( let [ character ( str char )] ( get dictionary character ))) ( defn message->clacks [ message dictionary ] ( map # ( character->clack % dictionary ) message )) ( defn clack->character [ clack dictionary ] ( get ( clojure.set/map-invert dictionary ) clack )) ( defn clack->character [ clack dictionary ] ( get dictionary-inverted clack )) ;; Create a clacks code back to a message ( defn clacks->message [ clacks dictionary ] ( string/join ( map # ( clack->character % dictionary ) clacks ))) Test the updated functions by calling them via the REPL ( message->clacks \"cab\" dictionary/english->clacks ) ;; => ([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0]) ( message->clacks \"cab cab\" dictionary/english->clacks ) ;; => ([0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0] [0 0 0 0 0 0 0 0] [0 1 1 0 0 0 1 1] [0 1 1 0 0 0 0 1] [0 1 1 0 0 0 1 0]) ;; Create a character from a clack code ;; test data ( clacks->message ' ([ 0 1 1 0 0 0 1 1 ] [ 0 1 1 0 0 0 0 1 ] [ 0 1 1 0 0 0 1 0 ]) dictionary/english->clacks ) ( clacks->message ' ([ 0 1 1 0 0 0 1 1 ] [ 0 1 1 0 0 0 0 1 ] [ 0 1 1 0 0 0 1 0 ] [ 0 0 0 0 0 0 0 0 ] [ 0 1 1 0 0 0 1 1 ] [ 0 1 1 0 0 0 0 1 ] [ 0 1 1 0 0 0 1 0 ]) dictionary )","title":"Removing side effects"},{"location":"simple-projects/encode-decode/clacks/#using-different-dictionaries","text":"Thanks to a flexible design with no side effects or side causes then its really easy to replace the English language alphabet with another language that can be encoded into Clack codes. All that is required is to define a dictionary for another language. So languages based on the greek, latin or cyrillic alphabet could be send if a suitable alphabet with clack codes is supplied.","title":"Using different dictionaries"},{"location":"simple-projects/encode-decode/convert-boolean-values/","text":"Convert boolean true false to 1 and 0 \u03bb\ufe0e A very simple example of encoding and decoding is converting the Clojure values of true and false to 1 and 0 respectively. Using 1 for true and 0 for false has been a common idiom in programming languages, especially where a language did not include true and false syntax. Define an association between values \u03bb\ufe0e Define a Clojure hash-map to associate the Clojure boolean true an false values to 1 and 0 respectively { false 0 true 1 } Find an associated value for the conversion \u03bb\ufe0e Using the get function the boolean-value is used to find a matching key in the map and if found the value that key is associated is returned. ( get { false 0 true 1 } boolean-value ) Example: (get {false 0 true 1} true) A map can be called, just like a function. the boolean-value is passed to the map as a function argument. As with the get expression, if the map contains the key the associated value is returned. ({ false 0 true 1 } boolean-value ) Example: ({false 0 true 1} true) Convert multiple boolean values \u03bb\ufe0e If there are a collection of boolean values to convert, the map function can be used to convert them all to 1 or 0. Map this over a collection of values ( map { false 0 true 1 } [ collection-of-boolean-values ]) Example: (map {false 0 true 1} [true false false true true true false false true false true false false true]) How does this work? \u03bb\ufe0e The map function takes two arguments, a function and a collection. The map function calls the function given as an argument and calls it with each element of the collection in turn. The result of each call is remembered by the map function and when the last element of the collection has been used, a new collection of all the results is returned. In the above example, the hash-map {false 0 true 1} acts as a function. ({false 0 true 1} true) A hash-map acts as a function in that it can return an associated value when given a key as an argument. Calling {false 0 true 1} with true as an argument returns the value 1 .","title":"Convert boolean values"},{"location":"simple-projects/encode-decode/convert-boolean-values/#convert-boolean-true-false-to-1-and-0","text":"A very simple example of encoding and decoding is converting the Clojure values of true and false to 1 and 0 respectively. Using 1 for true and 0 for false has been a common idiom in programming languages, especially where a language did not include true and false syntax.","title":"Convert boolean true false to 1 and 0"},{"location":"simple-projects/encode-decode/convert-boolean-values/#define-an-association-between-values","text":"Define a Clojure hash-map to associate the Clojure boolean true an false values to 1 and 0 respectively { false 0 true 1 }","title":"Define an association between values"},{"location":"simple-projects/encode-decode/convert-boolean-values/#find-an-associated-value-for-the-conversion","text":"Using the get function the boolean-value is used to find a matching key in the map and if found the value that key is associated is returned. ( get { false 0 true 1 } boolean-value ) Example: (get {false 0 true 1} true) A map can be called, just like a function. the boolean-value is passed to the map as a function argument. As with the get expression, if the map contains the key the associated value is returned. ({ false 0 true 1 } boolean-value ) Example: ({false 0 true 1} true)","title":"Find an associated value for the conversion"},{"location":"simple-projects/encode-decode/convert-boolean-values/#convert-multiple-boolean-values","text":"If there are a collection of boolean values to convert, the map function can be used to convert them all to 1 or 0. Map this over a collection of values ( map { false 0 true 1 } [ collection-of-boolean-values ]) Example: (map {false 0 true 1} [true false false true true true false false true false true false false true])","title":"Convert multiple boolean values"},{"location":"simple-projects/encode-decode/convert-boolean-values/#how-does-this-work","text":"The map function takes two arguments, a function and a collection. The map function calls the function given as an argument and calls it with each element of the collection in turn. The result of each call is remembered by the map function and when the last element of the collection has been used, a new collection of all the results is returned. In the above example, the hash-map {false 0 true 1} acts as a function. ({false 0 true 1} true) A hash-map acts as a function in that it can return an associated value when given a key as an argument. Calling {false 0 true 1} with true as an argument returns the value 1 .","title":"How does this work?"},{"location":"simple-projects/encode-decode/rna-dna/","text":"RNA to DNA transcription \u03bb\ufe0e Given a DNA strand, return its RNA complement ( RNA transcription ). Both DNA and RNA strands are a sequence of nucleotides. The four nucleotides found in DNA are adenine (A), cytosine (C), guanine (G) and thymine (T). The four nucleotides found in RNA are adenine (A), cytosine (C), guanine (G) and uracil (U). Given a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement: G -> C C -> G T -> A A -> U HINT::Exercism.io challenge \u03bb\ufe0e This project was inspired by the RNA Transcription exercise on Exercism.io. Related exercises include Nucleotide Count and Hamming. Create a project \u03bb\ufe0e The project is part of the Exercism.io Clojure track and a project can be downloaded via the Exercisim command line tool. Alternatively, use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:project/new app practicalli/rna-transcription Define unit tests \u03bb\ufe0e Open the test/practicalli/rna-transcription.clj and add the following tests ( ns practicalli.rna-transcription-test ( :require [ clojure.test :refer [ deftest is testing ]] [ rna-transcription :as SUT ])) ( deftest rna-transcription-test ( testing \"transcribe cytosine to guanine\" ( is ( = \"G\" ( SUT/to-rna \"C\" )))) ( testing \"transcribe guanine to cytosine\" ( is ( = \"C\" ( SUT/to-rna \"G\" )))) ( testing \"transcribe adenine to uracil\" ( is ( = \"U\" ( SUT/to-rna \"A\" )))) ( testing \"transcribe thymine to adenine\" ( is ( = \"A\" ( SUT/to-rna \"T\" )))) ( testing \"transcribe all nucleotides\" ( is ( = \"UGCACCAGAAUU\" ( rna-transcription/to-rna \"ACGTGGTCTTAA\" )))) ( testing \"validate dna strands\" ( is ( thrown? AssertionError ( rna-transcription/to-rna \"XCGFGGTDTTAA\" ))))) Code the RNA transcription \u03bb\ufe0e Edit the src/practicalli/rna-transcription.clj file and require the clojure.string library. The library is part of the Clojure standard library, so does not need to be added as a project dependency. ( ns practicalli.rna-transcription ( :require [ clojure.string :as string ])) Define a dictionary to convert from DNA nucleotide to its RNA complement ( def dictionary-dna->rna \"Convert DNA to RNA\" { \"G\" \"C\" \"C\" \"G\" \"T\" \"A\" \"A\" \"U\" } ) Define a function to convert a single DNA nucleotide (one of G , C, T, A) into its RNA complement, using the dictionary. The algorithm is a simple hash-map lookup using the DNA nucleotide as the Key and returning the RNA complement as the value. ( defn convert-nucleotide \"Convert a specific nucleotide from a DNA strand, into a nucleotide for an RNA strand\" [ dictionary nucleotide ] ( get dictionary ( str nucleotide ))) Now a single nucleotide can be converted, another function can be defined to convert all DNA nucleotides in a given sequence. ( defn to-rna [ dna-sequence ] ( if ( clojure.string/includes? dna-sequence \"X\" ) ( throw ( AssertionError. )) ( apply str ( map # ( convert-nucleotide dictionary-dna-rna % ) dna )))) Although apply str provides the correct answer, it is more idiomatic to use the clojure.string/join function. ( defn to-rna [ dna-sequence ] ( if ( clojure.string/includes? dna-sequence \"X\" ) ( throw ( AssertionError. )) ( string/join ( map # ( convert-nucleotide dictionary-dna-rna % ) dna )))) The functions provide the correct answer, however, to-rna is not a pure function as the dictionary is pulled in as a side cause. Update all the tests in test/practicalli/rna-transcription.clj to call SUT/to-rna with a dictionary included in the argument. ( ns practicalli.rna-transcription-test ( :require [ clojure.test :refer [ deftest is testing ]] [ rna-transcription :as SUT ])) ( deftest rna-transcription-test ( testing \"transcribe cytosine to guanine\" ( is ( = \"G\" ( SUT/to-rna SUT/dictionary-dna->rna \"C\" )))) ( testing \"transcribe guanine to cytosine\" ( is ( = \"C\" ( SUT/to-rna SUT/dictionary-dna->rna \"G\" )))) ( testing \"transcribe adenine to uracil\" ( is ( = \"U\" ( SUT/to-rna SUT/dictionary-dna->rna \"A\" )))) ( testing \"transcribe thymine to adenine\" ( is ( = \"A\" ( SUT/to-rna SUT/dictionary-dna->rna \"T\" )))) ( testing \"transcribe all nucleotides\" ( is ( = \"UGCACCAGAAUU\" ( SUT/to-rna SUT/dictionary-dna->rna \"ACGTGGTCTTAA\" )))) ( testing \"validate dna strands\" ( is ( thrown? AssertionError ( SUT/to-rna SUT/dictionary-dna->rna \"XCGFGGTDTTAA\" ))))) Update to-rna to be a pure function by including the dictionary as an argument and also pass the updated tests. ( defn to-rna [ dictionary dna-sequence ] ( if ( clojure.string/includes? dna-sequence \"X\" ) ( throw ( AssertionError. )) ( string/join ( map # ( convert-nucleotide dictionary % ) dna )))) Idiomatic improvements \u03bb\ufe0e The to-rna function is not pure, as it relies on a shared value in the namespace, the dictionary-dna-rna transcription map. Passing dictionary-dna-rna as an argument to the to-rna function as well as the dna sequence would make to-rna a pure function. It would also allow use of a range of transcription maps. ( defn to-rna \"Transcribe each nucleotide from a DNA strand into its RNA complement Arguments: string representing DNA strand Return: string representing RNA strand\" [ transcription dna ] ( string/join ( map # ( or ( transcription % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna ))) The change to the to-rna function will break all the tests. Hint::Exercisim project and the pure function \u03bb\ufe0e If you wish to keep the Exercisim project passing, then add a new namespace to the project by create a new file called rna-transcript-pure.clj . Add the new design of the to-rna function to that namespace. Copy the tests into a new namespace by creating a file called rna-transcription-pure.clj and update the tests to use two arguments when calling to-rna Updated unit tests that call to-rna with both arguments ( ns rna-transcription-pure-test ( :require [ clojure.test :refer [ deftest is ]] [ rna-transcription-pure :as SUT ] [ rna-transcription :as data ])) ( deftest transcribes-cytosine-to-guanine ( is ( = \"G\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"C\" )))) ( deftest transcribes-guanine-to-cytosine ( is ( = \"C\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"G\" )))) ( deftest transcribes-adenine-to-uracil ( is ( = \"U\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"A\" )))) ( deftest it-transcribes-thymine-to-adenine ( is ( = \"A\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"T\" )))) ( deftest it-transcribes-all-nucleotides ( is ( = \"UGCACCAGAAUU\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"ACGTGGTCTTAA\" )))) ( deftest it-validates-dna-strands ( is ( thrown? AssertionError ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"XCGFGGTDTTAA\" )))) Summary \u03bb\ufe0e This exercise has covered the concept of using a Clojure hash-map structure as a dictionary lookup.","title":"RNA to DNA transcription"},{"location":"simple-projects/encode-decode/rna-dna/#rna-to-dna-transcription","text":"Given a DNA strand, return its RNA complement ( RNA transcription ). Both DNA and RNA strands are a sequence of nucleotides. The four nucleotides found in DNA are adenine (A), cytosine (C), guanine (G) and thymine (T). The four nucleotides found in RNA are adenine (A), cytosine (C), guanine (G) and uracil (U). Given a DNA strand, its transcribed RNA strand is formed by replacing each nucleotide with its complement: G -> C C -> G T -> A A -> U","title":"RNA to DNA transcription"},{"location":"simple-projects/encode-decode/rna-dna/#hintexercismio-challenge","text":"This project was inspired by the RNA Transcription exercise on Exercism.io. Related exercises include Nucleotide Count and Hamming.","title":"HINT::Exercism.io challenge"},{"location":"simple-projects/encode-decode/rna-dna/#create-a-project","text":"The project is part of the Exercism.io Clojure track and a project can be downloaded via the Exercisim command line tool. Alternatively, use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:project/new app practicalli/rna-transcription","title":"Create a project"},{"location":"simple-projects/encode-decode/rna-dna/#define-unit-tests","text":"Open the test/practicalli/rna-transcription.clj and add the following tests ( ns practicalli.rna-transcription-test ( :require [ clojure.test :refer [ deftest is testing ]] [ rna-transcription :as SUT ])) ( deftest rna-transcription-test ( testing \"transcribe cytosine to guanine\" ( is ( = \"G\" ( SUT/to-rna \"C\" )))) ( testing \"transcribe guanine to cytosine\" ( is ( = \"C\" ( SUT/to-rna \"G\" )))) ( testing \"transcribe adenine to uracil\" ( is ( = \"U\" ( SUT/to-rna \"A\" )))) ( testing \"transcribe thymine to adenine\" ( is ( = \"A\" ( SUT/to-rna \"T\" )))) ( testing \"transcribe all nucleotides\" ( is ( = \"UGCACCAGAAUU\" ( rna-transcription/to-rna \"ACGTGGTCTTAA\" )))) ( testing \"validate dna strands\" ( is ( thrown? AssertionError ( rna-transcription/to-rna \"XCGFGGTDTTAA\" )))))","title":"Define unit tests"},{"location":"simple-projects/encode-decode/rna-dna/#code-the-rna-transcription","text":"Edit the src/practicalli/rna-transcription.clj file and require the clojure.string library. The library is part of the Clojure standard library, so does not need to be added as a project dependency. ( ns practicalli.rna-transcription ( :require [ clojure.string :as string ])) Define a dictionary to convert from DNA nucleotide to its RNA complement ( def dictionary-dna->rna \"Convert DNA to RNA\" { \"G\" \"C\" \"C\" \"G\" \"T\" \"A\" \"A\" \"U\" } ) Define a function to convert a single DNA nucleotide (one of G , C, T, A) into its RNA complement, using the dictionary. The algorithm is a simple hash-map lookup using the DNA nucleotide as the Key and returning the RNA complement as the value. ( defn convert-nucleotide \"Convert a specific nucleotide from a DNA strand, into a nucleotide for an RNA strand\" [ dictionary nucleotide ] ( get dictionary ( str nucleotide ))) Now a single nucleotide can be converted, another function can be defined to convert all DNA nucleotides in a given sequence. ( defn to-rna [ dna-sequence ] ( if ( clojure.string/includes? dna-sequence \"X\" ) ( throw ( AssertionError. )) ( apply str ( map # ( convert-nucleotide dictionary-dna-rna % ) dna )))) Although apply str provides the correct answer, it is more idiomatic to use the clojure.string/join function. ( defn to-rna [ dna-sequence ] ( if ( clojure.string/includes? dna-sequence \"X\" ) ( throw ( AssertionError. )) ( string/join ( map # ( convert-nucleotide dictionary-dna-rna % ) dna )))) The functions provide the correct answer, however, to-rna is not a pure function as the dictionary is pulled in as a side cause. Update all the tests in test/practicalli/rna-transcription.clj to call SUT/to-rna with a dictionary included in the argument. ( ns practicalli.rna-transcription-test ( :require [ clojure.test :refer [ deftest is testing ]] [ rna-transcription :as SUT ])) ( deftest rna-transcription-test ( testing \"transcribe cytosine to guanine\" ( is ( = \"G\" ( SUT/to-rna SUT/dictionary-dna->rna \"C\" )))) ( testing \"transcribe guanine to cytosine\" ( is ( = \"C\" ( SUT/to-rna SUT/dictionary-dna->rna \"G\" )))) ( testing \"transcribe adenine to uracil\" ( is ( = \"U\" ( SUT/to-rna SUT/dictionary-dna->rna \"A\" )))) ( testing \"transcribe thymine to adenine\" ( is ( = \"A\" ( SUT/to-rna SUT/dictionary-dna->rna \"T\" )))) ( testing \"transcribe all nucleotides\" ( is ( = \"UGCACCAGAAUU\" ( SUT/to-rna SUT/dictionary-dna->rna \"ACGTGGTCTTAA\" )))) ( testing \"validate dna strands\" ( is ( thrown? AssertionError ( SUT/to-rna SUT/dictionary-dna->rna \"XCGFGGTDTTAA\" ))))) Update to-rna to be a pure function by including the dictionary as an argument and also pass the updated tests. ( defn to-rna [ dictionary dna-sequence ] ( if ( clojure.string/includes? dna-sequence \"X\" ) ( throw ( AssertionError. )) ( string/join ( map # ( convert-nucleotide dictionary % ) dna ))))","title":"Code the RNA transcription"},{"location":"simple-projects/encode-decode/rna-dna/#idiomatic-improvements","text":"The to-rna function is not pure, as it relies on a shared value in the namespace, the dictionary-dna-rna transcription map. Passing dictionary-dna-rna as an argument to the to-rna function as well as the dna sequence would make to-rna a pure function. It would also allow use of a range of transcription maps. ( defn to-rna \"Transcribe each nucleotide from a DNA strand into its RNA complement Arguments: string representing DNA strand Return: string representing RNA strand\" [ transcription dna ] ( string/join ( map # ( or ( transcription % ) ( throw ( AssertionError. \"Unknown nucleotide\" ))) dna ))) The change to the to-rna function will break all the tests.","title":"Idiomatic improvements"},{"location":"simple-projects/encode-decode/rna-dna/#hintexercisim-project-and-the-pure-function","text":"If you wish to keep the Exercisim project passing, then add a new namespace to the project by create a new file called rna-transcript-pure.clj . Add the new design of the to-rna function to that namespace. Copy the tests into a new namespace by creating a file called rna-transcription-pure.clj and update the tests to use two arguments when calling to-rna Updated unit tests that call to-rna with both arguments ( ns rna-transcription-pure-test ( :require [ clojure.test :refer [ deftest is ]] [ rna-transcription-pure :as SUT ] [ rna-transcription :as data ])) ( deftest transcribes-cytosine-to-guanine ( is ( = \"G\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"C\" )))) ( deftest transcribes-guanine-to-cytosine ( is ( = \"C\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"G\" )))) ( deftest transcribes-adenine-to-uracil ( is ( = \"U\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"A\" )))) ( deftest it-transcribes-thymine-to-adenine ( is ( = \"A\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"T\" )))) ( deftest it-transcribes-all-nucleotides ( is ( = \"UGCACCAGAAUU\" ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"ACGTGGTCTTAA\" )))) ( deftest it-validates-dna-strands ( is ( thrown? AssertionError ( SUT/dna->rna data/dna-nucleotide->rna-nucleotide \"XCGFGGTDTTAA\" ))))","title":"Hint::Exercisim project and the pure function"},{"location":"simple-projects/encode-decode/rna-dna/#summary","text":"This exercise has covered the concept of using a Clojure hash-map structure as a dictionary lookup.","title":"Summary"},{"location":"simple-projects/mutating-state/","text":"Mutating State in a Controlled way \u03bb\ufe0e Mutating state should be used carefully and sparingly in Clojure (and all other programming languages). atom is a mutable container that can manage any value. The atom ensures that only one call at a time can affect the value it manages. This is part of the software transactions memory system in Clojure. As the atom is mutable in that the value it manages can be changed, however, this must be done with special commands (swap!, reset!, compare-and-set!, swap-vals!). Even though the atom is mutable, the values it manages are not. They are normal immutable (unchangeable) Clojure values. ref is similar to atom and can manage transactions, ensuring that all changes happen or no changes happen. Project Topics Overview Mutants assemble atom swap! reset! Using an atom to manage state changes Undo/Redo atom add-watch Traversing the history of an atom Poker game atom swap! reset! ref Simple transaction management using atom and ref in a card game, using constraints on an atom References \u03bb\ufe0e Atoms - clojure.org Refs and Transactions - clojure.org Agents - clojure.org","title":"Mutating State in a Controlled way"},{"location":"simple-projects/mutating-state/#mutating-state-in-a-controlled-way","text":"Mutating state should be used carefully and sparingly in Clojure (and all other programming languages). atom is a mutable container that can manage any value. The atom ensures that only one call at a time can affect the value it manages. This is part of the software transactions memory system in Clojure. As the atom is mutable in that the value it manages can be changed, however, this must be done with special commands (swap!, reset!, compare-and-set!, swap-vals!). Even though the atom is mutable, the values it manages are not. They are normal immutable (unchangeable) Clojure values. ref is similar to atom and can manage transactions, ensuring that all changes happen or no changes happen. Project Topics Overview Mutants assemble atom swap! reset! Using an atom to manage state changes Undo/Redo atom add-watch Traversing the history of an atom Poker game atom swap! reset! ref Simple transaction management using atom and ref in a card game, using constraints on an atom","title":"Mutating State in a Controlled way"},{"location":"simple-projects/mutating-state/#references","text":"Atoms - clojure.org Refs and Transactions - clojure.org Agents - clojure.org","title":"References"},{"location":"simple-projects/mutating-state/mutants-assemble/","text":"Mutants Assemble \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e In this section you will apply changes to values, how to define your own simple functions. We will also introduce the following functions for the first time: | atom | create an anonymous function, one without a name | | deref , @ | assign a name to a function | Create a new Clojure project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/mutants-assemble Open the src/practicalli/mutants-assemble.clj file in a Clojure aware editor and start the REPL. Define an atom \u03bb\ufe0e Use the standard def function to bind a name to an atom. The atom wraps data, initially an empty vector. (def mutants (atom [])) Define a function using defn which takes a mutant as an argument and updates the value managed by the atom. The reference to the atom is also an argument, making this a pure function and more generic as any given atom can be updated with this function. (defn add-mutant [mutants mutant] (swap! mutants conj mutant)) swap! uses a function to create a new value for the atom to manage. In this case the conj function is used to join the value of mutant with the existing mutants atom value, creating a new vector. swap! is a macro so the syntax is a little different. Essentially this is the same as an expression (conj mutants mutant) , with the value this returns swapped into the atom. Call the function with the mutants atom and a mutant to add, which is a string containing the name of a mutant character. ( add-mutant mutants \"Black Widow\" ) The value the atom is managing has been swapped for a new value. The original value was not modified (vectors are immutable) so the atom now points to a new value, a vector containing a string. Viewing the value managed by the atom \u03bb\ufe0e Use the deref function to see the value the atom is managing. (deref mutants) It is idiomatic to use @ which is a syntax alias for the deref function, rather than explicitly using deref . @mutants Reset the atom value \u03bb\ufe0e reset! will change the value managed by the atom by providing the new value. This is simpler than using swap! as it does not use the existing value in the atom. (reset! mutants []) Now all the mutants are gone (and we can start looking for new ones to add).","title":"Mutants Assemble"},{"location":"simple-projects/mutating-state/mutants-assemble/#mutants-assemble","text":"","title":"Mutants Assemble"},{"location":"simple-projects/mutating-state/mutants-assemble/#todowork-in-progress-sorry","text":"In this section you will apply changes to values, how to define your own simple functions. We will also introduce the following functions for the first time: | atom | create an anonymous function, one without a name | | deref , @ | assign a name to a function |","title":"TODO::work in progress, sorry"},{"location":"simple-projects/mutating-state/mutants-assemble/#create-a-new-clojure-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/mutants-assemble Open the src/practicalli/mutants-assemble.clj file in a Clojure aware editor and start the REPL.","title":"Create a new Clojure project"},{"location":"simple-projects/mutating-state/mutants-assemble/#define-an-atom","text":"Use the standard def function to bind a name to an atom. The atom wraps data, initially an empty vector. (def mutants (atom [])) Define a function using defn which takes a mutant as an argument and updates the value managed by the atom. The reference to the atom is also an argument, making this a pure function and more generic as any given atom can be updated with this function. (defn add-mutant [mutants mutant] (swap! mutants conj mutant)) swap! uses a function to create a new value for the atom to manage. In this case the conj function is used to join the value of mutant with the existing mutants atom value, creating a new vector. swap! is a macro so the syntax is a little different. Essentially this is the same as an expression (conj mutants mutant) , with the value this returns swapped into the atom. Call the function with the mutants atom and a mutant to add, which is a string containing the name of a mutant character. ( add-mutant mutants \"Black Widow\" ) The value the atom is managing has been swapped for a new value. The original value was not modified (vectors are immutable) so the atom now points to a new value, a vector containing a string.","title":"Define an atom"},{"location":"simple-projects/mutating-state/mutants-assemble/#viewing-the-value-managed-by-the-atom","text":"Use the deref function to see the value the atom is managing. (deref mutants) It is idiomatic to use @ which is a syntax alias for the deref function, rather than explicitly using deref . @mutants","title":"Viewing the value managed by the atom"},{"location":"simple-projects/mutating-state/mutants-assemble/#reset-the-atom-value","text":"reset! will change the value managed by the atom by providing the new value. This is simpler than using swap! as it does not use the existing value in the atom. (reset! mutants []) Now all the mutants are gone (and we can start looking for new ones to add).","title":"Reset the atom value"},{"location":"simple-projects/tdd-kata/","text":"Kata challenges - Test Driven Development with Clojure \u03bb\ufe0e A kata is a small challenge that you attempt to solve in different ways, so experiment with your solutions to these challenges. Project Topics Overview Recent song-list TDD Keep a list of recent songs played, without duplicates","title":"Kata challenges - Test Driven Development with Clojure"},{"location":"simple-projects/tdd-kata/#kata-challenges-test-driven-development-with-clojure","text":"A kata is a small challenge that you attempt to solve in different ways, so experiment with your solutions to these challenges. Project Topics Overview Recent song-list TDD Keep a list of recent songs played, without duplicates","title":"Kata challenges - Test Driven Development with Clojure"},{"location":"simple-projects/tdd-kata/recent-songlist/","text":"Recent song-list \u03bb\ufe0e Create a recent song list to hold a unique set of songs that have been played. The most recently played song is at the start of the list, the least recently played song is the last in the list. A recently-used-list is initially empty. Songs in the list are unique, so repeatedly played songs should only appear once in the list Songs can be looked up by index, which counts from zero. Optional extras: Empty song names are not allowed. Add a limit to the number of songs the list contains, with the least recently added items dropped when that limit is reached. Create a new Clojure project \u03bb\ufe0e Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/recent-song-list Using clojure.test \u03bb\ufe0e We are writing our tests with the clojure.test library Open test/playground/recent-song-list-test.clj file in your editor and update the namespace definition to include clojure.test (ns practicalli.recent-song-list-test (:require [clojure.test :refer [deftest is testing]] [playground.recent-song-list :as SUT])) Run Tests \u03bb\ufe0e At any time we can call the run-tests function in the REPL to get a report back on all of the tests in our current namespace ( recent-song-list ) (run-tests) The Cognitect Labs test runner is included in the project by default and can be run from the command line in the root directory of the project. clojure -M:test:runner Define a recent song list \u03bb\ufe0e In the source file, src/playground/recent-song-list.clj , define a name for your collection of recent songs You can use an empty collection to start with. Which collection type will you use though? (def recent-songs []) Note::Write a test to check a song-list exists \u03bb\ufe0e Write a test to see if a recent song list exists. This is an opportunity to think about what kind of data structure you want to use to hold your recent song list. A simple test that checks for a recent-songs list, checking ( deftest song-list-exists-test ( testing \"Does a recent song list exist\" ( is ( vector? recent-songs )))) Note::Write a test to check the song-list is empty \u03bb\ufe0e The recent song list should be empty to start with. A simple test that compares an empty vector with the value of recent-songs ( deftest song-list-empty-test ( testing \"Is song list empty if we haven't added any songs\" ( is ( = [] recent-songs )))) Here is the same test using the empty? function instead of the = function. ( deftest song-list-empty-test-2 ( testing \"Is song list empty if we haven't added any songs\" ( is ( empty? recent-songs )))) Hint:: \u03bb\ufe0e You could use either of these tests to replace the song list exists test, as these tests would fail if the song list did not exist. Note::Write a test to add a song to the list \u03bb\ufe0e Add a song to the collection, for example Tubular Bells - Mike Oldfield ( deftest adding-songs-test ( testing \"add song returns a song list with entries\" ( is ( not ( empty? ( add-song \"Barry Manilow - Love on the rocks\" recent-songs ))))) ( testing \"add multiple song returns a song list with entries\" ( is ( not ( empty? ( ->> recent-songs ( add-song \"Barry Manilow - Love on the rocks\" ) ( add-song \"Phil Colins - Sususudio\" ))))))) This suggested solution defines our recent songs as an empty vector. The add-song function takes the name of a song and the song list to which it will be added. A Thread-last macro ->> is used to pass the song list over two functions. The song-list is first passed to the remove expression as its last argument. This expression will remove any occurrence of the new song we want to add from the song-list . The results of the remove expression are then passed to the cons expression as its last argument. The cons expression simply adds the new song to the start of the list, making it the most recent song. ( def recent-songs []) ( defn add-song [ song song-list ] ( ->> song-list ( remove # ( = song % )) ( cons song )))","title":"Recent song-list"},{"location":"simple-projects/tdd-kata/recent-songlist/#recent-song-list","text":"Create a recent song list to hold a unique set of songs that have been played. The most recently played song is at the start of the list, the least recently played song is the last in the list. A recently-used-list is initially empty. Songs in the list are unique, so repeatedly played songs should only appear once in the list Songs can be looked up by index, which counts from zero. Optional extras: Empty song names are not allowed. Add a limit to the number of songs the list contains, with the least recently added items dropped when that limit is reached.","title":"Recent song-list"},{"location":"simple-projects/tdd-kata/recent-songlist/#create-a-new-clojure-project","text":"Use Clojure CLI tools and clj-new to create a new Clojure project. clojure -M:new app practicalli/recent-song-list","title":"Create a new Clojure project"},{"location":"simple-projects/tdd-kata/recent-songlist/#using-clojuretest","text":"We are writing our tests with the clojure.test library Open test/playground/recent-song-list-test.clj file in your editor and update the namespace definition to include clojure.test (ns practicalli.recent-song-list-test (:require [clojure.test :refer [deftest is testing]] [playground.recent-song-list :as SUT]))","title":"Using clojure.test"},{"location":"simple-projects/tdd-kata/recent-songlist/#run-tests","text":"At any time we can call the run-tests function in the REPL to get a report back on all of the tests in our current namespace ( recent-song-list ) (run-tests) The Cognitect Labs test runner is included in the project by default and can be run from the command line in the root directory of the project. clojure -M:test:runner","title":"Run Tests"},{"location":"simple-projects/tdd-kata/recent-songlist/#define-a-recent-song-list","text":"In the source file, src/playground/recent-song-list.clj , define a name for your collection of recent songs You can use an empty collection to start with. Which collection type will you use though? (def recent-songs [])","title":"Define a recent song list"},{"location":"simple-projects/tdd-kata/recent-songlist/#notewrite-a-test-to-check-a-song-list-exists","text":"Write a test to see if a recent song list exists. This is an opportunity to think about what kind of data structure you want to use to hold your recent song list. A simple test that checks for a recent-songs list, checking ( deftest song-list-exists-test ( testing \"Does a recent song list exist\" ( is ( vector? recent-songs ))))","title":"Note::Write a test to check a song-list exists"},{"location":"simple-projects/tdd-kata/recent-songlist/#notewrite-a-test-to-check-the-song-list-is-empty","text":"The recent song list should be empty to start with. A simple test that compares an empty vector with the value of recent-songs ( deftest song-list-empty-test ( testing \"Is song list empty if we haven't added any songs\" ( is ( = [] recent-songs )))) Here is the same test using the empty? function instead of the = function. ( deftest song-list-empty-test-2 ( testing \"Is song list empty if we haven't added any songs\" ( is ( empty? recent-songs ))))","title":"Note::Write a test to check the song-list is empty"},{"location":"simple-projects/tdd-kata/recent-songlist/#hint","text":"You could use either of these tests to replace the song list exists test, as these tests would fail if the song list did not exist.","title":"Hint::"},{"location":"simple-projects/tdd-kata/recent-songlist/#notewrite-a-test-to-add-a-song-to-the-list","text":"Add a song to the collection, for example Tubular Bells - Mike Oldfield ( deftest adding-songs-test ( testing \"add song returns a song list with entries\" ( is ( not ( empty? ( add-song \"Barry Manilow - Love on the rocks\" recent-songs ))))) ( testing \"add multiple song returns a song list with entries\" ( is ( not ( empty? ( ->> recent-songs ( add-song \"Barry Manilow - Love on the rocks\" ) ( add-song \"Phil Colins - Sususudio\" ))))))) This suggested solution defines our recent songs as an empty vector. The add-song function takes the name of a song and the song list to which it will be added. A Thread-last macro ->> is used to pass the song list over two functions. The song-list is first passed to the remove expression as its last argument. This expression will remove any occurrence of the new song we want to add from the song-list . The results of the remove expression are then passed to the cons expression as its last argument. The cons expression simply adds the new song to the start of the list, making it the most recent song. ( def recent-songs []) ( defn add-song [ song song-list ] ( ->> song-list ( remove # ( = song % )) ( cons song )))","title":"Note::Write a test to add a song to the list"},{"location":"standard-library/","text":"Clojure Standard Library \u03bb\ufe0e There are approximately 700 functions and macros available in the clojure.core namespace. These are referred to as the Clojure Standard Library. Hint::Counting the functions in clojure.core \u03bb\ufe0e You can see all the functions in clojure.core for yourself, simply create a default Clojure project using: lein new standard-library Now I dont remember the function to get the functions in the current project... time to google when back online","title":"Clojure Standard Library"},{"location":"standard-library/#clojure-standard-library","text":"There are approximately 700 functions and macros available in the clojure.core namespace. These are referred to as the Clojure Standard Library.","title":"Clojure Standard Library"},{"location":"standard-library/#hintcounting-the-functions-in-clojurecore","text":"You can see all the functions in clojure.core for yourself, simply create a default Clojure project using: lein new standard-library Now I dont remember the function to get the functions in the current project... time to google when back online","title":"Hint::Counting the functions in clojure.core"},{"location":"standard-library/collections/","text":"Standard Library: Collections \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Functions to create and work with the Clojure collection types, mainly maps, vectors and sets See Sequences for functions around lists and (lazy) sequences","title":"Standard Library: Collections"},{"location":"standard-library/collections/#standard-library-collections","text":"","title":"Standard Library: Collections"},{"location":"standard-library/collections/#todowork-in-progress-sorry","text":"Functions to create and work with the Clojure collection types, mainly maps, vectors and sets See Sequences for functions around lists and (lazy) sequences","title":"TODO::work in progress, sorry"},{"location":"standard-library/sequences/","text":"Standard Library: Sequences \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Functions to create and work with the Clojure sequences, including lists and sequence generators Sequence access \u03bb\ufe0e Function Description first second rest last butlast nth Infinite sequence generators \u03bb\ufe0e Function Description range cycle iterate","title":"Standard Library: Sequences"},{"location":"standard-library/sequences/#standard-library-sequences","text":"","title":"Standard Library: Sequences"},{"location":"standard-library/sequences/#todowork-in-progress-sorry","text":"Functions to create and work with the Clojure sequences, including lists and sequence generators","title":"TODO::work in progress, sorry"},{"location":"standard-library/sequences/#sequence-access","text":"Function Description first second rest last butlast nth","title":"Sequence access"},{"location":"standard-library/sequences/#infinite-sequence-generators","text":"Function Description range cycle iterate","title":"Infinite sequence generators"},{"location":"testing/","text":"Testing in Clojure \u03bb\ufe0e Testing is supported in Clojure with a range of testing libraries and test runners. Unit Test style frameworks \u03bb\ufe0e Unit testing is part of the Clojure standard library and provides assertion based testing * clojure.test Clojure Spec and Generative testing \u03bb\ufe0e Define specifications for data and functions, generating extensive test data from specifications and using that data to verify behavior of functions in generative testing. * clojure.spec.alpha * clojure.spec.test.alpha * clojure.spec.gen.alpha Behaviour Driven Development frameworks \u03bb\ufe0e Given, When, Then and scenario approach to outside in software testing * Scenari - executable specification / BDD in Clojure * kaocha-cucumber - support for Cucumber tests in the gerkin format * speclj - TDD/BDD framework for Clojure and ClojureScript based on RSpec. Alternative BDD libraries are discussed at https://github.com/gphilipp/bdd-guide-clojure Performance testing \u03bb\ufe0e Testing individual expressions through to application and load testing. * time - simple results of evaluating an expression * criterion - a realistic measure of performance for clojure expressions * Gatling - open source & commercial load test tool for web applications * clj-gatling - wrapper around Gatling which enables tests to be expressed in Clojure. Articles on testing in Clojure \u03bb\ufe0e Clojure test runner of my dreams Example based unit testing in Clojure TDD in Clojure at Funding Circle Bolth - a more humane test runner Announcing kaocha a new and improved clojure test runner Scenarios as code - Clojure Remote presentation Load testing with Gatling and Clojure - JUXT.pro","title":"Testing in Clojure"},{"location":"testing/#testing-in-clojure","text":"Testing is supported in Clojure with a range of testing libraries and test runners.","title":"Testing in Clojure"},{"location":"testing/#unit-test-style-frameworks","text":"Unit testing is part of the Clojure standard library and provides assertion based testing * clojure.test","title":"Unit Test style frameworks"},{"location":"testing/#clojure-spec-and-generative-testing","text":"Define specifications for data and functions, generating extensive test data from specifications and using that data to verify behavior of functions in generative testing. * clojure.spec.alpha * clojure.spec.test.alpha * clojure.spec.gen.alpha","title":"Clojure Spec and Generative testing"},{"location":"testing/#behaviour-driven-development-frameworks","text":"Given, When, Then and scenario approach to outside in software testing * Scenari - executable specification / BDD in Clojure * kaocha-cucumber - support for Cucumber tests in the gerkin format * speclj - TDD/BDD framework for Clojure and ClojureScript based on RSpec. Alternative BDD libraries are discussed at https://github.com/gphilipp/bdd-guide-clojure","title":"Behaviour Driven Development frameworks"},{"location":"testing/#performance-testing","text":"Testing individual expressions through to application and load testing. * time - simple results of evaluating an expression * criterion - a realistic measure of performance for clojure expressions * Gatling - open source & commercial load test tool for web applications * clj-gatling - wrapper around Gatling which enables tests to be expressed in Clojure.","title":"Performance testing"},{"location":"testing/#articles-on-testing-in-clojure","text":"Clojure test runner of my dreams Example based unit testing in Clojure TDD in Clojure at Funding Circle Bolth - a more humane test runner Announcing kaocha a new and improved clojure test runner Scenarios as code - Clojure Remote presentation Load testing with Gatling and Clojure - JUXT.pro","title":"Articles on testing in Clojure"},{"location":"testing/clojure-test/","text":"Unit Testing with clojure.test \u03bb\ufe0e clojure.test is a test library that is already part of Clojure and test package hierarchy is typically created (e.g. when generating Clojure projects with Leiningen). As with other unit testing libraries you use clojure.test to write test. These tests are defined as functions that contain one or more assertions. As a general guideline, a Clojure test function should test a specific Clojure function. Hint::What to test \u03bb\ufe0e Define a deftest for every public functions within a namespace, so the contract / api for each namespace is testable and will highlight obvious regressions. The testing function can be used to group assertions for a particular deftest , so different aspects of the tests can be grouped together. Test reports contain only the names of the deftest functions, as there are no names with testing clojure.spec provides another way to define a contract around your functions and data structures. It also includes generative testing approach to broaden the test data used to test your functions. Test namespaces \u03bb\ufe0e clojure.test needs to be included in the namespace in order to use the functions that namespace provides. The recommended syntax is to :refer the specific functions which makes those functions available as if they were defined in the current namespace. The namespace that is under test also needs to be included and and its recommended that you use the alias SUT for system under test. The test namespace matches the namespace you are testing, with the addition of -test to the name. ( ns my-clojure-app.core-test ( :require [ clojure.test :refer [ deftest deftest- testing is ]] [ my-clojure-app.core :as SUT ])) Writing an assertion \u03bb\ufe0e An assertion is where you compare an expected result with the result of calling a function. If the assertion is true, then then it is a pass. If the assertion is false, then its a fail. The form of an assertion takes a form (is (comparator expected-value function-call)) Some simple examples include ( is ( = 42 ( * 6 7 ))) ( is ( not= 24 ( * 6 7 ))) Defining a test \u03bb\ufe0e deftest is used to define a function that will test a similarly named function from the src tree. The test function name should match the function it is testing with -test added to the end. testing function allows you to group one or more assertions is defines an assertion ( deftest adder-test ( testing \"Using a range of numbers to test the adder\" # _ ( is ( = 0 1 )) ( is ( = ( + 1 2 ) ( adder 1 2 )) \"Adding 1 and 2\" ) ( is ( = ( + 1 -2 ) ( adder 1 -2 )) \"Adding 1 and -2\" ) # _ ( is ( not ( = ( + 1 2 )) ( adder \"a\" \"b\" )) \"Adding strings as negative test\" ) ( is ( false? ( = 0 1 )) \"A simple failing test\" ) ( is ( false? ( = 0 ( adder 3 4 ))) \"Purposefully using failing data\" )))","title":"Unit Testing with `clojure.test`"},{"location":"testing/clojure-test/#unit-testing-with-clojuretest","text":"clojure.test is a test library that is already part of Clojure and test package hierarchy is typically created (e.g. when generating Clojure projects with Leiningen). As with other unit testing libraries you use clojure.test to write test. These tests are defined as functions that contain one or more assertions. As a general guideline, a Clojure test function should test a specific Clojure function.","title":"Unit Testing with clojure.test"},{"location":"testing/clojure-test/#hintwhat-to-test","text":"Define a deftest for every public functions within a namespace, so the contract / api for each namespace is testable and will highlight obvious regressions. The testing function can be used to group assertions for a particular deftest , so different aspects of the tests can be grouped together. Test reports contain only the names of the deftest functions, as there are no names with testing clojure.spec provides another way to define a contract around your functions and data structures. It also includes generative testing approach to broaden the test data used to test your functions.","title":"Hint::What to test"},{"location":"testing/clojure-test/#test-namespaces","text":"clojure.test needs to be included in the namespace in order to use the functions that namespace provides. The recommended syntax is to :refer the specific functions which makes those functions available as if they were defined in the current namespace. The namespace that is under test also needs to be included and and its recommended that you use the alias SUT for system under test. The test namespace matches the namespace you are testing, with the addition of -test to the name. ( ns my-clojure-app.core-test ( :require [ clojure.test :refer [ deftest deftest- testing is ]] [ my-clojure-app.core :as SUT ]))","title":"Test namespaces"},{"location":"testing/clojure-test/#writing-an-assertion","text":"An assertion is where you compare an expected result with the result of calling a function. If the assertion is true, then then it is a pass. If the assertion is false, then its a fail. The form of an assertion takes a form (is (comparator expected-value function-call)) Some simple examples include ( is ( = 42 ( * 6 7 ))) ( is ( not= 24 ( * 6 7 )))","title":"Writing an assertion"},{"location":"testing/clojure-test/#defining-a-test","text":"deftest is used to define a function that will test a similarly named function from the src tree. The test function name should match the function it is testing with -test added to the end. testing function allows you to group one or more assertions is defines an assertion ( deftest adder-test ( testing \"Using a range of numbers to test the adder\" # _ ( is ( = 0 1 )) ( is ( = ( + 1 2 ) ( adder 1 2 )) \"Adding 1 and 2\" ) ( is ( = ( + 1 -2 ) ( adder 1 -2 )) \"Adding 1 and -2\" ) # _ ( is ( not ( = ( + 1 2 )) ( adder \"a\" \"b\" )) \"Adding strings as negative test\" ) ( is ( false? ( = 0 1 )) \"A simple failing test\" ) ( is ( false? ( = 0 ( adder 3 4 ))) \"Purposefully using failing data\" )))","title":"Defining a test"},{"location":"testing/integration-testing/","text":"Integration Testing \u03bb\ufe0e See the continuous integration section","title":"Integration Testing"},{"location":"testing/integration-testing/#integration-testing","text":"See the continuous integration section","title":"Integration Testing"},{"location":"testing/test-runners/","text":"Test Runners \u03bb\ufe0e A Test runner is a tool to run test in a project and report the results. During development test runners are called from editors or run om the command line and can be configured to run automatically when changes are detected in the code. Regularly running some or all of the tests in a project checks the design decisions made so far have not regressed by additional development. Test runners are highly recommended step as part of continuous integration and should be used in conjunction with a CI Server for every project. Hint::All code should compile \u03bb\ufe0e All the code in the project should be correct Clojure code and compiled unless commented with ;; , a (comment ,,,) blocks or prefixed with the #_ reader macro. If code is know not to be correct, ;; comment is recommended comment approach. Which test runner to use \u03bb\ufe0e Test runner Type Summary cognitect-labs test runner clj Defacto test runner for deps.edn projects cljs-test-runner cljs Run all ClojureScript tests with one simple command. Kaocha clj, cljs Full featured next gen test runner CIDER test runner clj CIDER built in test runner CIDER test runner is ideal if using Emacs for Clojure development, as its build into CIDER. Cognitect test runner is the defacto tool Clojure deps projects on the command line and with CI servers. cljs-test-runner for ClojureScript deps projects, complementing the Cognitect test runner. Automatic discover of cljs.test based tests, so no configuration required. Kaocha is a very feature rich test runner for Clojure and ClojureScript, BDD style cucumber tests, coverage and junit style reporting. Kaocha takes a little bit more effort to learn due to the additional features it provides. Hint::deps.edn aliases for test runners \u03bb\ufe0e Aliases for these test runners are provided the practicalli/clojure-deps.edn configuration. Improving test result readability \u03bb\ufe0e Include the :env/test alias when starting a REPL to include the Humane Test Output library, which will pretty print results Add the following code to a user namespace on the class path (i.e. a dev/user.clj file if including the :env/dev alias) ( require ' [ pjstadig.humane-test-output :as humane-test-results ]) ( humane-test-results/activate! ) humane-test-output - more human readable test output with equality assertions diffed","title":"Test Runners"},{"location":"testing/test-runners/#test-runners","text":"A Test runner is a tool to run test in a project and report the results. During development test runners are called from editors or run om the command line and can be configured to run automatically when changes are detected in the code. Regularly running some or all of the tests in a project checks the design decisions made so far have not regressed by additional development. Test runners are highly recommended step as part of continuous integration and should be used in conjunction with a CI Server for every project.","title":"Test Runners"},{"location":"testing/test-runners/#hintall-code-should-compile","text":"All the code in the project should be correct Clojure code and compiled unless commented with ;; , a (comment ,,,) blocks or prefixed with the #_ reader macro. If code is know not to be correct, ;; comment is recommended comment approach.","title":"Hint::All code should compile"},{"location":"testing/test-runners/#which-test-runner-to-use","text":"Test runner Type Summary cognitect-labs test runner clj Defacto test runner for deps.edn projects cljs-test-runner cljs Run all ClojureScript tests with one simple command. Kaocha clj, cljs Full featured next gen test runner CIDER test runner clj CIDER built in test runner CIDER test runner is ideal if using Emacs for Clojure development, as its build into CIDER. Cognitect test runner is the defacto tool Clojure deps projects on the command line and with CI servers. cljs-test-runner for ClojureScript deps projects, complementing the Cognitect test runner. Automatic discover of cljs.test based tests, so no configuration required. Kaocha is a very feature rich test runner for Clojure and ClojureScript, BDD style cucumber tests, coverage and junit style reporting. Kaocha takes a little bit more effort to learn due to the additional features it provides.","title":"Which test runner to use"},{"location":"testing/test-runners/#hintdepsedn-aliases-for-test-runners","text":"Aliases for these test runners are provided the practicalli/clojure-deps.edn configuration.","title":"Hint::deps.edn aliases for test runners"},{"location":"testing/test-runners/#improving-test-result-readability","text":"Include the :env/test alias when starting a REPL to include the Humane Test Output library, which will pretty print results Add the following code to a user namespace on the class path (i.e. a dev/user.clj file if including the :env/dev alias) ( require ' [ pjstadig.humane-test-output :as humane-test-results ]) ( humane-test-results/activate! ) humane-test-output - more human readable test output with equality assertions diffed","title":"Improving test result readability"},{"location":"testing/test-runners/aero/","text":"Aero \u03bb\ufe0e juxt/aero is used to read the kaocha configuration, so reader literals such as #env, #merge, #ref, and #include can be used. Set up profiles for different stages of the development workflow , dev, test, prod, etc. Each profile has a different configuration making it very easy to switch { :port 8000 :database # profile { :prod \"datomic:dev://localhost:4334/my-prod-db2\" :test \"datomic:dev://localhost:4334/my-test-db\" :default \"datomic:dev://localhost:4334/my-db\" } :known-users [{ :name \"Alice\" } { :name \"Betty\" }]} Then in application startup function or a component lifecycle library (mount, component, integrant) read in a specific profile ( aero.core/read-config \"config.edn\" { :profile :prod })","title":"Aero"},{"location":"testing/test-runners/aero/#aero","text":"juxt/aero is used to read the kaocha configuration, so reader literals such as #env, #merge, #ref, and #include can be used. Set up profiles for different stages of the development workflow , dev, test, prod, etc. Each profile has a different configuration making it very easy to switch { :port 8000 :database # profile { :prod \"datomic:dev://localhost:4334/my-prod-db2\" :test \"datomic:dev://localhost:4334/my-test-db\" :default \"datomic:dev://localhost:4334/my-db\" } :known-users [{ :name \"Alice\" } { :name \"Betty\" }]} Then in application startup function or a component lifecycle library (mount, component, integrant) read in a specific profile ( aero.core/read-config \"config.edn\" { :profile :prod })","title":"Aero"},{"location":"testing/test-runners/congnitect-labs-test-runner/","text":"Cognitect Labs Test Runner \u03bb\ufe0e test-runner is a test runner for Clojure projects defined with deps.edn and using clojure.test library which is part of the Clojure standard library. test-runner aims to provide a standard way to discover and run unit and property-based tests, in a simple to use and lightweight tool. Adding test-runner \u03bb\ufe0e Make test-runner available to all projects by adding it to ~/.clojure/deps.edn . Or add test-runner to specific projects by adding an alias to the project deps.edn file. Include :extra-paths configuration to include the standard test directory so that the runner has access to the test code. :test-runner-cognitect { :extra-paths [ \"test\" ] :extra-deps { com.cognitect/test-runner { :git/url \"https://github.com/cognitect-labs/test-runner.git\" :sha \"f7ef16dc3b8332b0d77bc0274578ad5270fbfedd\" }} :main-opts [ \"-m\" \"cognitect.test-runner\" ]} Hint::Use practicalli/clojure-deps-edn to add common tools \u03bb\ufe0e Fork and clone the practicalli/clojure-deps-edn GitHub repository to instantly have access to dozens of tools for Clojure software development Running the test runner \u03bb\ufe0e Then, invoke Clojure via the command line, invoking the test alias: clojure -M:test-runner-cognitect This calls the cognitect.test-runner/-main function which will scan the test directory of the current project for any tests defined using clojure.test and then run all the tests found. A summary is returned with the results of running the tests. TODO: screenshot of summary Additional command line options: \u03bb\ufe0e Flag Description -d, --dir DIRNAME Name of the directory containing tests. Defaults to \"test\". -n, --namespace SYMBOL Symbol indicating a specific namespace to test. -r, --namespace-regex REGEX Regex for namespaces to test. Defaults to #\".*-test$\" (i.e, only namespaces ending in '-test' are evaluated) -v, --var SYMBOL Symbol indicating the fully qualified name of a specific test. -i, --include KEYWORD Run only tests that have this metadata keyword. -e, --exclude KEYWORD Exclude tests with this metadata keyword. -H, --test-help Display this help message Options can be used multiple times in one command, for a logical OR effect. For example, the following command runs all tests in the practicalli.data.survey and practicalli.services.survey-report namespaces that are found in the src and test directories clojure -M:test-runner-cognitect -d test -d src -n practicalli.data.survey -n practicalli.services.survey-report Categorizing tests for selective test runs \u03bb\ufe0e Integration tests tend to take longer to run as they use larger data sets and/run a or more comprehensive set of tests. Categorizing tests is an approach to using test runners effectively, by selectively running tests at different stages of development. Use Clojure metadata when defining test functions using deftest . ( deftest ^ :integration test-live-system ( is ( = 200 ( :status ( http/get \"http://example.com\" ))))) Use the i inclusion flag with the test runner to specify specific categories of tests clojure -M:test-runner-cognitect -i :integration Categories can be used together by using multiple flags. Assuming categories of develop, uat, integration and pre-prod, use two -i inclusion flags to run only integration and pre-production tests: clojure -M:test-runner-cognitect -i :integration -i :pre-prod Clojure Unit Test - categories example integration and develop tests Use the e exclusion flag to run all tests except those in specific categories clojure -M:test-runner-cognitect -e :integration Exclusions take priority over inclusions if both flags are included. Hint::Category examples \u03bb\ufe0e On larger projects categories reduce the amount of time spent running tests to ensure regressions have not taken place. During a project at a large financial institution, tests were organised in the following categories :develop , :integration , data-loading , :data-migration , and :pre-production .","title":"Cognitect Labs Test Runner"},{"location":"testing/test-runners/congnitect-labs-test-runner/#cognitect-labs-test-runner","text":"test-runner is a test runner for Clojure projects defined with deps.edn and using clojure.test library which is part of the Clojure standard library. test-runner aims to provide a standard way to discover and run unit and property-based tests, in a simple to use and lightweight tool.","title":"Cognitect Labs Test Runner"},{"location":"testing/test-runners/congnitect-labs-test-runner/#adding-test-runner","text":"Make test-runner available to all projects by adding it to ~/.clojure/deps.edn . Or add test-runner to specific projects by adding an alias to the project deps.edn file. Include :extra-paths configuration to include the standard test directory so that the runner has access to the test code. :test-runner-cognitect { :extra-paths [ \"test\" ] :extra-deps { com.cognitect/test-runner { :git/url \"https://github.com/cognitect-labs/test-runner.git\" :sha \"f7ef16dc3b8332b0d77bc0274578ad5270fbfedd\" }} :main-opts [ \"-m\" \"cognitect.test-runner\" ]}","title":"Adding test-runner"},{"location":"testing/test-runners/congnitect-labs-test-runner/#hintuse-practicalliclojure-deps-edn-to-add-common-tools","text":"Fork and clone the practicalli/clojure-deps-edn GitHub repository to instantly have access to dozens of tools for Clojure software development","title":"Hint::Use practicalli/clojure-deps-edn to add common tools"},{"location":"testing/test-runners/congnitect-labs-test-runner/#running-the-test-runner","text":"Then, invoke Clojure via the command line, invoking the test alias: clojure -M:test-runner-cognitect This calls the cognitect.test-runner/-main function which will scan the test directory of the current project for any tests defined using clojure.test and then run all the tests found. A summary is returned with the results of running the tests. TODO: screenshot of summary","title":"Running the test runner"},{"location":"testing/test-runners/congnitect-labs-test-runner/#additional-command-line-options","text":"Flag Description -d, --dir DIRNAME Name of the directory containing tests. Defaults to \"test\". -n, --namespace SYMBOL Symbol indicating a specific namespace to test. -r, --namespace-regex REGEX Regex for namespaces to test. Defaults to #\".*-test$\" (i.e, only namespaces ending in '-test' are evaluated) -v, --var SYMBOL Symbol indicating the fully qualified name of a specific test. -i, --include KEYWORD Run only tests that have this metadata keyword. -e, --exclude KEYWORD Exclude tests with this metadata keyword. -H, --test-help Display this help message Options can be used multiple times in one command, for a logical OR effect. For example, the following command runs all tests in the practicalli.data.survey and practicalli.services.survey-report namespaces that are found in the src and test directories clojure -M:test-runner-cognitect -d test -d src -n practicalli.data.survey -n practicalli.services.survey-report","title":"Additional command line options:"},{"location":"testing/test-runners/congnitect-labs-test-runner/#categorizing-tests-for-selective-test-runs","text":"Integration tests tend to take longer to run as they use larger data sets and/run a or more comprehensive set of tests. Categorizing tests is an approach to using test runners effectively, by selectively running tests at different stages of development. Use Clojure metadata when defining test functions using deftest . ( deftest ^ :integration test-live-system ( is ( = 200 ( :status ( http/get \"http://example.com\" ))))) Use the i inclusion flag with the test runner to specify specific categories of tests clojure -M:test-runner-cognitect -i :integration Categories can be used together by using multiple flags. Assuming categories of develop, uat, integration and pre-prod, use two -i inclusion flags to run only integration and pre-production tests: clojure -M:test-runner-cognitect -i :integration -i :pre-prod Clojure Unit Test - categories example integration and develop tests Use the e exclusion flag to run all tests except those in specific categories clojure -M:test-runner-cognitect -e :integration Exclusions take priority over inclusions if both flags are included.","title":"Categorizing tests for selective test runs"},{"location":"testing/test-runners/congnitect-labs-test-runner/#hintcategory-examples","text":"On larger projects categories reduce the amount of time spent running tests to ensure regressions have not taken place. During a project at a large financial institution, tests were organised in the following categories :develop , :integration , data-loading , :data-migration , and :pre-production .","title":"Hint::Category examples"},{"location":"testing/test-runners/example-projects/","text":"Example projects \u03bb\ufe0e TDD Kata: Recent Song-list - simple tests examples Codewars: Rock Paper Scissors (lizard spock) solution - and examples practicalli/numbers-to-words - overly verbose example, ripe for refactor practicalli/codewars-guides - deps.edn projects practicalli/exercism-clojure-guides - Leiningen projects Sean Corfield - user manager \u03bb\ufe0e User manager has unit tests that also include an embedded database. Tests can run with the Cognitect Labs test runner. :test alias includes the test path and a dependency for the H2 database Cognitect Labs test runner included in the project deps.edn file as :runner clojure -M:test:runner will run the Cognitect Labs runner and include the dependency to run the in-memory database used for the tests. Using koacha with Sean Corfield user manager \u03bb\ufe0e Adding a test.edn file is not sufficient for testing this project with lambdaisland/kaocha, as the H2 dependency is also needed. Create a bin/koacha script and add the extra alias #!/usr/bin/env bash clojure -M:test:test-runner-kaocha \" $@ \" Status Monitor \u03bb\ufe0e Status monitor is a Leiningen project. Include a :kaocha profile in the project.clj file, adding the koacha dependency. The :kaocha alias sets the main namespace and uses the kaocha profile. { :dev { :dependencies [[ javax.servlet/servlet-api \"2.5\" ] [ ring/ring-mock \"0.3.2\" ]]} :kaocha { :dependencies [[ lambdaisland/kaocha \"1.0.632\" ]]}} :aliases { \"kaocha\" [ \"with-profile\" \"+kaocha\" \"run\" \"-m\" \"kaocha.runner\" ]} lein kaocha will run all the tests","title":"Example projects"},{"location":"testing/test-runners/example-projects/#example-projects","text":"TDD Kata: Recent Song-list - simple tests examples Codewars: Rock Paper Scissors (lizard spock) solution - and examples practicalli/numbers-to-words - overly verbose example, ripe for refactor practicalli/codewars-guides - deps.edn projects practicalli/exercism-clojure-guides - Leiningen projects","title":"Example projects"},{"location":"testing/test-runners/example-projects/#sean-corfield-user-manager","text":"User manager has unit tests that also include an embedded database. Tests can run with the Cognitect Labs test runner. :test alias includes the test path and a dependency for the H2 database Cognitect Labs test runner included in the project deps.edn file as :runner clojure -M:test:runner will run the Cognitect Labs runner and include the dependency to run the in-memory database used for the tests.","title":"Sean Corfield - user manager"},{"location":"testing/test-runners/example-projects/#using-koacha-with-sean-corfield-user-manager","text":"Adding a test.edn file is not sufficient for testing this project with lambdaisland/kaocha, as the H2 dependency is also needed. Create a bin/koacha script and add the extra alias #!/usr/bin/env bash clojure -M:test:test-runner-kaocha \" $@ \"","title":"Using koacha with Sean Corfield user manager"},{"location":"testing/test-runners/example-projects/#status-monitor","text":"Status monitor is a Leiningen project. Include a :kaocha profile in the project.clj file, adding the koacha dependency. The :kaocha alias sets the main namespace and uses the kaocha profile. { :dev { :dependencies [[ javax.servlet/servlet-api \"2.5\" ] [ ring/ring-mock \"0.3.2\" ]]} :kaocha { :dependencies [[ lambdaisland/kaocha \"1.0.632\" ]]}} :aliases { \"kaocha\" [ \"with-profile\" \"+kaocha\" \"run\" \"-m\" \"kaocha.runner\" ]} lein kaocha will run all the tests","title":"Status Monitor"},{"location":"testing/test-runners/kaocha-test-runner/","text":"Kaocha Test Runner from LambdaIsland \u03bb\ufe0e lambdaisland/kaocha (cow-cha) is a comprehensive test runner that support unit testing and clojure.spec generative testing. Clojure and ClojureScript languages are supported. A minimal starting point \u03bb\ufe0e Install the practicalli/clojure-deps-edn configuration to call kaocha from the root directory of a project which contains clojure.test defined unit tests under a test directory structure. clojure -M:test/run Or continually run tests by watching for changes with Kaocha. If a test fails, Koacha will stop the test run and restart from the failing test when a change is detected. clojure -M:test/watch Add kaocha binary to the project project \u03bb\ufe0e Kaocha recommends adding a bin/kaocha script to the project, providing a standard location from which to run kaocha and to include project command line options. Command line options will over-ride the same options in the tests.edn file. #!/usr/bin/env bash clojure -M:test/runner \" $@ \" Continuous Integration support \u03bb\ufe0e For CI services such as CircleCI or GitLabs, add an alias for kaocha to the project deps.edn file. :test/runner { :extra-paths [ \"test\" ] :extra-deps { lambdaisland/kaocha { :mvn/version \"1.0.700\" }} :main-opts [ \"-m\" \"kaocha.runner\" ]} Configuring test runs \u03bb\ufe0e Kaocha can be configure by options in a tests.edn configuration file and options passed via the command line (typically added to the bin/kaocha script). Create a tests.edn file in the root of the project directory. #kaocha/v1 {} is the minimum configuration, which will use a default configuration. The tests.edn file and command line options combine to make the complete configuration for the projects in the test. bin/kaocha --print-config will print out the complete configuration. Use the default configuration as a basis for customizing any specific project. Hint::Alternative kaocha configuration with aero \u03bb\ufe0e juxt/aero reader literals such as #env, #merge, #ref, and #include can be used to provide different options to the kaocha configuration. For example, a file change watcher can be configured to run unless kaocha is running in CI server environment. :kaocha/watch #profile {:default true :ci false} Running tests \u03bb\ufe0e With a deps.edn project with tests under the standard test directory and using -test postfix on test names, then all that is required is the kaocha command bin/kaocha If one or more tests fail, then a detailed description of the failure is printed The report progress plugin gives visual feedback as the tests are running. bin/kaocha --reporter kaocha.report.progress/report Stop testing on the first failure with the --fail-fast flag. Especially useful when running larger numbers of tests or slower running tests. kaocha --fail-fast Tests are run in a random order, controlled by a seed in the test.edn configuration. This helps find dependencies between tests where a test is only passing because of another test (or more likely the setup stage or lack of tear down from another test). The --no-randomize flag will run the tests in the same order each time. --print-result will return a hash-map of the test results. This is a very detailed output, so I assume its more suitable for diagnostic tools or viewing in a data browser (eg. Clojure inspector, REBL, etc.) --watch flag enables watch mode which monitors file changes in source and test paths (from the kaocha configuration), loads in changes and runs tests again. TODO: rerun just the tests that changed ?? Plugins \u03bb\ufe0e Much of the functionality of Kaocha is provide by plugins profiling - lists the slowest tests for each test category cucumber - bdd style test junit-xml reports - format used by Continuous Integration servers to display results Profiling \u03bb\ufe0e Show the 3 slowest tests for each category of test, after the test results As a command line option: bin/kaocha --plugin kaocha.plugin/profiling or added to the test.edn configuration # kaocha/v1 { :plugins [ :kaocha.plugin/profiling ]} Example: banking-on-clojure project \u03bb\ufe0e The practicalli/banking-on-clojure project is a web application backed by a relational database, using kaocha as the test runner. :kaocha/tests defines two types of tests. The hash-map containing :kaocha.testable/id :unit defines the configuration for unit tests using clojure.test . The hash-map containing :kaocha.testable/id :generative-fdef-checks are generative tests using clojure spec. :kaocha/color? and :kaocha/watch use a value dependent on the #profile kaocha is run under. # kaocha/v1 { :kaocha/tests [{ :kaocha.testable/id :unit :kaocha.testable/type :kaocha.type/clojure.test :kaocha/ns-patterns [ \"-test$\" ] , :kaocha/source-paths [ \"src\" ] , :kaocha/test-paths [ \"test\" ] , :kaocha.filter/skip-meta [ :kaocha/skip ]} { :kaocha.testable/id :generative-fdef-checks :kaocha.testable/type :kaocha.type/spec.test.check :kaocha/source-paths [ \"src\" ] :kaocha.spec.test.check/checks [{ :kaocha.spec.test.check/syms :all-fdefs :clojure.spec.test.check/instrument? true :clojure.spec.test.check/check-asserts? true :clojure.spec.test.check/opts { :num-tests 10 }}]} ] :kaocha/reporter [ kaocha.report/documentation ] :kaocha/color? # profile { :default true :ci false } ;; Run tests of file changes, unless running in CI server :kaocha/watch # profile { :default true :ci false } :kaocha/fail-fast? true :kaocha.plugin.randomize/randomize? false :kaocha/plugins [ :kaocha.plugin/randomize :kaocha.plugin/filter :kaocha.plugin/capture-output :kaocha.plugin.alpha/spec-test-check ] :kaocha.plugin.capture-output/capture-output? true } The above configuration could be streamlined and rely on more of the default values, but does show examples of how to configure different sections explicitly.","title":"Kaocha Test Runner from LambdaIsland"},{"location":"testing/test-runners/kaocha-test-runner/#kaocha-test-runner-from-lambdaisland","text":"lambdaisland/kaocha (cow-cha) is a comprehensive test runner that support unit testing and clojure.spec generative testing. Clojure and ClojureScript languages are supported.","title":"Kaocha Test Runner from LambdaIsland"},{"location":"testing/test-runners/kaocha-test-runner/#a-minimal-starting-point","text":"Install the practicalli/clojure-deps-edn configuration to call kaocha from the root directory of a project which contains clojure.test defined unit tests under a test directory structure. clojure -M:test/run Or continually run tests by watching for changes with Kaocha. If a test fails, Koacha will stop the test run and restart from the failing test when a change is detected. clojure -M:test/watch","title":"A minimal starting point"},{"location":"testing/test-runners/kaocha-test-runner/#add-kaocha-binary-to-the-project-project","text":"Kaocha recommends adding a bin/kaocha script to the project, providing a standard location from which to run kaocha and to include project command line options. Command line options will over-ride the same options in the tests.edn file. #!/usr/bin/env bash clojure -M:test/runner \" $@ \"","title":"Add kaocha binary to the project project"},{"location":"testing/test-runners/kaocha-test-runner/#continuous-integration-support","text":"For CI services such as CircleCI or GitLabs, add an alias for kaocha to the project deps.edn file. :test/runner { :extra-paths [ \"test\" ] :extra-deps { lambdaisland/kaocha { :mvn/version \"1.0.700\" }} :main-opts [ \"-m\" \"kaocha.runner\" ]}","title":"Continuous Integration support"},{"location":"testing/test-runners/kaocha-test-runner/#configuring-test-runs","text":"Kaocha can be configure by options in a tests.edn configuration file and options passed via the command line (typically added to the bin/kaocha script). Create a tests.edn file in the root of the project directory. #kaocha/v1 {} is the minimum configuration, which will use a default configuration. The tests.edn file and command line options combine to make the complete configuration for the projects in the test. bin/kaocha --print-config will print out the complete configuration. Use the default configuration as a basis for customizing any specific project.","title":"Configuring test runs"},{"location":"testing/test-runners/kaocha-test-runner/#hintalternative-kaocha-configuration-with-aero","text":"juxt/aero reader literals such as #env, #merge, #ref, and #include can be used to provide different options to the kaocha configuration. For example, a file change watcher can be configured to run unless kaocha is running in CI server environment. :kaocha/watch #profile {:default true :ci false}","title":"Hint::Alternative kaocha configuration with aero"},{"location":"testing/test-runners/kaocha-test-runner/#running-tests","text":"With a deps.edn project with tests under the standard test directory and using -test postfix on test names, then all that is required is the kaocha command bin/kaocha If one or more tests fail, then a detailed description of the failure is printed The report progress plugin gives visual feedback as the tests are running. bin/kaocha --reporter kaocha.report.progress/report Stop testing on the first failure with the --fail-fast flag. Especially useful when running larger numbers of tests or slower running tests. kaocha --fail-fast Tests are run in a random order, controlled by a seed in the test.edn configuration. This helps find dependencies between tests where a test is only passing because of another test (or more likely the setup stage or lack of tear down from another test). The --no-randomize flag will run the tests in the same order each time. --print-result will return a hash-map of the test results. This is a very detailed output, so I assume its more suitable for diagnostic tools or viewing in a data browser (eg. Clojure inspector, REBL, etc.) --watch flag enables watch mode which monitors file changes in source and test paths (from the kaocha configuration), loads in changes and runs tests again. TODO: rerun just the tests that changed ??","title":"Running tests"},{"location":"testing/test-runners/kaocha-test-runner/#plugins","text":"Much of the functionality of Kaocha is provide by plugins profiling - lists the slowest tests for each test category cucumber - bdd style test junit-xml reports - format used by Continuous Integration servers to display results","title":"Plugins"},{"location":"testing/test-runners/kaocha-test-runner/#profiling","text":"Show the 3 slowest tests for each category of test, after the test results As a command line option: bin/kaocha --plugin kaocha.plugin/profiling or added to the test.edn configuration # kaocha/v1 { :plugins [ :kaocha.plugin/profiling ]}","title":"Profiling"},{"location":"testing/test-runners/kaocha-test-runner/#example-banking-on-clojure-project","text":"The practicalli/banking-on-clojure project is a web application backed by a relational database, using kaocha as the test runner. :kaocha/tests defines two types of tests. The hash-map containing :kaocha.testable/id :unit defines the configuration for unit tests using clojure.test . The hash-map containing :kaocha.testable/id :generative-fdef-checks are generative tests using clojure spec. :kaocha/color? and :kaocha/watch use a value dependent on the #profile kaocha is run under. # kaocha/v1 { :kaocha/tests [{ :kaocha.testable/id :unit :kaocha.testable/type :kaocha.type/clojure.test :kaocha/ns-patterns [ \"-test$\" ] , :kaocha/source-paths [ \"src\" ] , :kaocha/test-paths [ \"test\" ] , :kaocha.filter/skip-meta [ :kaocha/skip ]} { :kaocha.testable/id :generative-fdef-checks :kaocha.testable/type :kaocha.type/spec.test.check :kaocha/source-paths [ \"src\" ] :kaocha.spec.test.check/checks [{ :kaocha.spec.test.check/syms :all-fdefs :clojure.spec.test.check/instrument? true :clojure.spec.test.check/check-asserts? true :clojure.spec.test.check/opts { :num-tests 10 }}]} ] :kaocha/reporter [ kaocha.report/documentation ] :kaocha/color? # profile { :default true :ci false } ;; Run tests of file changes, unless running in CI server :kaocha/watch # profile { :default true :ci false } :kaocha/fail-fast? true :kaocha.plugin.randomize/randomize? false :kaocha/plugins [ :kaocha.plugin/randomize :kaocha.plugin/filter :kaocha.plugin/capture-output :kaocha.plugin.alpha/spec-test-check ] :kaocha.plugin.capture-output/capture-output? true } The above configuration could be streamlined and rely on more of the default values, but does show examples of how to configure different sections explicitly.","title":"Example: banking-on-clojure project"},{"location":"testing/unit-testing/","text":"The function is the unit under test in Clojure. All public functions that form the API of their respective namespace should have a matching test, i.e. (deftest) definition. clojure.test namespace provides functions for defining and running unit tests and is available in the Clojure library for any project to use. Principles for writing unit tests \u03bb\ufe0e A test namespace for each src namespace under test A deftest function for each function under test, named after the function its testing with -test at the end of the name Multiple assertions ( is are ) for one function is defines an assertion returning true (test pass) or false (test fail), typically a comparison between a known value and the result of a function call are to testing similar functionality with different data sets (or use generative testing) testing to logically group assertions and provide a meaningful description of that grouping (easier to identify tests when they fail) use-fixtures to call fixture functions that setup and tear down any state required for test(s) to run Test API rather than implementation test generic helper or private functions through public functions of each namespace (minimise test churn and time to run all tests) ^:helper meta-data on deftest for more generic functions, to skip those tests via a test selector Use generative testing to create more maintainable test code with more extensive range of data Use test selectors with a test runner to selectively run tests and optimise speed of test runs Limit mocking of systems to integration tests (although mocking data is good everywhere) Running tests \u03bb\ufe0e Test runners can run be run in the REPL used for development or run separately via the command line and continuous integration tasks. Run tests in Editor connected REPL \u03bb\ufe0e Using an editor connected REPL keeps the workflow in one tool and helps maintain focus. Using editor commands to run the tests and navigable error reports provides an effective flow to run and debug issues. Ensure test directory is on the class path when evaluating tests in the REPL, otherwise the (deftest) test definitions may not be found. If functions or their associated tests are changed, they should be evaluated in the REPL before running tests to ensure those changes are loaded into the REPL. If renaming a function or deftest , the original name should be removed from the REPL to avoid phantom tests (older definitions of tests that were evaluated in the REPL and still run, even though those tests are no longer in the source code). Editors may include a command to remove function or test definitions, e.g. CIDER has undef command The original name can also be removed using Clojure (ns-unmap 'namespace 'name) , where namespace is where the name of the function or test is defined and name is the name of the function or test. ( ns practicalli.system-monitor ) ; namespace definition ( defn dashboard [] ,,, ) ; original function name ( defn dashboard-page [] ,,, ) ; new function name ( undef 'practicalli.system-monitor 'dashboard ) ; remove original function name Stop and start the REPL process ensures all function and tests are correctly loaded Command line test runners \u03bb\ufe0e Command line test runners (i.e. koacha, Cognitect Labs) load function and test definitions from the source code files each time, ensuring tests are run and a clean REPL state is created on each run. This clearly defined REPL state is especially valuable for running repeatable integration tests. Automate running the tests using a watch process, giving instant fast feedback, especially when displaying both the editor and test runner command line. test runner can be configure to run only selective tests (i.e kaocha) Run all tests (including integration tests) via the command line before pushing commits to ensure all changes to the code have been tested. If tests are not running in the REPL or are returning unexpected errors, a command line test runner is a useful way to diagnose if it is the test code or test tools causing the error. The CLI approach is also more robust for longer running tests than running within an editor. HINT::Avoid stale tests \u03bb\ufe0e Running tests via a command line test runner will never experience stale tests, as long as all relevant changes are saved to the source code files. Run tests in the REPL \u03bb\ufe0e clojure.test includes the run-tests function that runs tests ( deftest definitions) in given namespaces and run-all-tests which runs all tests in all namespaces. ( run-all-tests ) ; run all tests in all namespaces ( run-tests 'practicalli.system-monitor-test ) ; run all tests in practicalli.system-monitor-test run-tests and run-all-tests are a less common approach as the command line and editor driven test runners provide a rich set of features Project structure with tests \u03bb\ufe0e For each source code file in src there should be a corresponding file in test directory with the same name and _test postfix. For example, code to test the src/codewars/rock_paper_scissors.clj is saved in the file src/codewars/rock_paper_scissors_test.clj file. Example project: CodeWars: Rock Paper Scissors Source and Test Namespaces \u03bb\ufe0e As with file names, the namespaces for each test code file is the same as the source code it is testing, with a -test postfix. codewars/rock-paper-scissors source code namespace will have a matching codewars/rock-paper-scissors-test namespace. Hint::Create Projects from templates \u03bb\ufe0e Templates typically include a parallel test and src directory structure. The clj-new tool has build it templates (app, lib) and will create src and test directories in the projects it creates. clojure -T:project/new :template app :name practicalli/rock-paper-scissors-lizard-spock Project Examples: Code challenges with unit tests \u03bb\ufe0e TDD Kata: Recent Song-list - simple tests examples Codewars: Rock Paper Scissors (lizard spock) solution - and examples practicalli/numbers-to-words - overly verbose example, ripe for refactor practicalli/codewars-guides - deps.edn projects practicalli/exercism-clojure-guides - Leiningen projects References \u03bb\ufe0e Example based unit testing in Clojure - PurelyFunctional.tv","title":"Index"},{"location":"testing/unit-testing/#principles-for-writing-unit-tests","text":"A test namespace for each src namespace under test A deftest function for each function under test, named after the function its testing with -test at the end of the name Multiple assertions ( is are ) for one function is defines an assertion returning true (test pass) or false (test fail), typically a comparison between a known value and the result of a function call are to testing similar functionality with different data sets (or use generative testing) testing to logically group assertions and provide a meaningful description of that grouping (easier to identify tests when they fail) use-fixtures to call fixture functions that setup and tear down any state required for test(s) to run Test API rather than implementation test generic helper or private functions through public functions of each namespace (minimise test churn and time to run all tests) ^:helper meta-data on deftest for more generic functions, to skip those tests via a test selector Use generative testing to create more maintainable test code with more extensive range of data Use test selectors with a test runner to selectively run tests and optimise speed of test runs Limit mocking of systems to integration tests (although mocking data is good everywhere)","title":"Principles for writing unit tests"},{"location":"testing/unit-testing/#running-tests","text":"Test runners can run be run in the REPL used for development or run separately via the command line and continuous integration tasks.","title":"Running tests"},{"location":"testing/unit-testing/#run-tests-in-editor-connected-repl","text":"Using an editor connected REPL keeps the workflow in one tool and helps maintain focus. Using editor commands to run the tests and navigable error reports provides an effective flow to run and debug issues. Ensure test directory is on the class path when evaluating tests in the REPL, otherwise the (deftest) test definitions may not be found. If functions or their associated tests are changed, they should be evaluated in the REPL before running tests to ensure those changes are loaded into the REPL. If renaming a function or deftest , the original name should be removed from the REPL to avoid phantom tests (older definitions of tests that were evaluated in the REPL and still run, even though those tests are no longer in the source code). Editors may include a command to remove function or test definitions, e.g. CIDER has undef command The original name can also be removed using Clojure (ns-unmap 'namespace 'name) , where namespace is where the name of the function or test is defined and name is the name of the function or test. ( ns practicalli.system-monitor ) ; namespace definition ( defn dashboard [] ,,, ) ; original function name ( defn dashboard-page [] ,,, ) ; new function name ( undef 'practicalli.system-monitor 'dashboard ) ; remove original function name Stop and start the REPL process ensures all function and tests are correctly loaded","title":"Run tests in Editor connected REPL"},{"location":"testing/unit-testing/#command-line-test-runners","text":"Command line test runners (i.e. koacha, Cognitect Labs) load function and test definitions from the source code files each time, ensuring tests are run and a clean REPL state is created on each run. This clearly defined REPL state is especially valuable for running repeatable integration tests. Automate running the tests using a watch process, giving instant fast feedback, especially when displaying both the editor and test runner command line. test runner can be configure to run only selective tests (i.e kaocha) Run all tests (including integration tests) via the command line before pushing commits to ensure all changes to the code have been tested. If tests are not running in the REPL or are returning unexpected errors, a command line test runner is a useful way to diagnose if it is the test code or test tools causing the error. The CLI approach is also more robust for longer running tests than running within an editor.","title":"Command line test runners"},{"location":"testing/unit-testing/#hintavoid-stale-tests","text":"Running tests via a command line test runner will never experience stale tests, as long as all relevant changes are saved to the source code files.","title":"HINT::Avoid stale tests"},{"location":"testing/unit-testing/#run-tests-in-the-repl","text":"clojure.test includes the run-tests function that runs tests ( deftest definitions) in given namespaces and run-all-tests which runs all tests in all namespaces. ( run-all-tests ) ; run all tests in all namespaces ( run-tests 'practicalli.system-monitor-test ) ; run all tests in practicalli.system-monitor-test run-tests and run-all-tests are a less common approach as the command line and editor driven test runners provide a rich set of features","title":"Run tests in the REPL"},{"location":"testing/unit-testing/#project-structure-with-tests","text":"For each source code file in src there should be a corresponding file in test directory with the same name and _test postfix. For example, code to test the src/codewars/rock_paper_scissors.clj is saved in the file src/codewars/rock_paper_scissors_test.clj file. Example project: CodeWars: Rock Paper Scissors","title":"Project structure with tests"},{"location":"testing/unit-testing/#source-and-test-namespaces","text":"As with file names, the namespaces for each test code file is the same as the source code it is testing, with a -test postfix. codewars/rock-paper-scissors source code namespace will have a matching codewars/rock-paper-scissors-test namespace.","title":"Source and Test Namespaces"},{"location":"testing/unit-testing/#hintcreate-projects-from-templates","text":"Templates typically include a parallel test and src directory structure. The clj-new tool has build it templates (app, lib) and will create src and test directories in the projects it creates. clojure -T:project/new :template app :name practicalli/rock-paper-scissors-lizard-spock","title":"Hint::Create Projects from templates"},{"location":"testing/unit-testing/#project-examples-code-challenges-with-unit-tests","text":"TDD Kata: Recent Song-list - simple tests examples Codewars: Rock Paper Scissors (lizard spock) solution - and examples practicalli/numbers-to-words - overly verbose example, ripe for refactor practicalli/codewars-guides - deps.edn projects practicalli/exercism-clojure-guides - Leiningen projects","title":"Project Examples: Code challenges with unit tests"},{"location":"testing/unit-testing/#references","text":"Example based unit testing in Clojure - PurelyFunctional.tv","title":"References"},{"location":"testing/unit-testing/clojure-test-expectations/","text":"clojure.test Expectations \u03bb\ufe0e Add expectation style unit testing to clojure.test based tests. clojure.test.expectations uses the same tooling as clojure.test and only depends on that library. Using a deps.edn alias \u03bb\ufe0e practicalli/clojure-deps-edn Add dependency \u03bb\ufe0e Edit the deps.edn file for the current project","title":"`clojure.test` Expectations"},{"location":"testing/unit-testing/clojure-test-expectations/#clojuretest-expectations","text":"Add expectation style unit testing to clojure.test based tests. clojure.test.expectations uses the same tooling as clojure.test and only depends on that library.","title":"clojure.test Expectations"},{"location":"testing/unit-testing/clojure-test-expectations/#using-a-depsedn-alias","text":"practicalli/clojure-deps-edn","title":"Using a deps.edn alias"},{"location":"testing/unit-testing/clojure-test-expectations/#add-dependency","text":"Edit the deps.edn file for the current project","title":"Add dependency"},{"location":"testing/unit-testing/configure-projects-for-tests/","text":"Configure Unit Testing for deps.edn projects \u03bb\ufe0e clojure.test namespace is part of the Clojure standard library, so the Clojure library is the only dependency required in the project. { :deps { org.clojure/clojure { :mvn/version \"1.10.3\" }}} Unit tests code should reside under the test directory of a project. The test directory should not be part of the main classpath, otherwise test classes would be included in the project packaging and deployed to production. Use an alias to add the test directory, either from a user level configuration or the Clojure project deps.edn configuration file. {% tabs practicalli=\"practicalli/clojure-deps-edn\", deps=\"Manual deps.edn projects\" %} {% content \"practicalli\" %} Adding test path \u03bb\ufe0e practicalli/clojure-deps-edn user-level configuration contains several aliases for Clojure and ClojureScript test runners, each alias includes the test directory as an :extra-path . :env/test alias is also provided, which simply adds the test directory to the class path. The :env/test alias is useful in concert with other aliases or for editors that have their own built in test runners (e.g. CIDER). Using kaocha test runner \u03bb\ufe0e lambdaisland/kaocha is a fast and comprehensive test runner for Clojure and ClojureScript. :test/run alias runs all tests from the source code files, called with the clojure command in the root of the Clojure project. The alias includes test as an extra path and calls the Kaocha test runner. clojure -X:test/run Kaocha can also watch for changes saved to file and re-run the tests. clojure -X:test/watch Both kaocha aliases are configured to stop if a test fails. When re-running kaocha, only failed tests and tests that have changed are run (including tests where the code they are testing has changed). {% content \"deps\" %} Alias to include the test directory \u03bb\ufe0e Add the following aliases to the Clojure CLI tools user wide configuration, (e.g. ~/.clojure/deps.edn ), or to the project deps.edn file. To use a test runners with a deps.edn projects, the test directory should be on the classpath. practicalli/clojure-deps-edn defines an environment alias to include the test path. :aliases { :env/test { :extra-paths [ \"test\" ]} } {% endtabs %} Cognitect labs Clojure test runner \u03bb\ufe0e :test/cognitect is a simple to use test runner for Clojure projects. clojure -X :test/cognitect Kaocha unit test and clojure spec runner \u03bb\ufe0e :test/kaocha alias unit test runner that also supports Clojure Spec functional tests. the kaocha test runner on the current project. Add a test.edn file to configure which tests are run by kaocha. clojure -X:test/kaocha References \u03bb\ufe0e Practicalli Spacemacs - Unit testing with Cider and Kaocha in Emacs lambdaisland/kaocha is a test runner that supports Clojure CLI, Leiningen and Boot project configuration. Leiningen project configuration for unit testing","title":"Configure Unit Testing for deps.edn projects"},{"location":"testing/unit-testing/configure-projects-for-tests/#configure-unit-testing-for-depsedn-projects","text":"clojure.test namespace is part of the Clojure standard library, so the Clojure library is the only dependency required in the project. { :deps { org.clojure/clojure { :mvn/version \"1.10.3\" }}} Unit tests code should reside under the test directory of a project. The test directory should not be part of the main classpath, otherwise test classes would be included in the project packaging and deployed to production. Use an alias to add the test directory, either from a user level configuration or the Clojure project deps.edn configuration file. {% tabs practicalli=\"practicalli/clojure-deps-edn\", deps=\"Manual deps.edn projects\" %} {% content \"practicalli\" %}","title":"Configure Unit Testing for deps.edn projects"},{"location":"testing/unit-testing/configure-projects-for-tests/#adding-test-path","text":"practicalli/clojure-deps-edn user-level configuration contains several aliases for Clojure and ClojureScript test runners, each alias includes the test directory as an :extra-path . :env/test alias is also provided, which simply adds the test directory to the class path. The :env/test alias is useful in concert with other aliases or for editors that have their own built in test runners (e.g. CIDER).","title":"Adding test path"},{"location":"testing/unit-testing/configure-projects-for-tests/#using-kaocha-test-runner","text":"lambdaisland/kaocha is a fast and comprehensive test runner for Clojure and ClojureScript. :test/run alias runs all tests from the source code files, called with the clojure command in the root of the Clojure project. The alias includes test as an extra path and calls the Kaocha test runner. clojure -X:test/run Kaocha can also watch for changes saved to file and re-run the tests. clojure -X:test/watch Both kaocha aliases are configured to stop if a test fails. When re-running kaocha, only failed tests and tests that have changed are run (including tests where the code they are testing has changed). {% content \"deps\" %}","title":"Using kaocha test runner"},{"location":"testing/unit-testing/configure-projects-for-tests/#alias-to-include-the-test-directory","text":"Add the following aliases to the Clojure CLI tools user wide configuration, (e.g. ~/.clojure/deps.edn ), or to the project deps.edn file. To use a test runners with a deps.edn projects, the test directory should be on the classpath. practicalli/clojure-deps-edn defines an environment alias to include the test path. :aliases { :env/test { :extra-paths [ \"test\" ]} } {% endtabs %}","title":"Alias to include the test directory"},{"location":"testing/unit-testing/configure-projects-for-tests/#cognitect-labs-clojure-test-runner","text":":test/cognitect is a simple to use test runner for Clojure projects. clojure -X :test/cognitect","title":"Cognitect labs Clojure test runner"},{"location":"testing/unit-testing/configure-projects-for-tests/#kaocha-unit-test-and-clojure-spec-runner","text":":test/kaocha alias unit test runner that also supports Clojure Spec functional tests. the kaocha test runner on the current project. Add a test.edn file to configure which tests are run by kaocha. clojure -X:test/kaocha","title":"Kaocha unit test and clojure spec runner"},{"location":"testing/unit-testing/configure-projects-for-tests/#references","text":"Practicalli Spacemacs - Unit testing with Cider and Kaocha in Emacs lambdaisland/kaocha is a test runner that supports Clojure CLI, Leiningen and Boot project configuration. Leiningen project configuration for unit testing","title":"References"},{"location":"testing/unit-testing/fixtures/","text":"Fixtures: setup and tear down for unit tests \u03bb\ufe0e Unit tests may require the system to be in a particular state before running a test. The state may need to be reset after running a test such as a database Fixtures allow you to run code before and after tests, to set up the context in which tests should be run. Consider when fixtures should be run, especially fixtures that take a noticeable time to setup or tear down. Slow running unit tests lead to unit tests not being run so often and therefore limit their value. Hint::Organize tests with test selectors \u03bb\ufe0e Tests with fixtures may be slower to run so separate them by using a test selector , a piece of meta data attached to a deftest definition. For example, add the ^:database meta data to test that require database fixtures (deftest ^:database db-bulk-upload). The test runner can be instructed to skip or focus on tests with specific meta data. Defining a fixture \u03bb\ufe0e A fixture is a standard Clojure function which takes a function as an argument. The function passed as an argument is either an individual test or all tests in the namespace, depending on how the fixture is used. ( defn my-fixture [ test-run ] ;; Setup: define bindings, create state, etc. ( test-run ) ;; Run the relevant tests for the fixture (see `use-fixtures`) ;; Tear-down: reset state to a known value ) Requires for clojure.test fixtures \u03bb\ufe0e To use those fixtures in a test run, include the use-fixtures function in the require expression for clojure.test ( ns domain.application-test ( :require [ clojure.test :refer [ deftest is testing use-fixtures ]])) As fixtures are simply Clojure functions there are no additional requirements to define those functions. When to run fixtures \u03bb\ufe0e The use-fixtures function defines when a fixture should be called when running the unit tests in each namespace. All Clojure unit test runners should support the use-fixtures definitions when running the tests. When Description (use-fixtures :once fixture1 fixture2) Run the fixtures once for the namespace. (use-fixtures :each fixture1 fixture2) Run the fixtures for each `deftest** in the namespace Once The setup in the fixture is run, followed by all the deftest functions in the namespace, then the fixture tear-down is run. Running a fixture once per namespace is useful for establishing a database connection or creating a particular state of data for all the unit tests to use. Each The fixture setup is run before each deftest function in the namespace. The fixture tear-down is run after each deftest function. Anonymous functions as fixtures \u03bb\ufe0e The use-fixtures function can also include anonymous function as well as a namespace scoped functions ( deftest ). ( use-fixtures :each ( fn [ f ] # _setup... ( f ) # _teardown )) defn functions are usually recommended unless the fixture code is relatively terse. Example: development database \u03bb\ufe0e Define a fixture to reset the database before running a test and clear the database after each test. The create-database and delete-database are helper functions that are part of the namespace under test. ( defn database-reset-fixture \"Setup: drop all tables, creates new tables Teardown: drop all tables SQL schema code has if clauses to avoid errors running SQL code. Arguments: test-function - a function to run a specific test\" [ test-function ] ( SUT/create-database ) ( test-function ) ( SUT/delete-database )) The fixture should be used for each unit test ( deftest ) that is defined in the namespace the database-reset-fixture is defined in. ( use-fixtures :each database-reset-fixture ) References \u03bb\ufe0e use-fixtures - Clojuredocs.org Kaocha - focusing and skipping Clojure Test Fixtures - astrocaribe","title":"Fixtures: setup and tear down for unit tests"},{"location":"testing/unit-testing/fixtures/#fixtures-setup-and-tear-down-for-unit-tests","text":"Unit tests may require the system to be in a particular state before running a test. The state may need to be reset after running a test such as a database Fixtures allow you to run code before and after tests, to set up the context in which tests should be run. Consider when fixtures should be run, especially fixtures that take a noticeable time to setup or tear down. Slow running unit tests lead to unit tests not being run so often and therefore limit their value.","title":"Fixtures: setup and tear down for unit tests"},{"location":"testing/unit-testing/fixtures/#hintorganize-tests-with-test-selectors","text":"Tests with fixtures may be slower to run so separate them by using a test selector , a piece of meta data attached to a deftest definition. For example, add the ^:database meta data to test that require database fixtures (deftest ^:database db-bulk-upload). The test runner can be instructed to skip or focus on tests with specific meta data.","title":"Hint::Organize tests with test selectors"},{"location":"testing/unit-testing/fixtures/#defining-a-fixture","text":"A fixture is a standard Clojure function which takes a function as an argument. The function passed as an argument is either an individual test or all tests in the namespace, depending on how the fixture is used. ( defn my-fixture [ test-run ] ;; Setup: define bindings, create state, etc. ( test-run ) ;; Run the relevant tests for the fixture (see `use-fixtures`) ;; Tear-down: reset state to a known value )","title":"Defining a fixture"},{"location":"testing/unit-testing/fixtures/#requires-for-clojuretest-fixtures","text":"To use those fixtures in a test run, include the use-fixtures function in the require expression for clojure.test ( ns domain.application-test ( :require [ clojure.test :refer [ deftest is testing use-fixtures ]])) As fixtures are simply Clojure functions there are no additional requirements to define those functions.","title":"Requires for clojure.test fixtures"},{"location":"testing/unit-testing/fixtures/#when-to-run-fixtures","text":"The use-fixtures function defines when a fixture should be called when running the unit tests in each namespace. All Clojure unit test runners should support the use-fixtures definitions when running the tests. When Description (use-fixtures :once fixture1 fixture2) Run the fixtures once for the namespace. (use-fixtures :each fixture1 fixture2) Run the fixtures for each `deftest** in the namespace Once The setup in the fixture is run, followed by all the deftest functions in the namespace, then the fixture tear-down is run. Running a fixture once per namespace is useful for establishing a database connection or creating a particular state of data for all the unit tests to use. Each The fixture setup is run before each deftest function in the namespace. The fixture tear-down is run after each deftest function.","title":"When to run fixtures"},{"location":"testing/unit-testing/fixtures/#anonymous-functions-as-fixtures","text":"The use-fixtures function can also include anonymous function as well as a namespace scoped functions ( deftest ). ( use-fixtures :each ( fn [ f ] # _setup... ( f ) # _teardown )) defn functions are usually recommended unless the fixture code is relatively terse.","title":"Anonymous functions as fixtures"},{"location":"testing/unit-testing/fixtures/#example-development-database","text":"Define a fixture to reset the database before running a test and clear the database after each test. The create-database and delete-database are helper functions that are part of the namespace under test. ( defn database-reset-fixture \"Setup: drop all tables, creates new tables Teardown: drop all tables SQL schema code has if clauses to avoid errors running SQL code. Arguments: test-function - a function to run a specific test\" [ test-function ] ( SUT/create-database ) ( test-function ) ( SUT/delete-database )) The fixture should be used for each unit test ( deftest ) that is defined in the namespace the database-reset-fixture is defined in. ( use-fixtures :each database-reset-fixture )","title":"Example: development database"},{"location":"testing/unit-testing/fixtures/#references","text":"use-fixtures - Clojuredocs.org Kaocha - focusing and skipping Clojure Test Fixtures - astrocaribe","title":"References"},{"location":"testing/unit-testing/require-test-namespaces/","text":"Requiring Namespaces \u03bb\ufe0e A test namespace has a singular purpose to test a matching application namespace. Therefore the idiomatic approach is to :refer specific functions from clojure.test as those functions are used. The namespace to be tested is referred using the alias SUT meaning system under test. The alias highlight the exact functions being tested in the body of the code. This provides a visual way to separate functions under test with other test functions, especially if there are helper functions or vars used for test data. In the above example it is easy to see which namespaces the functions being tested are from. The dictionary namespace is a source of data for those tests. {% tabs repl=\"In the REPL\", project=\"In a Clojure Project\" %} {% content \"repl\" %} ( require ' [ clojure.test :refer [ are deftest is testing ]]) The namespace under test should be referred, typically using the alias SUT for software under test. ( require ' [ practicalli.playground :as SUT ]) {% content \"project\" %} Add clojure.test to the namespace definition along with the namespace under test. ( ns practicalli.app-namespace-test ( :require ' [ clojure.test :refer [ are deftest is testing ]] [ practicalli.app-namespace :as SUT ])) {% endtabs %} Hint::SUT alias - system under test \u03bb\ufe0e The alias SUT , meaning system under test, is a common convention in software testing . Using the SUT alias makes it easier for developers to see which functions from the application are being tested at a glance.","title":"Require test namespaces"},{"location":"testing/unit-testing/require-test-namespaces/#requiring-namespaces","text":"A test namespace has a singular purpose to test a matching application namespace. Therefore the idiomatic approach is to :refer specific functions from clojure.test as those functions are used. The namespace to be tested is referred using the alias SUT meaning system under test. The alias highlight the exact functions being tested in the body of the code. This provides a visual way to separate functions under test with other test functions, especially if there are helper functions or vars used for test data. In the above example it is easy to see which namespaces the functions being tested are from. The dictionary namespace is a source of data for those tests. {% tabs repl=\"In the REPL\", project=\"In a Clojure Project\" %} {% content \"repl\" %} ( require ' [ clojure.test :refer [ are deftest is testing ]]) The namespace under test should be referred, typically using the alias SUT for software under test. ( require ' [ practicalli.playground :as SUT ]) {% content \"project\" %} Add clojure.test to the namespace definition along with the namespace under test. ( ns practicalli.app-namespace-test ( :require ' [ clojure.test :refer [ are deftest is testing ]] [ practicalli.app-namespace :as SUT ])) {% endtabs %}","title":"Requiring Namespaces"},{"location":"testing/unit-testing/require-test-namespaces/#hintsut-alias-system-under-test","text":"The alias SUT , meaning system under test, is a common convention in software testing . Using the SUT alias makes it easier for developers to see which functions from the application are being tested at a glance.","title":"Hint::SUT alias - system under test"},{"location":"testing/unit-testing/test-selectors/","text":"Test Selectors \u03bb\ufe0e As a project grows in scope its important that unit tests are quick to run. Test that take a noticeable time to run diminish the motivation to run tests frequently. Dividing tests into categories means selective tests can be run, continuing to provide fast feedback. Longer running tests or very large test suites can be run less often without loosing quality in the feedback from tests. Test selectors can be included, so only that category of tests run. Or exclude test selectors so all tests except that category runs. Hint::lambdaisland/kaocha focus and skipping \u03bb\ufe0e kaocha can be used to group tests into categories in the tests.edn configuration, making it easy to focus or exclude different types of tests (e.g. :unit and :spec ) Defining test catagories with metadata \u03bb\ufe0e Add metadata to deftest functions to provide categories of tests ( deftest ^ :integration register-customer ( is ,,, )) Example from Banking on Clojure ( deftest ^ :database new-customer-test ( testing \"New customer generative testing\" ) ( is ( spec/valid? :customer/id ( :customer/id ( SUT/new-customer ( spec-gen/generate ( spec/gen :customer/unregistered ))))))) Running selective tests \u03bb\ufe0e Start a test running by specifying test selectors to include and/or exclude. {% tabs kaocha=\"kaocha\", spacemacs=\"Spacemacs\", cider=\"CIDER\", cognitect=\"Cognitect Labs\" %} {% content \"kaocha\" %} kaocha supports meta data on deftest expressions and has its own metadata tag for skipping tests, ^:koacha/skip Examples of tests with and without test selectors ( deftest simple-test ( is ( = 1 1 ))) ( deftest ^ :integration system-update-test ( is ( spec/valid? :system/update ( long-running-function )))) ( deftest ^ :kaocha/skip under-development-test ( is ( = 3 21/7 ))) Tests with test selector metadata can be skipped using a tests.edn configuration # kaocha/v1 { :tests [{ :kaocha.filter/skip-meta [ :integration ]}]} Running kaocha will only run the simple-test , skipping the other two tests. Specifying --skip-meta on the command line gives the same results bin/kaocha --skip-meta :metadata-name {% content \"spacemacs\" %} Running tests with the universal argument will prompt for test selector filters and only Run those tests that match the selector inclusions/exclusions. SPC u , t a runs all tests, prompting for tests selector names to include (space separated) Then prompting for the test selectors to exclude. A warning displays if CIDER does not find the test selector name. {% content \"cider\" %} Invoke the CIDER test runner commands with the universal argument and CIDER will prompt for test selector filters, running only those tests that match the selector inclusions/exclusions. C-c C-t p runs all the tests in a project. C-u C-c C-t p prompts for test selectors and runs the matching tests in a project. C-c C-t l runs all tests currently evaluated in the REPL. C-u C-c C-t l prompts for test selectors and runs the matching tests currently evaluated in the REPL. CIDER first prompts for the test selectors to include: Then prompts for the test selectors to exclude. A warning displays if CIDER does not find the test selector name. {% content \"cognitect\" %} The Cognitect Labs test runner uses command line options to specify test selectors, --include and --exclude . practicalli/clojure-deps-edn configuration provides the :test/congnitect alias. clojure -M:test/cognitect --include :database only runs tests with the ^:database test selector clojure -M:test/cognitect --exclude :integration runs all tests except those with the ^:integration test selector {% endtabs %} References \u03bb\ufe0e Kaocha - Focus and skipping tests with test selectors Convoluted Magic of Leiningen Test Selectors How to use Leiningen test selectors to filter by test name Stack overflow - Lein test with Selectors - how to specify a test for multiple conditions","title":"Test Selectors"},{"location":"testing/unit-testing/test-selectors/#test-selectors","text":"As a project grows in scope its important that unit tests are quick to run. Test that take a noticeable time to run diminish the motivation to run tests frequently. Dividing tests into categories means selective tests can be run, continuing to provide fast feedback. Longer running tests or very large test suites can be run less often without loosing quality in the feedback from tests. Test selectors can be included, so only that category of tests run. Or exclude test selectors so all tests except that category runs.","title":"Test Selectors"},{"location":"testing/unit-testing/test-selectors/#hintlambdaislandkaocha-focus-and-skipping","text":"kaocha can be used to group tests into categories in the tests.edn configuration, making it easy to focus or exclude different types of tests (e.g. :unit and :spec )","title":"Hint::lambdaisland/kaocha focus and skipping"},{"location":"testing/unit-testing/test-selectors/#defining-test-catagories-with-metadata","text":"Add metadata to deftest functions to provide categories of tests ( deftest ^ :integration register-customer ( is ,,, )) Example from Banking on Clojure ( deftest ^ :database new-customer-test ( testing \"New customer generative testing\" ) ( is ( spec/valid? :customer/id ( :customer/id ( SUT/new-customer ( spec-gen/generate ( spec/gen :customer/unregistered )))))))","title":"Defining test catagories with metadata"},{"location":"testing/unit-testing/test-selectors/#running-selective-tests","text":"Start a test running by specifying test selectors to include and/or exclude. {% tabs kaocha=\"kaocha\", spacemacs=\"Spacemacs\", cider=\"CIDER\", cognitect=\"Cognitect Labs\" %} {% content \"kaocha\" %} kaocha supports meta data on deftest expressions and has its own metadata tag for skipping tests, ^:koacha/skip Examples of tests with and without test selectors ( deftest simple-test ( is ( = 1 1 ))) ( deftest ^ :integration system-update-test ( is ( spec/valid? :system/update ( long-running-function )))) ( deftest ^ :kaocha/skip under-development-test ( is ( = 3 21/7 ))) Tests with test selector metadata can be skipped using a tests.edn configuration # kaocha/v1 { :tests [{ :kaocha.filter/skip-meta [ :integration ]}]} Running kaocha will only run the simple-test , skipping the other two tests. Specifying --skip-meta on the command line gives the same results bin/kaocha --skip-meta :metadata-name {% content \"spacemacs\" %} Running tests with the universal argument will prompt for test selector filters and only Run those tests that match the selector inclusions/exclusions. SPC u , t a runs all tests, prompting for tests selector names to include (space separated) Then prompting for the test selectors to exclude. A warning displays if CIDER does not find the test selector name. {% content \"cider\" %} Invoke the CIDER test runner commands with the universal argument and CIDER will prompt for test selector filters, running only those tests that match the selector inclusions/exclusions. C-c C-t p runs all the tests in a project. C-u C-c C-t p prompts for test selectors and runs the matching tests in a project. C-c C-t l runs all tests currently evaluated in the REPL. C-u C-c C-t l prompts for test selectors and runs the matching tests currently evaluated in the REPL. CIDER first prompts for the test selectors to include: Then prompts for the test selectors to exclude. A warning displays if CIDER does not find the test selector name. {% content \"cognitect\" %} The Cognitect Labs test runner uses command line options to specify test selectors, --include and --exclude . practicalli/clojure-deps-edn configuration provides the :test/congnitect alias. clojure -M:test/cognitect --include :database only runs tests with the ^:database test selector clojure -M:test/cognitect --exclude :integration runs all tests except those with the ^:integration test selector {% endtabs %}","title":"Running selective tests"},{"location":"testing/unit-testing/test-selectors/#references","text":"Kaocha - Focus and skipping tests with test selectors Convoluted Magic of Leiningen Test Selectors How to use Leiningen test selectors to filter by test name Stack overflow - Lein test with Selectors - how to specify a test for multiple conditions","title":"References"},{"location":"testing/unit-testing/writing-unit-tests/","text":"Writing Unit Tests with clojure.test \u03bb\ufe0e Unit tests are centered on assertions, testing if something returns a true or false value. is function is the simplest assertion and the most common. It checks to see if an expression given is true and if so then the assertion passes. If the value is false then that assertion fails. as provides a way to run the same assertion with different values, testing the same function with a collection of arguments. This provides a clean way to test a function without lots of repetition. testing is a macro to group multiple assertions together, providing a string in which to describe the context the assertions are testing. The well worded context string is invaluable for narrowing down on which assertions are failing. deftest is a collection of assertions, with or without testing expressions. The name of the deftest should be the name of the function it is testing with -test as a postfix. For example, the function practicalli.playground/calculator would have a deftest called practicalli.playground-test/calculator-test Simple Example \u03bb\ufe0e ( deftest public-function-in-namespace-test ( testing \"A description of the test\" ( is ( = 1 ( public-function arg ))) ( is ( predicate-function? arg )))) Testing assertions with a data set \u03bb\ufe0e The are macro can also be used to define assertions, especially when there would otherwise be multiple assertions that only differ by their test data. An are assertion defines the arguments to the test, the logic of the test and a series of test data. ( are [ x y ] ( = x y ) 2 ( + 1 1 ) 4 ( * 2 2 )) This is equivalent to writing ( do ( is ( = 2 ( + 1 1 ))) ( is ( = 4 ( * 2 2 )))) In this example 5 assertions are almost the same, so are a candidate to be refactored using the are macro. ( testing \"Tens to number words\" ( is ( = ' ( \"zero\" \"ten\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\1 \\0 )))) ( is ( = ' ( \"zero\" \"eleven\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\1 \\1 )))) ( is ( = ' ( \"zero\" \"twenty\" \"zero\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\2 \\0 )))) ( is ( = ' ( \"zero\" \"twenty\"\"one\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\2 \\1 )))) ( is ( = ' ( \"zero\" \"forty\" \"two\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\4 \\2 ))))) Refactor the assertions using are simplifies the code, making it simpler to change further and extend with more data. ( testing \"Tens to number words\" ( are [ words numbers ] ( = words ( sut/character-sequence->word-sequence dictionary/digit->word numbers )) ' ( \"zero\" \"ten\" ) ' ( \\0 \\1 \\0 ) ' ( \"zero\" \"eleven\" ) ' ( \\0 \\1 \\1 ) ' ( \"zero\" \"twenty\" \"zero\" ) ' ( \\0 \\2 \\0 ) ' ( \"zero\" \"twenty\"\"one\" ) ' ( \\0 \\2 \\1 ) ' ( \"zero\" \"forty\" \"two\" ) ' ( \\0 \\4 \\2 )) Reference \u03bb\ufe0e For full details, visit the API for clojure.test Project Examples: Code challenges with unit tests \u03bb\ufe0e TDD Kata: Recent Song-list TDD Kata: Numbers in words Codewars: Rock Paper Scissors (lizard spock) solution practicalli/codewars-guides - deps.edn projects practicalli/exercism-clojure-guides - Leiningen projects","title":"Writing Unit Tests with clojure.test"},{"location":"testing/unit-testing/writing-unit-tests/#writing-unit-tests-with-clojuretest","text":"Unit tests are centered on assertions, testing if something returns a true or false value. is function is the simplest assertion and the most common. It checks to see if an expression given is true and if so then the assertion passes. If the value is false then that assertion fails. as provides a way to run the same assertion with different values, testing the same function with a collection of arguments. This provides a clean way to test a function without lots of repetition. testing is a macro to group multiple assertions together, providing a string in which to describe the context the assertions are testing. The well worded context string is invaluable for narrowing down on which assertions are failing. deftest is a collection of assertions, with or without testing expressions. The name of the deftest should be the name of the function it is testing with -test as a postfix. For example, the function practicalli.playground/calculator would have a deftest called practicalli.playground-test/calculator-test","title":"Writing Unit Tests with clojure.test"},{"location":"testing/unit-testing/writing-unit-tests/#simple-example","text":"( deftest public-function-in-namespace-test ( testing \"A description of the test\" ( is ( = 1 ( public-function arg ))) ( is ( predicate-function? arg ))))","title":"Simple Example"},{"location":"testing/unit-testing/writing-unit-tests/#testing-assertions-with-a-data-set","text":"The are macro can also be used to define assertions, especially when there would otherwise be multiple assertions that only differ by their test data. An are assertion defines the arguments to the test, the logic of the test and a series of test data. ( are [ x y ] ( = x y ) 2 ( + 1 1 ) 4 ( * 2 2 )) This is equivalent to writing ( do ( is ( = 2 ( + 1 1 ))) ( is ( = 4 ( * 2 2 )))) In this example 5 assertions are almost the same, so are a candidate to be refactored using the are macro. ( testing \"Tens to number words\" ( is ( = ' ( \"zero\" \"ten\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\1 \\0 )))) ( is ( = ' ( \"zero\" \"eleven\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\1 \\1 )))) ( is ( = ' ( \"zero\" \"twenty\" \"zero\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\2 \\0 )))) ( is ( = ' ( \"zero\" \"twenty\"\"one\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\2 \\1 )))) ( is ( = ' ( \"zero\" \"forty\" \"two\" ) ( sut/character-sequence->word-sequence dictionary/digit->word ' ( \\0 \\4 \\2 ))))) Refactor the assertions using are simplifies the code, making it simpler to change further and extend with more data. ( testing \"Tens to number words\" ( are [ words numbers ] ( = words ( sut/character-sequence->word-sequence dictionary/digit->word numbers )) ' ( \"zero\" \"ten\" ) ' ( \\0 \\1 \\0 ) ' ( \"zero\" \"eleven\" ) ' ( \\0 \\1 \\1 ) ' ( \"zero\" \"twenty\" \"zero\" ) ' ( \\0 \\2 \\0 ) ' ( \"zero\" \"twenty\"\"one\" ) ' ( \\0 \\2 \\1 ) ' ( \"zero\" \"forty\" \"two\" ) ' ( \\0 \\4 \\2 ))","title":"Testing assertions with a data set"},{"location":"testing/unit-testing/writing-unit-tests/#reference","text":"For full details, visit the API for clojure.test","title":"Reference"},{"location":"testing/unit-testing/writing-unit-tests/#project-examples-code-challenges-with-unit-tests","text":"TDD Kata: Recent Song-list TDD Kata: Numbers in words Codewars: Rock Paper Scissors (lizard spock) solution practicalli/codewars-guides - deps.edn projects practicalli/exercism-clojure-guides - Leiningen projects","title":"Project Examples: Code challenges with unit tests"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/","text":"Test Driven Development Kata - Recent Song-list \u03bb\ufe0e TODO::work in progress, sorry \u03bb\ufe0e Create a recent song list to hold a unique set of songs that have been played. The most recently played song is at the start of the list, the least recently played song is the last in the list. A recently-used-list is initially empty. Songs in the list are unique, so repeatedly played songs should only appear once in the list Songs can be looked up by index, which counts from zero. Optional extras: Empty song names are not allowed. Add a limit to the number of songs the list contains, with the least recently added items dropped when that limit is reached. Add two files to the playground project \u03bb\ufe0e Create a new project using clj-new clojure -M:new app practicalli/recent-song-list Using clojure.test \u03bb\ufe0e We are writing our tests with the clojure.test library Open test/playground/recent-song-list-test.clj file in your editor and update the namespace definition to include clojure.test (ns practicalli.recent-song-list-test (:require [clojure.test :refer [deftest is testing]] [playground.recent-song-list :as SUT])) Run Tests \u03bb\ufe0e At any time we can call the run-tests function in the REPL to get a report back on all of the tests in our current namespace ( recent-song-list ) (run-tests) The Cognitect Labs test runner is included in the project by default and can be run from the command line in the root directory of the project. clojure -M:test:runner Define a recent song list \u03bb\ufe0e In the source file, src/playground/recent-song-list.clj , define a name for your collection of recent songs You can use an empty collection to start with. Which collection type will you use though? (def recent-songs []) Note::Write a test to check a song-list exists \u03bb\ufe0e Write a test to see if a recent song list exists. This is an opportunity to think about what kind of data structure you want to use to hold your recent song list. A simple test that checks for a recent-songs list, checking ( deftest song-list-exists-test ( testing \"Does a recent song list exist\" ( is ( vector? recent-songs )))) Note::Write a test to check the song-list is empty \u03bb\ufe0e The recent song list should be empty to start with. A simple test that compares an empty vector with the value of recent-songs ( deftest song-list-empty-test ( testing \"Is song list empty if we haven't added any songs\" ( is ( = [] recent-songs )))) Here is the same test using the empty? function instead of the = function. ( deftest song-list-empty-test-2 ( testing \"Is song list empty if we haven't added any songs\" ( is ( empty? recent-songs )))) Hint:: \u03bb\ufe0e You could use either of these tests to replace the song list exists test, as these tests would fail if the song list did not exist. Note::Write a test to add a song to the list \u03bb\ufe0e Add a song to the collection, for example Tubular Bells - Mike Oldfield ( deftest adding-songs-test ( testing \"add song returns a song list with entries\" ( is ( not ( empty? ( add-song \"Barry Manilow - Love on the rocks\" recent-songs ))))) ( testing \"add multiple song returns a song list with entries\" ( is ( not ( empty? ( ->> recent-songs ( add-song \"Barry Manilow - Love on the rocks\" ) ( add-song \"Phil Colins - Sususudio\" ))))))) This suggested solution defines our recent songs as an empty vector. The add-song function takes the name of a song and the song list to which it will be added. A Thread-last macro ->> is used to pass the song list over two functions. The song-list is first passed to the remove expression as its last argument. This expression will remove any occurrence of the new song we want to add from the song-list . The results of the remove expression are then passed to the cons expression as its last argument. The cons expression simply adds the new song to the start of the list, making it the most recent song. ( def recent-songs []) ( defn add-song [ song song-list ] ( ->> song-list ( remove # ( = song % )) ( cons song )))","title":"Test Driven Development Kata - Recent Song-list"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#test-driven-development-kata-recent-song-list","text":"","title":"Test Driven Development Kata - Recent Song-list"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#todowork-in-progress-sorry","text":"Create a recent song list to hold a unique set of songs that have been played. The most recently played song is at the start of the list, the least recently played song is the last in the list. A recently-used-list is initially empty. Songs in the list are unique, so repeatedly played songs should only appear once in the list Songs can be looked up by index, which counts from zero. Optional extras: Empty song names are not allowed. Add a limit to the number of songs the list contains, with the least recently added items dropped when that limit is reached.","title":"TODO::work in progress, sorry"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#add-two-files-to-the-playground-project","text":"Create a new project using clj-new clojure -M:new app practicalli/recent-song-list","title":"Add two files to the playground project"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#using-clojuretest","text":"We are writing our tests with the clojure.test library Open test/playground/recent-song-list-test.clj file in your editor and update the namespace definition to include clojure.test (ns practicalli.recent-song-list-test (:require [clojure.test :refer [deftest is testing]] [playground.recent-song-list :as SUT]))","title":"Using clojure.test"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#run-tests","text":"At any time we can call the run-tests function in the REPL to get a report back on all of the tests in our current namespace ( recent-song-list ) (run-tests) The Cognitect Labs test runner is included in the project by default and can be run from the command line in the root directory of the project. clojure -M:test:runner","title":"Run Tests"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#define-a-recent-song-list","text":"In the source file, src/playground/recent-song-list.clj , define a name for your collection of recent songs You can use an empty collection to start with. Which collection type will you use though? (def recent-songs [])","title":"Define a recent song list"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#notewrite-a-test-to-check-a-song-list-exists","text":"Write a test to see if a recent song list exists. This is an opportunity to think about what kind of data structure you want to use to hold your recent song list. A simple test that checks for a recent-songs list, checking ( deftest song-list-exists-test ( testing \"Does a recent song list exist\" ( is ( vector? recent-songs ))))","title":"Note::Write a test to check a song-list exists"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#notewrite-a-test-to-check-the-song-list-is-empty","text":"The recent song list should be empty to start with. A simple test that compares an empty vector with the value of recent-songs ( deftest song-list-empty-test ( testing \"Is song list empty if we haven't added any songs\" ( is ( = [] recent-songs )))) Here is the same test using the empty? function instead of the = function. ( deftest song-list-empty-test-2 ( testing \"Is song list empty if we haven't added any songs\" ( is ( empty? recent-songs ))))","title":"Note::Write a test to check the song-list is empty"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#hint","text":"You could use either of these tests to replace the song list exists test, as these tests would fail if the song list did not exist.","title":"Hint::"},{"location":"testing/unit-testing/tdd-kata/recent-songlist/#notewrite-a-test-to-add-a-song-to-the-list","text":"Add a song to the collection, for example Tubular Bells - Mike Oldfield ( deftest adding-songs-test ( testing \"add song returns a song list with entries\" ( is ( not ( empty? ( add-song \"Barry Manilow - Love on the rocks\" recent-songs ))))) ( testing \"add multiple song returns a song list with entries\" ( is ( not ( empty? ( ->> recent-songs ( add-song \"Barry Manilow - Love on the rocks\" ) ( add-song \"Phil Colins - Sususudio\" ))))))) This suggested solution defines our recent songs as an empty vector. The add-song function takes the name of a song and the song list to which it will be added. A Thread-last macro ->> is used to pass the song list over two functions. The song-list is first passed to the remove expression as its last argument. This expression will remove any occurrence of the new song we want to add from the song-list . The results of the remove expression are then passed to the cons expression as its last argument. The cons expression simply adds the new song to the start of the list, making it the most recent song. ( def recent-songs []) ( defn add-song [ song song-list ] ( ->> song-list ( remove # ( = song % )) ( cons song )))","title":"Note::Write a test to add a song to the list"},{"location":"thinking-functionally/","text":"Thinking Functionally \u03bb\ufe0e In this section I cover some simple examples of Clojure code to help you think about the concepts involved in functional programming. An overview of thinking functionally is also covered in the presentation entitled Getting into Functional Programming with Clojure on slideshare and its accompanying youtube video Get into Functional Programming with Clojure from John Stevenson Get a free Clojurians slack community account","title":"Thinking Functionally"},{"location":"thinking-functionally/#thinking-functionally","text":"In this section I cover some simple examples of Clojure code to help you think about the concepts involved in functional programming. An overview of thinking functionally is also covered in the presentation entitled Getting into Functional Programming with Clojure on slideshare and its accompanying youtube video Get into Functional Programming with Clojure from John Stevenson Get a free Clojurians slack community account","title":"Thinking Functionally"},{"location":"thinking-functionally/arity/","text":"Arity \u03bb\ufe0e Fixme work in progress","title":"Arity"},{"location":"thinking-functionally/arity/#arity","text":"Fixme work in progress","title":"Arity"},{"location":"thinking-functionally/example-hitchhikers-guide/","text":"Example: Hitchhikers Guide \u03bb\ufe0e This is an example of using the threading macros and a REPL to give fast feedback as you are developing code. NOTE:: \u03bb\ufe0e Write functions that will give a list of the most used words used in a book, excluding the common English words like \"the, and, it, I\". Join those functions with a threading macro. Suggest you use the assumed perfectly legal copy of the Hitch-hickers book text using the slurp function Approximate algorithm * Use a regular expression to create a collection of individual words - eg. #\"[a-zA-Z0-9|']+\" * Convert all the words to lower case so they match with common words source - clojure.string/lower-case * Remove the common English words used in the book, leaving more context specific words * Calculate the frequencies of the remaining words, returning a map of word & word count pairs * Sort-by word count values in the map * Reverse the collection so the most commonly used word is the first element in the map ( def book ( slurp \"http://clearwhitelight.org/hitch/hhgttg.txt\" )) ( def common-english-words ( -> ( slurp \"https://www.textfixer.com/tutorials/common-english-words.txt\" ) ( clojure.string/split # \",\" ) set )) ;; using a function to pull in any book ( defn get-book [ book-url ] ( slurp book-url )) ( defn -main [ book-url ] ( ->> ( get-book book-url ) ( re-seq # \"[a-zA-Z0-9|']+\" ) ( map # ( clojure.string/lower-case % )) ( remove common-english-words ) frequencies ( sort-by val ) reverse )) ;; Call the program ( -main \"http://clearwhitelight.org/hitch/hhgttg.txt\" ) Deconstructing the code in the repl \u03bb\ufe0e To understand what each of the functions do in the -main function then you can simply comment out one or more expressions using in front of the expression #_ ( defn -main [ book-url ] ( ->> ( get-book book-url ) # _ ( re-seq # \"[a-zA-Z0-9|']+\" ) # _ ( map # ( clojure.string/lower-case % )) # _ ( remove common-english-words ) # _frequencies # _ ( sort-by val ) # _reverse )) Now the -main function will only return the result of the (get-book book-url) function. To see what each of the other lines do, simply remove the #_ character from the front of an expression and re-evaluate the -main function in the repl Hint In Spacemacs / Emacs, the keybinding C-c C-p show the output in a seperate buffer. Very useful when the function returns a large results set. Off-line sources of Hitch-hickers book and common English words \u03bb\ufe0e (def book (slurp \"./hhgttg.txt\")) (def common-english-words (-> (slurp \"common-english-words.txt\") (clojure.string/split #\",\") set)) Original concept from Misophistful: Understanding thread macros in clojure Hint The slurp function holds the contents of the whole file in memory, so it may not be appropriate for very large files. If you are dealing with a large file, consider wrapping slurp in a lazy evaluation or use Java IO (eg. java.io.BufferedReader , java.io.FileReader. ). See the Clojure I/O cookbook and The Ins & Outs of Clojure for examples.","title":"Example: Hitchhikers Guide"},{"location":"thinking-functionally/example-hitchhikers-guide/#example-hitchhikers-guide","text":"This is an example of using the threading macros and a REPL to give fast feedback as you are developing code.","title":"Example: Hitchhikers Guide"},{"location":"thinking-functionally/example-hitchhikers-guide/#note","text":"Write functions that will give a list of the most used words used in a book, excluding the common English words like \"the, and, it, I\". Join those functions with a threading macro. Suggest you use the assumed perfectly legal copy of the Hitch-hickers book text using the slurp function Approximate algorithm * Use a regular expression to create a collection of individual words - eg. #\"[a-zA-Z0-9|']+\" * Convert all the words to lower case so they match with common words source - clojure.string/lower-case * Remove the common English words used in the book, leaving more context specific words * Calculate the frequencies of the remaining words, returning a map of word & word count pairs * Sort-by word count values in the map * Reverse the collection so the most commonly used word is the first element in the map ( def book ( slurp \"http://clearwhitelight.org/hitch/hhgttg.txt\" )) ( def common-english-words ( -> ( slurp \"https://www.textfixer.com/tutorials/common-english-words.txt\" ) ( clojure.string/split # \",\" ) set )) ;; using a function to pull in any book ( defn get-book [ book-url ] ( slurp book-url )) ( defn -main [ book-url ] ( ->> ( get-book book-url ) ( re-seq # \"[a-zA-Z0-9|']+\" ) ( map # ( clojure.string/lower-case % )) ( remove common-english-words ) frequencies ( sort-by val ) reverse )) ;; Call the program ( -main \"http://clearwhitelight.org/hitch/hhgttg.txt\" )","title":"NOTE::"},{"location":"thinking-functionally/example-hitchhikers-guide/#deconstructing-the-code-in-the-repl","text":"To understand what each of the functions do in the -main function then you can simply comment out one or more expressions using in front of the expression #_ ( defn -main [ book-url ] ( ->> ( get-book book-url ) # _ ( re-seq # \"[a-zA-Z0-9|']+\" ) # _ ( map # ( clojure.string/lower-case % )) # _ ( remove common-english-words ) # _frequencies # _ ( sort-by val ) # _reverse )) Now the -main function will only return the result of the (get-book book-url) function. To see what each of the other lines do, simply remove the #_ character from the front of an expression and re-evaluate the -main function in the repl Hint In Spacemacs / Emacs, the keybinding C-c C-p show the output in a seperate buffer. Very useful when the function returns a large results set.","title":"Deconstructing the code in the repl"},{"location":"thinking-functionally/example-hitchhikers-guide/#off-line-sources-of-hitch-hickers-book-and-common-english-words","text":"(def book (slurp \"./hhgttg.txt\")) (def common-english-words (-> (slurp \"common-english-words.txt\") (clojure.string/split #\",\") set)) Original concept from Misophistful: Understanding thread macros in clojure Hint The slurp function holds the contents of the whole file in memory, so it may not be appropriate for very large files. If you are dealing with a large file, consider wrapping slurp in a lazy evaluation or use Java IO (eg. java.io.BufferedReader , java.io.FileReader. ). See the Clojure I/O cookbook and The Ins & Outs of Clojure for examples.","title":"Off-line sources of Hitch-hickers book and common English words"},{"location":"thinking-functionally/first-class-functions/","text":"First Class functions \u03bb\ufe0e Idempotent - given the same input you get the same output Note:: \u03bb\ufe0e Write an expression to add up the numbers from 1 to 10 and return the overall total. (+ 1 2 3 4 5 6 7 8 9 10) Note:: \u03bb\ufe0e Create an expression to do the same calculation, but without having to write all the numbers. Hint: consider the functions called range and reduce. The range function generates a sequence of numbers and when given arguments it does so from a specific range. The second number is exclusive, so for 1 to 10 the second argument should be 11. (range 1 11) Unfortunately we cant just add the result of a range, because it returns a lazy sequence So (range) by itself will create an error (+ 1 (range 1 11)) Using a function called reduce we can calculate a single total value from all the numbers in the collection. The reduce function take 2 arguments, the first is the function to apply to a data structure, the second is the data structure. (reduce + (range 1 11)) (reduce + (1 2 3 4 5 6 7 8 9 10))","title":"First Class functions"},{"location":"thinking-functionally/first-class-functions/#first-class-functions","text":"Idempotent - given the same input you get the same output","title":"First Class functions"},{"location":"thinking-functionally/first-class-functions/#note","text":"Write an expression to add up the numbers from 1 to 10 and return the overall total. (+ 1 2 3 4 5 6 7 8 9 10)","title":"Note::"},{"location":"thinking-functionally/first-class-functions/#note_1","text":"Create an expression to do the same calculation, but without having to write all the numbers. Hint: consider the functions called range and reduce. The range function generates a sequence of numbers and when given arguments it does so from a specific range. The second number is exclusive, so for 1 to 10 the second argument should be 11. (range 1 11) Unfortunately we cant just add the result of a range, because it returns a lazy sequence So (range) by itself will create an error (+ 1 (range 1 11)) Using a function called reduce we can calculate a single total value from all the numbers in the collection. The reduce function take 2 arguments, the first is the function to apply to a data structure, the second is the data structure. (reduce + (range 1 11)) (reduce + (1 2 3 4 5 6 7 8 9 10))","title":"Note::"},{"location":"thinking-functionally/function-composition/","text":"Function Composition \u03bb\ufe0e We have discussed how functional programs are essentially a number of functions that work together, this is called composition (functional composition). (let [calculated-value (* 10 (reduce + (map inc (range 5))))] calculated-value) This expression is common in the Lisp & Clojure languages. Occasionally the created expressions can becomes challenging to read. To overcome this parsing complexity, developers often break down a more complex expression into its parts, extracting code into its own function. Note Brake down the above example into each expression that gives a value (range 5) (map inc (range 5)) (reduce + (map inc (range 5))) (* 10 (reduce + (map inc (range 5)))) ;; Additional examples ;; Use a let expression for code that is used more than once in a function (let [calculated-value (* 10 (reduce + (map inc (range 5))))] calculated-value) ;; Use defn to define a function for code that multiple functions will call ;; and generalise the function with arguments (defn common-data-calculation [certainty-factor scope] (* certainty-factor (reduce + (map inc (range scope)))))","title":"Function Composition"},{"location":"thinking-functionally/function-composition/#function-composition","text":"We have discussed how functional programs are essentially a number of functions that work together, this is called composition (functional composition). (let [calculated-value (* 10 (reduce + (map inc (range 5))))] calculated-value) This expression is common in the Lisp & Clojure languages. Occasionally the created expressions can becomes challenging to read. To overcome this parsing complexity, developers often break down a more complex expression into its parts, extracting code into its own function. Note Brake down the above example into each expression that gives a value (range 5) (map inc (range 5)) (reduce + (map inc (range 5))) (* 10 (reduce + (map inc (range 5)))) ;; Additional examples ;; Use a let expression for code that is used more than once in a function (let [calculated-value (* 10 (reduce + (map inc (range 5))))] calculated-value) ;; Use defn to define a function for code that multiple functions will call ;; and generalise the function with arguments (defn common-data-calculation [certainty-factor scope] (* certainty-factor (reduce + (map inc (range scope)))))","title":"Function Composition"},{"location":"thinking-functionally/functors/","text":"Functors \u03bb\ufe0e Fixme work in progress Put simply, a function that takes a value and a function as its arguments, eg map . The argument pass as a value is most commonly a collection type (vector, map, string, list). From Wikipedia In mathematics, a functor is a type of mapping between categories which is applied in category theory. Functors can be thought of as homomorphisms between categories. In the category of small categories, functors can be thought of more generally as morphisms. A functor applies the given function to each element in the the collection by unpacking and each element from the collection and passing it to the function as an argument. The result from each application of the function from the element of the collection is put into a new collection. This new collection is returned once all elements of the original collection have been processed. The function, eg. + is applied in turn to each value and returns a structured value as a result, eg. a list or vector (map inc [1 2 3 4 5]) (inc 1 )","title":"Functors"},{"location":"thinking-functionally/functors/#functors","text":"Fixme work in progress Put simply, a function that takes a value and a function as its arguments, eg map . The argument pass as a value is most commonly a collection type (vector, map, string, list). From Wikipedia In mathematics, a functor is a type of mapping between categories which is applied in category theory. Functors can be thought of as homomorphisms between categories. In the category of small categories, functors can be thought of more generally as morphisms. A functor applies the given function to each element in the the collection by unpacking and each element from the collection and passing it to the function as an argument. The result from each application of the function from the element of the collection is put into a new collection. This new collection is returned once all elements of the original collection have been processed. The function, eg. + is applied in turn to each value and returns a structured value as a result, eg. a list or vector (map inc [1 2 3 4 5]) (inc 1 )","title":"Functors"},{"location":"thinking-functionally/higher-order-functions/","text":"Higher Order functions \u03bb\ufe0e Functions can be used as an arguments to other functions as we have seen in function composition. This is possible because a function always evaluates to a value. This is the basis of function composition. Higher Order functions can also return a function definition, as when that function definition is evaluated it to will return a value. You could have a function that returns a function definition which in turn returns a function definition, but at some point this will get very confusing for the developers (yes, that means you). Note::Return the even numbers from 1 to 10 \u03bb\ufe0e Generate a range of numbers from 1 to 10 Use a function that checks if a number is even and filter the range of numbers to return only the numbers that match (filter even? (range 1 10)) Note::Create a named function as a higher order function called twice \u03bb\ufe0e The function twice which takes a function and value as arguments. The twice function should call the function passed as an argument on the value passed as an argument. The result should be then used as an argument to calling the function passed as an argument again. Call the twice function with an inline function which takes a number as an argument and adds it to Pi, 3.14 . (defn twice [f] ,,,) ;; Our higher order function (defn twice [function x] (function (function x))) (twice (fn [arg] (* 3.14 arg)) 21) ;; => 207.0516 ;; using the short syntax for a function definition (twice #(+ 3.14 %) 21) ;; => 207.0516 Note::Define a function that returns a function \u03bb\ufe0e The function should take a clojure.core function for a mathematical calculation, i.e. + , - , * , / The returning function should take one or more arguments [& args] and use the function originally passed as an argument to reduce the data to a single value. (defn calculation [f] ,,,) (defn calculation [f] (fn [& args] (reduce f args))) ((calculation +) 1 1 2 3 5 8 13) ;; The result of `(calculation +)` is also in a list, ;; so it will be called as a function, with the arguments 1 1 2 3 5 8 13 References \u03bb\ufe0e Writing Elegant Clojure code using Higher Order functions","title":"Higher Order functions"},{"location":"thinking-functionally/higher-order-functions/#higher-order-functions","text":"Functions can be used as an arguments to other functions as we have seen in function composition. This is possible because a function always evaluates to a value. This is the basis of function composition. Higher Order functions can also return a function definition, as when that function definition is evaluated it to will return a value. You could have a function that returns a function definition which in turn returns a function definition, but at some point this will get very confusing for the developers (yes, that means you).","title":"Higher Order functions"},{"location":"thinking-functionally/higher-order-functions/#notereturn-the-even-numbers-from-1-to-10","text":"Generate a range of numbers from 1 to 10 Use a function that checks if a number is even and filter the range of numbers to return only the numbers that match (filter even? (range 1 10))","title":"Note::Return the even numbers from 1 to 10"},{"location":"thinking-functionally/higher-order-functions/#notecreate-a-named-function-as-a-higher-order-function-called-twice","text":"The function twice which takes a function and value as arguments. The twice function should call the function passed as an argument on the value passed as an argument. The result should be then used as an argument to calling the function passed as an argument again. Call the twice function with an inline function which takes a number as an argument and adds it to Pi, 3.14 . (defn twice [f] ,,,) ;; Our higher order function (defn twice [function x] (function (function x))) (twice (fn [arg] (* 3.14 arg)) 21) ;; => 207.0516 ;; using the short syntax for a function definition (twice #(+ 3.14 %) 21) ;; => 207.0516","title":"Note::Create a named function as a higher order function called twice"},{"location":"thinking-functionally/higher-order-functions/#notedefine-a-function-that-returns-a-function","text":"The function should take a clojure.core function for a mathematical calculation, i.e. + , - , * , / The returning function should take one or more arguments [& args] and use the function originally passed as an argument to reduce the data to a single value. (defn calculation [f] ,,,) (defn calculation [f] (fn [& args] (reduce f args))) ((calculation +) 1 1 2 3 5 8 13) ;; The result of `(calculation +)` is also in a list, ;; so it will be called as a function, with the arguments 1 1 2 3 5 8 13","title":"Note::Define a function that returns a function"},{"location":"thinking-functionally/higher-order-functions/#references","text":"Writing Elegant Clojure code using Higher Order functions","title":"References"},{"location":"thinking-functionally/homoiconicity/","text":"Homoiconicity \u03bb\ufe0e Clojure is a homoiconic language, which is a term describing the fact that Clojure programs are represented by Clojure data structures. In Clojure you write your business logic as functions. A function is defined using a list structure. A function is called using a list structure, as the first element of a list is evaluated as a function call. Hint Everything in Clojure is a List (or vector, map, set). This is a very important difference between Clojure (and Common Lisp) and most other programming languages - Clojure is defined in terms of the evaluation of data structures and not in terms of the syntax of character streams/files. It is quite easy for Clojure programs to manipulate, transform and produce other Clojure programs. This is essentially what macros do in Clojure, they re-write Clojure for you. Hint If you were going to create Skynet, it would be so much easier to do in Clojure An example \u03bb\ufe0e Consider the following expression: (let [x 1] (inc x)) Evaluating the above code in the REPL returns 2 because the repl compiles and executes any code entered into it. But [x 1] is also a literal vector data structure when it appears in a different context. All Clojure code can be interpreted as data in this way. In fact, Clojure is a superset of EDN \u2013 Extensible Data Notation, a data transfer format similar to JSON. EDN supports numbers, strings, lists (1 2 3), vectors [1 2 3], maps {\"key\" \"value\"}. If this sounds and looks a lot like Clojure syntax, it\u2019s because it is. The relationship between Clojure and EDN is similar to that of Javascript and JSON, but much more powerful. In Clojure, unlike JavaScript, all code is written in this data format. We can look at our let statement not as Clojure code, but an EDN data structure. Let\u2019s take a closer look: (let [x 1] (inc x)) In this data structure, there are four different types of data. 1 is a literal integer. let, x, and inc are symbols. A symbol is an object representing a name \u2013 think a string, but as an atomic object and not a sequence of characters. [x 1] is a vector containing two elements: symbol, x, and an integer, 1. Square brackets always signify vectors when talking about EDN data structures. (inc x) is a list (a linked list data structure) containing two symbols, inc and x. When thinking about a piece of Clojure code as a data structure, we say we are talking about the form. Clojure programmers don\u2019t normally talk about EDN, there are just two ways to think about any bit of Clojure: 1) as code that will execute or 2) as a form, a data structure composed of numbers, symbols, keywords, strings, vectors, lists, maps, etc. Symbols are particularly important. They are first class names. In Clojure, we distinguish between a variable and the name of that variable. When our code is executing, x refers to the variable established by our let binding. But when we deal with that code as a form, x is just a piece of data, it\u2019s a name, which in Clojure is called a symbol. This is why Clojure is homoiconic. Code forms are data structures and data structures can be thought of as forms and executed as code. This transformation is quite literal, and two core operations, quote and eval are key ingredients to this potion. References \u03bb\ufe0e The Reader - Clojure. org Homoiconicity - Wikipedia Is Clojure Homoiconic - muhuk.com Understanding Homoiconicity in Clojure - Drew Colthorp","title":"Homoiconicity"},{"location":"thinking-functionally/homoiconicity/#homoiconicity","text":"Clojure is a homoiconic language, which is a term describing the fact that Clojure programs are represented by Clojure data structures. In Clojure you write your business logic as functions. A function is defined using a list structure. A function is called using a list structure, as the first element of a list is evaluated as a function call. Hint Everything in Clojure is a List (or vector, map, set). This is a very important difference between Clojure (and Common Lisp) and most other programming languages - Clojure is defined in terms of the evaluation of data structures and not in terms of the syntax of character streams/files. It is quite easy for Clojure programs to manipulate, transform and produce other Clojure programs. This is essentially what macros do in Clojure, they re-write Clojure for you. Hint If you were going to create Skynet, it would be so much easier to do in Clojure","title":"Homoiconicity"},{"location":"thinking-functionally/homoiconicity/#an-example","text":"Consider the following expression: (let [x 1] (inc x)) Evaluating the above code in the REPL returns 2 because the repl compiles and executes any code entered into it. But [x 1] is also a literal vector data structure when it appears in a different context. All Clojure code can be interpreted as data in this way. In fact, Clojure is a superset of EDN \u2013 Extensible Data Notation, a data transfer format similar to JSON. EDN supports numbers, strings, lists (1 2 3), vectors [1 2 3], maps {\"key\" \"value\"}. If this sounds and looks a lot like Clojure syntax, it\u2019s because it is. The relationship between Clojure and EDN is similar to that of Javascript and JSON, but much more powerful. In Clojure, unlike JavaScript, all code is written in this data format. We can look at our let statement not as Clojure code, but an EDN data structure. Let\u2019s take a closer look: (let [x 1] (inc x)) In this data structure, there are four different types of data. 1 is a literal integer. let, x, and inc are symbols. A symbol is an object representing a name \u2013 think a string, but as an atomic object and not a sequence of characters. [x 1] is a vector containing two elements: symbol, x, and an integer, 1. Square brackets always signify vectors when talking about EDN data structures. (inc x) is a list (a linked list data structure) containing two symbols, inc and x. When thinking about a piece of Clojure code as a data structure, we say we are talking about the form. Clojure programmers don\u2019t normally talk about EDN, there are just two ways to think about any bit of Clojure: 1) as code that will execute or 2) as a form, a data structure composed of numbers, symbols, keywords, strings, vectors, lists, maps, etc. Symbols are particularly important. They are first class names. In Clojure, we distinguish between a variable and the name of that variable. When our code is executing, x refers to the variable established by our let binding. But when we deal with that code as a form, x is just a piece of data, it\u2019s a name, which in Clojure is called a symbol. This is why Clojure is homoiconic. Code forms are data structures and data structures can be thought of as forms and executed as code. This transformation is quite literal, and two core operations, quote and eval are key ingredients to this potion.","title":"An example"},{"location":"thinking-functionally/homoiconicity/#references","text":"The Reader - Clojure. org Homoiconicity - Wikipedia Is Clojure Homoiconic - muhuk.com Understanding Homoiconicity in Clojure - Drew Colthorp","title":"References"},{"location":"thinking-functionally/immutability/","text":"Immutability \u03bb\ufe0e There is a strong emphasis on immutability in Clojure. Rather than create variables that change, Clojure uses values that do not change. Values in Clojure include numbers, characters, strings. When functions act on values, a new value is created and returned, rather than modifying the existing value. TODO include a diagram to visualise this... Immutabile data structures \u03bb\ufe0e List, Map, Vector and Set are all immutable data structures in Clojure. So when you use these data structures with a function, a new data structure is returned. Hint When a new data structure is created from an existing data structure, then under the covers the two data structures actually share memory use for any elements that are common. This keeps copies very cheap to create in terms of memory used. See the section on data structures for more details.","title":"Immutability"},{"location":"thinking-functionally/immutability/#immutability","text":"There is a strong emphasis on immutability in Clojure. Rather than create variables that change, Clojure uses values that do not change. Values in Clojure include numbers, characters, strings. When functions act on values, a new value is created and returned, rather than modifying the existing value. TODO include a diagram to visualise this...","title":"Immutability"},{"location":"thinking-functionally/immutability/#immutabile-data-structures","text":"List, Map, Vector and Set are all immutable data structures in Clojure. So when you use these data structures with a function, a new data structure is returned. Hint When a new data structure is created from an existing data structure, then under the covers the two data structures actually share memory use for any elements that are common. This keeps copies very cheap to create in terms of memory used. See the section on data structures for more details.","title":"Immutabile data structures"},{"location":"thinking-functionally/immutable-collections/","text":"Immutable collections \u03bb\ufe0e As we have discussed, immutable data structures cannot be changed. So when you run a function over a collection a copy of that collection is returned. Lets see this by running some code in the REPL. Note Define a data structure called numbers using a vector. Then write a function that uses the map and inc function to increment all the numbers in a vector. Then check the current value of the numbers data structure by evaluating its name. ;; define the data structure ( defn numbers [ 1 2 3 4 5 ]) ;; increment the numbers ( map inc numbers ) ;; see the current value of numbers numbers Note Use the conj function to first add the number 5 to the numbers vector from the previous exercise and check the value of numbers . Then add the number 6 to the numbers vector and check the value of numbers . Finally, use the conj function to add both 5 and 6 to the numbers vector and check the value of numbers (def numbers [1 2 3 4]) ;; add 5 to the numbers vector (conj numbers 5) ;; check the value of numbers numbers ;; => [1 2 3 4] ;; add 6 to the numbers vector (conj numbers 6) ;; check the value of numbers numbers ;; => [1 2 3 4] ;; add 5 and 6 to the numbers vector (conj numbers 5 6) ;; Alternatively, you can use the threading macro to chain two conj function calls (-> numbers (conj 5) (conj 6)) ;; check the value of numbers numbers ;; => [1 2 3 4] So even though we have applied several functions on the numbers data structure it still has the same value.","title":"Immutable collections"},{"location":"thinking-functionally/immutable-collections/#immutable-collections","text":"As we have discussed, immutable data structures cannot be changed. So when you run a function over a collection a copy of that collection is returned. Lets see this by running some code in the REPL. Note Define a data structure called numbers using a vector. Then write a function that uses the map and inc function to increment all the numbers in a vector. Then check the current value of the numbers data structure by evaluating its name. ;; define the data structure ( defn numbers [ 1 2 3 4 5 ]) ;; increment the numbers ( map inc numbers ) ;; see the current value of numbers numbers Note Use the conj function to first add the number 5 to the numbers vector from the previous exercise and check the value of numbers . Then add the number 6 to the numbers vector and check the value of numbers . Finally, use the conj function to add both 5 and 6 to the numbers vector and check the value of numbers (def numbers [1 2 3 4]) ;; add 5 to the numbers vector (conj numbers 5) ;; check the value of numbers numbers ;; => [1 2 3 4] ;; add 6 to the numbers vector (conj numbers 6) ;; check the value of numbers numbers ;; => [1 2 3 4] ;; add 5 and 6 to the numbers vector (conj numbers 5 6) ;; Alternatively, you can use the threading macro to chain two conj function calls (-> numbers (conj 5) (conj 6)) ;; check the value of numbers numbers ;; => [1 2 3 4] So even though we have applied several functions on the numbers data structure it still has the same value.","title":"Immutable collections"},{"location":"thinking-functionally/immutable-local-bindings/","text":"Immutable Local Bindings \u03bb\ufe0e Names can be bound to values & and data structures with either the def or let function. The def binding is global to the namespace, however the let function is local to its use. Hint The let function is typically used to define names within a function definition, or in snippets of code created during repl driven development. ( let [ five 5 ] ( str \"Within the let expression the value is \" five )) ;; => Within the let expression the value is 5 ;; evaluating the name five outside the let expression returns an error five ;; => Unable to resolve symbol: five in this context Note Create a local binding called number that represents the value 5 using the let function. Increment the number, then print out the value of number. ( let [ number 5 ] ( inc number ) ( str \"The number is still \" number )) So the value that any local binding points to is immutable too.","title":"Immutable Local Bindings"},{"location":"thinking-functionally/immutable-local-bindings/#immutable-local-bindings","text":"Names can be bound to values & and data structures with either the def or let function. The def binding is global to the namespace, however the let function is local to its use. Hint The let function is typically used to define names within a function definition, or in snippets of code created during repl driven development. ( let [ five 5 ] ( str \"Within the let expression the value is \" five )) ;; => Within the let expression the value is 5 ;; evaluating the name five outside the let expression returns an error five ;; => Unable to resolve symbol: five in this context Note Create a local binding called number that represents the value 5 using the let function. Increment the number, then print out the value of number. ( let [ number 5 ] ( inc number ) ( str \"The number is still \" number )) So the value that any local binding points to is immutable too.","title":"Immutable Local Bindings"},{"location":"thinking-functionally/immutable-values/","text":"Immutable values \u03bb\ufe0e Fixme work in progress Values in Clojure include numbers, characters and strings. When you use functions on these values they do not change, instead a new value is returned. Lets look at a simple example with a number: ( def two-little-ducks 22 ) ( inc two-little-ducks ) ;; => 23 two-little-ducks ;; => 22 Another example with a string: ( def message \"Strings are immutable\" ) ( str message \",\" \" \" \"you cant change them\" ) ;; => \"Strings are immutable, you cant change them\" message ;; => \"Strings are immutable\" Fixme Add an exercise","title":"Immutable values"},{"location":"thinking-functionally/immutable-values/#immutable-values","text":"Fixme work in progress Values in Clojure include numbers, characters and strings. When you use functions on these values they do not change, instead a new value is returned. Lets look at a simple example with a number: ( def two-little-ducks 22 ) ( inc two-little-ducks ) ;; => 23 two-little-ducks ;; => 22 Another example with a string: ( def message \"Strings are immutable\" ) ( str message \",\" \" \" \"you cant change them\" ) ;; => \"Strings are immutable, you cant change them\" message ;; => \"Strings are immutable\" Fixme Add an exercise","title":"Immutable values"},{"location":"thinking-functionally/impure-functions/","text":"Impure functions \u03bb\ufe0e We have seen some simple examples of pure functions, so lets see impure functions as a comparison. (def global-value '(5 4 3 2 1)) (defn impure-increment-numbers [number-collection] (map inc global-value)) (impure-increment-numbers '(1 2 3 4 5)) The above function is using a global value rather than the argument passed makes this function deterministic Side Effect: Printing to the console log \u03bb\ufe0e Although the following example is probably quite harmless, it is a simple example of a function effecting the state of something outside. These side effects should be avoided where possible to keep your code simpler to reason about. (defn print-to-console [value-to-print] (println \"The value is:\" value-to-print)) (print-to-console \"a side effect\") Side Causes: Calling libraries \u03bb\ufe0e To demonstrate a side causes form of impure functions, lets create a task-comple function that marks a current task complete using the current timestamp. (defn task-complete [task-name] (str \"Setting task \" task-name \" completed on \" (js/Date))) (task-complete \"hack clojure\") ( :import java.util.Date ) ( defn task-complete [ task-name ] ( str \"Setting task \" task-name \" completed on \" ( java.util.Date. ))) ( task-complete \"hack clojure\" ) Hint:: The function (java.util.Date.) is actually a call to instantiate a java.util.Date object. The full-stop character at the end of the name makes it a function call and is the short form of (new java.util.Date) \u03bb\ufe0e In this example we have called to the outside world to generate a value for us. The above example is fairly simple, however by calling the outside world rather than passing in a date it makes the functions purpose far less clear. Re-write as a pure function \u03bb\ufe0e Change the task-complete function definition and function call to take both the task-name and completed-date as arguments. (defn task-complete [task-name completed-date] (str \"Setting task \" task-name \" completed on \" completed-date)) (task-complete \"hack clojure\" (js/Date)) Required values should be generated outside a function where possible. In this case in the (js/Date) function is first evaluated and replaced by its value, then that date value is passed to the function as an argument, keeping the function pure. The pure version of the function in Clojure, using the java.util.Date function. ( :import java.util.Date ) ( defn task-complete [ task-name completed-date ] ( str \"Setting task \" task-name \" completed on \" completed-date )) ( task-complete \"hack clojure\" ( java.util.Date. ))","title":"Impure functions"},{"location":"thinking-functionally/impure-functions/#impure-functions","text":"We have seen some simple examples of pure functions, so lets see impure functions as a comparison. (def global-value '(5 4 3 2 1)) (defn impure-increment-numbers [number-collection] (map inc global-value)) (impure-increment-numbers '(1 2 3 4 5)) The above function is using a global value rather than the argument passed makes this function deterministic","title":"Impure functions"},{"location":"thinking-functionally/impure-functions/#side-effect-printing-to-the-console-log","text":"Although the following example is probably quite harmless, it is a simple example of a function effecting the state of something outside. These side effects should be avoided where possible to keep your code simpler to reason about. (defn print-to-console [value-to-print] (println \"The value is:\" value-to-print)) (print-to-console \"a side effect\")","title":"Side Effect: Printing to the console log"},{"location":"thinking-functionally/impure-functions/#side-causes-calling-libraries","text":"To demonstrate a side causes form of impure functions, lets create a task-comple function that marks a current task complete using the current timestamp. (defn task-complete [task-name] (str \"Setting task \" task-name \" completed on \" (js/Date))) (task-complete \"hack clojure\") ( :import java.util.Date ) ( defn task-complete [ task-name ] ( str \"Setting task \" task-name \" completed on \" ( java.util.Date. ))) ( task-complete \"hack clojure\" )","title":"Side Causes: Calling libraries"},{"location":"thinking-functionally/impure-functions/#hint-the-function-javautildate-is-actually-a-call-to-instantiate-a-javautildate-object-the-full-stop-character-at-the-end-of-the-name-makes-it-a-function-call-and-is-the-short-form-of-new-javautildate","text":"In this example we have called to the outside world to generate a value for us. The above example is fairly simple, however by calling the outside world rather than passing in a date it makes the functions purpose far less clear.","title":"Hint:: The function (java.util.Date.) is actually a call to instantiate a java.util.Date object.  The full-stop character at the end of the name makes it a function call and is the short form of (new java.util.Date)"},{"location":"thinking-functionally/impure-functions/#re-write-as-a-pure-function","text":"Change the task-complete function definition and function call to take both the task-name and completed-date as arguments. (defn task-complete [task-name completed-date] (str \"Setting task \" task-name \" completed on \" completed-date)) (task-complete \"hack clojure\" (js/Date)) Required values should be generated outside a function where possible. In this case in the (js/Date) function is first evaluated and replaced by its value, then that date value is passed to the function as an argument, keeping the function pure. The pure version of the function in Clojure, using the java.util.Date function. ( :import java.util.Date ) ( defn task-complete [ task-name completed-date ] ( str \"Setting task \" task-name \" completed on \" completed-date )) ( task-complete \"hack clojure\" ( java.util.Date. ))","title":"Re-write as a pure function"},{"location":"thinking-functionally/iterate-over-values/","text":"iterate Over Values \u03bb\ufe0e This Hint::Work in progress \u03bb\ufe0e loop recur reducing functions map apply reduce partition group-by sort-by loop recur \u03bb\ufe0e loop recur is a very detailed way of defining a way to iterate over values. map, reduce and apply are commonly used abstractions for iterating over values. They simplify the code (once you are comfortable with them) Functions that iterate over values usually treat a string as a sequence of characters.","title":"iterate Over Values"},{"location":"thinking-functionally/iterate-over-values/#iterate-over-values","text":"This","title":"iterate Over Values"},{"location":"thinking-functionally/iterate-over-values/#hintwork-in-progress","text":"loop recur reducing functions map apply reduce partition group-by sort-by","title":"Hint::Work in progress"},{"location":"thinking-functionally/iterate-over-values/#loop-recur","text":"loop recur is a very detailed way of defining a way to iterate over values. map, reduce and apply are commonly used abstractions for iterating over values. They simplify the code (once you are comfortable with them) Functions that iterate over values usually treat a string as a sequence of characters.","title":"loop recur"},{"location":"thinking-functionally/lazy-evaluation/","text":"Lazy Evaluation \u03bb\ufe0e Fixme work in progress In the most basic way possible, laziness is the ability to evaluate an expression only when it's actually needed. Taken further, laziness is also evaluating an expression only to the extent required. Laziness in definition \u03bb\ufe0e Laziness in evaluation \u03bb\ufe0e Laziness in partial evaluation \u03bb\ufe0e Clojure is not entirely lazy, only the majority of sequence operations like map, reduce, filter or repeatedly are lazy evaluated. The most common use of laziness are infinite lists or streams. For example, we could define a list of all prime numbers. In case you didn't know, that's a lot of prime numbers (infinitely many). If we would define such list in a language like C++ or Python then the language would try to calculate all prime numbers immediately, which would run literally forever. If we define such list in Haskell or Clojure, then nothing is calculated just yet. As a matter of fact we could happily print out the first 1000 prime numbers from that list without running into a problem. Again, because lazy evaluation only calculates what is really needed, and nothing more. Laziness in number calculation - Ratio type \u03bb\ufe0e Dividing an integer value by another results in a Ratio type if the result would otherwise result in a decimal number. Clojure only partially evaluates this expression. ( / 22 7 ) We can also just express a value as a ratio. This works because of the prefix notation of Clojure 22/7 The laziness can be overridden by specifying a precision, eg coercing the result into a specific type ( / 22 7.0 ) ( double ( / 22 7 )) ( float ( / 22 7 )) Making something lazy \u03bb\ufe0e The range function returns a sequence of numbers limited by any arguments given when calling the range function. Calling the range function without arguments will force an infinite sequence of numbers to be generated, quickly resulting in an out of memory error in the heap. Instead, we can either pass arguments to the range function that limit the sequence size or wrap the range function in another function ( take 7 ( range )) The take function defines how much of a sequence that range should generate. So we can call range without arguments and it will generate only those numbers in the sequence as specified by take . References \u03bb\ufe0e Being lazy in Clojure - lazily generating monsters","title":"Lazy Evaluation"},{"location":"thinking-functionally/lazy-evaluation/#lazy-evaluation","text":"Fixme work in progress In the most basic way possible, laziness is the ability to evaluate an expression only when it's actually needed. Taken further, laziness is also evaluating an expression only to the extent required.","title":"Lazy Evaluation"},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-definition","text":"","title":"Laziness in definition"},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-evaluation","text":"","title":"Laziness in evaluation"},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-partial-evaluation","text":"Clojure is not entirely lazy, only the majority of sequence operations like map, reduce, filter or repeatedly are lazy evaluated. The most common use of laziness are infinite lists or streams. For example, we could define a list of all prime numbers. In case you didn't know, that's a lot of prime numbers (infinitely many). If we would define such list in a language like C++ or Python then the language would try to calculate all prime numbers immediately, which would run literally forever. If we define such list in Haskell or Clojure, then nothing is calculated just yet. As a matter of fact we could happily print out the first 1000 prime numbers from that list without running into a problem. Again, because lazy evaluation only calculates what is really needed, and nothing more.","title":"Laziness in partial evaluation"},{"location":"thinking-functionally/lazy-evaluation/#laziness-in-number-calculation-ratio-type","text":"Dividing an integer value by another results in a Ratio type if the result would otherwise result in a decimal number. Clojure only partially evaluates this expression. ( / 22 7 ) We can also just express a value as a ratio. This works because of the prefix notation of Clojure 22/7 The laziness can be overridden by specifying a precision, eg coercing the result into a specific type ( / 22 7.0 ) ( double ( / 22 7 )) ( float ( / 22 7 ))","title":"Laziness in number calculation - Ratio type"},{"location":"thinking-functionally/lazy-evaluation/#making-something-lazy","text":"The range function returns a sequence of numbers limited by any arguments given when calling the range function. Calling the range function without arguments will force an infinite sequence of numbers to be generated, quickly resulting in an out of memory error in the heap. Instead, we can either pass arguments to the range function that limit the sequence size or wrap the range function in another function ( take 7 ( range )) The take function defines how much of a sequence that range should generate. So we can call range without arguments and it will generate only those numbers in the sequence as specified by take .","title":"Making something lazy"},{"location":"thinking-functionally/lazy-evaluation/#references","text":"Being lazy in Clojure - lazily generating monsters","title":"References"},{"location":"thinking-functionally/list-comprehension/","text":"List Comprehension \u03bb\ufe0e In general terms, list comprehensions should: be distinct from (nested) for loops and the use of map & filter functions within the syntax of the language. return either a list or an iterator (an iterating being something that returns successive members of a collection, in order), In Clojure, list comprehension is via the for function. This is different to the for in other languages as you will see. (for [number [1 2 3]] (* number 2)) The for function should be read as follows: \"for each number in the collection [1 2 3], apply the function (* number 2)\" Couldn't we just do this with map? Yes, we could. (map #(* % 2) [1 2 3]) So why do we need for function? It really shows its value when you are working with multiple collections (for [number [1 2 3] letter [:a :b :c]] (str number letter)) Again we could use map function for this as follows (mapcat (fn [number] (map (fn [letter] (str number letter))))) So with the for function we can do the same calculation with much easier code to reason about. Filtering results with predicates \u03bb\ufe0e With the for function we can add a filter on the results by using a predicate, to test if a condition is true or false. Any values that meet the condition as true are returned, values that are false are omitted. (for [x (range 10) :when (odd? x)] x) (for [x (range 10) :while (even? x)] x) To do this kind of filtering with maps would be possible, however the code would be harder for humans to parse and understand. Note Create a 3-tumbler combination padlock, with each tumbler having a range of 0 to 9. Count the number of possible combinations. Then add a predicate that filters out some of the combinations Lets just model all the possible combinations (for [tumbler-1 (range 10) tumbler-2 (range 10) tumbler-3 (range 10)] [tumbler-1 tumbler-2 tumbler-3]) Now lets count the combinations (count (for [tumbler-1 (range 10) tumbler-2 (range 10) tumbler-3 (range 10)] [tumbler-1 tumbler-2 tumbler-3])) Now add a predicate using :when to filter out the combinations that do not match. (count (for [tumbler-1 (range 10) tumbler-2 (range 10) tumbler-3 (range 10) :when (or (= tumbler-1 tumbler-2) (= tumbler-2 tumbler-3) (= tumbler-3 tumbler-1))] [tumbler-1 tumbler-2 tumbler-3])) Note Create a 2 character prefix for tickets, using capital letters from the English alphabet. However, exclude I and O as they can be mistaken for numbers Lets just model all the possible combinations (for [letter-1 capital-letters letter-2 capital-letters :when (and (not (blacklisted letter-1)) (not (blacklisted letter-2)))] (str letter-1 letter-2))","title":"List Comprehension"},{"location":"thinking-functionally/list-comprehension/#list-comprehension","text":"In general terms, list comprehensions should: be distinct from (nested) for loops and the use of map & filter functions within the syntax of the language. return either a list or an iterator (an iterating being something that returns successive members of a collection, in order), In Clojure, list comprehension is via the for function. This is different to the for in other languages as you will see. (for [number [1 2 3]] (* number 2)) The for function should be read as follows: \"for each number in the collection [1 2 3], apply the function (* number 2)\" Couldn't we just do this with map? Yes, we could. (map #(* % 2) [1 2 3]) So why do we need for function? It really shows its value when you are working with multiple collections (for [number [1 2 3] letter [:a :b :c]] (str number letter)) Again we could use map function for this as follows (mapcat (fn [number] (map (fn [letter] (str number letter))))) So with the for function we can do the same calculation with much easier code to reason about.","title":"List Comprehension"},{"location":"thinking-functionally/list-comprehension/#filtering-results-with-predicates","text":"With the for function we can add a filter on the results by using a predicate, to test if a condition is true or false. Any values that meet the condition as true are returned, values that are false are omitted. (for [x (range 10) :when (odd? x)] x) (for [x (range 10) :while (even? x)] x) To do this kind of filtering with maps would be possible, however the code would be harder for humans to parse and understand. Note Create a 3-tumbler combination padlock, with each tumbler having a range of 0 to 9. Count the number of possible combinations. Then add a predicate that filters out some of the combinations Lets just model all the possible combinations (for [tumbler-1 (range 10) tumbler-2 (range 10) tumbler-3 (range 10)] [tumbler-1 tumbler-2 tumbler-3]) Now lets count the combinations (count (for [tumbler-1 (range 10) tumbler-2 (range 10) tumbler-3 (range 10)] [tumbler-1 tumbler-2 tumbler-3])) Now add a predicate using :when to filter out the combinations that do not match. (count (for [tumbler-1 (range 10) tumbler-2 (range 10) tumbler-3 (range 10) :when (or (= tumbler-1 tumbler-2) (= tumbler-2 tumbler-3) (= tumbler-3 tumbler-1))] [tumbler-1 tumbler-2 tumbler-3])) Note Create a 2 character prefix for tickets, using capital letters from the English alphabet. However, exclude I and O as they can be mistaken for numbers Lets just model all the possible combinations (for [letter-1 capital-letters letter-2 capital-letters :when (and (not (blacklisted letter-1)) (not (blacklisted letter-2)))] (str letter-1 letter-2))","title":"Filtering results with predicates"},{"location":"thinking-functionally/managing-state-changes/","text":"Managing state changes \u03bb\ufe0e","title":"Managing state changes"},{"location":"thinking-functionally/managing-state-changes/#managing-state-changes","text":"","title":"Managing state changes"},{"location":"thinking-functionally/map-with-partial/","text":"map with partial \u03bb\ufe0e Lets look at different ways we can map functions over collections with partial We can map over a collection of words and increment them by writing an anonymous function. ( map ( fn [ animal ] ( str animal \"s\" )) [ \"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\" ]) The anonymous function has a terse form, that removes the boiler plate function definition (fn []) , allowing definition of only the body of a function. % represents a single argument passed to the function. The % syntax also supports numbers where there are multiple arguments, e.g. %1 , %2 for the first and second arguments. %& represents all other arguments and is the same as (fn [& args]) or (fn [arg1 & args]) . The # character tells the Clojure reader that this is the macro form of a function definition and expands the code to the full form before executing. (map #(str % \"s\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"]) Hint::When to use the terse form of anonymous function \u03bb\ufe0e The terse form is often used with higher order functions, as an argument to a function. If the body of the function is simple to comprehend, then the terse form of anonymous function definition is appropriate. When the body of a function is more complex, then consider using a separate defn function definition. Returning a Vector instead of a sequence \u03bb\ufe0e The map function returns a lazy sequence. This is very useful for large data sets. mapv is an eager version of map that returns the result as a vector. This is useful when you require random access lookup in real time. mapv can also be used to return an eager result if laziness is not required. (mapv #(str % \"s\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"]) Hint::Lists and vectors - does it matter? \u03bb\ufe0e Some functions in clojure.core will return a sequence using the list syntax, even if the arguments given are vectors. Most of the time this is not important, as Clojure considers values rather than constructs for most of its functions. For example, (= (\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"]) is true as the values are compared rather than the type of container (list, vector) Using conditionals \u03bb\ufe0e Adding sheep as an element raises a problem, as the plural of sheep is sheep. Using a conditional, a test can be added to determine if a name should be made plural First lets abstract out the anonymous function to a shared function using defn (defn pluralise \"Pluralise a given string value\" [animal] (str string \"s\")) def will bind a name to our collection of animals (def animals [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"]) (map pluralise animals) The if function included a conditional test. If that test is true the next expression is evaluated. If the test is false, the second expression is evaluated. (defn pluralise \"Pluralise a given string value\" [animal] (if (= animal \"sheep\") animal (str animal \"s\"))) (map pluralise animals) There are several animals that do not have a plural form. Rather than make a complicated test, a collection of animals that are not plural can be defined. (def non-plural-words [\"deer\" \"sheep\" \"shrimp\" ]) (defn pluralise \"Pluralise a given string value\" [animal] (if (some #{animal} non-plural-words) animal (str animal \"s\"))) (def animals [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\" \"sheep\" \"shrimp\" \"deer\"]) (map pluralise animals) To keep the function pure, we should pass the non-plural-words as an argument (defn pluralise \"Pluralise a given string value\" [animal non-plural-words] (if (some #{animal} non-plural-words) animal (str animal \"s\"))) Using the terse form of the anonymous function, #() , call the pluralise function with two arguments. map will replace the % character with an element from the animals collection for each element in the collection. (map #(pluralise % non-plural-words) animals) The partial function can be used instead of creating an anonymous function, removing the need for more custom code. The order of the arguments must be swapped for partial to call pluralise correctly (defn pluralise \"Pluralise a given string value\" [non-plural-words animal] (if (some #{animal} non-plural-words) animal (str animal \"s\"))) Now we can call pluralise by wrapping it as a partial function. The argument that is the non-plural-words is constant, its the individual elements of animals I want to get out via map. So when map runs it gets an element from the animals collection and adds it to the call to pluralise, along with non-plural-words (map (partial pluralise non-plural-words) animals) Using partial here is like calling (pluralise non-plural-words ,,,) but each time including an element from animals where the ,,, is. Learning at the REPL \u03bb\ufe0e At first I was getting incorrect output, [\"deer\" \"sheep\" \"shrimp\"] , then I realised that it was returning the non-plural-words instead of pluralised animals. The arguments from the partial function were being sent in the wrong order. So I simply changed the order in the pluralise function and it worked. I checked this by adding some old-fashioned print statement. (defn pluralise-wrong-argument-order \"Pluralise a given string value\" [animal non-plural-words ] (if (some #{animal} non-plural-words) (do (println (str animal \" its true\")) animal) (do (println (str animal \" its false\")) (str animal \"s\"))))","title":"map with partial"},{"location":"thinking-functionally/map-with-partial/#map-with-partial","text":"Lets look at different ways we can map functions over collections with partial We can map over a collection of words and increment them by writing an anonymous function. ( map ( fn [ animal ] ( str animal \"s\" )) [ \"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\" ]) The anonymous function has a terse form, that removes the boiler plate function definition (fn []) , allowing definition of only the body of a function. % represents a single argument passed to the function. The % syntax also supports numbers where there are multiple arguments, e.g. %1 , %2 for the first and second arguments. %& represents all other arguments and is the same as (fn [& args]) or (fn [arg1 & args]) . The # character tells the Clojure reader that this is the macro form of a function definition and expands the code to the full form before executing. (map #(str % \"s\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"])","title":"map with partial"},{"location":"thinking-functionally/map-with-partial/#hintwhen-to-use-the-terse-form-of-anonymous-function","text":"The terse form is often used with higher order functions, as an argument to a function. If the body of the function is simple to comprehend, then the terse form of anonymous function definition is appropriate. When the body of a function is more complex, then consider using a separate defn function definition.","title":"Hint::When to use the terse form of anonymous function"},{"location":"thinking-functionally/map-with-partial/#returning-a-vector-instead-of-a-sequence","text":"The map function returns a lazy sequence. This is very useful for large data sets. mapv is an eager version of map that returns the result as a vector. This is useful when you require random access lookup in real time. mapv can also be used to return an eager result if laziness is not required. (mapv #(str % \"s\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"])","title":"Returning a Vector instead of a sequence"},{"location":"thinking-functionally/map-with-partial/#hintlists-and-vectors-does-it-matter","text":"Some functions in clojure.core will return a sequence using the list syntax, even if the arguments given are vectors. Most of the time this is not important, as Clojure considers values rather than constructs for most of its functions. For example, (= (\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\") [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"]) is true as the values are compared rather than the type of container (list, vector)","title":"Hint::Lists and vectors - does it matter?"},{"location":"thinking-functionally/map-with-partial/#using-conditionals","text":"Adding sheep as an element raises a problem, as the plural of sheep is sheep. Using a conditional, a test can be added to determine if a name should be made plural First lets abstract out the anonymous function to a shared function using defn (defn pluralise \"Pluralise a given string value\" [animal] (str string \"s\")) def will bind a name to our collection of animals (def animals [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\"]) (map pluralise animals) The if function included a conditional test. If that test is true the next expression is evaluated. If the test is false, the second expression is evaluated. (defn pluralise \"Pluralise a given string value\" [animal] (if (= animal \"sheep\") animal (str animal \"s\"))) (map pluralise animals) There are several animals that do not have a plural form. Rather than make a complicated test, a collection of animals that are not plural can be defined. (def non-plural-words [\"deer\" \"sheep\" \"shrimp\" ]) (defn pluralise \"Pluralise a given string value\" [animal] (if (some #{animal} non-plural-words) animal (str animal \"s\"))) (def animals [\"pig\" \"cow\" \"goat\" \"cat\" \"dog\" \"rabbit\" \"sheep\" \"shrimp\" \"deer\"]) (map pluralise animals) To keep the function pure, we should pass the non-plural-words as an argument (defn pluralise \"Pluralise a given string value\" [animal non-plural-words] (if (some #{animal} non-plural-words) animal (str animal \"s\"))) Using the terse form of the anonymous function, #() , call the pluralise function with two arguments. map will replace the % character with an element from the animals collection for each element in the collection. (map #(pluralise % non-plural-words) animals) The partial function can be used instead of creating an anonymous function, removing the need for more custom code. The order of the arguments must be swapped for partial to call pluralise correctly (defn pluralise \"Pluralise a given string value\" [non-plural-words animal] (if (some #{animal} non-plural-words) animal (str animal \"s\"))) Now we can call pluralise by wrapping it as a partial function. The argument that is the non-plural-words is constant, its the individual elements of animals I want to get out via map. So when map runs it gets an element from the animals collection and adds it to the call to pluralise, along with non-plural-words (map (partial pluralise non-plural-words) animals) Using partial here is like calling (pluralise non-plural-words ,,,) but each time including an element from animals where the ,,, is.","title":"Using conditionals"},{"location":"thinking-functionally/map-with-partial/#learning-at-the-repl","text":"At first I was getting incorrect output, [\"deer\" \"sheep\" \"shrimp\"] , then I realised that it was returning the non-plural-words instead of pluralised animals. The arguments from the partial function were being sent in the wrong order. So I simply changed the order in the pluralise function and it worked. I checked this by adding some old-fashioned print statement. (defn pluralise-wrong-argument-order \"Pluralise a given string value\" [animal non-plural-words ] (if (some #{animal} non-plural-words) (do (println (str animal \" its true\")) animal) (do (println (str animal \" its false\")) (str animal \"s\"))))","title":"Learning at the REPL"},{"location":"thinking-functionally/partial-functions/","text":"Currying & Partial Functions \u03bb\ufe0e Clojure does not support automatic currying, (+3) would result in applying + to 3, resulting with number 3 instead of a function that adds 3 as in Haskell. Therefore, in Clojure we use partial that enables the equivalent behavior. ( defn sum \"Sum two numbers together\" [ number1 number2 ] ( + number1 number2 )) ( sum 1 2 ) ;; => 3 If you try and evaluate sum with a single value then you get an arity exception ( sum 1 ) ;; => clojure.lang.ArityException ;; => Wrong number of args (1) passed to: functional-concepts/sum If we did need to call sum with fewer than the required arguments, for example if we are mapping sum over a vector, then we can use partial to help us call the sum function with the right number of arguments. Lets add the value 2 to each element in our collection ( map ( partial sum 2 ) [ 1 3 5 7 9 ]) Using functions on more arguments than they can normally take \u03bb\ufe0e The reduce function can only work on a single collection as an argument (or a value and a collection), so an error occurs if you wish to reduce over multiple collections. ( reduce + [ 1 2 3 4 ]) ;; => 10 ( reduce + [ 1 2 3 4 ] [ 5 6 7 8 ]) ;; returns an error due to invalid arguments However, by using partial we can take one collection at once and return the result of reduce on each of those collections. ( map ( partial reduce + ) [[ 1 2 3 4 ] [ 5 6 7 8 ]]) In the above example we map the partial reduce function over each element of the vector, each element being a collection. Using partial to set a default value \u03bb\ufe0e We can use the partial function to create a default message that can be just given just the custom part. For example, if we want to have a default welcome message but include a custom part to the message at the end. First we would define a function that combines parts of the message together. ( defn join-strings \"join one or more strings\" [ & args ] ( apply str args )) The [& args] argument string says take all the arguments passed and refer to them by the name args. Its the & character that has the semantic meaning, so any name after the & can be used, although args is common if there is no domain specific context involved. We can simply call this function with all the words of the message. ( join-strings \"Hello\" \" \" \"Clojure\" \" \" \"world\" ) ;; \u21d2 \"Hello Clojure world\" Now we define a name called wrap-message that can be used to wrap the start of our message. This name binds to a partial function call to join-strings which send that function the default message and any custom message you add when evaluate wrap-message ( def wrap-message ( partial join-strings \"Hello Clojurians in \" )) ( wrap-message ) ;; \u21d2 \"Hello Clojurians in \" ( wrap-message \"London\" ) ;; => \"Hello Clojurians in London\" Currying in clojure \u03bb\ufe0e Currying is the process of taking some function that accepts multiple arguments, and turning it into a sequence of functions, each accepting a single argument. Or put another way, to transform a function with multiple arguments into a chain of single-argument functions. Currying relies on having fixed argument sizes, whereas Clojure gets a lot of flexibility from variable argument lengths (variable arity). Clojure therefore has the partial function gives results similar to currying, however the partial function also works with variable functions. partial refers to supplying some number of arguments to a function, and getting back a new function that takes the rest of the arguments and returns the final result One advantage of partial is to avoid having to write your own anonymous functions Useful references \u03bb\ufe0e Partial function applications for humans","title":"Currying & Partial Functions"},{"location":"thinking-functionally/partial-functions/#currying-partial-functions","text":"Clojure does not support automatic currying, (+3) would result in applying + to 3, resulting with number 3 instead of a function that adds 3 as in Haskell. Therefore, in Clojure we use partial that enables the equivalent behavior. ( defn sum \"Sum two numbers together\" [ number1 number2 ] ( + number1 number2 )) ( sum 1 2 ) ;; => 3 If you try and evaluate sum with a single value then you get an arity exception ( sum 1 ) ;; => clojure.lang.ArityException ;; => Wrong number of args (1) passed to: functional-concepts/sum If we did need to call sum with fewer than the required arguments, for example if we are mapping sum over a vector, then we can use partial to help us call the sum function with the right number of arguments. Lets add the value 2 to each element in our collection ( map ( partial sum 2 ) [ 1 3 5 7 9 ])","title":"Currying &amp; Partial Functions"},{"location":"thinking-functionally/partial-functions/#using-functions-on-more-arguments-than-they-can-normally-take","text":"The reduce function can only work on a single collection as an argument (or a value and a collection), so an error occurs if you wish to reduce over multiple collections. ( reduce + [ 1 2 3 4 ]) ;; => 10 ( reduce + [ 1 2 3 4 ] [ 5 6 7 8 ]) ;; returns an error due to invalid arguments However, by using partial we can take one collection at once and return the result of reduce on each of those collections. ( map ( partial reduce + ) [[ 1 2 3 4 ] [ 5 6 7 8 ]]) In the above example we map the partial reduce function over each element of the vector, each element being a collection.","title":"Using functions on more arguments than they can normally take"},{"location":"thinking-functionally/partial-functions/#using-partial-to-set-a-default-value","text":"We can use the partial function to create a default message that can be just given just the custom part. For example, if we want to have a default welcome message but include a custom part to the message at the end. First we would define a function that combines parts of the message together. ( defn join-strings \"join one or more strings\" [ & args ] ( apply str args )) The [& args] argument string says take all the arguments passed and refer to them by the name args. Its the & character that has the semantic meaning, so any name after the & can be used, although args is common if there is no domain specific context involved. We can simply call this function with all the words of the message. ( join-strings \"Hello\" \" \" \"Clojure\" \" \" \"world\" ) ;; \u21d2 \"Hello Clojure world\" Now we define a name called wrap-message that can be used to wrap the start of our message. This name binds to a partial function call to join-strings which send that function the default message and any custom message you add when evaluate wrap-message ( def wrap-message ( partial join-strings \"Hello Clojurians in \" )) ( wrap-message ) ;; \u21d2 \"Hello Clojurians in \" ( wrap-message \"London\" ) ;; => \"Hello Clojurians in London\"","title":"Using partial to set a default value"},{"location":"thinking-functionally/partial-functions/#currying-in-clojure","text":"Currying is the process of taking some function that accepts multiple arguments, and turning it into a sequence of functions, each accepting a single argument. Or put another way, to transform a function with multiple arguments into a chain of single-argument functions. Currying relies on having fixed argument sizes, whereas Clojure gets a lot of flexibility from variable argument lengths (variable arity). Clojure therefore has the partial function gives results similar to currying, however the partial function also works with variable functions. partial refers to supplying some number of arguments to a function, and getting back a new function that takes the rest of the arguments and returns the final result One advantage of partial is to avoid having to write your own anonymous functions","title":"Currying in clojure"},{"location":"thinking-functionally/partial-functions/#useful-references","text":"Partial function applications for humans","title":"Useful references"},{"location":"thinking-functionally/pattern-matching/","text":"Pattern matching \u03bb\ufe0e Fixme work in progress Regular Expression \u03bb\ufe0e Destructuring \u03bb\ufe0e","title":"Pattern matching"},{"location":"thinking-functionally/pattern-matching/#pattern-matching","text":"Fixme work in progress","title":"Pattern matching"},{"location":"thinking-functionally/pattern-matching/#regular-expression","text":"","title":"Regular Expression"},{"location":"thinking-functionally/pattern-matching/#destructuring","text":"","title":"Destructuring"},{"location":"thinking-functionally/persistent-data-structures/","text":"Persistent data structures \u03bb\ufe0e","title":"Persistent data structures"},{"location":"thinking-functionally/persistent-data-structures/#persistent-data-structures","text":"","title":"Persistent data structures"},{"location":"thinking-functionally/polymorphism/","text":"Polymorphic function definitions \u03bb\ufe0e Polymorphic means many forms. The simplest example of polymorphism in Clojure is a function definition that acts differently based on the number of arguments passed. Usually you define a function with one set of arguments, either none [] , one [one] or many [any number of args] , using the basic syntax ( defn name \"I am the doc string to describe the function\" [ args ] ( str \"define your behaviour here\" )) Instead of writing multiple functions with the same name that each take different numbers of arguments, you can use the following polymorphic syntax in Clojure ( defn name \"I am the doc string to describe the function\" ([] ( str \"behaviour with no args\" )) ([ one ] ( str \"behaviour with one arg\" )) ([ one two & args ] ( str \"behaviour with multiple args\" ))) Note Write a simple function called i-am-polly that returns a default message when given no arguments and a custom message when given a custom string as an argument ( defn i-am-polly ([] ( i-am-polly \"My name is polly\" )) ([ message ] ( str message ))) ( i-am-polly ) ( i-am-polly \"I call different behaviour depending on arguments sent\" )","title":"Polymorphic function definitions"},{"location":"thinking-functionally/polymorphism/#polymorphic-function-definitions","text":"Polymorphic means many forms. The simplest example of polymorphism in Clojure is a function definition that acts differently based on the number of arguments passed. Usually you define a function with one set of arguments, either none [] , one [one] or many [any number of args] , using the basic syntax ( defn name \"I am the doc string to describe the function\" [ args ] ( str \"define your behaviour here\" )) Instead of writing multiple functions with the same name that each take different numbers of arguments, you can use the following polymorphic syntax in Clojure ( defn name \"I am the doc string to describe the function\" ([] ( str \"behaviour with no args\" )) ([ one ] ( str \"behaviour with one arg\" )) ([ one two & args ] ( str \"behaviour with multiple args\" ))) Note Write a simple function called i-am-polly that returns a default message when given no arguments and a custom message when given a custom string as an argument ( defn i-am-polly ([] ( i-am-polly \"My name is polly\" )) ([ message ] ( str message ))) ( i-am-polly ) ( i-am-polly \"I call different behaviour depending on arguments sent\" )","title":"Polymorphic function definitions"},{"location":"thinking-functionally/pure-functions/","text":"Pure functions \u03bb\ufe0e A function is considered pure if does not side effects or is affected by side causes. A pure function does not change any other part of the system and is not affected by any other part of the system. When you pass arguments to a function and that function returns a value without interacting with any other part of the system, then that function is considered pure. Should something from outside a function be allowed to affect the result of evaluating a function, or if that function be allowed to affect the outside world, then its an impure function. So lets look at a simple code example Note::Write a pure function that adds two numbers together ? \u03bb\ufe0e (defn add-numbers [number1 number2] (+ number1 number2)) (add-numbers 1 2) Lets look at each line of this suggested answer ;; function takes 2 arguments ;; function uses both arguments for result (defn add-numbers [number1 number2] (+ number1 number2)) ;; specific values are passed as arguments (add-numbers 1 2) An example with map \u03bb\ufe0e Note Define a collection called numbers and write a named function that increments each number of the numbers collection. Is your function pure or impure ? (def numbers '(5 4 3 2 1)) (defn increment-numbers [] (map inc numbers)) (increment-numbers) The function takes no arguments and is pulling in a value from outside the function. This is a trivial example, but if all your code is like this it would be more complex. If the value pointed to by numbers is mutable and changes before the increment-numbers function is called then you will get different results. Here is a Pure function example (def numbers '(5 4 3 2 1)) (defn increment-numbers [number-collection] (map inc number-collection)) (increment-numbers numbers) In this example we are explicitly passing the numbers collection to the function. The function works on passed value and returns a predictable result.","title":"Pure functions"},{"location":"thinking-functionally/pure-functions/#pure-functions","text":"A function is considered pure if does not side effects or is affected by side causes. A pure function does not change any other part of the system and is not affected by any other part of the system. When you pass arguments to a function and that function returns a value without interacting with any other part of the system, then that function is considered pure. Should something from outside a function be allowed to affect the result of evaluating a function, or if that function be allowed to affect the outside world, then its an impure function. So lets look at a simple code example","title":"Pure functions"},{"location":"thinking-functionally/pure-functions/#notewrite-a-pure-function-that-adds-two-numbers-together","text":"(defn add-numbers [number1 number2] (+ number1 number2)) (add-numbers 1 2) Lets look at each line of this suggested answer ;; function takes 2 arguments ;; function uses both arguments for result (defn add-numbers [number1 number2] (+ number1 number2)) ;; specific values are passed as arguments (add-numbers 1 2)","title":"Note::Write a pure function that adds two numbers together ?"},{"location":"thinking-functionally/pure-functions/#an-example-with-map","text":"Note Define a collection called numbers and write a named function that increments each number of the numbers collection. Is your function pure or impure ? (def numbers '(5 4 3 2 1)) (defn increment-numbers [] (map inc numbers)) (increment-numbers) The function takes no arguments and is pulling in a value from outside the function. This is a trivial example, but if all your code is like this it would be more complex. If the value pointed to by numbers is mutable and changes before the increment-numbers function is called then you will get different results. Here is a Pure function example (def numbers '(5 4 3 2 1)) (defn increment-numbers [number-collection] (map inc number-collection)) (increment-numbers numbers) In this example we are explicitly passing the numbers collection to the function. The function works on passed value and returns a predictable result.","title":"An example with map"},{"location":"thinking-functionally/recursion-polymorphism/","text":"Recursion & Polymorphism \u03bb\ufe0e Fixme work in progress The following sum function will calculate the value of adding all the elements in a collection. You can alter the results by adding a starting value to the calculation as a second argument when calling sum ( defn sum ([ vals ] ( sum vals 0 )) ([ vals accumulating-total ] ( if ( empty? vals ) accumulating-total ( sum ( rest vals ) ( + ( first vals ) accumulating-total ))))) ( sum [ 2 7 9 11 13 ]) ( sum [ 1 ]) ( sum [ 2 7 9 11 13 ] 9 ) Rather than duplicate the calculation, the behaviour of calling sum with just a collection simply calls sum again, this time passing a starting value of zero.","title":"Recursion & Polymorphism"},{"location":"thinking-functionally/recursion-polymorphism/#recursion-polymorphism","text":"Fixme work in progress The following sum function will calculate the value of adding all the elements in a collection. You can alter the results by adding a starting value to the calculation as a second argument when calling sum ( defn sum ([ vals ] ( sum vals 0 )) ([ vals accumulating-total ] ( if ( empty? vals ) accumulating-total ( sum ( rest vals ) ( + ( first vals ) accumulating-total ))))) ( sum [ 2 7 9 11 13 ]) ( sum [ 1 ]) ( sum [ 2 7 9 11 13 ] 9 ) Rather than duplicate the calculation, the behaviour of calling sum with just a collection simply calls sum again, this time passing a starting value of zero.","title":"Recursion &amp; Polymorphism"},{"location":"thinking-functionally/recursion/","text":"Recursion \u03bb\ufe0e Fixme work in progress Recursion is used greatly in Clojure to iterate through data and as anything can be treated as data in Clojure you can understand why. The constructs available in Clojure for recursion include * loop and recur * Named function that calls itself * map , reduce , filter , remove , etc. * for Recursively calling the same function \u03bb\ufe0e Lets iterate though a collection using recursion by writing a function that calls itself ( defn recursively-use-a-collection [ collection ] ( println ( first collection )) ( if ( empty? collection ) ( print-str \"no more values to process\" ) ( recursively-use-a-collection ( rest collection )))) ( recursively-use-a-collection [ 1 2 3 ]) Lets take this recursive approach to create a function that can tell us the length of a collection (list or vector) We define a function that takes a collection of an argument. The collection is tested to see if it is empty and if so a zero value is returned. If the collection is not empty, then we ( defn length [ collection ] ( if ( empty? collection ) 0 ( + 1 ( length ( rest collection ))))) ;; => #'clojure-through-code.01-basics/length If we call the length function with an empty collection, then the empty? condition will return true and the if expression will evaluate the first expression, 0, returning 0. ( length []) ;; => 0 If we call the length function with a collection containing 3 values, then the empty? function will return false and the if function will evaluate the second expression. The second expression starts with a simple counter, using the + function and the value one ( length [ 0 1 2 ]) ;; => 3 ( + 1 ( length [ 1 2 ])) ( + 1 ( + 1 ( length [ 2 ]))) ( + 1 ( + 1 ( + 1 ( length [])))) ( + 1 ( + 1 ( + 1 0 ))) ( length ( range 24 )) ;; => 24 (defn length [collection] (kk)) Further recursion examples \u03bb\ufe0e Other functions to consider * every * accumulating / accumulative * keep","title":"Recursion"},{"location":"thinking-functionally/recursion/#recursion","text":"Fixme work in progress Recursion is used greatly in Clojure to iterate through data and as anything can be treated as data in Clojure you can understand why. The constructs available in Clojure for recursion include * loop and recur * Named function that calls itself * map , reduce , filter , remove , etc. * for","title":"Recursion"},{"location":"thinking-functionally/recursion/#recursively-calling-the-same-function","text":"Lets iterate though a collection using recursion by writing a function that calls itself ( defn recursively-use-a-collection [ collection ] ( println ( first collection )) ( if ( empty? collection ) ( print-str \"no more values to process\" ) ( recursively-use-a-collection ( rest collection )))) ( recursively-use-a-collection [ 1 2 3 ]) Lets take this recursive approach to create a function that can tell us the length of a collection (list or vector) We define a function that takes a collection of an argument. The collection is tested to see if it is empty and if so a zero value is returned. If the collection is not empty, then we ( defn length [ collection ] ( if ( empty? collection ) 0 ( + 1 ( length ( rest collection ))))) ;; => #'clojure-through-code.01-basics/length If we call the length function with an empty collection, then the empty? condition will return true and the if expression will evaluate the first expression, 0, returning 0. ( length []) ;; => 0 If we call the length function with a collection containing 3 values, then the empty? function will return false and the if function will evaluate the second expression. The second expression starts with a simple counter, using the + function and the value one ( length [ 0 1 2 ]) ;; => 3 ( + 1 ( length [ 1 2 ])) ( + 1 ( + 1 ( length [ 2 ]))) ( + 1 ( + 1 ( + 1 ( length [])))) ( + 1 ( + 1 ( + 1 0 ))) ( length ( range 24 )) ;; => 24 (defn length [collection] (kk))","title":"Recursively calling the same function"},{"location":"thinking-functionally/recursion/#further-recursion-examples","text":"Other functions to consider * every * accumulating / accumulative * keep","title":"Further recursion examples"},{"location":"thinking-functionally/sequence-abstractions/","text":"Sequence abstraction \u03bb\ufe0e Fixme work in progress ( first ' ( 1 2 3 4 5 )) ( rest ' ( 1 2 3 4 5 )) ( last ' ( 1 2 3 4 5 )) ( defn nth [ items n ] ( if ( = n 0 ) ( first items ) ( recur ( rest items ) ( - n 1 )))) ( define squares ' ( 0 1 4 9 16 25 )) ( nth squares 3 )","title":"Sequence abstraction"},{"location":"thinking-functionally/sequence-abstractions/#sequence-abstraction","text":"Fixme work in progress ( first ' ( 1 2 3 4 5 )) ( rest ' ( 1 2 3 4 5 )) ( last ' ( 1 2 3 4 5 )) ( defn nth [ items n ] ( if ( = n 0 ) ( first items ) ( recur ( rest items ) ( - n 1 )))) ( define squares ' ( 0 1 4 9 16 25 )) ( nth squares 3 )","title":"Sequence abstraction"},{"location":"thinking-functionally/sequences/","text":"Sequences \u03bb\ufe0e Fixme work in progress Data structures can be built by combining functions ( cons 1 ( cons 2 ( cons 3 ( cons 4 nil )))) ( ->> nil ( cons 4 ) ( cons 3 ) ( cons 2 ) ( cons 1 ))","title":"Sequences"},{"location":"thinking-functionally/sequences/#sequences","text":"Fixme work in progress Data structures can be built by combining functions ( cons 1 ( cons 2 ( cons 3 ( cons 4 nil )))) ( ->> nil ( cons 4 ) ( cons 3 ) ( cons 2 ) ( cons 1 ))","title":"Sequences"},{"location":"thinking-functionally/side-effects/","text":"Side effects \u03bb\ufe0e A side effect is something that creates a change outside of the current code scope, or something external that affects the behaviour or result of executing the code in the current scope. Nondeterministic - the complexity iceberg \u03bb\ufe0e When you have side effects, you cannot reason accurately about a piece of the code. In order to understand a piece of code you must look at all possible side effects created in all lines of code to ensure you fully understand the result of executing your code. With side effects in your system, complexity is hidden, causing a far greater risk of a dangerous situation. Side causes - side effects \u03bb\ufe0e You can think about these effects is in two specific areas, Side Causes and Side Effects Side Causes - are where other pieces of code (function) or state change affects the behaviour of a function. Side Effects - are where the current code (function) affects the rest of the system Hint::Side Causes term \u03bb\ufe0e The term of side causes was coined by Kris Jenkins in the superb article What is Functional Programming?","title":"Side effects"},{"location":"thinking-functionally/side-effects/#side-effects","text":"A side effect is something that creates a change outside of the current code scope, or something external that affects the behaviour or result of executing the code in the current scope.","title":"Side effects"},{"location":"thinking-functionally/side-effects/#nondeterministic-the-complexity-iceberg","text":"When you have side effects, you cannot reason accurately about a piece of the code. In order to understand a piece of code you must look at all possible side effects created in all lines of code to ensure you fully understand the result of executing your code. With side effects in your system, complexity is hidden, causing a far greater risk of a dangerous situation.","title":"Nondeterministic - the complexity iceberg"},{"location":"thinking-functionally/side-effects/#side-causes-side-effects","text":"You can think about these effects is in two specific areas, Side Causes and Side Effects Side Causes - are where other pieces of code (function) or state change affects the behaviour of a function. Side Effects - are where the current code (function) affects the rest of the system","title":"Side causes - side effects"},{"location":"thinking-functionally/side-effects/#hintside-causes-term","text":"The term of side causes was coined by Kris Jenkins in the superb article What is Functional Programming?","title":"Hint::Side Causes term"},{"location":"thinking-functionally/tail-recursion/","text":"Tail recursion \u03bb\ufe0e Fixme work in progress If we generate a very large collection we run the risk of blowing our heap space. For example we could use range to generate a very large collection, say a vector containing 10 billion values Don't try this example below ( vec ( range 0 9999999999 )) ;; this will crash after a short while as it will use up all your heap space Using tail call optimisation (tail recursion) allows us to reuse a memory location when we call a function recursively. This tail recursion is not part of the underlying Java Virtual Machine (JVM), so instead Clojure has a specific function called recur The recur function allows the processing of a very large data set without blowing the heap space because the memory space will be reused. The recur function must be the last expression in order to work. ( defn sum ([ vals ] ( sum vals 0 )) ([ vals accumulating-total ] ( if ( empty? vals ) accumulating-total ( recur ( rest vals ) ( + ( first vals ) accumulating-total ))))) ( sum ( vec ( range 0 9999999 )))","title":"Tail recursion"},{"location":"thinking-functionally/tail-recursion/#tail-recursion","text":"Fixme work in progress If we generate a very large collection we run the risk of blowing our heap space. For example we could use range to generate a very large collection, say a vector containing 10 billion values Don't try this example below ( vec ( range 0 9999999999 )) ;; this will crash after a short while as it will use up all your heap space Using tail call optimisation (tail recursion) allows us to reuse a memory location when we call a function recursively. This tail recursion is not part of the underlying Java Virtual Machine (JVM), so instead Clojure has a specific function called recur The recur function allows the processing of a very large data set without blowing the heap space because the memory space will be reused. The recur function must be the last expression in order to work. ( defn sum ([ vals ] ( sum vals 0 )) ([ vals accumulating-total ] ( if ( empty? vals ) accumulating-total ( recur ( rest vals ) ( + ( first vals ) accumulating-total ))))) ( sum ( vec ( range 0 9999999 )))","title":"Tail recursion"},{"location":"thinking-functionally/threading-macros/","text":"Threading macros \u03bb\ufe0e The thread-first -> and thread-last ->> macros allow Clojure code to be written in a more sequential style and with a more terse syntax. This can sometimes make code easier to understand by humans. Using the thread-first macro, -> , the result of the first evaluation is passed as the first argument to the next function and so on. ```eval-clojure (-> (clojure.string/lower-case \"HELLO\") (str \", Clojure world\")) The value hello is converted to lower case and that result is passed as the first argument to the next function. The string function is then evaluated with this new argument and the final \"hello, Clojure world\" string is returned as the result. The thread-last macro `->>` passes the result of the first evaluation as the **last argument** to the next expression. ```eval-clojure (->> \" this\" (str \" is\") (str \" backwards\")) Hint::Parens optional \u03bb\ufe0e function calls that only take one argument, the one passed by earlier expressions, can be included in the threading macro code without the surrounding () parens. Reading Clojure code \u03bb\ufe0e To read Clojure it is common to start from the inside out, as this is how the Clojure reader also works. This style is inherited from Lisp of which Clojure is an implementation. The following code is written in classic Lisp style. ( reverse ( sort-by val ( frequencies ( remove common-english-words ( map # ( clojure.string/lower-case % ) ( re-seq # \"[a-zA-Z0-9|']+\" ( slurp book.txt ))))))) Reading inside out: 1. slurp in the contents of the book.txt file, converting it to a string. 2. use a regular expression to create a new sequence where the book is a sequence of individual strings for each word. 3. convert each string in the sequence by mapping the lower-case function over each element of the sequence. 4. remove common english words such as the and and from the sequence. 5. count how many times each word occurs and pair the string with its frequency in the book. 6. reverse the order of the sequence by the value of frequency, so the most used word is at the start of the sequence. This function uses the var common-english-words which is defined as: ( def ( set ( clojure.string/split ( slurp \"common-english-words.txt\" ) # \",\" ))) This takes a comma separated file of words and splits them. The words are put into a set so only one instance of each word is included. Rewriting the code with threading macros \u03bb\ufe0e ( ->> ( slurp book.txt ) ( re-seq # \"[a-zA-Z0-9|']+\" ,,, ) ( map # ( clojure.string/lower-case % )) ( remove common-english-words ) frequencies ( sort-by val ) reverse ) frequencies and reverse only take one argument, so they do not require surrounding () inside the threading macro. The common-english-words var is fairly easy to read, so probably doesn't need to be written using a threading macro, however, for completeness here is a thread-first example. ( def common-english-words ( -> ( slurp \"common-english-words.txt\" ) ( clojure.string/split # \",\" ) set )) Hint::Macroexpand \u03bb\ufe0e use macroexpand-1 around the threading macro code to show resulting lisp style Clojure code. Clojure editors also provide evaluation functions that will macroexpand.","title":"Threading macros"},{"location":"thinking-functionally/threading-macros/#threading-macros","text":"The thread-first -> and thread-last ->> macros allow Clojure code to be written in a more sequential style and with a more terse syntax. This can sometimes make code easier to understand by humans. Using the thread-first macro, -> , the result of the first evaluation is passed as the first argument to the next function and so on. ```eval-clojure (-> (clojure.string/lower-case \"HELLO\") (str \", Clojure world\")) The value hello is converted to lower case and that result is passed as the first argument to the next function. The string function is then evaluated with this new argument and the final \"hello, Clojure world\" string is returned as the result. The thread-last macro `->>` passes the result of the first evaluation as the **last argument** to the next expression. ```eval-clojure (->> \" this\" (str \" is\") (str \" backwards\"))","title":"Threading macros"},{"location":"thinking-functionally/threading-macros/#hintparens-optional","text":"function calls that only take one argument, the one passed by earlier expressions, can be included in the threading macro code without the surrounding () parens.","title":"Hint::Parens optional"},{"location":"thinking-functionally/threading-macros/#reading-clojure-code","text":"To read Clojure it is common to start from the inside out, as this is how the Clojure reader also works. This style is inherited from Lisp of which Clojure is an implementation. The following code is written in classic Lisp style. ( reverse ( sort-by val ( frequencies ( remove common-english-words ( map # ( clojure.string/lower-case % ) ( re-seq # \"[a-zA-Z0-9|']+\" ( slurp book.txt ))))))) Reading inside out: 1. slurp in the contents of the book.txt file, converting it to a string. 2. use a regular expression to create a new sequence where the book is a sequence of individual strings for each word. 3. convert each string in the sequence by mapping the lower-case function over each element of the sequence. 4. remove common english words such as the and and from the sequence. 5. count how many times each word occurs and pair the string with its frequency in the book. 6. reverse the order of the sequence by the value of frequency, so the most used word is at the start of the sequence. This function uses the var common-english-words which is defined as: ( def ( set ( clojure.string/split ( slurp \"common-english-words.txt\" ) # \",\" ))) This takes a comma separated file of words and splits them. The words are put into a set so only one instance of each word is included.","title":"Reading Clojure code"},{"location":"thinking-functionally/threading-macros/#rewriting-the-code-with-threading-macros","text":"( ->> ( slurp book.txt ) ( re-seq # \"[a-zA-Z0-9|']+\" ,,, ) ( map # ( clojure.string/lower-case % )) ( remove common-english-words ) frequencies ( sort-by val ) reverse ) frequencies and reverse only take one argument, so they do not require surrounding () inside the threading macro. The common-english-words var is fairly easy to read, so probably doesn't need to be written using a threading macro, however, for completeness here is a thread-first example. ( def common-english-words ( -> ( slurp \"common-english-words.txt\" ) ( clojure.string/split # \",\" ) set ))","title":"Rewriting the code with threading macros"},{"location":"thinking-functionally/threading-macros/#hintmacroexpand","text":"use macroexpand-1 around the threading macro code to show resulting lisp style Clojure code. Clojure editors also provide evaluation functions that will macroexpand.","title":"Hint::Macroexpand"},{"location":"thinking-functionally/transducers/","text":"Transducers \u03bb\ufe0e In Clojure everything is a value, as even a function is a value potential which returns that value when evaluated. Transducers provide an efficient way to transform values which can be simple values, collections, core.async channels and java.jdbc (0.7.0 upwards). TODO::work in progress, sorry \u03bb\ufe0e A very messy brain dump of ideas to tidy up. Pull requests are welcome https://www.youtube.com/watch?v=WkHdqg_DBBs From slack - beginners channel \u03bb\ufe0e Transducers are a functional design to compose operations on data collections, whereby the operations you describe through your transducers, aren't applied each on the entire input collection as in normal plain clojure code, but rather every element in the collection gets acted upon by a composition of what you specify in your transducers. Meaning, the input collection gets walked only once! Transducers provide an alternative way to act on data collections, which requires of you to stray from the plain clojure API you'd normally would, but brings along some benefits like lazy evaluation and/or different performance trade-offs. In addition, some advantages in terms of affording greater modularity in applying transformations on data, are mentioned in the linked SO question above \u2015 although not really well elucidated in code examples there. Using Transducers eliminates the need for intermediate structures. A walk through the basics of Transducers Items coming from a collection are a common case with transducers, but a big motivation for making transducers was the ability to apply transformation directly to the source of data, without forcing it into a collection first (eg. a core.async channel or a network stream etc.) the fact that you can chain transducing functions without intermediate collections comes from this - the context of another transducer is one of the data sources you can apply a transducer to you can use (map f), as one example of a transducing function, directly on a channel it's an optional arg when you create the channel, and causes that transform to be applied to all data that goes through the channel channels are part of why transducers were added to Clojure. The Clojure maintainers discovered they were re-implementing filter, map, partition, etc. etc. on core.async and realized it would be better to have an abstraction for the transforms independent of the source and destination of data As of java.jdbc 0.7.0-beta1, you can also apply transducers to \u201creducible queries\u201d (and reducible result sets). Instead of passing in functions to transform rows and process the transformed result set, you can now just create a \u201creducible query\u201d and hand it off to anything that knows how to reduce it: reducers, transducers, plain ol\u2019 reduce and into etc\u2026 from stackoverflow \u03bb\ufe0e https://stackoverflow.com/questions/26317325/can-someone-explain-clojure-transducers-to-me-in-simple-terms Transducers are recipes what to do with a sequence of data without knowledge what the underlying sequence is (how to do it). It can be any seq, async channel or maybe observable. They are composable and polymorphic. The benefit is, you don't have to implement all standard combinators every time new data source is added. Again and again. As resulting effect you as user are able to reuse those recipes on different data sources. Ad Update Prior version 1.7 of Clojure you had three ways how to write dataflow queries: nested calls ( reduce + ( filter odd? ( map # ( + 2 % ) ( range 0 10 )))) functional composition ( def xform ( comp ( partial filter odd? ) ( partial map # ( + 2 % )))) ( reduce + ( xform ( range 0 10 ))) threading macro ( defn xform [ xs ] ( ->> xs ( map # ( + 2 % )) ( filter odd? ))) ( reduce + ( xform ( range 0 10 ))) With transducers you will write it like: ( def xform ( comp ( map # ( + 2 % )) ( filter odd? ))) ( transduce xform + ( range 0 10 )) They all do the same. The difference is that you never call Transducers directly, you pass them to another function. Transducers know what to do, the function that gets transducer knows how. The order of combinators is like you write it with threading macro (natural order). Now you can reuse xform with channel: ( chan 1 xform ) Business case \u03bb\ufe0e Transducers seem to be a useful way of abstracting over various forms of iterable objects. These can be non-consumable, such as Clojure seqs, or consumable (such as async channels). In this respect, it seems to me you would benefit greatly from using transducers if, e.g., you switch from a seq-based implementation to a core.async implementation using channels. Transducers should allow you to keep the core of your logic unchanged. Using traditional sequence-based processing you would have to convert this to use either transducers or some core-async analog. That's the business case Transducers improve efficiency, and allow you to write efficient code in a more modular way. Trivial examples of using Clojure Transducers Compared to composing calls to the old map, filter, reduce etc. you get better performance because you don't need to build intermediate collections between each step, and repeatedly walk those collections. Compared to reducers, or manually composing all your operations into a single expression, you get easier to use abstractions, better modularity and reuse of processing functions. Just curious, you said above: \"to build intermediate collections between each step\". But doesn't \"intermediate collections\" sound like an anti-pattern? .NET offers lazy enumerables, Java offers lazy streams or Guava-driven iterables, lazy Haskell must have something lazy too. None of these requires map/reduce to use intermediate collections because all of them build an iterator chain. Where am I wrong here? \u2013 Lyubomyr Shaydariv Oct 11 '14 at 21:01 1 Clojure map and filter create intermediate collections when nested. \u2013 noisesmith Oct 11 '14 at 22:59 2 And at least regarding Clojure's version of laziness, the issue of laziness is orthogonal here. Yes, map and filter are lazy, the also generate containers for lazy values when you chain them. If you don't hold onto the head, you don't build up large lazy sequences that aren't needed, but you still build those intermediate abstractions for each lazy element. \u2013 noisesmith Oct 12 '14 at 0:59 An example would be nice. \u2013 Zubair Oct 13 '14 at 6:56 2 @LyubomyrShaydariv By \"intermediate collection\", noisesmith doesn't mean \"iterate/reify an entire collection, then iterate/reify another entire collection\". He or she means that when you nest function calls that return sequentials, each function call results in the creation of a new sequential. The actual iteration still only happens once, but there is additional memory consumption and object allocation due to the nested sequentials Transducers are a means of combination for reducing functions. Example: Reducing functions are functions that take two arguments: A result so far and an input. They return a new result (so far). For example +: With two arguments, you can think of the first as the result so far and the second as the input. A transducer could now take the + function and make it a twice-plus function (doubles every input before adding it). This is how that transducer would look like (in most basic terms): (defn double [rfn] (fn [r i] (rfn r (* 2 i)))) For illustration substitute rfn with + to see how + is transformed into twice-plus: (def twice-plus ;; result of (double +) (fn [r i] (+ r (* 2 i)))) (twice-plus 1 2) ;-> 5 (= (twice-plus 1 2) ((double +) 1 2)) ;-> true So (reduce (double +) 0 [1 2 3]) would now yield 12. Reducing functions returned by transducers are independent of how the result is accumulated because they accumulate with the reducing function passed to them, unknowingly how. Here we use conj instead of +. Conj takes a collection and a value and returns a new collection with that value appended. (reduce (double conj) [] [1 2 3]) would yield [2 4 6] They are also independent of what kind of source the input is. Multiple transducers can be chained as a (chainable) recipe to transform reducing functions. Update: Since there now is an official page about it, I highly recommend to read it: http://clojure.org/transducers Say you want to use a series of functions to transform a stream of data. The Unix shell lets you do this kind of thing with the pipe operator, e.g. cat /etc/passwd | tr '[:lower:]' '[:upper:]' | cut -d: -f1| grep R| wc -l (The above command counts the number of users with the letter r in either upper- or lowercase in their username). This is implemented as a set of processes, each of which reads from the previous processes's output, so there are four intermediate streams. You could imagine a different implementation that composes the five commands into a single aggregate command, which would read from its input and write its output exactly once. If intermediate streams were expensive, and composition were cheap, that might be a good trade-off. The same kind of thing holds for Clojure. There are multiple, concise ways to express a pipeline of transformations, but depending on how you do it, you can end up with intermediate streams passing from one function to the next. If you have a lot of data, it's faster to compose those functions into a single function. Transducers make it easy to do that. An earlier Clojure innovation, reducers, let you do that too, but with some restrictions. Transducers remove some of those restrictions. So to answer your question, transducers won't necessarily make your code shorter or more understandable, but your code probably won't be longer or less understandable either, and if you're working with a lot of data, transducers can make your code faster. https://bendyworks.com/transducers-clojures-next-big-idea/ Ah, so transducers are mostly a performance optimisation, is that what you are saying? \u2013 Zubair Oct 13 '14 at 9:10 @Zubair Yes, that's right. Note that the optimization goes beyond eliminating intermediate streams; you may also be able to perform operations in parallel. \u2013 user100464 Oct 14 '14 at 19:17 It's worth mentioning pmap, which doesn't seem to get enough attention. If you are mapping an expensive function over a sequence, making the operation parallel is as easy as adding \"p\". No need to change anything else in your code, and it's available now--not alpha, not beta. (If the function creates intermediate sequences, then transducers might be faster, I would guess.) \u2013 Mars Oct 30 '14 at 15:13 Rich Hickey gave a 'Transducers' talk at the Strange Loop 2014 conference (45 min). He explains in simple way what transducers are, with real world examples - processing bags in an airport. He clearly separates the different aspects and contrasts them with the current approaches. Towards the end, he gives the rationale for their existence. Video: https://www.youtube.com/watch?v=6mTbuzafcII 5 down vote A transducer clear definition is here: Transducers are a powerful and composable way to build algorithmic transformations that you can reuse in many contexts, and they\u2019re coming to Clojure core and core.async. To understand it, let's consider the following simple example: ;; The Families in the Village (def village [{:home :north :family \"smith\" :name \"sue\" :age 37 :sex :f :role :parent} {:home :north :family \"smith\" :name \"stan\" :age 35 :sex :m :role :parent} {:home :north :family \"smith\" :name \"simon\" :age 7 :sex :m :role :child} {:home :south :family \"jones\" :name \"jill\" :age 45 :sex :f :role :parent} {:home :south :family \"jones\" :name \"jeff\" :age 45 :sex :m :role :parent} {:home :south :family \"jones\" :name \"jackie\" :age 19 :sex :f :role :child} {:home :south :family \"jones\" :name \"jason\" :age 16 :sex :f :role :child} {:home :west :family \"brown\" :name \"billie\" :age 55 :sex :f :role :parent} {:home :west :family \"brown\" :name \"brian\" :age 23 :sex :m :role :child} {:home :east :family \"williams\" :name \"walter\" :age 23 :sex :m :role :parent} {:home :east :family \"williams\" :name \"wanda\" :age 3 :sex :f :role :child}]) What about it we want to know how many children are in the village? We can easily find it out with the following reducer: ;; Example 1a - using a reducer to add up all the mapped values (def ex1a-map-children-to-value-1 (r/map #(if (= :child (:role %)) 1 0))) (r/reduce + 0 (ex1a-map-children-to-value-1 village)) ;;=> 8 Here is another way to do it: ;; Example 1b - using a transducer to add up all the mapped values ;; create the transducers using the new arity for map that ;; takes just the function, no collection (def ex1b-map-children-to-value-1 (map #(if (= :child (:role %)) 1 0))) ;; now use transduce (c.f r/reduce) with the transducer to get the answer (transduce ex1b-map-children-to-value-1 + 0 village) ;;=> 8 Besides, it is really powerful when taking subgroups in account as well. For instance, if we would like to know how many children are in Brown Family, we can execute: ;; Example 2a - using a reducer to count the children in the Brown family ;; create the reducer to select members of the Brown family (def ex2a-select-brown-family (r/filter #(= \"brown\" (string/lower-case (:family %))))) ;; compose a composite function to select the Brown family and map children to 1 (def ex2a-count-brown-family-children (comp ex1a-map-children-to-value-1 ex2a-select-brown-family)) ;; reduce to add up all the Brown children (r/reduce + 0 (ex2a-count-brown-family-children village)) ;;=> 2","title":"Transducers"},{"location":"thinking-functionally/transducers/#transducers","text":"In Clojure everything is a value, as even a function is a value potential which returns that value when evaluated. Transducers provide an efficient way to transform values which can be simple values, collections, core.async channels and java.jdbc (0.7.0 upwards).","title":"Transducers"},{"location":"thinking-functionally/transducers/#todowork-in-progress-sorry","text":"A very messy brain dump of ideas to tidy up. Pull requests are welcome https://www.youtube.com/watch?v=WkHdqg_DBBs","title":"TODO::work in progress, sorry"},{"location":"thinking-functionally/transducers/#from-slack-beginners-channel","text":"Transducers are a functional design to compose operations on data collections, whereby the operations you describe through your transducers, aren't applied each on the entire input collection as in normal plain clojure code, but rather every element in the collection gets acted upon by a composition of what you specify in your transducers. Meaning, the input collection gets walked only once! Transducers provide an alternative way to act on data collections, which requires of you to stray from the plain clojure API you'd normally would, but brings along some benefits like lazy evaluation and/or different performance trade-offs. In addition, some advantages in terms of affording greater modularity in applying transformations on data, are mentioned in the linked SO question above \u2015 although not really well elucidated in code examples there. Using Transducers eliminates the need for intermediate structures. A walk through the basics of Transducers Items coming from a collection are a common case with transducers, but a big motivation for making transducers was the ability to apply transformation directly to the source of data, without forcing it into a collection first (eg. a core.async channel or a network stream etc.) the fact that you can chain transducing functions without intermediate collections comes from this - the context of another transducer is one of the data sources you can apply a transducer to you can use (map f), as one example of a transducing function, directly on a channel it's an optional arg when you create the channel, and causes that transform to be applied to all data that goes through the channel channels are part of why transducers were added to Clojure. The Clojure maintainers discovered they were re-implementing filter, map, partition, etc. etc. on core.async and realized it would be better to have an abstraction for the transforms independent of the source and destination of data As of java.jdbc 0.7.0-beta1, you can also apply transducers to \u201creducible queries\u201d (and reducible result sets). Instead of passing in functions to transform rows and process the transformed result set, you can now just create a \u201creducible query\u201d and hand it off to anything that knows how to reduce it: reducers, transducers, plain ol\u2019 reduce and into etc\u2026","title":"From slack - beginners channel"},{"location":"thinking-functionally/transducers/#from-stackoverflow","text":"https://stackoverflow.com/questions/26317325/can-someone-explain-clojure-transducers-to-me-in-simple-terms Transducers are recipes what to do with a sequence of data without knowledge what the underlying sequence is (how to do it). It can be any seq, async channel or maybe observable. They are composable and polymorphic. The benefit is, you don't have to implement all standard combinators every time new data source is added. Again and again. As resulting effect you as user are able to reuse those recipes on different data sources. Ad Update Prior version 1.7 of Clojure you had three ways how to write dataflow queries: nested calls ( reduce + ( filter odd? ( map # ( + 2 % ) ( range 0 10 )))) functional composition ( def xform ( comp ( partial filter odd? ) ( partial map # ( + 2 % )))) ( reduce + ( xform ( range 0 10 ))) threading macro ( defn xform [ xs ] ( ->> xs ( map # ( + 2 % )) ( filter odd? ))) ( reduce + ( xform ( range 0 10 ))) With transducers you will write it like: ( def xform ( comp ( map # ( + 2 % )) ( filter odd? ))) ( transduce xform + ( range 0 10 )) They all do the same. The difference is that you never call Transducers directly, you pass them to another function. Transducers know what to do, the function that gets transducer knows how. The order of combinators is like you write it with threading macro (natural order). Now you can reuse xform with channel: ( chan 1 xform )","title":"from stackoverflow"},{"location":"thinking-functionally/transducers/#business-case","text":"Transducers seem to be a useful way of abstracting over various forms of iterable objects. These can be non-consumable, such as Clojure seqs, or consumable (such as async channels). In this respect, it seems to me you would benefit greatly from using transducers if, e.g., you switch from a seq-based implementation to a core.async implementation using channels. Transducers should allow you to keep the core of your logic unchanged. Using traditional sequence-based processing you would have to convert this to use either transducers or some core-async analog. That's the business case Transducers improve efficiency, and allow you to write efficient code in a more modular way. Trivial examples of using Clojure Transducers Compared to composing calls to the old map, filter, reduce etc. you get better performance because you don't need to build intermediate collections between each step, and repeatedly walk those collections. Compared to reducers, or manually composing all your operations into a single expression, you get easier to use abstractions, better modularity and reuse of processing functions. Just curious, you said above: \"to build intermediate collections between each step\". But doesn't \"intermediate collections\" sound like an anti-pattern? .NET offers lazy enumerables, Java offers lazy streams or Guava-driven iterables, lazy Haskell must have something lazy too. None of these requires map/reduce to use intermediate collections because all of them build an iterator chain. Where am I wrong here? \u2013 Lyubomyr Shaydariv Oct 11 '14 at 21:01 1 Clojure map and filter create intermediate collections when nested. \u2013 noisesmith Oct 11 '14 at 22:59 2 And at least regarding Clojure's version of laziness, the issue of laziness is orthogonal here. Yes, map and filter are lazy, the also generate containers for lazy values when you chain them. If you don't hold onto the head, you don't build up large lazy sequences that aren't needed, but you still build those intermediate abstractions for each lazy element. \u2013 noisesmith Oct 12 '14 at 0:59 An example would be nice. \u2013 Zubair Oct 13 '14 at 6:56 2 @LyubomyrShaydariv By \"intermediate collection\", noisesmith doesn't mean \"iterate/reify an entire collection, then iterate/reify another entire collection\". He or she means that when you nest function calls that return sequentials, each function call results in the creation of a new sequential. The actual iteration still only happens once, but there is additional memory consumption and object allocation due to the nested sequentials Transducers are a means of combination for reducing functions. Example: Reducing functions are functions that take two arguments: A result so far and an input. They return a new result (so far). For example +: With two arguments, you can think of the first as the result so far and the second as the input. A transducer could now take the + function and make it a twice-plus function (doubles every input before adding it). This is how that transducer would look like (in most basic terms): (defn double [rfn] (fn [r i] (rfn r (* 2 i)))) For illustration substitute rfn with + to see how + is transformed into twice-plus: (def twice-plus ;; result of (double +) (fn [r i] (+ r (* 2 i)))) (twice-plus 1 2) ;-> 5 (= (twice-plus 1 2) ((double +) 1 2)) ;-> true So (reduce (double +) 0 [1 2 3]) would now yield 12. Reducing functions returned by transducers are independent of how the result is accumulated because they accumulate with the reducing function passed to them, unknowingly how. Here we use conj instead of +. Conj takes a collection and a value and returns a new collection with that value appended. (reduce (double conj) [] [1 2 3]) would yield [2 4 6] They are also independent of what kind of source the input is. Multiple transducers can be chained as a (chainable) recipe to transform reducing functions. Update: Since there now is an official page about it, I highly recommend to read it: http://clojure.org/transducers Say you want to use a series of functions to transform a stream of data. The Unix shell lets you do this kind of thing with the pipe operator, e.g. cat /etc/passwd | tr '[:lower:]' '[:upper:]' | cut -d: -f1| grep R| wc -l (The above command counts the number of users with the letter r in either upper- or lowercase in their username). This is implemented as a set of processes, each of which reads from the previous processes's output, so there are four intermediate streams. You could imagine a different implementation that composes the five commands into a single aggregate command, which would read from its input and write its output exactly once. If intermediate streams were expensive, and composition were cheap, that might be a good trade-off. The same kind of thing holds for Clojure. There are multiple, concise ways to express a pipeline of transformations, but depending on how you do it, you can end up with intermediate streams passing from one function to the next. If you have a lot of data, it's faster to compose those functions into a single function. Transducers make it easy to do that. An earlier Clojure innovation, reducers, let you do that too, but with some restrictions. Transducers remove some of those restrictions. So to answer your question, transducers won't necessarily make your code shorter or more understandable, but your code probably won't be longer or less understandable either, and if you're working with a lot of data, transducers can make your code faster. https://bendyworks.com/transducers-clojures-next-big-idea/ Ah, so transducers are mostly a performance optimisation, is that what you are saying? \u2013 Zubair Oct 13 '14 at 9:10 @Zubair Yes, that's right. Note that the optimization goes beyond eliminating intermediate streams; you may also be able to perform operations in parallel. \u2013 user100464 Oct 14 '14 at 19:17 It's worth mentioning pmap, which doesn't seem to get enough attention. If you are mapping an expensive function over a sequence, making the operation parallel is as easy as adding \"p\". No need to change anything else in your code, and it's available now--not alpha, not beta. (If the function creates intermediate sequences, then transducers might be faster, I would guess.) \u2013 Mars Oct 30 '14 at 15:13 Rich Hickey gave a 'Transducers' talk at the Strange Loop 2014 conference (45 min). He explains in simple way what transducers are, with real world examples - processing bags in an airport. He clearly separates the different aspects and contrasts them with the current approaches. Towards the end, he gives the rationale for their existence. Video: https://www.youtube.com/watch?v=6mTbuzafcII 5 down vote A transducer clear definition is here: Transducers are a powerful and composable way to build algorithmic transformations that you can reuse in many contexts, and they\u2019re coming to Clojure core and core.async. To understand it, let's consider the following simple example: ;; The Families in the Village (def village [{:home :north :family \"smith\" :name \"sue\" :age 37 :sex :f :role :parent} {:home :north :family \"smith\" :name \"stan\" :age 35 :sex :m :role :parent} {:home :north :family \"smith\" :name \"simon\" :age 7 :sex :m :role :child} {:home :south :family \"jones\" :name \"jill\" :age 45 :sex :f :role :parent} {:home :south :family \"jones\" :name \"jeff\" :age 45 :sex :m :role :parent} {:home :south :family \"jones\" :name \"jackie\" :age 19 :sex :f :role :child} {:home :south :family \"jones\" :name \"jason\" :age 16 :sex :f :role :child} {:home :west :family \"brown\" :name \"billie\" :age 55 :sex :f :role :parent} {:home :west :family \"brown\" :name \"brian\" :age 23 :sex :m :role :child} {:home :east :family \"williams\" :name \"walter\" :age 23 :sex :m :role :parent} {:home :east :family \"williams\" :name \"wanda\" :age 3 :sex :f :role :child}]) What about it we want to know how many children are in the village? We can easily find it out with the following reducer: ;; Example 1a - using a reducer to add up all the mapped values (def ex1a-map-children-to-value-1 (r/map #(if (= :child (:role %)) 1 0))) (r/reduce + 0 (ex1a-map-children-to-value-1 village)) ;;=> 8 Here is another way to do it: ;; Example 1b - using a transducer to add up all the mapped values ;; create the transducers using the new arity for map that ;; takes just the function, no collection (def ex1b-map-children-to-value-1 (map #(if (= :child (:role %)) 1 0))) ;; now use transduce (c.f r/reduce) with the transducer to get the answer (transduce ex1b-map-children-to-value-1 + 0 village) ;;=> 8 Besides, it is really powerful when taking subgroups in account as well. For instance, if we would like to know how many children are in Brown Family, we can execute: ;; Example 2a - using a reducer to count the children in the Brown family ;; create the reducer to select members of the Brown family (def ex2a-select-brown-family (r/filter #(= \"brown\" (string/lower-case (:family %))))) ;; compose a composite function to select the Brown family and map children to 1 (def ex2a-count-brown-family-children (comp ex1a-map-children-to-value-1 ex2a-select-brown-family)) ;; reduce to add up all the Brown children (r/reduce + 0 (ex2a-count-brown-family-children village)) ;;=> 2","title":"Business case"},{"location":"using-clojure-tools/coding-in-the-repl/","text":"Coding in the REPL \u03bb\ufe0e Hint::Use an Editor for Clojure Projects \u03bb\ufe0e Using an editor (or ide) is a more effective way to develop projects, although having a command line REPL is very fast and convenient way to experiment and discover Clojure. Evaluating code \u03bb\ufe0e Type Clojure code at the REPL prompt, not forgetting to ensure your parens are balanced. Press Enter to evaluate the code and see the result. The REPL evaluates one expression at a time, although it remembers all expressions that correctly evaluate. This enables your own function definitions to be called, until you end the REPL session. Up / down arrow keys navigate the REPL history, providing an efficient way to evaluate the same or similar code many times. Including code from a file \u03bb\ufe0e Clojure code is typically saved in files, with each file representing a specific namespace in the project. A namespace is a collection of expressions that have a logical grouping within the project. Any namespace on the class path can be included in the REPL using the clojure.core/require function. ( require 'practicalli.playground ) The ' character is a short-cut for the quote function that wraps the namespace name, ensuring that only the symbol name of the namespace is passed to require . The require function will take the symbol name and read in all the code from that namespace and evaluate each expression. Functions defined in the required namespace are available using their fully qualified names. Assuming the namespace contains a function called greet , that function can be called using (practicalli.playground/greet) . Hint::Loading a file into the REPL \u03bb\ufe0e The load-file function will read and evaluate the code in a given file, e.g. (load-file \"src/practicalli/playground.clj\") Changing to a namespace \u03bb\ufe0e Change the default user namespace to practicalli.playground and functions defined in that namespace can be called by just the function name, eg. (greet) . in-ns will change change the current namespace to the one specified as an argument. ( in-ns 'practicalli.playground ) Now the (greet) function can be called without having to include the full namespace name. Including changes from a file \u03bb\ufe0e The :reload option to require will load in any changes to a namespace that happened outside of the REPL, eg. change in the source code file. ( require 'practicalli.playground :reload ) Hint::Workflow regardless of tooling \u03bb\ufe0e It is more effective to connect an editor to a REPL process, however, the above workflow is still the same. Clojure projects \u03bb\ufe0e A terminal UI REPL can start even without a Clojure project, e.g. clojure -M:repl/rebel . In this case only the user level deps.edn and Clojure CLI configuration is used. When a REPL starts from a Clojure project, the deps.edn configuration file in the root of the project directory is added to or over-rides the user level configuration.","title":"Coding in the REPL"},{"location":"using-clojure-tools/coding-in-the-repl/#coding-in-the-repl","text":"","title":"Coding in the REPL"},{"location":"using-clojure-tools/coding-in-the-repl/#hintuse-an-editor-for-clojure-projects","text":"Using an editor (or ide) is a more effective way to develop projects, although having a command line REPL is very fast and convenient way to experiment and discover Clojure.","title":"Hint::Use an Editor for Clojure Projects"},{"location":"using-clojure-tools/coding-in-the-repl/#evaluating-code","text":"Type Clojure code at the REPL prompt, not forgetting to ensure your parens are balanced. Press Enter to evaluate the code and see the result. The REPL evaluates one expression at a time, although it remembers all expressions that correctly evaluate. This enables your own function definitions to be called, until you end the REPL session. Up / down arrow keys navigate the REPL history, providing an efficient way to evaluate the same or similar code many times.","title":"Evaluating code"},{"location":"using-clojure-tools/coding-in-the-repl/#including-code-from-a-file","text":"Clojure code is typically saved in files, with each file representing a specific namespace in the project. A namespace is a collection of expressions that have a logical grouping within the project. Any namespace on the class path can be included in the REPL using the clojure.core/require function. ( require 'practicalli.playground ) The ' character is a short-cut for the quote function that wraps the namespace name, ensuring that only the symbol name of the namespace is passed to require . The require function will take the symbol name and read in all the code from that namespace and evaluate each expression. Functions defined in the required namespace are available using their fully qualified names. Assuming the namespace contains a function called greet , that function can be called using (practicalli.playground/greet) .","title":"Including code from a file"},{"location":"using-clojure-tools/coding-in-the-repl/#hintloading-a-file-into-the-repl","text":"The load-file function will read and evaluate the code in a given file, e.g. (load-file \"src/practicalli/playground.clj\")","title":"Hint::Loading a file into the REPL"},{"location":"using-clojure-tools/coding-in-the-repl/#changing-to-a-namespace","text":"Change the default user namespace to practicalli.playground and functions defined in that namespace can be called by just the function name, eg. (greet) . in-ns will change change the current namespace to the one specified as an argument. ( in-ns 'practicalli.playground ) Now the (greet) function can be called without having to include the full namespace name.","title":"Changing to a namespace"},{"location":"using-clojure-tools/coding-in-the-repl/#including-changes-from-a-file","text":"The :reload option to require will load in any changes to a namespace that happened outside of the REPL, eg. change in the source code file. ( require 'practicalli.playground :reload )","title":"Including changes from a file"},{"location":"using-clojure-tools/coding-in-the-repl/#hintworkflow-regardless-of-tooling","text":"It is more effective to connect an editor to a REPL process, however, the above workflow is still the same.","title":"Hint::Workflow regardless of tooling"},{"location":"using-clojure-tools/coding-in-the-repl/#clojure-projects","text":"A terminal UI REPL can start even without a Clojure project, e.g. clojure -M:repl/rebel . In this case only the user level deps.edn and Clojure CLI configuration is used. When a REPL starts from a Clojure project, the deps.edn configuration file in the root of the project directory is added to or over-rides the user level configuration.","title":"Clojure projects"},{"location":"using-data-structures/","text":"Using data structures \u03bb\ufe0e Data structures in Clojure are used to model information and data, within a particular namespace. Functions are used to run behaviour over the data structures. Lets look at some of the common functions that are used in Clojure with data structures fixme the below content is work in progress, sorry. Managing Return values \u03bb\ufe0e If you run a function over a data structure, you may not always get back the type of value you want. It easy to wrap a function around to give you the desired value type. Note Use the str function to get a string from person, rather than a set of characters ( first person ) ( rest person ) ( str ( first person )) ;; How do we return the rest of the string as a string ? ( str ( rest person )) ( map str ( rest person )) ( str ( map str ( rest person ))) ( apply str ( rest person )) You can get the value of this map (def luke {:name \"Luke Skywalker\" :skill \"Targeting Swamp Rats\"}) (def darth {:name \"Darth Vader\" :skill \"Crank phone calls\"}) (def jarjar {:name \"JarJar Binks\" :skill \"Upsetting a generation of fans\"}) (get luke :skill) Immutability \u03bb\ufe0e When you use functions on data structures, although they can return a new value they do not change the original data structure. Lets define a name for a data structure (def name1 [1 2 3 4]) when we evaluate that name we get the original data we set name1 Now we use a function called conj to adds (conjoin) another number to our data structure (conj name1 5) This returns a new value without changing the original data structure name1 We cant change the original data structure, it is immutable. Once it is set it cant be changed. However, if we give a name to the result of changing the original data structure, we can refer to that new data structure (def name2(conj name1 5)) Now name2 is the new data structure, but name1 remains unchanged name2 name1 So we cannot change the data structure, however we can achieve something that looks like we have changed it. We can re-assign the original name to the result of changing the original data structure (def name2(conj name1 5)) Now name1 and name2 are the same result name2 name1 Hint An analogy (thanks to Chris Ford) You have the number 2. If you add 1 to 2, what value is the number 2? The number 2 is still 2 no mater that you add 1 to it, however, you get the value 3 in return Creating new data structures \u03bb\ufe0e Use concat to add lists or vectors together (concat [1 2] '(3 4)) ; => (1 2 3 4) Use filter, map to interact with collections (map inc [1 2 3]) ; => (2 3 4) (filter even? [1 2 3]) ; => (2) Use reduce to reduce them (reduce + [1 2 3 4]) ; = (+ (+ (+ 1 2) 3) 4) ; => 10 Reduce can take an initial-value argument too (reduce conj [] '(3 2 1)) ; = (conj (conj (conj [] 3) 2) 1) ; => [3 2 1] Use cons to add an item to the beginning of a list or vector (cons 4 [1 2 3]) ; => (4 1 2 3) (cons 4 '(1 2 3)) ; => (4 1 2 3) Use conj to add an item to the beginning of a list, or the end of a vector (conj [1 2 3] 4) ; => [1 2 3 4] (conj '(1 2 3) 4) ; => (4 1 2 3)","title":"Using data structures"},{"location":"using-data-structures/#using-data-structures","text":"Data structures in Clojure are used to model information and data, within a particular namespace. Functions are used to run behaviour over the data structures. Lets look at some of the common functions that are used in Clojure with data structures fixme the below content is work in progress, sorry.","title":"Using data structures"},{"location":"using-data-structures/#managing-return-values","text":"If you run a function over a data structure, you may not always get back the type of value you want. It easy to wrap a function around to give you the desired value type. Note Use the str function to get a string from person, rather than a set of characters ( first person ) ( rest person ) ( str ( first person )) ;; How do we return the rest of the string as a string ? ( str ( rest person )) ( map str ( rest person )) ( str ( map str ( rest person ))) ( apply str ( rest person )) You can get the value of this map (def luke {:name \"Luke Skywalker\" :skill \"Targeting Swamp Rats\"}) (def darth {:name \"Darth Vader\" :skill \"Crank phone calls\"}) (def jarjar {:name \"JarJar Binks\" :skill \"Upsetting a generation of fans\"}) (get luke :skill)","title":"Managing Return values"},{"location":"using-data-structures/#immutability","text":"When you use functions on data structures, although they can return a new value they do not change the original data structure. Lets define a name for a data structure (def name1 [1 2 3 4]) when we evaluate that name we get the original data we set name1 Now we use a function called conj to adds (conjoin) another number to our data structure (conj name1 5) This returns a new value without changing the original data structure name1 We cant change the original data structure, it is immutable. Once it is set it cant be changed. However, if we give a name to the result of changing the original data structure, we can refer to that new data structure (def name2(conj name1 5)) Now name2 is the new data structure, but name1 remains unchanged name2 name1 So we cannot change the data structure, however we can achieve something that looks like we have changed it. We can re-assign the original name to the result of changing the original data structure (def name2(conj name1 5)) Now name1 and name2 are the same result name2 name1 Hint An analogy (thanks to Chris Ford) You have the number 2. If you add 1 to 2, what value is the number 2? The number 2 is still 2 no mater that you add 1 to it, however, you get the value 3 in return","title":"Immutability"},{"location":"using-data-structures/#creating-new-data-structures","text":"Use concat to add lists or vectors together (concat [1 2] '(3 4)) ; => (1 2 3 4) Use filter, map to interact with collections (map inc [1 2 3]) ; => (2 3 4) (filter even? [1 2 3]) ; => (2) Use reduce to reduce them (reduce + [1 2 3 4]) ; = (+ (+ (+ 1 2) 3) 4) ; => 10 Reduce can take an initial-value argument too (reduce conj [] '(3 2 1)) ; = (conj (conj (conj [] 3) 2) 1) ; => [3 2 1] Use cons to add an item to the beginning of a list or vector (cons 4 [1 2 3]) ; => (4 1 2 3) (cons 4 '(1 2 3)) ; => (4 1 2 3) Use conj to add an item to the beginning of a list, or the end of a vector (conj [1 2 3] 4) ; => [1 2 3 4] (conj '(1 2 3) 4) ; => (4 1 2 3)","title":"Creating new data structures"},{"location":"using-data-structures/applying-functions/","text":"Applying functions to data structures \u03bb\ufe0e Applying a functions behaviour to the elements of a data structure","title":"Applying functions to data structures"},{"location":"using-data-structures/applying-functions/#applying-functions-to-data-structures","text":"Applying a functions behaviour to the elements of a data structure","title":"Applying functions to data structures"},{"location":"using-data-structures/destructuring/","text":"Destructuring \u03bb\ufe0e Destructuring is a form of pattern matching that is common in Clojure. Destructuring allow you to pull out the specific elements from a collection. Destructuring is commonly used with the let method for creating local bindings (locally scoped names). (let [[a b c & d :as e] [1 2 3 4 5 6 7]] [a b c d e]) (let [[[x1 y1][x2 y2]] [[1 2] [3 4]]] [x1 y1 x2 y2]) ;; with strings (let [[a b & c :as str] \"asdjhhfdas\"] [a b c str]) ;; with maps (let [{a :a, b :b, c :c, :as m :or {a 2 b 3}} {:a 5 :c 6}] [a b c m]) It is often the case that you will want to bind same-named symbols to the map keys. The :keys directive allows you to avoid the redundancy: (let [{fred :fred ethel :ethel lucy :lucy} m] ) This can be written in a shorter form as follows: (let [{:keys [fred ethel lucy]} m] ) As of Clojure 1.6, you can also use prefixed map keys in the map destructuring form: (let [m {:x/a 1, :y/b 2} {:keys [x/a y/b]} m] (+ a b)) As shown above, in the case of using prefixed keys, the bound symbol name will be the same as the right-hand side of the prefixed key. You can also use auto-resolved keyword forms in the :keys directive: (let [m {::x 42} {:keys [::x]} m] x)","title":"Destructuring"},{"location":"using-data-structures/destructuring/#destructuring","text":"Destructuring is a form of pattern matching that is common in Clojure. Destructuring allow you to pull out the specific elements from a collection. Destructuring is commonly used with the let method for creating local bindings (locally scoped names). (let [[a b c & d :as e] [1 2 3 4 5 6 7]] [a b c d e]) (let [[[x1 y1][x2 y2]] [[1 2] [3 4]]] [x1 y1 x2 y2]) ;; with strings (let [[a b & c :as str] \"asdjhhfdas\"] [a b c str]) ;; with maps (let [{a :a, b :b, c :c, :as m :or {a 2 b 3}} {:a 5 :c 6}] [a b c m]) It is often the case that you will want to bind same-named symbols to the map keys. The :keys directive allows you to avoid the redundancy: (let [{fred :fred ethel :ethel lucy :lucy} m] ) This can be written in a shorter form as follows: (let [{:keys [fred ethel lucy]} m] ) As of Clojure 1.6, you can also use prefixed map keys in the map destructuring form: (let [m {:x/a 1, :y/b 2} {:keys [x/a y/b]} m] (+ a b)) As shown above, in the case of using prefixed keys, the bound symbol name will be the same as the right-hand side of the prefixed key. You can also use auto-resolved keyword forms in the :keys directive: (let [m {::x 42} {:keys [::x]} m] x)","title":"Destructuring"},{"location":"using-data-structures/lazy-sequences/","text":"Lazy Sequences \u03bb\ufe0e Sequences are an interface for logical lists, which can be lazy. \"Lazy\" means that a sequence can define an infinite series, like so: (range 4) If you evaluate (range) just by itself it will return an infinite number of integers, well at least until your computers memory space fills up. So we dont blow up our memory and just get the values we want we can use range in conjunction with other functions that define how many numbers we actually want. For example, if we just wanted the first four numbers from the infinite sequence of range we could specify that with the take function (take 4 (range)) ; (0 1 2 3) Here the range function is being lazy, because it will only generate the first 4 numbers in its sequence. Clojure (and Lisps in general) often evaluate at the last possible moment, usually when they have been given more specific content.","title":"Lazy Sequences"},{"location":"using-data-structures/lazy-sequences/#lazy-sequences","text":"Sequences are an interface for logical lists, which can be lazy. \"Lazy\" means that a sequence can define an infinite series, like so: (range 4) If you evaluate (range) just by itself it will return an infinite number of integers, well at least until your computers memory space fills up. So we dont blow up our memory and just get the values we want we can use range in conjunction with other functions that define how many numbers we actually want. For example, if we just wanted the first four numbers from the infinite sequence of range we could specify that with the take function (take 4 (range)) ; (0 1 2 3) Here the range function is being lazy, because it will only generate the first 4 numbers in its sequence. Clojure (and Lisps in general) often evaluate at the last possible moment, usually when they have been given more specific content.","title":"Lazy Sequences"},{"location":"using-data-structures/mapping-data-structures/","text":"Mapping functions over data structures \u03bb\ufe0e Map allows you to work over one or more data sets, applying the function to each element of each of the data structures. When the data structures are of equal size, then the same sized data structure is returned. ( map + [ 1 2 3 ] [ 1 2 3 ]) ;; => (2 4 6) If one data structure is smaller, then the function is only applied up to the last element of the smallest data structure. ( map + [ 1 2 3 ] [ 1 2 ]) ;; => (2 4) ( map + [ 1 2 3 ] [ 1 ]) ;; => (2) ( map + [ 1 2 3 ] []) ;; => () ( map + [ 1 2 3 ]) ;; => (1 2 3) Lets look at another example. Here we have a pre-defined Fibonacci sequence up to the first 12 values. ( def fibonacci-sequence [ 1 2 3 5 8 13 21 34 55 89 144 278 ]) If we just want the first 10 values of the sequence, we can use the take function. ( take 10 fibonacci-sequence ) ;; => (1 2 3 5 8 13 21 34 55 89) If we want a calculation using the values of the fibonacci-sequence then we can use map with a function. In this case we are going to generate a range of Integer numbers from 0-9 using the function range . That range of numbers is then multiplied element by element with the corresponding element in the fibonacci-sequence. ( map * ( range 10 ) fibonacci-sequence ) ;; => (0 2 6 15 32 65 126 238 440 801) So, - 0 times 1 is 0, - 1, times 2 is 2, - 2 times 3 is 6, etc. If we evaluate the previous expression part by part, its easier to see what is going on. First lets evaluate the fibonacci-sequence ( map * ( range 10 ) [ 1 2 3 5 8 13 21 34 55 89 144 278 ]) ;; => (0 2 6 15 32 65 126 238 440 801) Now lets evaluate the (range 10) function call ( map * ( 0 1 2 3 4 5 6 7 8 9 ) [ 1 2 3 5 8 13 21 34 55 89 144 278 ]) ;; => (0 2 6 15 32 65 126 238 440 801) We can see the answer is the same, however by evaluating each part of the expression we get an exact view of what is going to happen with the map function.","title":"Mapping functions over data structures"},{"location":"using-data-structures/mapping-data-structures/#mapping-functions-over-data-structures","text":"Map allows you to work over one or more data sets, applying the function to each element of each of the data structures. When the data structures are of equal size, then the same sized data structure is returned. ( map + [ 1 2 3 ] [ 1 2 3 ]) ;; => (2 4 6) If one data structure is smaller, then the function is only applied up to the last element of the smallest data structure. ( map + [ 1 2 3 ] [ 1 2 ]) ;; => (2 4) ( map + [ 1 2 3 ] [ 1 ]) ;; => (2) ( map + [ 1 2 3 ] []) ;; => () ( map + [ 1 2 3 ]) ;; => (1 2 3) Lets look at another example. Here we have a pre-defined Fibonacci sequence up to the first 12 values. ( def fibonacci-sequence [ 1 2 3 5 8 13 21 34 55 89 144 278 ]) If we just want the first 10 values of the sequence, we can use the take function. ( take 10 fibonacci-sequence ) ;; => (1 2 3 5 8 13 21 34 55 89) If we want a calculation using the values of the fibonacci-sequence then we can use map with a function. In this case we are going to generate a range of Integer numbers from 0-9 using the function range . That range of numbers is then multiplied element by element with the corresponding element in the fibonacci-sequence. ( map * ( range 10 ) fibonacci-sequence ) ;; => (0 2 6 15 32 65 126 238 440 801) So, - 0 times 1 is 0, - 1, times 2 is 2, - 2 times 3 is 6, etc. If we evaluate the previous expression part by part, its easier to see what is going on. First lets evaluate the fibonacci-sequence ( map * ( range 10 ) [ 1 2 3 5 8 13 21 34 55 89 144 278 ]) ;; => (0 2 6 15 32 65 126 238 440 801) Now lets evaluate the (range 10) function call ( map * ( 0 1 2 3 4 5 6 7 8 9 ) [ 1 2 3 5 8 13 21 34 55 89 144 278 ]) ;; => (0 2 6 15 32 65 126 238 440 801) We can see the answer is the same, however by evaluating each part of the expression we get an exact view of what is going to happen with the map function.","title":"Mapping functions over data structures"},{"location":"using-data-structures/sequences/","text":"Sequence abstractions \u03bb\ufe0e There are functions that work on all the built in data-structures in Clojure. first second rest cons Practising with lists \u03bb\ufe0e Note Create a simple collection of developer events. First use a list of strings, then try a map with keywords. For each data structure, pull out some of the event details ( def developer-events-strings ' ( \"Devoxx UK\" \"Devoxx France\" \"Devoxx\" \"Hack the Tower\" )) ( def developer-events-strings2 ( list \"Devoxx UK\" \"Devoxx France\" \"Devoxx\" \"Hack the Tower\" )) developer-events-strings ( first developer-events-strings ) ( def developer-events-vector [ :devoxxuk :devoxxfr :devoxx :hackthetower ] ) Using a Clojure Vector data structure is a more Clojure approach, especially when the vector contains keywords. Think of a Vector as an Array, although in Clojure it is again immutable in the same way a list is. Note Create a slightly more involved data structure, holding more data around each developer events. Suggest using a map, with each key being the unique name of the developer event. The details of each event (the value to go with the event name key) is itself a map as there are several pieces of data associated with each event name. ( def dev-event-details { :devoxxuk { :URL \"http://jaxlondon.co.uk\" :event-type \"Conference\" :number-of-attendees 700 :call-for-papers true } :hackthetower { :URL \"http://hackthetower.co.uk\" :event-type \"hackday\" :number-of-attendees 60 :call-for-papers false }}) Lets call the data structure and see what it evaluates too, it should not be a surprise dev-event-details We can ask for the value of a specific key, and just that value is returned (dev-event-details :devoxxuk) In our example, the value returned from the :devoxxuk key is also a map, so we can ask for a specific part of that map value by again using its key (:URL (dev-event-details :devoxxuk)) Note Lets define a simple data structure for stocks data using a vector of maps, as there will be one or more company stocks to track. Each map represents the stock information for a company. Get the value of the whole data structure by referring to it by name, ask for a specific element by its position in the array using the nth function. Then try some of the common functions that work on collections. ( def portfolio [ { :ticker \"CRM\" :lastTrade 233.12 :open 230.66 } { :ticker \"AAPL\" :lastTrade 203.25 :open 204.50 } { :ticker \"MSFT\" :lastTrade 29.12 :open 29.08 } { :ticker \"ORCL\" :lastTrade 21.90 :open 21.83 }]) portfolio ( nth portfolio 0 ) ( nth portfolio 3 ) ( first portfolio ) ( rest portfolio ) ( last portfolio ) First and next are termed as sequence functions in Clojure, unlike other lisps, you can use first and next on other data structures too","title":"Sequence abstractions"},{"location":"using-data-structures/sequences/#sequence-abstractions","text":"There are functions that work on all the built in data-structures in Clojure. first second rest cons","title":"Sequence abstractions"},{"location":"using-data-structures/sequences/#practising-with-lists","text":"Note Create a simple collection of developer events. First use a list of strings, then try a map with keywords. For each data structure, pull out some of the event details ( def developer-events-strings ' ( \"Devoxx UK\" \"Devoxx France\" \"Devoxx\" \"Hack the Tower\" )) ( def developer-events-strings2 ( list \"Devoxx UK\" \"Devoxx France\" \"Devoxx\" \"Hack the Tower\" )) developer-events-strings ( first developer-events-strings ) ( def developer-events-vector [ :devoxxuk :devoxxfr :devoxx :hackthetower ] ) Using a Clojure Vector data structure is a more Clojure approach, especially when the vector contains keywords. Think of a Vector as an Array, although in Clojure it is again immutable in the same way a list is. Note Create a slightly more involved data structure, holding more data around each developer events. Suggest using a map, with each key being the unique name of the developer event. The details of each event (the value to go with the event name key) is itself a map as there are several pieces of data associated with each event name. ( def dev-event-details { :devoxxuk { :URL \"http://jaxlondon.co.uk\" :event-type \"Conference\" :number-of-attendees 700 :call-for-papers true } :hackthetower { :URL \"http://hackthetower.co.uk\" :event-type \"hackday\" :number-of-attendees 60 :call-for-papers false }}) Lets call the data structure and see what it evaluates too, it should not be a surprise dev-event-details We can ask for the value of a specific key, and just that value is returned (dev-event-details :devoxxuk) In our example, the value returned from the :devoxxuk key is also a map, so we can ask for a specific part of that map value by again using its key (:URL (dev-event-details :devoxxuk)) Note Lets define a simple data structure for stocks data using a vector of maps, as there will be one or more company stocks to track. Each map represents the stock information for a company. Get the value of the whole data structure by referring to it by name, ask for a specific element by its position in the array using the nth function. Then try some of the common functions that work on collections. ( def portfolio [ { :ticker \"CRM\" :lastTrade 233.12 :open 230.66 } { :ticker \"AAPL\" :lastTrade 203.25 :open 204.50 } { :ticker \"MSFT\" :lastTrade 29.12 :open 29.08 } { :ticker \"ORCL\" :lastTrade 21.90 :open 21.83 }]) portfolio ( nth portfolio 0 ) ( nth portfolio 3 ) ( first portfolio ) ( rest portfolio ) ( last portfolio ) First and next are termed as sequence functions in Clojure, unlike other lisps, you can use first and next on other data structures too","title":"Practising with lists"}]}